/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ "./node_modules/css-loader/dist/cjs.js!./src/style.css":
/*!*************************************************************!*\
  !*** ./node_modules/css-loader/dist/cjs.js!./src/style.css ***!
  \*************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/sourceMaps.js */ "./node_modules/css-loader/dist/runtime/sourceMaps.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../node_modules/css-loader/dist/runtime/api.js */ "./node_modules/css-loader/dist/runtime/api.js");
/* harmony import */ var _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1__);
// Imports


var ___CSS_LOADER_EXPORT___ = _node_modules_css_loader_dist_runtime_api_js__WEBPACK_IMPORTED_MODULE_1___default()((_node_modules_css_loader_dist_runtime_sourceMaps_js__WEBPACK_IMPORTED_MODULE_0___default()));
// Module
___CSS_LOADER_EXPORT___.push([module.id, "html,\nbody {\n  height: 100%;\n  margin: 0;\n  font-family: Raleway;\n  display: flex;\n  flex: 1 1 none;\n  min-width: calc(100vw + 17px);\n  overflow-x: scroll;\n  flex-direction: column;\n}\n\n\n\n.header {\n  height: 60px;\n  margin: 0;\n  background-color: #d49d6b;\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  width: 100%;\n  position: fixed;\n  top: 0;\n}\n\n.navbar-toggler {\n  margin-left: 15px;\n  border-width: 0;\n  border-radius: 7%;\n  --bs-navbar-toggler-border-radius: 0;\n  --bs-navbar-toggler-focus-width: 0;\n  transition: 0.25s;\n}\n\n.navbar-toggler:hover,\n.test:hover {\n  background-color: rgba(255, 255, 255, 0.15);\n}\n\n.home-button {\n  font-size: 1.5em;\n  color: rgba(0, 0, 0, 0.55);\n  height: 38px;\n  width: 54px;\n  background-color: transparent;\n  border-width: 0;\n  border-radius: 7%;\n  transition: 0.25s;\n}\n\n.home-button:hover {\n  background-color: rgba(255, 255, 255, 0.15);\n}\n\n.content {\n  display: flex;\n  height: 100%;\n  padding-top: 60px;\n}\n\n.sidebar {\n  display: flex;\n  flex-direction: column;\n  gap: 30px;\n  background-color: #f9fafb;\n  overflow: hidden;\n  transition: 0.5s;\n  width: 200px;\n  min-width: 200px;\n}\n\n.sidebar > div {\n  margin: 0 30px;\n  min-width: 140px;\n  border-radius: 3px;\n  padding-left: 15px;\n  padding-top: 3px;\n  padding-bottom: 3px;\n  transition: 0.1s;\n}\n\n.page:hover {\n  background-color: rgba(128, 128, 128, 0.1);\n  cursor: pointer;\n}\n\n.page.active {\n  background-color: rgba(128, 128, 128, 0.1);\n}\n\nhr {\n  border-top: 1px solid #191919;\n  width: 120px;\n  margin: -15px 30px;\n}\n\n.main-content,\n.sidebar {\n  padding-top: 30px;\n  color: #1f2937;\n}\n\n.main-content {\n  display: flex;\n  flex: 1 1 none;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  min-width: 1070px;\n  margin-left: 30px;\n}\n\n.todo {\n  display: flex;\n  flex: 1 1 none;\n  align-items: center;\n  width: 1100px;\n  background-color: #eee;\n  margin-bottom: 20px;\n  transition: 0.2s;\n}\n\n.todo > *:not(.priority-strip) {\n    margin-top: 10px;\n    margin-bottom: 10px;\n}\n\n.todo:hover {\n    transform:scale(1.005);\n    -webkit-box-shadow: 7px 7px 10px -6px rgba(0,0,0,0.4);\n}\n\n.priority-strip {\n    min-width: 4px;\n    height: 100%;\n    margin-right: 0.75rem;\n}\n\n.priority-low {\n    background-color: green;\n}\n\n.priority-medium {\n    background-color: orange;\n}\n\n.priority-high {\n    background-color: red;\n}\n\n.todo-checkbox {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  margin-right: 0.75rem;\n  background-color: transparent;\n  border: 2px solid #3ba395;\n  border-radius: 5px;\n  min-height: 20px;\n  min-width: 20px;\n  max-height: 20px;\n  max-width: 20px;\n  position: relative;\n}\n\n.todo-checkbox:checked {\n  background-color: #3ba395;\n}\n\n.todo-checkbox:checked::before {\n  content: \"✔\";\n  font-size: 12px;\n  color: white;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.todo-title {\n  margin-right: 3rem;\n  font-size: 18px;\n  width: 42rem;\n  overflow-x: scroll;\n}\n\n.todo-details,\n.todo-date {\n  margin-right: 2rem;\n}\n\n.todo-date {\n  color: #793d05;\n  font-size: 14px;\n}\n\n.todo-details {\n  color: #3ba395;\n  border-color: #3ba395;\n  background-color: transparent;\n  border: solid 1px;\n  border-radius: 3px;\n  font-size: 0.9rem;\n  transition: 0.2s;\n  padding: 3px 15px;\n}\n\n.todo-details:hover {\n  color: white;\n  background-color: #3ba395;\n  border-color: #3ba395;\n}\n\n.todo-edit,\n.todo-delete {\n  border-width: 0;\n  color: #793d05;\n  transition: 0.1s;\n}\n\n.todo-edit:hover,\n.todo-delete:hover {\n  cursor: pointer;\n  color: #0f766e;\n}\n\n.add-task {\n  height: 60px;\n  width: 60px;\n  position: fixed;\n  bottom: 50px;\n  right: 50px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-width: 0;\n  border-radius: 50%;\n  background-color: #0f766e;\n  font-size: 36px;\n  color: #f9fafb;\n}\n\n.form {\n  z-index: 3;\n  box-shadow: 0 2rem 4rem rgb(0 0 0 / 60%);\n  border-radius: 5px;\n  margin-right: auto;\n  margin-left: auto;\n  max-width: 65%;\n  min-width: 650px;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.form-header {\n  display: flex;\n  align-items: center;\n  padding-left: 15px;\n  font-size: 24px;\n  background-color: #d49d6b;\n  height: 55px;\n  border-top-left-radius: 5px;\n  border-top-right-radius: 5px;\n}\n\n.form-body {\n  display: flex;\n  flex-direction: column;\n  padding: 20px;\n  gap: 40px;\n  background-color: white;\n  border-bottom-left-radius: 5px;\n  border-bottom-right-radius: 5px;\n}\n\n.form-title,\n.form-details {\n  resize: none;\n  outline: none;\n  border-width: 0;\n}\n\n.form-title {\n  font-size: 20px;\n  height: 40px;\n}\n\n.form-details {\n  height: 200px;\n  margin-top: -30px;\n  font-size: 16px;\n}\n\n.form-priority {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n}\n\n.add-button {\n  margin-left: auto;\n}\n\n.checked {\n  opacity: 0.3;\n}\n\n.checked.todo-title {\n  text-decoration: line-through;\n}\n\n.details-form {\n    background-color: rgba(128, 128, 128, 0.3);\n    box-shadow: 0 2rem 4rem rgb(0 0 0 / 60%);\n    color: #793d05;\n    padding: 30px;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 640px;\n    min-width: 500px;\n    position: relative;\n    border-radius: 3px;\n    margin-right: auto;\n    margin-left: auto;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 3;\n}\n\n.details-close, .form-close {\n    position: absolute;\n    right: 25px;\n    top: 10px;\n    font-size: 24px;\n    font-weight: bolder;\n}\n\n.details-close:hover {\n    color: goldenrod;\n    cursor: pointer;\n}\n\n.form-close:hover {\n    color: #693705;\n    cursor: pointer;\n}\n\n.details-project {\n    margin-right: 3.1rem;\n    font-weight: 700;\n}\n\n.details-priority {\n    margin-right: 3.1rem;\n    font-weight: 700;\n}\n\n.details-date {\n    margin-right: 2rem;\n    font-weight: 700;\n}\n\n.details-description {\n    margin-right: 1.1rem;\n    font-weight: 700;\n}\n\n.overlay {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    mix-blend-mode: multiply;\n    background-repeat: repeat;\n    pointer-events: none;\n}\n\n.overlay.enabled{\n  min-width: calc(100vw + 17px);\n  backdrop-filter: blur(6px);\n  z-index: 2;\n  margin-top: -500px;\n\n}\n\n.footer {\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 10px;\n  width: 100%;\n  padding: 10px;\n  font-size: 20px;\n  color: #191919;\n  background-color: #f9fafb;\n}\n\n.fa-github {\n  color: #191919;\n  /* color: #f9fafb; */\n  font-size: 24px;\n  transition: transform 0.3s ease-in-out;\n}\n\n.fa-github:hover {\n  transform: rotate(360deg) scale(1.2);\n}\n", "",{"version":3,"sources":["webpack://./src/style.css"],"names":[],"mappings":"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","sourcesContent":["html,\nbody {\n  height: 100%;\n  margin: 0;\n  font-family: Raleway;\n  display: flex;\n  flex: 1 1 none;\n  min-width: calc(100vw + 17px);\n  overflow-x: scroll;\n  flex-direction: column;\n}\n\n\n\n.header {\n  height: 60px;\n  margin: 0;\n  background-color: #d49d6b;\n  display: flex;\n  align-items: center;\n  gap: 10px;\n  width: 100%;\n  position: fixed;\n  top: 0;\n}\n\n.navbar-toggler {\n  margin-left: 15px;\n  border-width: 0;\n  border-radius: 7%;\n  --bs-navbar-toggler-border-radius: 0;\n  --bs-navbar-toggler-focus-width: 0;\n  transition: 0.25s;\n}\n\n.navbar-toggler:hover,\n.test:hover {\n  background-color: rgba(255, 255, 255, 0.15);\n}\n\n.home-button {\n  font-size: 1.5em;\n  color: rgba(0, 0, 0, 0.55);\n  height: 38px;\n  width: 54px;\n  background-color: transparent;\n  border-width: 0;\n  border-radius: 7%;\n  transition: 0.25s;\n}\n\n.home-button:hover {\n  background-color: rgba(255, 255, 255, 0.15);\n}\n\n.content {\n  display: flex;\n  height: 100%;\n  padding-top: 60px;\n}\n\n.sidebar {\n  display: flex;\n  flex-direction: column;\n  gap: 30px;\n  background-color: #f9fafb;\n  overflow: hidden;\n  transition: 0.5s;\n  width: 200px;\n  min-width: 200px;\n}\n\n.sidebar > div {\n  margin: 0 30px;\n  min-width: 140px;\n  border-radius: 3px;\n  padding-left: 15px;\n  padding-top: 3px;\n  padding-bottom: 3px;\n  transition: 0.1s;\n}\n\n.page:hover {\n  background-color: rgba(128, 128, 128, 0.1);\n  cursor: pointer;\n}\n\n.page.active {\n  background-color: rgba(128, 128, 128, 0.1);\n}\n\nhr {\n  border-top: 1px solid #191919;\n  width: 120px;\n  margin: -15px 30px;\n}\n\n.main-content,\n.sidebar {\n  padding-top: 30px;\n  color: #1f2937;\n}\n\n.main-content {\n  display: flex;\n  flex: 1 1 none;\n  flex-direction: column;\n  align-items: center;\n  width: 100%;\n  min-width: 1070px;\n  margin-left: 30px;\n}\n\n.todo {\n  display: flex;\n  flex: 1 1 none;\n  align-items: center;\n  width: 1100px;\n  background-color: #eee;\n  margin-bottom: 20px;\n  transition: 0.2s;\n}\n\n.todo > *:not(.priority-strip) {\n    margin-top: 10px;\n    margin-bottom: 10px;\n}\n\n.todo:hover {\n    transform:scale(1.005);\n    -webkit-box-shadow: 7px 7px 10px -6px rgba(0,0,0,0.4);\n}\n\n.priority-strip {\n    min-width: 4px;\n    height: 100%;\n    margin-right: 0.75rem;\n}\n\n.priority-low {\n    background-color: green;\n}\n\n.priority-medium {\n    background-color: orange;\n}\n\n.priority-high {\n    background-color: red;\n}\n\n.todo-checkbox {\n  -webkit-appearance: none;\n  -moz-appearance: none;\n  appearance: none;\n  margin-right: 0.75rem;\n  background-color: transparent;\n  border: 2px solid #3ba395;\n  border-radius: 5px;\n  min-height: 20px;\n  min-width: 20px;\n  max-height: 20px;\n  max-width: 20px;\n  position: relative;\n}\n\n.todo-checkbox:checked {\n  background-color: #3ba395;\n}\n\n.todo-checkbox:checked::before {\n  content: \"✔\";\n  font-size: 12px;\n  color: white;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.todo-title {\n  margin-right: 3rem;\n  font-size: 18px;\n  width: 42rem;\n  overflow-x: scroll;\n}\n\n.todo-details,\n.todo-date {\n  margin-right: 2rem;\n}\n\n.todo-date {\n  color: #793d05;\n  font-size: 14px;\n}\n\n.todo-details {\n  color: #3ba395;\n  border-color: #3ba395;\n  background-color: transparent;\n  border: solid 1px;\n  border-radius: 3px;\n  font-size: 0.9rem;\n  transition: 0.2s;\n  padding: 3px 15px;\n}\n\n.todo-details:hover {\n  color: white;\n  background-color: #3ba395;\n  border-color: #3ba395;\n}\n\n.todo-edit,\n.todo-delete {\n  border-width: 0;\n  color: #793d05;\n  transition: 0.1s;\n}\n\n.todo-edit:hover,\n.todo-delete:hover {\n  cursor: pointer;\n  color: #0f766e;\n}\n\n.add-task {\n  height: 60px;\n  width: 60px;\n  position: fixed;\n  bottom: 50px;\n  right: 50px;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  border-width: 0;\n  border-radius: 50%;\n  background-color: #0f766e;\n  font-size: 36px;\n  color: #f9fafb;\n}\n\n.form {\n  z-index: 3;\n  box-shadow: 0 2rem 4rem rgb(0 0 0 / 60%);\n  border-radius: 5px;\n  margin-right: auto;\n  margin-left: auto;\n  max-width: 65%;\n  min-width: 650px;\n  position: absolute;\n  top: 50%;\n  left: 50%;\n  transform: translate(-50%, -50%);\n}\n\n.form-header {\n  display: flex;\n  align-items: center;\n  padding-left: 15px;\n  font-size: 24px;\n  background-color: #d49d6b;\n  height: 55px;\n  border-top-left-radius: 5px;\n  border-top-right-radius: 5px;\n}\n\n.form-body {\n  display: flex;\n  flex-direction: column;\n  padding: 20px;\n  gap: 40px;\n  background-color: white;\n  border-bottom-left-radius: 5px;\n  border-bottom-right-radius: 5px;\n}\n\n.form-title,\n.form-details {\n  resize: none;\n  outline: none;\n  border-width: 0;\n}\n\n.form-title {\n  font-size: 20px;\n  height: 40px;\n}\n\n.form-details {\n  height: 200px;\n  margin-top: -30px;\n  font-size: 16px;\n}\n\n.form-priority {\n  display: flex;\n  align-items: center;\n  gap: 10px;\n}\n\n.add-button {\n  margin-left: auto;\n}\n\n.checked {\n  opacity: 0.3;\n}\n\n.checked.todo-title {\n  text-decoration: line-through;\n}\n\n.details-form {\n    background-color: rgba(128, 128, 128, 0.3);\n    box-shadow: 0 2rem 4rem rgb(0 0 0 / 60%);\n    color: #793d05;\n    padding: 30px;\n    display: flex;\n    flex-direction: column;\n    gap: 10px;\n    width: 640px;\n    min-width: 500px;\n    position: relative;\n    border-radius: 3px;\n    margin-right: auto;\n    margin-left: auto;\n    position: absolute;\n    top: 50%;\n    left: 50%;\n    transform: translate(-50%, -50%);\n    z-index: 3;\n}\n\n.details-close, .form-close {\n    position: absolute;\n    right: 25px;\n    top: 10px;\n    font-size: 24px;\n    font-weight: bolder;\n}\n\n.details-close:hover {\n    color: goldenrod;\n    cursor: pointer;\n}\n\n.form-close:hover {\n    color: #693705;\n    cursor: pointer;\n}\n\n.details-project {\n    margin-right: 3.1rem;\n    font-weight: 700;\n}\n\n.details-priority {\n    margin-right: 3.1rem;\n    font-weight: 700;\n}\n\n.details-date {\n    margin-right: 2rem;\n    font-weight: 700;\n}\n\n.details-description {\n    margin-right: 1.1rem;\n    font-weight: 700;\n}\n\n.overlay {\n    position: absolute;\n    top: 0;\n    bottom: 0;\n    left: 0;\n    right: 0;\n    mix-blend-mode: multiply;\n    background-repeat: repeat;\n    pointer-events: none;\n}\n\n.overlay.enabled{\n  min-width: calc(100vw + 17px);\n  backdrop-filter: blur(6px);\n  z-index: 2;\n  margin-top: -500px;\n\n}\n\n.footer {\n  position: fixed;\n  bottom: 0;\n  left: 0;\n  display: flex;\n  align-items: center;\n  justify-content: center;\n  gap: 10px;\n  width: 100%;\n  padding: 10px;\n  font-size: 20px;\n  color: #191919;\n  background-color: #f9fafb;\n}\n\n.fa-github {\n  color: #191919;\n  /* color: #f9fafb; */\n  font-size: 24px;\n  transition: transform 0.3s ease-in-out;\n}\n\n.fa-github:hover {\n  transform: rotate(360deg) scale(1.2);\n}\n"],"sourceRoot":""}]);
// Exports
/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (___CSS_LOADER_EXPORT___);


/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/api.js":
/*!*****************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/api.js ***!
  \*****************************************************/
/***/ ((module) => {

"use strict";


/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
*/
module.exports = function (cssWithMappingToString) {
  var list = [];

  // return the list of modules as css string
  list.toString = function toString() {
    return this.map(function (item) {
      var content = "";
      var needLayer = typeof item[5] !== "undefined";
      if (item[4]) {
        content += "@supports (".concat(item[4], ") {");
      }
      if (item[2]) {
        content += "@media ".concat(item[2], " {");
      }
      if (needLayer) {
        content += "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {");
      }
      content += cssWithMappingToString(item);
      if (needLayer) {
        content += "}";
      }
      if (item[2]) {
        content += "}";
      }
      if (item[4]) {
        content += "}";
      }
      return content;
    }).join("");
  };

  // import a list of modules into the list
  list.i = function i(modules, media, dedupe, supports, layer) {
    if (typeof modules === "string") {
      modules = [[null, modules, undefined]];
    }
    var alreadyImportedModules = {};
    if (dedupe) {
      for (var k = 0; k < this.length; k++) {
        var id = this[k][0];
        if (id != null) {
          alreadyImportedModules[id] = true;
        }
      }
    }
    for (var _k = 0; _k < modules.length; _k++) {
      var item = [].concat(modules[_k]);
      if (dedupe && alreadyImportedModules[item[0]]) {
        continue;
      }
      if (typeof layer !== "undefined") {
        if (typeof item[5] === "undefined") {
          item[5] = layer;
        } else {
          item[1] = "@layer".concat(item[5].length > 0 ? " ".concat(item[5]) : "", " {").concat(item[1], "}");
          item[5] = layer;
        }
      }
      if (media) {
        if (!item[2]) {
          item[2] = media;
        } else {
          item[1] = "@media ".concat(item[2], " {").concat(item[1], "}");
          item[2] = media;
        }
      }
      if (supports) {
        if (!item[4]) {
          item[4] = "".concat(supports);
        } else {
          item[1] = "@supports (".concat(item[4], ") {").concat(item[1], "}");
          item[4] = supports;
        }
      }
      list.push(item);
    }
  };
  return list;
};

/***/ }),

/***/ "./node_modules/css-loader/dist/runtime/sourceMaps.js":
/*!************************************************************!*\
  !*** ./node_modules/css-loader/dist/runtime/sourceMaps.js ***!
  \************************************************************/
/***/ ((module) => {

"use strict";


module.exports = function (item) {
  var content = item[1];
  var cssMapping = item[3];
  if (!cssMapping) {
    return content;
  }
  if (typeof btoa === "function") {
    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(cssMapping))));
    var data = "sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(base64);
    var sourceMapping = "/*# ".concat(data, " */");
    return [content].concat([sourceMapping]).join("\n");
  }
  return [content].join("\n");
};

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js":
/*!****************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/defaultOptions/index.js ***!
  \****************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "getDefaultOptions": () => (/* binding */ getDefaultOptions),
/* harmony export */   "setDefaultOptions": () => (/* binding */ setDefaultOptions)
/* harmony export */ });
var defaultOptions = {};
function getDefaultOptions() {
  return defaultOptions;
}
function setDefaultOptions(newOptions) {
  defaultOptions = newOptions;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js":
/*!**************************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/requiredArgs/index.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ requiredArgs)
/* harmony export */ });
function requiredArgs(required, args) {
  if (args.length < required) {
    throw new TypeError(required + ' argument' + (required > 1 ? 's' : '') + ' required, but only ' + args.length + ' present');
  }
}

/***/ }),

/***/ "./node_modules/date-fns/esm/_lib/toInteger/index.js":
/*!***********************************************************!*\
  !*** ./node_modules/date-fns/esm/_lib/toInteger/index.js ***!
  \***********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toInteger)
/* harmony export */ });
function toInteger(dirtyNumber) {
  if (dirtyNumber === null || dirtyNumber === true || dirtyNumber === false) {
    return NaN;
  }

  var number = Number(dirtyNumber);

  if (isNaN(number)) {
    return number;
  }

  return number < 0 ? Math.ceil(number) : Math.floor(number);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/constants/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/constants/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "daysInWeek": () => (/* binding */ daysInWeek),
/* harmony export */   "daysInYear": () => (/* binding */ daysInYear),
/* harmony export */   "maxTime": () => (/* binding */ maxTime),
/* harmony export */   "millisecondsInHour": () => (/* binding */ millisecondsInHour),
/* harmony export */   "millisecondsInMinute": () => (/* binding */ millisecondsInMinute),
/* harmony export */   "millisecondsInSecond": () => (/* binding */ millisecondsInSecond),
/* harmony export */   "minTime": () => (/* binding */ minTime),
/* harmony export */   "minutesInHour": () => (/* binding */ minutesInHour),
/* harmony export */   "monthsInQuarter": () => (/* binding */ monthsInQuarter),
/* harmony export */   "monthsInYear": () => (/* binding */ monthsInYear),
/* harmony export */   "quartersInYear": () => (/* binding */ quartersInYear),
/* harmony export */   "secondsInDay": () => (/* binding */ secondsInDay),
/* harmony export */   "secondsInHour": () => (/* binding */ secondsInHour),
/* harmony export */   "secondsInMinute": () => (/* binding */ secondsInMinute),
/* harmony export */   "secondsInMonth": () => (/* binding */ secondsInMonth),
/* harmony export */   "secondsInQuarter": () => (/* binding */ secondsInQuarter),
/* harmony export */   "secondsInWeek": () => (/* binding */ secondsInWeek),
/* harmony export */   "secondsInYear": () => (/* binding */ secondsInYear)
/* harmony export */ });
/**
 * Days in 1 week.
 *
 * @name daysInWeek
 * @constant
 * @type {number}
 * @default
 */
var daysInWeek = 7;
/**
 * Days in 1 year
 * One years equals 365.2425 days according to the formula:
 *
 * > Leap year occures every 4 years, except for years that are divisable by 100 and not divisable by 400.
 * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days
 *
 * @name daysInYear
 * @constant
 * @type {number}
 * @default
 */

var daysInYear = 365.2425;
/**
 * Maximum allowed time.
 *
 * @name maxTime
 * @constant
 * @type {number}
 * @default
 */

var maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;
/**
 * Milliseconds in 1 minute
 *
 * @name millisecondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInMinute = 60000;
/**
 * Milliseconds in 1 hour
 *
 * @name millisecondsInHour
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInHour = 3600000;
/**
 * Milliseconds in 1 second
 *
 * @name millisecondsInSecond
 * @constant
 * @type {number}
 * @default
 */

var millisecondsInSecond = 1000;
/**
 * Minimum allowed time.
 *
 * @name minTime
 * @constant
 * @type {number}
 * @default
 */

var minTime = -maxTime;
/**
 * Minutes in 1 hour
 *
 * @name minutesInHour
 * @constant
 * @type {number}
 * @default
 */

var minutesInHour = 60;
/**
 * Months in 1 quarter
 *
 * @name monthsInQuarter
 * @constant
 * @type {number}
 * @default
 */

var monthsInQuarter = 3;
/**
 * Months in 1 year
 *
 * @name monthsInYear
 * @constant
 * @type {number}
 * @default
 */

var monthsInYear = 12;
/**
 * Quarters in 1 year
 *
 * @name quartersInYear
 * @constant
 * @type {number}
 * @default
 */

var quartersInYear = 4;
/**
 * Seconds in 1 hour
 *
 * @name secondsInHour
 * @constant
 * @type {number}
 * @default
 */

var secondsInHour = 3600;
/**
 * Seconds in 1 minute
 *
 * @name secondsInMinute
 * @constant
 * @type {number}
 * @default
 */

var secondsInMinute = 60;
/**
 * Seconds in 1 day
 *
 * @name secondsInDay
 * @constant
 * @type {number}
 * @default
 */

var secondsInDay = secondsInHour * 24;
/**
 * Seconds in 1 week
 *
 * @name secondsInWeek
 * @constant
 * @type {number}
 * @default
 */

var secondsInWeek = secondsInDay * 7;
/**
 * Seconds in 1 year
 *
 * @name secondsInYear
 * @constant
 * @type {number}
 * @default
 */

var secondsInYear = secondsInDay * daysInYear;
/**
 * Seconds in 1 month
 *
 * @name secondsInMonth
 * @constant
 * @type {number}
 * @default
 */

var secondsInMonth = secondsInYear / 12;
/**
 * Seconds in 1 quarter
 *
 * @name secondsInQuarter
 * @constant
 * @type {number}
 * @default
 */

var secondsInQuarter = secondsInMonth * 3;

/***/ }),

/***/ "./node_modules/date-fns/esm/isSameDay/index.js":
/*!******************************************************!*\
  !*** ./node_modules/date-fns/esm/isSameDay/index.js ***!
  \******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isSameDay)
/* harmony export */ });
/* harmony import */ var _startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../startOfDay/index.js */ "./node_modules/date-fns/esm/startOfDay/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isSameDay
 * @category Day Helpers
 * @summary Are the given dates in the same day (and year and month)?
 *
 * @description
 * Are the given dates in the same day (and year and month)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @returns {Boolean} the dates are in the same day (and year and month)
 * @throws {TypeError} 2 arguments required
 *
 * @example
 * // Are 4 September 06:00:00 and 4 September 18:00:00 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4, 6, 0), new Date(2014, 8, 4, 18, 0))
 * //=> true
 *
 * @example
 * // Are 4 September and 4 October in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2014, 9, 4))
 * //=> false
 *
 * @example
 * // Are 4 September, 2014 and 4 September, 2015 in the same day?
 * const result = isSameDay(new Date(2014, 8, 4), new Date(2015, 8, 4))
 * //=> false
 */

function isSameDay(dirtyDateLeft, dirtyDateRight) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeftStartOfDay = (0,_startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft);
  var dateRightStartOfDay = (0,_startOfDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight);
  return dateLeftStartOfDay.getTime() === dateRightStartOfDay.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isSameWeek/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/esm/isSameWeek/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isSameWeek)
/* harmony export */ });
/* harmony import */ var _startOfWeek_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../startOfWeek/index.js */ "./node_modules/date-fns/esm/startOfWeek/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name isSameWeek
 * @category Week Helpers
 * @summary Are the given dates in the same week (and month and year)?
 *
 * @description
 * Are the given dates in the same week (and month and year)?
 *
 * @param {Date|Number} dateLeft - the first date to check
 * @param {Date|Number} dateRight - the second date to check
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Boolean} the dates are in the same week (and month and year)
 * @throws {TypeError} 2 arguments required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // Are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4))
 * //=> true
 *
 * @example
 * // If week starts with Monday,
 * // are 31 August 2014 and 4 September 2014 in the same week?
 * const result = isSameWeek(new Date(2014, 7, 31), new Date(2014, 8, 4), {
 *   weekStartsOn: 1
 * })
 * //=> false
 *
 * @example
 * // Are 1 January 2014 and 1 January 2015 in the same week?
 * const result = isSameWeek(new Date(2014, 0, 1), new Date(2015, 0, 1))
 * //=> false
 */
function isSameWeek(dirtyDateLeft, dirtyDateRight, options) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(2, arguments);
  var dateLeftStartOfWeek = (0,_startOfWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateLeft, options);
  var dateRightStartOfWeek = (0,_startOfWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDateRight, options);
  return dateLeftStartOfWeek.getTime() === dateRightStartOfWeek.getTime();
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isThisWeek/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/esm/isThisWeek/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isThisWeek)
/* harmony export */ });
/* harmony import */ var _isSameWeek_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../isSameWeek/index.js */ "./node_modules/date-fns/esm/isSameWeek/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");



/**
 * @name isThisWeek
 * @category Week Helpers
 * @summary Is the given date in the same week as the current date?
 * @pure false
 *
 * @description
 * Is the given date in the same week as the current date?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @param {Object} [options] - the object with options
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Boolean} the date is in this week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // If today is 25 September 2014, is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21))
 * //=> true
 *
 * @example
 * // If today is 25 September 2014 and week starts with Monday
 * // is 21 September 2014 in this week?
 * const result = isThisWeek(new Date(2014, 8, 21), { weekStartsOn: 1 })
 * //=> false
 */
function isThisWeek(dirtyDate, options) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  return (0,_isSameWeek_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate, Date.now(), options);
}

/***/ }),

/***/ "./node_modules/date-fns/esm/isToday/index.js":
/*!****************************************************!*\
  !*** ./node_modules/date-fns/esm/isToday/index.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ isToday)
/* harmony export */ });
/* harmony import */ var _isSameDay_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../isSameDay/index.js */ "./node_modules/date-fns/esm/isSameDay/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name isToday
 * @category Day Helpers
 * @summary Is the given date today?
 * @pure false
 *
 * @description
 * Is the given date today?
 *
 * > ⚠️ Please note that this function is not present in the FP submodule as
 * > it uses `Date.now()` internally hence impure and can't be safely curried.
 *
 * @param {Date|Number} date - the date to check
 * @returns {Boolean} the date is today
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // If today is 6 October 2014, is 6 October 14:00:00 today?
 * const result = isToday(new Date(2014, 9, 6, 14, 0))
 * //=> true
 */

function isToday(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  return (0,_isSameDay_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate, Date.now());
}

/***/ }),

/***/ "./node_modules/date-fns/esm/parseISO/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/date-fns/esm/parseISO/index.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ parseISO)
/* harmony export */ });
/* harmony import */ var _constants_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../constants/index.js */ "./node_modules/date-fns/esm/constants/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");



/**
 * @name parseISO
 * @category Common Helpers
 * @summary Parse ISO string
 *
 * @description
 * Parse the given string in ISO 8601 format and return an instance of Date.
 *
 * Function accepts complete ISO 8601 formats as well as partial implementations.
 * ISO 8601: http://en.wikipedia.org/wiki/ISO_8601
 *
 * If the argument isn't a string, the function cannot parse the string or
 * the values are invalid, it returns Invalid Date.
 *
 * @param {String} argument - the value to convert
 * @param {Object} [options] - an object with options.
 * @param {0|1|2} [options.additionalDigits=2] - the additional number of digits in the extended year format
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.additionalDigits` must be 0, 1 or 2
 *
 * @example
 * // Convert string '2014-02-11T11:30:30' to date:
 * const result = parseISO('2014-02-11T11:30:30')
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert string '+02014101' to date,
 * // if the additional number of digits in the extended year format is 1:
 * const result = parseISO('+02014101', { additionalDigits: 1 })
 * //=> Fri Apr 11 2014 00:00:00
 */

function parseISO(argument, options) {
  var _options$additionalDi;

  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var additionalDigits = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])((_options$additionalDi = options === null || options === void 0 ? void 0 : options.additionalDigits) !== null && _options$additionalDi !== void 0 ? _options$additionalDi : 2);

  if (additionalDigits !== 2 && additionalDigits !== 1 && additionalDigits !== 0) {
    throw new RangeError('additionalDigits must be 0, 1 or 2');
  }

  if (!(typeof argument === 'string' || Object.prototype.toString.call(argument) === '[object String]')) {
    return new Date(NaN);
  }

  var dateStrings = splitDateString(argument);
  var date;

  if (dateStrings.date) {
    var parseYearResult = parseYear(dateStrings.date, additionalDigits);
    date = parseDate(parseYearResult.restDateString, parseYearResult.year);
  }

  if (!date || isNaN(date.getTime())) {
    return new Date(NaN);
  }

  var timestamp = date.getTime();
  var time = 0;
  var offset;

  if (dateStrings.time) {
    time = parseTime(dateStrings.time);

    if (isNaN(time)) {
      return new Date(NaN);
    }
  }

  if (dateStrings.timezone) {
    offset = parseTimezone(dateStrings.timezone);

    if (isNaN(offset)) {
      return new Date(NaN);
    }
  } else {
    var dirtyDate = new Date(timestamp + time); // js parsed string assuming it's in UTC timezone
    // but we need it to be parsed in our timezone
    // so we use utc values to build date in our timezone.
    // Year values from 0 to 99 map to the years 1900 to 1999
    // so set year explicitly with setFullYear.

    var result = new Date(0);
    result.setFullYear(dirtyDate.getUTCFullYear(), dirtyDate.getUTCMonth(), dirtyDate.getUTCDate());
    result.setHours(dirtyDate.getUTCHours(), dirtyDate.getUTCMinutes(), dirtyDate.getUTCSeconds(), dirtyDate.getUTCMilliseconds());
    return result;
  }

  return new Date(timestamp + time + offset);
}
var patterns = {
  dateTimeDelimiter: /[T ]/,
  timeZoneDelimiter: /[Z ]/i,
  timezone: /([Z+-].*)$/
};
var dateRegex = /^-?(?:(\d{3})|(\d{2})(?:-?(\d{2}))?|W(\d{2})(?:-?(\d{1}))?|)$/;
var timeRegex = /^(\d{2}(?:[.,]\d*)?)(?::?(\d{2}(?:[.,]\d*)?))?(?::?(\d{2}(?:[.,]\d*)?))?$/;
var timezoneRegex = /^([+-])(\d{2})(?::?(\d{2}))?$/;

function splitDateString(dateString) {
  var dateStrings = {};
  var array = dateString.split(patterns.dateTimeDelimiter);
  var timeString; // The regex match should only return at maximum two array elements.
  // [date], [time], or [date, time].

  if (array.length > 2) {
    return dateStrings;
  }

  if (/:/.test(array[0])) {
    timeString = array[0];
  } else {
    dateStrings.date = array[0];
    timeString = array[1];

    if (patterns.timeZoneDelimiter.test(dateStrings.date)) {
      dateStrings.date = dateString.split(patterns.timeZoneDelimiter)[0];
      timeString = dateString.substr(dateStrings.date.length, dateString.length);
    }
  }

  if (timeString) {
    var token = patterns.timezone.exec(timeString);

    if (token) {
      dateStrings.time = timeString.replace(token[1], '');
      dateStrings.timezone = token[1];
    } else {
      dateStrings.time = timeString;
    }
  }

  return dateStrings;
}

function parseYear(dateString, additionalDigits) {
  var regex = new RegExp('^(?:(\\d{4}|[+-]\\d{' + (4 + additionalDigits) + '})|(\\d{2}|[+-]\\d{' + (2 + additionalDigits) + '})$)');
  var captures = dateString.match(regex); // Invalid ISO-formatted year

  if (!captures) return {
    year: NaN,
    restDateString: ''
  };
  var year = captures[1] ? parseInt(captures[1]) : null;
  var century = captures[2] ? parseInt(captures[2]) : null; // either year or century is null, not both

  return {
    year: century === null ? year : century * 100,
    restDateString: dateString.slice((captures[1] || captures[2]).length)
  };
}

function parseDate(dateString, year) {
  // Invalid ISO-formatted year
  if (year === null) return new Date(NaN);
  var captures = dateString.match(dateRegex); // Invalid ISO-formatted string

  if (!captures) return new Date(NaN);
  var isWeekDate = !!captures[4];
  var dayOfYear = parseDateUnit(captures[1]);
  var month = parseDateUnit(captures[2]) - 1;
  var day = parseDateUnit(captures[3]);
  var week = parseDateUnit(captures[4]);
  var dayOfWeek = parseDateUnit(captures[5]) - 1;

  if (isWeekDate) {
    if (!validateWeekDate(year, week, dayOfWeek)) {
      return new Date(NaN);
    }

    return dayOfISOWeekYear(year, week, dayOfWeek);
  } else {
    var date = new Date(0);

    if (!validateDate(year, month, day) || !validateDayOfYearDate(year, dayOfYear)) {
      return new Date(NaN);
    }

    date.setUTCFullYear(year, month, Math.max(dayOfYear, day));
    return date;
  }
}

function parseDateUnit(value) {
  return value ? parseInt(value) : 1;
}

function parseTime(timeString) {
  var captures = timeString.match(timeRegex);
  if (!captures) return NaN; // Invalid ISO-formatted time

  var hours = parseTimeUnit(captures[1]);
  var minutes = parseTimeUnit(captures[2]);
  var seconds = parseTimeUnit(captures[3]);

  if (!validateTime(hours, minutes, seconds)) {
    return NaN;
  }

  return hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInMinute + seconds * 1000;
}

function parseTimeUnit(value) {
  return value && parseFloat(value.replace(',', '.')) || 0;
}

function parseTimezone(timezoneString) {
  if (timezoneString === 'Z') return 0;
  var captures = timezoneString.match(timezoneRegex);
  if (!captures) return 0;
  var sign = captures[1] === '+' ? -1 : 1;
  var hours = parseInt(captures[2]);
  var minutes = captures[3] && parseInt(captures[3]) || 0;

  if (!validateTimezone(hours, minutes)) {
    return NaN;
  }

  return sign * (hours * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInHour + minutes * _constants_index_js__WEBPACK_IMPORTED_MODULE_2__.millisecondsInMinute);
}

function dayOfISOWeekYear(isoWeekYear, week, day) {
  var date = new Date(0);
  date.setUTCFullYear(isoWeekYear, 0, 4);
  var fourthOfJanuaryDay = date.getUTCDay() || 7;
  var diff = (week - 1) * 7 + day + 1 - fourthOfJanuaryDay;
  date.setUTCDate(date.getUTCDate() + diff);
  return date;
} // Validation functions
// February is null to handle the leap year (using ||)


var daysInMonths = [31, null, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];

function isLeapYearIndex(year) {
  return year % 400 === 0 || year % 4 === 0 && year % 100 !== 0;
}

function validateDate(year, month, date) {
  return month >= 0 && month <= 11 && date >= 1 && date <= (daysInMonths[month] || (isLeapYearIndex(year) ? 29 : 28));
}

function validateDayOfYearDate(year, dayOfYear) {
  return dayOfYear >= 1 && dayOfYear <= (isLeapYearIndex(year) ? 366 : 365);
}

function validateWeekDate(_year, week, day) {
  return week >= 1 && week <= 53 && day >= 0 && day <= 6;
}

function validateTime(hours, minutes, seconds) {
  if (hours === 24) {
    return minutes === 0 && seconds === 0;
  }

  return seconds >= 0 && seconds < 60 && minutes >= 0 && minutes < 60 && hours >= 0 && hours < 25;
}

function validateTimezone(_hours, minutes) {
  return minutes >= 0 && minutes <= 59;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/startOfDay/index.js":
/*!*******************************************************!*\
  !*** ./node_modules/date-fns/esm/startOfDay/index.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfDay)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");


/**
 * @name startOfDay
 * @category Day Helpers
 * @summary Return the start of a day for the given date.
 *
 * @description
 * Return the start of a day for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @returns {Date} the start of a day
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // The start of a day for 2 September 2014 11:55:00:
 * const result = startOfDay(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Tue Sep 02 2014 00:00:00
 */

function startOfDay(dirtyDate) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_1__["default"])(dirtyDate);
  date.setHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/startOfWeek/index.js":
/*!********************************************************!*\
  !*** ./node_modules/date-fns/esm/startOfWeek/index.js ***!
  \********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ startOfWeek)
/* harmony export */ });
/* harmony import */ var _toDate_index_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../toDate/index.js */ "./node_modules/date-fns/esm/toDate/index.js");
/* harmony import */ var _lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../_lib/toInteger/index.js */ "./node_modules/date-fns/esm/_lib/toInteger/index.js");
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
/* harmony import */ var _lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../_lib/defaultOptions/index.js */ "./node_modules/date-fns/esm/_lib/defaultOptions/index.js");




/**
 * @name startOfWeek
 * @category Week Helpers
 * @summary Return the start of a week for the given date.
 *
 * @description
 * Return the start of a week for the given date.
 * The result will be in the local timezone.
 *
 * @param {Date|Number} date - the original date
 * @param {Object} [options] - an object with options.
 * @param {Locale} [options.locale=defaultLocale] - the locale object. See [Locale]{@link https://date-fns.org/docs/Locale}
 * @param {0|1|2|3|4|5|6} [options.weekStartsOn=0] - the index of the first day of the week (0 - Sunday)
 * @returns {Date} the start of a week
 * @throws {TypeError} 1 argument required
 * @throws {RangeError} `options.weekStartsOn` must be between 0 and 6
 *
 * @example
 * // The start of a week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0))
 * //=> Sun Aug 31 2014 00:00:00
 *
 * @example
 * // If the week starts on Monday, the start of the week for 2 September 2014 11:55:00:
 * const result = startOfWeek(new Date(2014, 8, 2, 11, 55, 0), { weekStartsOn: 1 })
 * //=> Mon Sep 01 2014 00:00:00
 */

function startOfWeek(dirtyDate, options) {
  var _ref, _ref2, _ref3, _options$weekStartsOn, _options$locale, _options$locale$optio, _defaultOptions$local, _defaultOptions$local2;

  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var defaultOptions = (0,_lib_defaultOptions_index_js__WEBPACK_IMPORTED_MODULE_1__.getDefaultOptions)();
  var weekStartsOn = (0,_lib_toInteger_index_js__WEBPACK_IMPORTED_MODULE_2__["default"])((_ref = (_ref2 = (_ref3 = (_options$weekStartsOn = options === null || options === void 0 ? void 0 : options.weekStartsOn) !== null && _options$weekStartsOn !== void 0 ? _options$weekStartsOn : options === null || options === void 0 ? void 0 : (_options$locale = options.locale) === null || _options$locale === void 0 ? void 0 : (_options$locale$optio = _options$locale.options) === null || _options$locale$optio === void 0 ? void 0 : _options$locale$optio.weekStartsOn) !== null && _ref3 !== void 0 ? _ref3 : defaultOptions.weekStartsOn) !== null && _ref2 !== void 0 ? _ref2 : (_defaultOptions$local = defaultOptions.locale) === null || _defaultOptions$local === void 0 ? void 0 : (_defaultOptions$local2 = _defaultOptions$local.options) === null || _defaultOptions$local2 === void 0 ? void 0 : _defaultOptions$local2.weekStartsOn) !== null && _ref !== void 0 ? _ref : 0); // Test if weekStartsOn is between 0 and 6 _and_ is not NaN

  if (!(weekStartsOn >= 0 && weekStartsOn <= 6)) {
    throw new RangeError('weekStartsOn must be between 0 and 6 inclusively');
  }

  var date = (0,_toDate_index_js__WEBPACK_IMPORTED_MODULE_3__["default"])(dirtyDate);
  var day = date.getDay();
  var diff = (day < weekStartsOn ? 7 : 0) + day - weekStartsOn;
  date.setDate(date.getDate() - diff);
  date.setHours(0, 0, 0, 0);
  return date;
}

/***/ }),

/***/ "./node_modules/date-fns/esm/toDate/index.js":
/*!***************************************************!*\
  !*** ./node_modules/date-fns/esm/toDate/index.js ***!
  \***************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (/* binding */ toDate)
/* harmony export */ });
/* harmony import */ var _lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../_lib/requiredArgs/index.js */ "./node_modules/date-fns/esm/_lib/requiredArgs/index.js");
function _typeof(obj) { "@babel/helpers - typeof"; if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }


/**
 * @name toDate
 * @category Common Helpers
 * @summary Convert the given argument to an instance of Date.
 *
 * @description
 * Convert the given argument to an instance of Date.
 *
 * If the argument is an instance of Date, the function returns its clone.
 *
 * If the argument is a number, it is treated as a timestamp.
 *
 * If the argument is none of the above, the function returns Invalid Date.
 *
 * **Note**: *all* Date arguments passed to any *date-fns* function is processed by `toDate`.
 *
 * @param {Date|Number} argument - the value to convert
 * @returns {Date} the parsed date in the local time zone
 * @throws {TypeError} 1 argument required
 *
 * @example
 * // Clone the date:
 * const result = toDate(new Date(2014, 1, 11, 11, 30, 30))
 * //=> Tue Feb 11 2014 11:30:30
 *
 * @example
 * // Convert the timestamp to date:
 * const result = toDate(1392098430000)
 * //=> Tue Feb 11 2014 11:30:30
 */

function toDate(argument) {
  (0,_lib_requiredArgs_index_js__WEBPACK_IMPORTED_MODULE_0__["default"])(1, arguments);
  var argStr = Object.prototype.toString.call(argument); // Clone the date

  if (argument instanceof Date || _typeof(argument) === 'object' && argStr === '[object Date]') {
    // Prevent the date to lose the milliseconds when passed to new Date() in IE10
    return new Date(argument.getTime());
  } else if (typeof argument === 'number' || argStr === '[object Number]') {
    return new Date(argument);
  } else {
    if ((typeof argument === 'string' || argStr === '[object String]') && typeof console !== 'undefined') {
      // eslint-disable-next-line no-console
      console.warn("Starting with v2.0.0-beta.1 date-fns doesn't accept strings as date arguments. Please use `parseISO` to parse strings. See: https://github.com/date-fns/date-fns/blob/master/docs/upgradeGuide.md#string-arguments"); // eslint-disable-next-line no-console

      console.warn(new Error().stack);
    }

    return new Date(NaN);
  }
}

/***/ }),

/***/ "./node_modules/lodash/lodash.js":
/*!***************************************!*\
  !*** ./node_modules/lodash/lodash.js ***!
  \***************************************/
/***/ (function(module, exports, __webpack_require__) {

/* module decorator */ module = __webpack_require__.nmd(module);
var __WEBPACK_AMD_DEFINE_RESULT__;/**
 * @license
 * Lodash <https://lodash.com/>
 * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */
;(function() {

  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  var undefined;

  /** Used as the semantic version number. */
  var VERSION = '4.17.21';

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Error message constants. */
  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
      FUNC_ERROR_TEXT = 'Expected a function',
      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as the maximum memoize cache size. */
  var MAX_MEMOIZE_SIZE = 500;

  /** Used as the internal argument placeholder. */
  var PLACEHOLDER = '__lodash_placeholder__';

  /** Used to compose bitmasks for cloning. */
  var CLONE_DEEP_FLAG = 1,
      CLONE_FLAT_FLAG = 2,
      CLONE_SYMBOLS_FLAG = 4;

  /** Used to compose bitmasks for value comparisons. */
  var COMPARE_PARTIAL_FLAG = 1,
      COMPARE_UNORDERED_FLAG = 2;

  /** Used to compose bitmasks for function metadata. */
  var WRAP_BIND_FLAG = 1,
      WRAP_BIND_KEY_FLAG = 2,
      WRAP_CURRY_BOUND_FLAG = 4,
      WRAP_CURRY_FLAG = 8,
      WRAP_CURRY_RIGHT_FLAG = 16,
      WRAP_PARTIAL_FLAG = 32,
      WRAP_PARTIAL_RIGHT_FLAG = 64,
      WRAP_ARY_FLAG = 128,
      WRAP_REARG_FLAG = 256,
      WRAP_FLIP_FLAG = 512;

  /** Used as default options for `_.truncate`. */
  var DEFAULT_TRUNC_LENGTH = 30,
      DEFAULT_TRUNC_OMISSION = '...';

  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  var HOT_COUNT = 800,
      HOT_SPAN = 16;

  /** Used to indicate the type of lazy iteratees. */
  var LAZY_FILTER_FLAG = 1,
      LAZY_MAP_FLAG = 2,
      LAZY_WHILE_FLAG = 3;

  /** Used as references for various `Number` constants. */
  var INFINITY = 1 / 0,
      MAX_SAFE_INTEGER = 9007199254740991,
      MAX_INTEGER = 1.7976931348623157e+308,
      NAN = 0 / 0;

  /** Used as references for the maximum length and index of an array. */
  var MAX_ARRAY_LENGTH = 4294967295,
      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  /** Used to associate wrap methods with their bit flags. */
  var wrapFlags = [
    ['ary', WRAP_ARY_FLAG],
    ['bind', WRAP_BIND_FLAG],
    ['bindKey', WRAP_BIND_KEY_FLAG],
    ['curry', WRAP_CURRY_FLAG],
    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
    ['flip', WRAP_FLIP_FLAG],
    ['partial', WRAP_PARTIAL_FLAG],
    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
    ['rearg', WRAP_REARG_FLAG]
  ];

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      asyncTag = '[object AsyncFunction]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      domExcTag = '[object DOMException]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      nullTag = '[object Null]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      proxyTag = '[object Proxy]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      undefinedTag = '[object Undefined]',
      weakMapTag = '[object WeakMap]',
      weakSetTag = '[object WeakSet]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /** Used to match empty string literals in compiled template source. */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match HTML entities and HTML characters. */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
      reUnescapedHtml = /[&<>"']/g,
      reHasEscapedHtml = RegExp(reEscapedHtml.source),
      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  /** Used to match template delimiters. */
  var reEscape = /<%-([\s\S]+?)%>/g,
      reEvaluate = /<%([\s\S]+?)%>/g,
      reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to match property names within property paths. */
  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
      reIsPlainProp = /^\w*$/,
      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
      reHasRegExpChar = RegExp(reRegExpChar.source);

  /** Used to match leading whitespace. */
  var reTrimStart = /^\s+/;

  /** Used to match a single whitespace character. */
  var reWhitespace = /\s/;

  /** Used to match wrap detail comments. */
  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
      reSplitDetails = /,? & /;

  /** Used to match words composed of alphanumeric characters. */
  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  /**
   * Used to validate the `validate` option in `_.template` variable.
   *
   * Forbids characters which could potentially change the meaning of the function argument definition:
   * - "()," (modification of function parameters)
   * - "=" (default value)
   * - "[]{}" (destructuring of function parameters)
   * - "/" (beginning of a comment)
   * - whitespace
   */
  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  /** Used to match backslashes in property paths. */
  var reEscapeChar = /\\(\\)?/g;

  /**
   * Used to match
   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
   */
  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect bad signed hexadecimal string values. */
  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  /** Used to detect binary string values. */
  var reIsBinary = /^0b[01]+$/i;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect octal string values. */
  var reIsOctal = /^0o[0-7]+$/i;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  /** Used to ensure capturing order of template delimiters. */
  var reNoMatch = /($^)/;

  /** Used to match unescaped characters in compiled string literals. */
  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  /** Used to compose unicode character classes. */
  var rsAstralRange = '\\ud800-\\udfff',
      rsComboMarksRange = '\\u0300-\\u036f',
      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
      rsComboSymbolsRange = '\\u20d0-\\u20ff',
      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
      rsDingbatRange = '\\u2700-\\u27bf',
      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
      rsPunctuationRange = '\\u2000-\\u206f',
      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
      rsVarRange = '\\ufe0e\\ufe0f',
      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  /** Used to compose unicode capture groups. */
  var rsApos = "['\u2019]",
      rsAstral = '[' + rsAstralRange + ']',
      rsBreak = '[' + rsBreakRange + ']',
      rsCombo = '[' + rsComboRange + ']',
      rsDigits = '\\d+',
      rsDingbat = '[' + rsDingbatRange + ']',
      rsLower = '[' + rsLowerRange + ']',
      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
      rsFitz = '\\ud83c[\\udffb-\\udfff]',
      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
      rsNonAstral = '[^' + rsAstralRange + ']',
      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
      rsUpper = '[' + rsUpperRange + ']',
      rsZWJ = '\\u200d';

  /** Used to compose unicode regexes. */
  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
      reOptMod = rsModifier + '?',
      rsOptVar = '[' + rsVarRange + ']?',
      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
      rsSeq = rsOptVar + reOptMod + rsOptJoin,
      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  /** Used to match apostrophes. */
  var reApos = RegExp(rsApos, 'g');

  /**
   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
   */
  var reComboMark = RegExp(rsCombo, 'g');

  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  /** Used to match complex or compound words. */
  var reUnicodeWord = RegExp([
    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
    rsUpper + '+' + rsOptContrUpper,
    rsOrdUpper,
    rsOrdLower,
    rsDigits,
    rsEmoji
  ].join('|'), 'g');

  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  /** Used to detect strings that need a more robust regexp to match words. */
  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  /** Used to assign default `context` object properties. */
  var contextProps = [
    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  ];

  /** Used to make template sourceURLs easier to identify. */
  var templateCounter = -1;

  /** Used to identify `toStringTag` values of typed arrays. */
  var typedArrayTags = {};
  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  typedArrayTags[uint32Tag] = true;
  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  typedArrayTags[weakMapTag] = false;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Used to map Latin Unicode letters to basic Latin letters. */
  var deburredLetters = {
    // Latin-1 Supplement block.
    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
    '\xc7': 'C',  '\xe7': 'c',
    '\xd0': 'D',  '\xf0': 'd',
    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
    '\xd1': 'N',  '\xf1': 'n',
    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
    '\xc6': 'Ae', '\xe6': 'ae',
    '\xde': 'Th', '\xfe': 'th',
    '\xdf': 'ss',
    // Latin Extended-A block.
    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
    '\u0134': 'J',  '\u0135': 'j',
    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
    '\u0174': 'W',  '\u0175': 'w',
    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
    '\u0132': 'IJ', '\u0133': 'ij',
    '\u0152': 'Oe', '\u0153': 'oe',
    '\u0149': "'n", '\u017f': 's'
  };

  /** Used to map characters to HTML entities. */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#39;'
  };

  /** Used to map HTML entities to characters. */
  var htmlUnescapes = {
    '&amp;': '&',
    '&lt;': '<',
    '&gt;': '>',
    '&quot;': '"',
    '&#39;': "'"
  };

  /** Used to escape characters for inclusion in compiled string literals. */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /** Built-in method references without a dependency on `root`. */
  var freeParseFloat = parseFloat,
      freeParseInt = parseInt;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports =  true && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /** Detect free variable `process` from Node.js. */
  var freeProcess = moduleExports && freeGlobal.process;

  /** Used to access faster Node.js helpers. */
  var nodeUtil = (function() {
    try {
      // Use `util.types` for Node.js 10+.
      var types = freeModule && freeModule.require && freeModule.require('util').types;

      if (types) {
        return types;
      }

      // Legacy `process.binding('util')` for Node.js < 10.
      return freeProcess && freeProcess.binding && freeProcess.binding('util');
    } catch (e) {}
  }());

  /* Node.js helper references. */
  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
      nodeIsDate = nodeUtil && nodeUtil.isDate,
      nodeIsMap = nodeUtil && nodeUtil.isMap,
      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
      nodeIsSet = nodeUtil && nodeUtil.isSet,
      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  /*--------------------------------------------------------------------------*/

  /**
   * A faster alternative to `Function#apply`, this function invokes `func`
   * with the `this` binding of `thisArg` and the arguments of `args`.
   *
   * @private
   * @param {Function} func The function to invoke.
   * @param {*} thisArg The `this` binding of `func`.
   * @param {Array} args The arguments to invoke `func` with.
   * @returns {*} Returns the result of `func`.
   */
  function apply(func, thisArg, args) {
    switch (args.length) {
      case 0: return func.call(thisArg);
      case 1: return func.call(thisArg, args[0]);
      case 2: return func.call(thisArg, args[0], args[1]);
      case 3: return func.call(thisArg, args[0], args[1], args[2]);
    }
    return func.apply(thisArg, args);
  }

  /**
   * A specialized version of `baseAggregator` for arrays.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} setter The function to set `accumulator` values.
   * @param {Function} iteratee The iteratee to transform keys.
   * @param {Object} accumulator The initial aggregated object.
   * @returns {Function} Returns `accumulator`.
   */
  function arrayAggregator(array, setter, iteratee, accumulator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      var value = array[index];
      setter(accumulator, value, iteratee(value), array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.forEachRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEachRight(array, iteratee) {
    var length = array == null ? 0 : array.length;

    while (length--) {
      if (iteratee(array[length], length, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * A specialized version of `_.every` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if all elements pass the predicate check,
   *  else `false`.
   */
  function arrayEvery(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (!predicate(array[index], index, array)) {
        return false;
      }
    }
    return true;
  }

  /**
   * A specialized version of `_.filter` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {Array} Returns the new filtered array.
   */
  function arrayFilter(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (predicate(value, index, array)) {
        result[resIndex++] = value;
      }
    }
    return result;
  }

  /**
   * A specialized version of `_.includes` for arrays without support for
   * specifying an index to search from.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludes(array, value) {
    var length = array == null ? 0 : array.length;
    return !!length && baseIndexOf(array, value, 0) > -1;
  }

  /**
   * This function is like `arrayIncludes` except that it accepts a comparator.
   *
   * @private
   * @param {Array} [array] The array to inspect.
   * @param {*} target The value to search for.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {boolean} Returns `true` if `target` is found, else `false`.
   */
  function arrayIncludesWith(array, value, comparator) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (comparator(value, array[index])) {
        return true;
      }
    }
    return false;
  }

  /**
   * A specialized version of `_.map` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the new mapped array.
   */
  function arrayMap(array, iteratee) {
    var index = -1,
        length = array == null ? 0 : array.length,
        result = Array(length);

    while (++index < length) {
      result[index] = iteratee(array[index], index, array);
    }
    return result;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array == null ? 0 : array.length;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.reduceRight` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the last element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
    var length = array == null ? 0 : array.length;
    if (initAccum && length) {
      accumulator = array[--length];
    }
    while (length--) {
      accumulator = iteratee(accumulator, array[length], length, array);
    }
    return accumulator;
  }

  /**
   * A specialized version of `_.some` for arrays without support for iteratee
   * shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} predicate The function invoked per iteration.
   * @returns {boolean} Returns `true` if any element passes the predicate check,
   *  else `false`.
   */
  function arraySome(array, predicate) {
    var index = -1,
        length = array == null ? 0 : array.length;

    while (++index < length) {
      if (predicate(array[index], index, array)) {
        return true;
      }
    }
    return false;
  }

  /**
   * Gets the size of an ASCII `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  var asciiSize = baseProperty('length');

  /**
   * Converts an ASCII `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function asciiToArray(string) {
    return string.split('');
  }

  /**
   * Splits an ASCII `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function asciiWords(string) {
    return string.match(reAsciiWord) || [];
  }

  /**
   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
   * without support for iteratee shorthands, which iterates over `collection`
   * using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the found element or its key, else `undefined`.
   */
  function baseFindKey(collection, predicate, eachFunc) {
    var result;
    eachFunc(collection, function(value, key, collection) {
      if (predicate(value, key, collection)) {
        result = key;
        return false;
      }
    });
    return result;
  }

  /**
   * The base implementation of `_.findIndex` and `_.findLastIndex` without
   * support for iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {Function} predicate The function invoked per iteration.
   * @param {number} fromIndex The index to search from.
   * @param {boolean} [fromRight] Specify iterating from right to left.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length,
        index = fromIndex + (fromRight ? 1 : -1);

    while ((fromRight ? index-- : ++index < length)) {
      if (predicate(array[index], index, array)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOf(array, value, fromIndex) {
    return value === value
      ? strictIndexOf(array, value, fromIndex)
      : baseFindIndex(array, baseIsNaN, fromIndex);
  }

  /**
   * This function is like `baseIndexOf` except that it accepts a comparator.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @param {Function} comparator The comparator invoked per element.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function baseIndexOfWith(array, value, fromIndex, comparator) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (comparator(array[index], value)) {
        return index;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.isNaN` without support for number objects.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
   */
  function baseIsNaN(value) {
    return value !== value;
  }

  /**
   * The base implementation of `_.mean` and `_.meanBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the mean.
   */
  function baseMean(array, iteratee) {
    var length = array == null ? 0 : array.length;
    return length ? (baseSum(array, iteratee) / length) : NAN;
  }

  /**
   * The base implementation of `_.property` without support for deep paths.
   *
   * @private
   * @param {string} key The key of the property to get.
   * @returns {Function} Returns the new accessor function.
   */
  function baseProperty(key) {
    return function(object) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.propertyOf` without support for deep paths.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Function} Returns the new accessor function.
   */
  function basePropertyOf(object) {
    return function(key) {
      return object == null ? undefined : object[key];
    };
  }

  /**
   * The base implementation of `_.reduce` and `_.reduceRight`, without support
   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
   *
   * @private
   * @param {Array|Object} collection The collection to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} accumulator The initial value.
   * @param {boolean} initAccum Specify using the first or last element of
   *  `collection` as the initial value.
   * @param {Function} eachFunc The function to iterate over `collection`.
   * @returns {*} Returns the accumulated value.
   */
  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
    eachFunc(collection, function(value, index, collection) {
      accumulator = initAccum
        ? (initAccum = false, value)
        : iteratee(accumulator, value, index, collection);
    });
    return accumulator;
  }

  /**
   * The base implementation of `_.sortBy` which uses `comparer` to define the
   * sort order of `array` and replaces criteria objects with their corresponding
   * values.
   *
   * @private
   * @param {Array} array The array to sort.
   * @param {Function} comparer The function to define sort order.
   * @returns {Array} Returns `array`.
   */
  function baseSortBy(array, comparer) {
    var length = array.length;

    array.sort(comparer);
    while (length--) {
      array[length] = array[length].value;
    }
    return array;
  }

  /**
   * The base implementation of `_.sum` and `_.sumBy` without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {number} Returns the sum.
   */
  function baseSum(array, iteratee) {
    var result,
        index = -1,
        length = array.length;

    while (++index < length) {
      var current = iteratee(array[index]);
      if (current !== undefined) {
        result = result === undefined ? current : (result + current);
      }
    }
    return result;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
   * of key-value pairs for `object` corresponding to the property names of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the key-value pairs.
   */
  function baseToPairs(object, props) {
    return arrayMap(props, function(key) {
      return [key, object[key]];
    });
  }

  /**
   * The base implementation of `_.trim`.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} Returns the trimmed string.
   */
  function baseTrim(string) {
    return string
      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
      : string;
  }

  /**
   * The base implementation of `_.unary` without support for storing metadata.
   *
   * @private
   * @param {Function} func The function to cap arguments for.
   * @returns {Function} Returns the new capped function.
   */
  function baseUnary(func) {
    return function(value) {
      return func(value);
    };
  }

  /**
   * The base implementation of `_.values` and `_.valuesIn` which creates an
   * array of `object` property values corresponding to the property names
   * of `props`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Array} props The property names to get values for.
   * @returns {Object} Returns the array of property values.
   */
  function baseValues(object, props) {
    return arrayMap(props, function(key) {
      return object[key];
    });
  }

  /**
   * Checks if a `cache` value for `key` exists.
   *
   * @private
   * @param {Object} cache The cache to query.
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function cacheHas(cache, key) {
    return cache.has(key);
  }

  /**
   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the first unmatched string symbol.
   */
  function charsStartIndex(strSymbols, chrSymbols) {
    var index = -1,
        length = strSymbols.length;

    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
   * that is not found in the character symbols.
   *
   * @private
   * @param {Array} strSymbols The string symbols to inspect.
   * @param {Array} chrSymbols The character symbols to find.
   * @returns {number} Returns the index of the last unmatched string symbol.
   */
  function charsEndIndex(strSymbols, chrSymbols) {
    var index = strSymbols.length;

    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
    return index;
  }

  /**
   * Gets the number of `placeholder` occurrences in `array`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} placeholder The placeholder to search for.
   * @returns {number} Returns the placeholder count.
   */
  function countHolders(array, placeholder) {
    var length = array.length,
        result = 0;

    while (length--) {
      if (array[length] === placeholder) {
        ++result;
      }
    }
    return result;
  }

  /**
   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
   * letters to basic Latin letters.
   *
   * @private
   * @param {string} letter The matched letter to deburr.
   * @returns {string} Returns the deburred letter.
   */
  var deburrLetter = basePropertyOf(deburredLetters);

  /**
   * Used by `_.escape` to convert characters to HTML entities.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  /**
   * Used by `_.template` to escape characters for inclusion in compiled string literals.
   *
   * @private
   * @param {string} chr The matched character to escape.
   * @returns {string} Returns the escaped character.
   */
  function escapeStringChar(chr) {
    return '\\' + stringEscapes[chr];
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `string` contains Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
   */
  function hasUnicode(string) {
    return reHasUnicode.test(string);
  }

  /**
   * Checks if `string` contains a word composed of Unicode symbols.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {boolean} Returns `true` if a word is found, else `false`.
   */
  function hasUnicodeWord(string) {
    return reHasUnicodeWord.test(string);
  }

  /**
   * Converts `iterator` to an array.
   *
   * @private
   * @param {Object} iterator The iterator to convert.
   * @returns {Array} Returns the converted array.
   */
  function iteratorToArray(iterator) {
    var data,
        result = [];

    while (!(data = iterator.next()).done) {
      result.push(data.value);
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Replaces all `placeholder` elements in `array` with an internal placeholder
   * and returns an array of their indexes.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {*} placeholder The placeholder to replace.
   * @returns {Array} Returns the new array of placeholder indexes.
   */
  function replaceHolders(array, placeholder) {
    var index = -1,
        length = array.length,
        resIndex = 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value === placeholder || value === PLACEHOLDER) {
        array[index] = PLACEHOLDER;
        result[resIndex++] = index;
      }
    }
    return result;
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /**
   * Converts `set` to its value-value pairs.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the value-value pairs.
   */
  function setToPairs(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = [value, value];
    });
    return result;
  }

  /**
   * A specialized version of `_.indexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictIndexOf(array, value, fromIndex) {
    var index = fromIndex - 1,
        length = array.length;

    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * A specialized version of `_.lastIndexOf` which performs strict equality
   * comparisons of values, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} value The value to search for.
   * @param {number} fromIndex The index to search from.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function strictLastIndexOf(array, value, fromIndex) {
    var index = fromIndex + 1;
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return index;
  }

  /**
   * Gets the number of symbols in `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the string size.
   */
  function stringSize(string) {
    return hasUnicode(string)
      ? unicodeSize(string)
      : asciiSize(string);
  }

  /**
   * Converts `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function stringToArray(string) {
    return hasUnicode(string)
      ? unicodeToArray(string)
      : asciiToArray(string);
  }

  /**
   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
   * character of `string`.
   *
   * @private
   * @param {string} string The string to inspect.
   * @returns {number} Returns the index of the last non-whitespace character.
   */
  function trimmedEndIndex(string) {
    var index = string.length;

    while (index-- && reWhitespace.test(string.charAt(index))) {}
    return index;
  }

  /**
   * Used by `_.unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {string} chr The matched character to unescape.
   * @returns {string} Returns the unescaped character.
   */
  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  /**
   * Gets the size of a Unicode `string`.
   *
   * @private
   * @param {string} string The string inspect.
   * @returns {number} Returns the string size.
   */
  function unicodeSize(string) {
    var result = reUnicode.lastIndex = 0;
    while (reUnicode.test(string)) {
      ++result;
    }
    return result;
  }

  /**
   * Converts a Unicode `string` to an array.
   *
   * @private
   * @param {string} string The string to convert.
   * @returns {Array} Returns the converted array.
   */
  function unicodeToArray(string) {
    return string.match(reUnicode) || [];
  }

  /**
   * Splits a Unicode `string` into an array of its words.
   *
   * @private
   * @param {string} The string to inspect.
   * @returns {Array} Returns the words of `string`.
   */
  function unicodeWords(string) {
    return string.match(reUnicodeWord) || [];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Create a new pristine `lodash` function using the `context` object.
   *
   * @static
   * @memberOf _
   * @since 1.1.0
   * @category Util
   * @param {Object} [context=root] The context object.
   * @returns {Function} Returns a new `lodash` function.
   * @example
   *
   * _.mixin({ 'foo': _.constant('foo') });
   *
   * var lodash = _.runInContext();
   * lodash.mixin({ 'bar': lodash.constant('bar') });
   *
   * _.isFunction(_.foo);
   * // => true
   * _.isFunction(_.bar);
   * // => false
   *
   * lodash.isFunction(lodash.foo);
   * // => false
   * lodash.isFunction(lodash.bar);
   * // => true
   *
   * // Create a suped-up `defer` in Node.js.
   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
   */
  var runInContext = (function runInContext(context) {
    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

    /** Built-in constructor references. */
    var Array = context.Array,
        Date = context.Date,
        Error = context.Error,
        Function = context.Function,
        Math = context.Math,
        Object = context.Object,
        RegExp = context.RegExp,
        String = context.String,
        TypeError = context.TypeError;

    /** Used for built-in method references. */
    var arrayProto = Array.prototype,
        funcProto = Function.prototype,
        objectProto = Object.prototype;

    /** Used to detect overreaching core-js shims. */
    var coreJsData = context['__core-js_shared__'];

    /** Used to resolve the decompiled source of functions. */
    var funcToString = funcProto.toString;

    /** Used to check objects for own properties. */
    var hasOwnProperty = objectProto.hasOwnProperty;

    /** Used to generate unique IDs. */
    var idCounter = 0;

    /** Used to detect methods masquerading as native. */
    var maskSrcKey = (function() {
      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
      return uid ? ('Symbol(src)_1.' + uid) : '';
    }());

    /**
     * Used to resolve the
     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
     * of values.
     */
    var nativeObjectToString = objectProto.toString;

    /** Used to infer the `Object` constructor. */
    var objectCtorString = funcToString.call(Object);

    /** Used to restore the original `_` reference in `_.noConflict`. */
    var oldDash = root._;

    /** Used to detect if a method is native. */
    var reIsNative = RegExp('^' +
      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
    );

    /** Built-in value references. */
    var Buffer = moduleExports ? context.Buffer : undefined,
        Symbol = context.Symbol,
        Uint8Array = context.Uint8Array,
        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined,
        getPrototype = overArg(Object.getPrototypeOf, Object),
        objectCreate = Object.create,
        propertyIsEnumerable = objectProto.propertyIsEnumerable,
        splice = arrayProto.splice,
        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined,
        symIterator = Symbol ? Symbol.iterator : undefined,
        symToStringTag = Symbol ? Symbol.toStringTag : undefined;

    var defineProperty = (function() {
      try {
        var func = getNative(Object, 'defineProperty');
        func({}, '', {});
        return func;
      } catch (e) {}
    }());

    /** Mocked built-ins. */
    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
        ctxNow = Date && Date.now !== root.Date.now && Date.now,
        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

    /* Built-in method references for those with the same name as other `lodash` methods. */
    var nativeCeil = Math.ceil,
        nativeFloor = Math.floor,
        nativeGetSymbols = Object.getOwnPropertySymbols,
        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined,
        nativeIsFinite = context.isFinite,
        nativeJoin = arrayProto.join,
        nativeKeys = overArg(Object.keys, Object),
        nativeMax = Math.max,
        nativeMin = Math.min,
        nativeNow = Date.now,
        nativeParseInt = context.parseInt,
        nativeRandom = Math.random,
        nativeReverse = arrayProto.reverse;

    /* Built-in method references that are verified to be native. */
    var DataView = getNative(context, 'DataView'),
        Map = getNative(context, 'Map'),
        Promise = getNative(context, 'Promise'),
        Set = getNative(context, 'Set'),
        WeakMap = getNative(context, 'WeakMap'),
        nativeCreate = getNative(Object, 'create');

    /** Used to store function metadata. */
    var metaMap = WeakMap && new WeakMap;

    /** Used to lookup unminified function names. */
    var realNames = {};

    /** Used to detect maps, sets, and weakmaps. */
    var dataViewCtorString = toSource(DataView),
        mapCtorString = toSource(Map),
        promiseCtorString = toSource(Promise),
        setCtorString = toSource(Set),
        weakMapCtorString = toSource(WeakMap);

    /** Used to convert symbols to primitives and strings. */
    var symbolProto = Symbol ? Symbol.prototype : undefined,
        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined,
        symbolToString = symbolProto ? symbolProto.toString : undefined;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` object which wraps `value` to enable implicit method
     * chain sequences. Methods that operate on and return arrays, collections,
     * and functions can be chained together. Methods that retrieve a single value
     * or may return a primitive value will automatically end the chain sequence
     * and return the unwrapped value. Otherwise, the value must be unwrapped
     * with `_#value`.
     *
     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
     * enabled using `_.chain`.
     *
     * The execution of chained methods is lazy, that is, it's deferred until
     * `_#value` is implicitly or explicitly called.
     *
     * Lazy evaluation allows several methods to support shortcut fusion.
     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
     * the creation of intermediate arrays and can greatly reduce the number of
     * iteratee executions. Sections of a chain sequence qualify for shortcut
     * fusion if the section is applied to an array and iteratees accept only
     * one argument. The heuristic for whether a section qualifies for shortcut
     * fusion is subject to change.
     *
     * Chaining is supported in custom builds as long as the `_#value` method is
     * directly or indirectly included in the build.
     *
     * In addition to lodash methods, wrappers have `Array` and `String` methods.
     *
     * The wrapper `Array` methods are:
     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
     *
     * The wrapper `String` methods are:
     * `replace` and `split`
     *
     * The wrapper methods that support shortcut fusion are:
     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
     *
     * The chainable wrapper methods are:
     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
     * `zipObject`, `zipObjectDeep`, and `zipWith`
     *
     * The wrapper methods that are **not** chainable by default are:
     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
     * `upperFirst`, `value`, and `words`
     *
     * @name _
     * @constructor
     * @category Seq
     * @param {*} value The value to wrap in a `lodash` instance.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2, 3]);
     *
     * // Returns an unwrapped value.
     * wrapped.reduce(_.add);
     * // => 6
     *
     * // Returns a wrapped value.
     * var squares = wrapped.map(square);
     *
     * _.isArray(squares);
     * // => false
     *
     * _.isArray(squares.value());
     * // => true
     */
    function lodash(value) {
      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
        if (value instanceof LodashWrapper) {
          return value;
        }
        if (hasOwnProperty.call(value, '__wrapped__')) {
          return wrapperClone(value);
        }
      }
      return new LodashWrapper(value);
    }

    /**
     * The base implementation of `_.create` without support for assigning
     * properties to the created object.
     *
     * @private
     * @param {Object} proto The object to inherit from.
     * @returns {Object} Returns the new object.
     */
    var baseCreate = (function() {
      function object() {}
      return function(proto) {
        if (!isObject(proto)) {
          return {};
        }
        if (objectCreate) {
          return objectCreate(proto);
        }
        object.prototype = proto;
        var result = new object;
        object.prototype = undefined;
        return result;
      };
    }());

    /**
     * The function whose prototype chain sequence wrappers inherit from.
     *
     * @private
     */
    function baseLodash() {
      // No operation performed.
    }

    /**
     * The base constructor for creating `lodash` wrapper objects.
     *
     * @private
     * @param {*} value The value to wrap.
     * @param {boolean} [chainAll] Enable explicit method chain sequences.
     */
    function LodashWrapper(value, chainAll) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__chain__ = !!chainAll;
      this.__index__ = 0;
      this.__values__ = undefined;
    }

    /**
     * By default, the template delimiters used by lodash are like those in
     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
     * following template settings to use alternative delimiters.
     *
     * @static
     * @memberOf _
     * @type {Object}
     */
    lodash.templateSettings = {

      /**
       * Used to detect `data` property values to be HTML-escaped.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'escape': reEscape,

      /**
       * Used to detect code to be evaluated.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'evaluate': reEvaluate,

      /**
       * Used to detect `data` property values to inject.
       *
       * @memberOf _.templateSettings
       * @type {RegExp}
       */
      'interpolate': reInterpolate,

      /**
       * Used to reference the data object in the template text.
       *
       * @memberOf _.templateSettings
       * @type {string}
       */
      'variable': '',

      /**
       * Used to import variables into the compiled template.
       *
       * @memberOf _.templateSettings
       * @type {Object}
       */
      'imports': {

        /**
         * A reference to the `lodash` function.
         *
         * @memberOf _.templateSettings.imports
         * @type {Function}
         */
        '_': lodash
      }
    };

    // Ensure wrappers are instances of `baseLodash`.
    lodash.prototype = baseLodash.prototype;
    lodash.prototype.constructor = lodash;

    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
    LodashWrapper.prototype.constructor = LodashWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
     *
     * @private
     * @constructor
     * @param {*} value The value to wrap.
     */
    function LazyWrapper(value) {
      this.__wrapped__ = value;
      this.__actions__ = [];
      this.__dir__ = 1;
      this.__filtered__ = false;
      this.__iteratees__ = [];
      this.__takeCount__ = MAX_ARRAY_LENGTH;
      this.__views__ = [];
    }

    /**
     * Creates a clone of the lazy wrapper object.
     *
     * @private
     * @name clone
     * @memberOf LazyWrapper
     * @returns {Object} Returns the cloned `LazyWrapper` object.
     */
    function lazyClone() {
      var result = new LazyWrapper(this.__wrapped__);
      result.__actions__ = copyArray(this.__actions__);
      result.__dir__ = this.__dir__;
      result.__filtered__ = this.__filtered__;
      result.__iteratees__ = copyArray(this.__iteratees__);
      result.__takeCount__ = this.__takeCount__;
      result.__views__ = copyArray(this.__views__);
      return result;
    }

    /**
     * Reverses the direction of lazy iteration.
     *
     * @private
     * @name reverse
     * @memberOf LazyWrapper
     * @returns {Object} Returns the new reversed `LazyWrapper` object.
     */
    function lazyReverse() {
      if (this.__filtered__) {
        var result = new LazyWrapper(this);
        result.__dir__ = -1;
        result.__filtered__ = true;
      } else {
        result = this.clone();
        result.__dir__ *= -1;
      }
      return result;
    }

    /**
     * Extracts the unwrapped value from its lazy wrapper.
     *
     * @private
     * @name value
     * @memberOf LazyWrapper
     * @returns {*} Returns the unwrapped value.
     */
    function lazyValue() {
      var array = this.__wrapped__.value(),
          dir = this.__dir__,
          isArr = isArray(array),
          isRight = dir < 0,
          arrLength = isArr ? array.length : 0,
          view = getView(0, arrLength, this.__views__),
          start = view.start,
          end = view.end,
          length = end - start,
          index = isRight ? end : (start - 1),
          iteratees = this.__iteratees__,
          iterLength = iteratees.length,
          resIndex = 0,
          takeCount = nativeMin(length, this.__takeCount__);

      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
        return baseWrapperValue(array, this.__actions__);
      }
      var result = [];

      outer:
      while (length-- && resIndex < takeCount) {
        index += dir;

        var iterIndex = -1,
            value = array[index];

        while (++iterIndex < iterLength) {
          var data = iteratees[iterIndex],
              iteratee = data.iteratee,
              type = data.type,
              computed = iteratee(value);

          if (type == LAZY_MAP_FLAG) {
            value = computed;
          } else if (!computed) {
            if (type == LAZY_FILTER_FLAG) {
              continue outer;
            } else {
              break outer;
            }
          }
        }
        result[resIndex++] = value;
      }
      return result;
    }

    // Ensure `LazyWrapper` is an instance of `baseLodash`.
    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
    LazyWrapper.prototype.constructor = LazyWrapper;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a hash object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Hash(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the hash.
     *
     * @private
     * @name clear
     * @memberOf Hash
     */
    function hashClear() {
      this.__data__ = nativeCreate ? nativeCreate(null) : {};
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the hash.
     *
     * @private
     * @name delete
     * @memberOf Hash
     * @param {Object} hash The hash to modify.
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function hashDelete(key) {
      var result = this.has(key) && delete this.__data__[key];
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the hash value for `key`.
     *
     * @private
     * @name get
     * @memberOf Hash
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function hashGet(key) {
      var data = this.__data__;
      if (nativeCreate) {
        var result = data[key];
        return result === HASH_UNDEFINED ? undefined : result;
      }
      return hasOwnProperty.call(data, key) ? data[key] : undefined;
    }

    /**
     * Checks if a hash value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Hash
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function hashHas(key) {
      var data = this.__data__;
      return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
    }

    /**
     * Sets the hash `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Hash
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the hash instance.
     */
    function hashSet(key, value) {
      var data = this.__data__;
      this.size += this.has(key) ? 0 : 1;
      data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
      return this;
    }

    // Add methods to `Hash`.
    Hash.prototype.clear = hashClear;
    Hash.prototype['delete'] = hashDelete;
    Hash.prototype.get = hashGet;
    Hash.prototype.has = hashHas;
    Hash.prototype.set = hashSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an list cache object.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function ListCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the list cache.
     *
     * @private
     * @name clear
     * @memberOf ListCache
     */
    function listCacheClear() {
      this.__data__ = [];
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the list cache.
     *
     * @private
     * @name delete
     * @memberOf ListCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function listCacheDelete(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        return false;
      }
      var lastIndex = data.length - 1;
      if (index == lastIndex) {
        data.pop();
      } else {
        splice.call(data, index, 1);
      }
      --this.size;
      return true;
    }

    /**
     * Gets the list cache value for `key`.
     *
     * @private
     * @name get
     * @memberOf ListCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function listCacheGet(key) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      return index < 0 ? undefined : data[index][1];
    }

    /**
     * Checks if a list cache value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf ListCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function listCacheHas(key) {
      return assocIndexOf(this.__data__, key) > -1;
    }

    /**
     * Sets the list cache `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf ListCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the list cache instance.
     */
    function listCacheSet(key, value) {
      var data = this.__data__,
          index = assocIndexOf(data, key);

      if (index < 0) {
        ++this.size;
        data.push([key, value]);
      } else {
        data[index][1] = value;
      }
      return this;
    }

    // Add methods to `ListCache`.
    ListCache.prototype.clear = listCacheClear;
    ListCache.prototype['delete'] = listCacheDelete;
    ListCache.prototype.get = listCacheGet;
    ListCache.prototype.has = listCacheHas;
    ListCache.prototype.set = listCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a map cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function MapCache(entries) {
      var index = -1,
          length = entries == null ? 0 : entries.length;

      this.clear();
      while (++index < length) {
        var entry = entries[index];
        this.set(entry[0], entry[1]);
      }
    }

    /**
     * Removes all key-value entries from the map.
     *
     * @private
     * @name clear
     * @memberOf MapCache
     */
    function mapCacheClear() {
      this.size = 0;
      this.__data__ = {
        'hash': new Hash,
        'map': new (Map || ListCache),
        'string': new Hash
      };
    }

    /**
     * Removes `key` and its value from the map.
     *
     * @private
     * @name delete
     * @memberOf MapCache
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function mapCacheDelete(key) {
      var result = getMapData(this, key)['delete'](key);
      this.size -= result ? 1 : 0;
      return result;
    }

    /**
     * Gets the map value for `key`.
     *
     * @private
     * @name get
     * @memberOf MapCache
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function mapCacheGet(key) {
      return getMapData(this, key).get(key);
    }

    /**
     * Checks if a map value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf MapCache
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function mapCacheHas(key) {
      return getMapData(this, key).has(key);
    }

    /**
     * Sets the map `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf MapCache
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the map cache instance.
     */
    function mapCacheSet(key, value) {
      var data = getMapData(this, key),
          size = data.size;

      data.set(key, value);
      this.size += data.size == size ? 0 : 1;
      return this;
    }

    // Add methods to `MapCache`.
    MapCache.prototype.clear = mapCacheClear;
    MapCache.prototype['delete'] = mapCacheDelete;
    MapCache.prototype.get = mapCacheGet;
    MapCache.prototype.has = mapCacheHas;
    MapCache.prototype.set = mapCacheSet;

    /*------------------------------------------------------------------------*/

    /**
     *
     * Creates an array cache object to store unique values.
     *
     * @private
     * @constructor
     * @param {Array} [values] The values to cache.
     */
    function SetCache(values) {
      var index = -1,
          length = values == null ? 0 : values.length;

      this.__data__ = new MapCache;
      while (++index < length) {
        this.add(values[index]);
      }
    }

    /**
     * Adds `value` to the array cache.
     *
     * @private
     * @name add
     * @memberOf SetCache
     * @alias push
     * @param {*} value The value to cache.
     * @returns {Object} Returns the cache instance.
     */
    function setCacheAdd(value) {
      this.__data__.set(value, HASH_UNDEFINED);
      return this;
    }

    /**
     * Checks if `value` is in the array cache.
     *
     * @private
     * @name has
     * @memberOf SetCache
     * @param {*} value The value to search for.
     * @returns {number} Returns `true` if `value` is found, else `false`.
     */
    function setCacheHas(value) {
      return this.__data__.has(value);
    }

    // Add methods to `SetCache`.
    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
    SetCache.prototype.has = setCacheHas;

    /*------------------------------------------------------------------------*/

    /**
     * Creates a stack cache object to store key-value pairs.
     *
     * @private
     * @constructor
     * @param {Array} [entries] The key-value pairs to cache.
     */
    function Stack(entries) {
      var data = this.__data__ = new ListCache(entries);
      this.size = data.size;
    }

    /**
     * Removes all key-value entries from the stack.
     *
     * @private
     * @name clear
     * @memberOf Stack
     */
    function stackClear() {
      this.__data__ = new ListCache;
      this.size = 0;
    }

    /**
     * Removes `key` and its value from the stack.
     *
     * @private
     * @name delete
     * @memberOf Stack
     * @param {string} key The key of the value to remove.
     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
     */
    function stackDelete(key) {
      var data = this.__data__,
          result = data['delete'](key);

      this.size = data.size;
      return result;
    }

    /**
     * Gets the stack value for `key`.
     *
     * @private
     * @name get
     * @memberOf Stack
     * @param {string} key The key of the value to get.
     * @returns {*} Returns the entry value.
     */
    function stackGet(key) {
      return this.__data__.get(key);
    }

    /**
     * Checks if a stack value for `key` exists.
     *
     * @private
     * @name has
     * @memberOf Stack
     * @param {string} key The key of the entry to check.
     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
     */
    function stackHas(key) {
      return this.__data__.has(key);
    }

    /**
     * Sets the stack `key` to `value`.
     *
     * @private
     * @name set
     * @memberOf Stack
     * @param {string} key The key of the value to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns the stack cache instance.
     */
    function stackSet(key, value) {
      var data = this.__data__;
      if (data instanceof ListCache) {
        var pairs = data.__data__;
        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
          pairs.push([key, value]);
          this.size = ++data.size;
          return this;
        }
        data = this.__data__ = new MapCache(pairs);
      }
      data.set(key, value);
      this.size = data.size;
      return this;
    }

    // Add methods to `Stack`.
    Stack.prototype.clear = stackClear;
    Stack.prototype['delete'] = stackDelete;
    Stack.prototype.get = stackGet;
    Stack.prototype.has = stackHas;
    Stack.prototype.set = stackSet;

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of the enumerable property names of the array-like `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @param {boolean} inherited Specify returning inherited property names.
     * @returns {Array} Returns the array of property names.
     */
    function arrayLikeKeys(value, inherited) {
      var isArr = isArray(value),
          isArg = !isArr && isArguments(value),
          isBuff = !isArr && !isArg && isBuffer(value),
          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
          skipIndexes = isArr || isArg || isBuff || isType,
          result = skipIndexes ? baseTimes(value.length, String) : [],
          length = result.length;

      for (var key in value) {
        if ((inherited || hasOwnProperty.call(value, key)) &&
            !(skipIndexes && (
               // Safari 9 has enumerable `arguments.length` in strict mode.
               key == 'length' ||
               // Node.js 0.10 has enumerable non-index properties on buffers.
               (isBuff && (key == 'offset' || key == 'parent')) ||
               // PhantomJS 2 has enumerable non-index properties on typed arrays.
               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
               // Skip index properties.
               isIndex(key, length)
            ))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * A specialized version of `_.sample` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @returns {*} Returns the random element.
     */
    function arraySample(array) {
      var length = array.length;
      return length ? array[baseRandom(0, length - 1)] : undefined;
    }

    /**
     * A specialized version of `_.sampleSize` for arrays.
     *
     * @private
     * @param {Array} array The array to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function arraySampleSize(array, n) {
      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
    }

    /**
     * A specialized version of `_.shuffle` for arrays.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function arrayShuffle(array) {
      return shuffleSelf(copyArray(array));
    }

    /**
     * This function is like `assignValue` except that it doesn't assign
     * `undefined` values.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignMergeValue(object, key, value) {
      if ((value !== undefined && !eq(object[key], value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Assigns `value` to `key` of `object` if the existing value is not equivalent
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function assignValue(object, key, value) {
      var objValue = object[key];
      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
          (value === undefined && !(key in object))) {
        baseAssignValue(object, key, value);
      }
    }

    /**
     * Gets the index at which the `key` is found in `array` of key-value pairs.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {*} key The key to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     */
    function assocIndexOf(array, key) {
      var length = array.length;
      while (length--) {
        if (eq(array[length][0], key)) {
          return length;
        }
      }
      return -1;
    }

    /**
     * Aggregates elements of `collection` on `accumulator` with keys transformed
     * by `iteratee` and values set by `setter`.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform keys.
     * @param {Object} accumulator The initial aggregated object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseAggregator(collection, setter, iteratee, accumulator) {
      baseEach(collection, function(value, key, collection) {
        setter(accumulator, value, iteratee(value), collection);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.assign` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssign(object, source) {
      return object && copyObject(source, keys(source), object);
    }

    /**
     * The base implementation of `_.assignIn` without support for multiple sources
     * or `customizer` functions.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @returns {Object} Returns `object`.
     */
    function baseAssignIn(object, source) {
      return object && copyObject(source, keysIn(source), object);
    }

    /**
     * The base implementation of `assignValue` and `assignMergeValue` without
     * value checks.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {string} key The key of the property to assign.
     * @param {*} value The value to assign.
     */
    function baseAssignValue(object, key, value) {
      if (key == '__proto__' && defineProperty) {
        defineProperty(object, key, {
          'configurable': true,
          'enumerable': true,
          'value': value,
          'writable': true
        });
      } else {
        object[key] = value;
      }
    }

    /**
     * The base implementation of `_.at` without support for individual paths.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {string[]} paths The property paths to pick.
     * @returns {Array} Returns the picked elements.
     */
    function baseAt(object, paths) {
      var index = -1,
          length = paths.length,
          result = Array(length),
          skip = object == null;

      while (++index < length) {
        result[index] = skip ? undefined : get(object, paths[index]);
      }
      return result;
    }

    /**
     * The base implementation of `_.clamp` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     */
    function baseClamp(number, lower, upper) {
      if (number === number) {
        if (upper !== undefined) {
          number = number <= upper ? number : upper;
        }
        if (lower !== undefined) {
          number = number >= lower ? number : lower;
        }
      }
      return number;
    }

    /**
     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
     * traversed objects.
     *
     * @private
     * @param {*} value The value to clone.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Deep clone
     *  2 - Flatten inherited properties
     *  4 - Clone symbols
     * @param {Function} [customizer] The function to customize cloning.
     * @param {string} [key] The key of `value`.
     * @param {Object} [object] The parent object of `value`.
     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
     * @returns {*} Returns the cloned value.
     */
    function baseClone(value, bitmask, customizer, key, object, stack) {
      var result,
          isDeep = bitmask & CLONE_DEEP_FLAG,
          isFlat = bitmask & CLONE_FLAT_FLAG,
          isFull = bitmask & CLONE_SYMBOLS_FLAG;

      if (customizer) {
        result = object ? customizer(value, key, object, stack) : customizer(value);
      }
      if (result !== undefined) {
        return result;
      }
      if (!isObject(value)) {
        return value;
      }
      var isArr = isArray(value);
      if (isArr) {
        result = initCloneArray(value);
        if (!isDeep) {
          return copyArray(value, result);
        }
      } else {
        var tag = getTag(value),
            isFunc = tag == funcTag || tag == genTag;

        if (isBuffer(value)) {
          return cloneBuffer(value, isDeep);
        }
        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
          result = (isFlat || isFunc) ? {} : initCloneObject(value);
          if (!isDeep) {
            return isFlat
              ? copySymbolsIn(value, baseAssignIn(result, value))
              : copySymbols(value, baseAssign(result, value));
          }
        } else {
          if (!cloneableTags[tag]) {
            return object ? value : {};
          }
          result = initCloneByTag(value, tag, isDeep);
        }
      }
      // Check for circular references and return its corresponding clone.
      stack || (stack = new Stack);
      var stacked = stack.get(value);
      if (stacked) {
        return stacked;
      }
      stack.set(value, result);

      if (isSet(value)) {
        value.forEach(function(subValue) {
          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
        });
      } else if (isMap(value)) {
        value.forEach(function(subValue, key) {
          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
        });
      }

      var keysFunc = isFull
        ? (isFlat ? getAllKeysIn : getAllKeys)
        : (isFlat ? keysIn : keys);

      var props = isArr ? undefined : keysFunc(value);
      arrayEach(props || value, function(subValue, key) {
        if (props) {
          key = subValue;
          subValue = value[key];
        }
        // Recursively populate clone (susceptible to call stack limits).
        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
      });
      return result;
    }

    /**
     * The base implementation of `_.conforms` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     */
    function baseConforms(source) {
      var props = keys(source);
      return function(object) {
        return baseConformsTo(object, source, props);
      };
    }

    /**
     * The base implementation of `_.conformsTo` which accepts `props` to check.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     */
    function baseConformsTo(object, source, props) {
      var length = props.length;
      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (length--) {
        var key = props[length],
            predicate = source[key],
            value = object[key];

        if ((value === undefined && !(key in object)) || !predicate(value)) {
          return false;
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.delay` and `_.defer` which accepts `args`
     * to provide to `func`.
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {Array} args The arguments to provide to `func`.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    function baseDelay(func, wait, args) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return setTimeout(function() { func.apply(undefined, args); }, wait);
    }

    /**
     * The base implementation of methods like `_.difference` without support
     * for excluding multiple arrays or iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Array} values The values to exclude.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     */
    function baseDifference(array, values, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          isCommon = true,
          length = array.length,
          result = [],
          valuesLength = values.length;

      if (!length) {
        return result;
      }
      if (iteratee) {
        values = arrayMap(values, baseUnary(iteratee));
      }
      if (comparator) {
        includes = arrayIncludesWith;
        isCommon = false;
      }
      else if (values.length >= LARGE_ARRAY_SIZE) {
        includes = cacheHas;
        isCommon = false;
        values = new SetCache(values);
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee == null ? value : iteratee(value);

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var valuesIndex = valuesLength;
          while (valuesIndex--) {
            if (values[valuesIndex] === computed) {
              continue outer;
            }
          }
          result.push(value);
        }
        else if (!includes(values, computed, comparator)) {
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.forEach` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEach = createBaseEach(baseForOwn);

    /**
     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     */
    var baseEachRight = createBaseEach(baseForOwnRight, true);

    /**
     * The base implementation of `_.every` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`
     */
    function baseEvery(collection, predicate) {
      var result = true;
      baseEach(collection, function(value, index, collection) {
        result = !!predicate(value, index, collection);
        return result;
      });
      return result;
    }

    /**
     * The base implementation of methods like `_.max` and `_.min` which accepts a
     * `comparator` to determine the extremum value.
     *
     * @private
     * @param {Array} array The array to iterate over.
     * @param {Function} iteratee The iteratee invoked per iteration.
     * @param {Function} comparator The comparator used to compare values.
     * @returns {*} Returns the extremum value.
     */
    function baseExtremum(array, iteratee, comparator) {
      var index = -1,
          length = array.length;

      while (++index < length) {
        var value = array[index],
            current = iteratee(value);

        if (current != null && (computed === undefined
              ? (current === current && !isSymbol(current))
              : comparator(current, computed)
            )) {
          var computed = current,
              result = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.fill` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     */
    function baseFill(array, value, start, end) {
      var length = array.length;

      start = toInteger(start);
      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = (end === undefined || end > length) ? length : toInteger(end);
      if (end < 0) {
        end += length;
      }
      end = start > end ? 0 : toLength(end);
      while (start < end) {
        array[start++] = value;
      }
      return array;
    }

    /**
     * The base implementation of `_.filter` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     */
    function baseFilter(collection, predicate) {
      var result = [];
      baseEach(collection, function(value, index, collection) {
        if (predicate(value, index, collection)) {
          result.push(value);
        }
      });
      return result;
    }

    /**
     * The base implementation of `_.flatten` with support for restricting flattening.
     *
     * @private
     * @param {Array} array The array to flatten.
     * @param {number} depth The maximum recursion depth.
     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
     * @param {Array} [result=[]] The initial result value.
     * @returns {Array} Returns the new flattened array.
     */
    function baseFlatten(array, depth, predicate, isStrict, result) {
      var index = -1,
          length = array.length;

      predicate || (predicate = isFlattenable);
      result || (result = []);

      while (++index < length) {
        var value = array[index];
        if (depth > 0 && predicate(value)) {
          if (depth > 1) {
            // Recursively flatten arrays (susceptible to call stack limits).
            baseFlatten(value, depth - 1, predicate, isStrict, result);
          } else {
            arrayPush(result, value);
          }
        } else if (!isStrict) {
          result[result.length] = value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `baseForOwn` which iterates over `object`
     * properties returned by `keysFunc` and invokes `iteratee` for each property.
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseFor = createBaseFor();

    /**
     * This function is like `baseFor` except that it iterates over properties
     * in the opposite order.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @returns {Object} Returns `object`.
     */
    var baseForRight = createBaseFor(true);

    /**
     * The base implementation of `_.forOwn` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwn(object, iteratee) {
      return object && baseFor(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Object} Returns `object`.
     */
    function baseForOwnRight(object, iteratee) {
      return object && baseForRight(object, iteratee, keys);
    }

    /**
     * The base implementation of `_.functions` which creates an array of
     * `object` function property names filtered from `props`.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Array} props The property names to filter.
     * @returns {Array} Returns the function names.
     */
    function baseFunctions(object, props) {
      return arrayFilter(props, function(key) {
        return isFunction(object[key]);
      });
    }

    /**
     * The base implementation of `_.get` without support for default values.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @returns {*} Returns the resolved value.
     */
    function baseGet(object, path) {
      path = castPath(path, object);

      var index = 0,
          length = path.length;

      while (object != null && index < length) {
        object = object[toKey(path[index++])];
      }
      return (index && index == length) ? object : undefined;
    }

    /**
     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Function} keysFunc The function to get the keys of `object`.
     * @param {Function} symbolsFunc The function to get the symbols of `object`.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
      var result = keysFunc(object);
      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
    }

    /**
     * The base implementation of `getTag` without fallbacks for buggy environments.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    function baseGetTag(value) {
      if (value == null) {
        return value === undefined ? undefinedTag : nullTag;
      }
      return (symToStringTag && symToStringTag in Object(value))
        ? getRawTag(value)
        : objectToString(value);
    }

    /**
     * The base implementation of `_.gt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     */
    function baseGt(value, other) {
      return value > other;
    }

    /**
     * The base implementation of `_.has` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHas(object, key) {
      return object != null && hasOwnProperty.call(object, key);
    }

    /**
     * The base implementation of `_.hasIn` without support for deep paths.
     *
     * @private
     * @param {Object} [object] The object to query.
     * @param {Array|string} key The key to check.
     * @returns {boolean} Returns `true` if `key` exists, else `false`.
     */
    function baseHasIn(object, key) {
      return object != null && key in Object(object);
    }

    /**
     * The base implementation of `_.inRange` which doesn't coerce arguments.
     *
     * @private
     * @param {number} number The number to check.
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     */
    function baseInRange(number, start, end) {
      return number >= nativeMin(start, end) && number < nativeMax(start, end);
    }

    /**
     * The base implementation of methods like `_.intersection`, without support
     * for iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of shared values.
     */
    function baseIntersection(arrays, iteratee, comparator) {
      var includes = comparator ? arrayIncludesWith : arrayIncludes,
          length = arrays[0].length,
          othLength = arrays.length,
          othIndex = othLength,
          caches = Array(othLength),
          maxLength = Infinity,
          result = [];

      while (othIndex--) {
        var array = arrays[othIndex];
        if (othIndex && iteratee) {
          array = arrayMap(array, baseUnary(iteratee));
        }
        maxLength = nativeMin(array.length, maxLength);
        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
          ? new SetCache(othIndex && array)
          : undefined;
      }
      array = arrays[0];

      var index = -1,
          seen = caches[0];

      outer:
      while (++index < length && result.length < maxLength) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (!(seen
              ? cacheHas(seen, computed)
              : includes(result, computed, comparator)
            )) {
          othIndex = othLength;
          while (--othIndex) {
            var cache = caches[othIndex];
            if (!(cache
                  ? cacheHas(cache, computed)
                  : includes(arrays[othIndex], computed, comparator))
                ) {
              continue outer;
            }
          }
          if (seen) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.invert` and `_.invertBy` which inverts
     * `object` with values transformed by `iteratee` and set by `setter`.
     *
     * @private
     * @param {Object} object The object to iterate over.
     * @param {Function} setter The function to set `accumulator` values.
     * @param {Function} iteratee The iteratee to transform values.
     * @param {Object} accumulator The initial inverted object.
     * @returns {Function} Returns `accumulator`.
     */
    function baseInverter(object, setter, iteratee, accumulator) {
      baseForOwn(object, function(value, key, object) {
        setter(accumulator, iteratee(value), key, object);
      });
      return accumulator;
    }

    /**
     * The base implementation of `_.invoke` without support for individual
     * method arguments.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {Array} args The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     */
    function baseInvoke(object, path, args) {
      path = castPath(path, object);
      object = parent(object, path);
      var func = object == null ? object : object[toKey(last(path))];
      return func == null ? undefined : apply(func, object, args);
    }

    /**
     * The base implementation of `_.isArguments`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     */
    function baseIsArguments(value) {
      return isObjectLike(value) && baseGetTag(value) == argsTag;
    }

    /**
     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     */
    function baseIsArrayBuffer(value) {
      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
    }

    /**
     * The base implementation of `_.isDate` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     */
    function baseIsDate(value) {
      return isObjectLike(value) && baseGetTag(value) == dateTag;
    }

    /**
     * The base implementation of `_.isEqual` which supports partial comparisons
     * and tracks traversed objects.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {boolean} bitmask The bitmask flags.
     *  1 - Unordered comparison
     *  2 - Partial comparison
     * @param {Function} [customizer] The function to customize comparisons.
     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     */
    function baseIsEqual(value, other, bitmask, customizer, stack) {
      if (value === other) {
        return true;
      }
      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
        return value !== value && other !== other;
      }
      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
    }

    /**
     * A specialized version of `baseIsEqual` for arrays and objects which performs
     * deep comparisons and tracks traversed objects enabling objects with circular
     * references to be compared.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
      var objIsArr = isArray(object),
          othIsArr = isArray(other),
          objTag = objIsArr ? arrayTag : getTag(object),
          othTag = othIsArr ? arrayTag : getTag(other);

      objTag = objTag == argsTag ? objectTag : objTag;
      othTag = othTag == argsTag ? objectTag : othTag;

      var objIsObj = objTag == objectTag,
          othIsObj = othTag == objectTag,
          isSameTag = objTag == othTag;

      if (isSameTag && isBuffer(object)) {
        if (!isBuffer(other)) {
          return false;
        }
        objIsArr = true;
        objIsObj = false;
      }
      if (isSameTag && !objIsObj) {
        stack || (stack = new Stack);
        return (objIsArr || isTypedArray(object))
          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
      }
      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

        if (objIsWrapped || othIsWrapped) {
          var objUnwrapped = objIsWrapped ? object.value() : object,
              othUnwrapped = othIsWrapped ? other.value() : other;

          stack || (stack = new Stack);
          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
        }
      }
      if (!isSameTag) {
        return false;
      }
      stack || (stack = new Stack);
      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
    }

    /**
     * The base implementation of `_.isMap` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     */
    function baseIsMap(value) {
      return isObjectLike(value) && getTag(value) == mapTag;
    }

    /**
     * The base implementation of `_.isMatch` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Array} matchData The property names, values, and compare flags to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     */
    function baseIsMatch(object, source, matchData, customizer) {
      var index = matchData.length,
          length = index,
          noCustomizer = !customizer;

      if (object == null) {
        return !length;
      }
      object = Object(object);
      while (index--) {
        var data = matchData[index];
        if ((noCustomizer && data[2])
              ? data[1] !== object[data[0]]
              : !(data[0] in object)
            ) {
          return false;
        }
      }
      while (++index < length) {
        data = matchData[index];
        var key = data[0],
            objValue = object[key],
            srcValue = data[1];

        if (noCustomizer && data[2]) {
          if (objValue === undefined && !(key in object)) {
            return false;
          }
        } else {
          var stack = new Stack;
          if (customizer) {
            var result = customizer(objValue, srcValue, key, object, source, stack);
          }
          if (!(result === undefined
                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
                : result
              )) {
            return false;
          }
        }
      }
      return true;
    }

    /**
     * The base implementation of `_.isNative` without bad shim checks.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     */
    function baseIsNative(value) {
      if (!isObject(value) || isMasked(value)) {
        return false;
      }
      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
      return pattern.test(toSource(value));
    }

    /**
     * The base implementation of `_.isRegExp` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     */
    function baseIsRegExp(value) {
      return isObjectLike(value) && baseGetTag(value) == regexpTag;
    }

    /**
     * The base implementation of `_.isSet` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     */
    function baseIsSet(value) {
      return isObjectLike(value) && getTag(value) == setTag;
    }

    /**
     * The base implementation of `_.isTypedArray` without Node.js optimizations.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     */
    function baseIsTypedArray(value) {
      return isObjectLike(value) &&
        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
    }

    /**
     * The base implementation of `_.iteratee`.
     *
     * @private
     * @param {*} [value=_.identity] The value to convert to an iteratee.
     * @returns {Function} Returns the iteratee.
     */
    function baseIteratee(value) {
      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
      if (typeof value == 'function') {
        return value;
      }
      if (value == null) {
        return identity;
      }
      if (typeof value == 'object') {
        return isArray(value)
          ? baseMatchesProperty(value[0], value[1])
          : baseMatches(value);
      }
      return property(value);
    }

    /**
     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeys(object) {
      if (!isPrototype(object)) {
        return nativeKeys(object);
      }
      var result = [];
      for (var key in Object(object)) {
        if (hasOwnProperty.call(object, key) && key != 'constructor') {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function baseKeysIn(object) {
      if (!isObject(object)) {
        return nativeKeysIn(object);
      }
      var isProto = isPrototype(object),
          result = [];

      for (var key in object) {
        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.lt` which doesn't coerce arguments.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     */
    function baseLt(value, other) {
      return value < other;
    }

    /**
     * The base implementation of `_.map` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} iteratee The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     */
    function baseMap(collection, iteratee) {
      var index = -1,
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value, key, collection) {
        result[++index] = iteratee(value, key, collection);
      });
      return result;
    }

    /**
     * The base implementation of `_.matches` which doesn't clone `source`.
     *
     * @private
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatches(source) {
      var matchData = getMatchData(source);
      if (matchData.length == 1 && matchData[0][2]) {
        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
      }
      return function(object) {
        return object === source || baseIsMatch(object, source, matchData);
      };
    }

    /**
     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
     *
     * @private
     * @param {string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function baseMatchesProperty(path, srcValue) {
      if (isKey(path) && isStrictComparable(srcValue)) {
        return matchesStrictComparable(toKey(path), srcValue);
      }
      return function(object) {
        var objValue = get(object, path);
        return (objValue === undefined && objValue === srcValue)
          ? hasIn(object, path)
          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
      };
    }

    /**
     * The base implementation of `_.merge` without support for multiple sources.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} [customizer] The function to customize merged values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMerge(object, source, srcIndex, customizer, stack) {
      if (object === source) {
        return;
      }
      baseFor(source, function(srcValue, key) {
        stack || (stack = new Stack);
        if (isObject(srcValue)) {
          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
        }
        else {
          var newValue = customizer
            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
            : undefined;

          if (newValue === undefined) {
            newValue = srcValue;
          }
          assignMergeValue(object, key, newValue);
        }
      }, keysIn);
    }

    /**
     * A specialized version of `baseMerge` for arrays and objects which performs
     * deep merges and tracks traversed objects enabling objects with circular
     * references to be merged.
     *
     * @private
     * @param {Object} object The destination object.
     * @param {Object} source The source object.
     * @param {string} key The key of the value to merge.
     * @param {number} srcIndex The index of `source`.
     * @param {Function} mergeFunc The function to merge values.
     * @param {Function} [customizer] The function to customize assigned values.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     */
    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
      var objValue = safeGet(object, key),
          srcValue = safeGet(source, key),
          stacked = stack.get(srcValue);

      if (stacked) {
        assignMergeValue(object, key, stacked);
        return;
      }
      var newValue = customizer
        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
        : undefined;

      var isCommon = newValue === undefined;

      if (isCommon) {
        var isArr = isArray(srcValue),
            isBuff = !isArr && isBuffer(srcValue),
            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

        newValue = srcValue;
        if (isArr || isBuff || isTyped) {
          if (isArray(objValue)) {
            newValue = objValue;
          }
          else if (isArrayLikeObject(objValue)) {
            newValue = copyArray(objValue);
          }
          else if (isBuff) {
            isCommon = false;
            newValue = cloneBuffer(srcValue, true);
          }
          else if (isTyped) {
            isCommon = false;
            newValue = cloneTypedArray(srcValue, true);
          }
          else {
            newValue = [];
          }
        }
        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
          newValue = objValue;
          if (isArguments(objValue)) {
            newValue = toPlainObject(objValue);
          }
          else if (!isObject(objValue) || isFunction(objValue)) {
            newValue = initCloneObject(srcValue);
          }
        }
        else {
          isCommon = false;
        }
      }
      if (isCommon) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, newValue);
        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
        stack['delete'](srcValue);
      }
      assignMergeValue(object, key, newValue);
    }

    /**
     * The base implementation of `_.nth` which doesn't coerce arguments.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {number} n The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     */
    function baseNth(array, n) {
      var length = array.length;
      if (!length) {
        return;
      }
      n += n < 0 ? length : 0;
      return isIndex(n, length) ? array[n] : undefined;
    }

    /**
     * The base implementation of `_.orderBy` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
     * @param {string[]} orders The sort orders of `iteratees`.
     * @returns {Array} Returns the new sorted array.
     */
    function baseOrderBy(collection, iteratees, orders) {
      if (iteratees.length) {
        iteratees = arrayMap(iteratees, function(iteratee) {
          if (isArray(iteratee)) {
            return function(value) {
              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
            }
          }
          return iteratee;
        });
      } else {
        iteratees = [identity];
      }

      var index = -1;
      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

      var result = baseMap(collection, function(value, key, collection) {
        var criteria = arrayMap(iteratees, function(iteratee) {
          return iteratee(value);
        });
        return { 'criteria': criteria, 'index': ++index, 'value': value };
      });

      return baseSortBy(result, function(object, other) {
        return compareMultiple(object, other, orders);
      });
    }

    /**
     * The base implementation of `_.pick` without support for individual
     * property identifiers.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @returns {Object} Returns the new object.
     */
    function basePick(object, paths) {
      return basePickBy(object, paths, function(value, path) {
        return hasIn(object, path);
      });
    }

    /**
     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Object} object The source object.
     * @param {string[]} paths The property paths to pick.
     * @param {Function} predicate The function invoked per property.
     * @returns {Object} Returns the new object.
     */
    function basePickBy(object, paths, predicate) {
      var index = -1,
          length = paths.length,
          result = {};

      while (++index < length) {
        var path = paths[index],
            value = baseGet(object, path);

        if (predicate(value, path)) {
          baseSet(result, castPath(path, object), value);
        }
      }
      return result;
    }

    /**
     * A specialized version of `baseProperty` which supports deep paths.
     *
     * @private
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     */
    function basePropertyDeep(path) {
      return function(object) {
        return baseGet(object, path);
      };
    }

    /**
     * The base implementation of `_.pullAllBy` without support for iteratee
     * shorthands.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     */
    function basePullAll(array, values, iteratee, comparator) {
      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
          index = -1,
          length = values.length,
          seen = array;

      if (array === values) {
        values = copyArray(values);
      }
      if (iteratee) {
        seen = arrayMap(array, baseUnary(iteratee));
      }
      while (++index < length) {
        var fromIndex = 0,
            value = values[index],
            computed = iteratee ? iteratee(value) : value;

        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
          if (seen !== array) {
            splice.call(seen, fromIndex, 1);
          }
          splice.call(array, fromIndex, 1);
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.pullAt` without support for individual
     * indexes or capturing the removed elements.
     *
     * @private
     * @param {Array} array The array to modify.
     * @param {number[]} indexes The indexes of elements to remove.
     * @returns {Array} Returns `array`.
     */
    function basePullAt(array, indexes) {
      var length = array ? indexes.length : 0,
          lastIndex = length - 1;

      while (length--) {
        var index = indexes[length];
        if (length == lastIndex || index !== previous) {
          var previous = index;
          if (isIndex(index)) {
            splice.call(array, index, 1);
          } else {
            baseUnset(array, index);
          }
        }
      }
      return array;
    }

    /**
     * The base implementation of `_.random` without support for returning
     * floating-point numbers.
     *
     * @private
     * @param {number} lower The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the random number.
     */
    function baseRandom(lower, upper) {
      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
    }

    /**
     * The base implementation of `_.range` and `_.rangeRight` which doesn't
     * coerce arguments.
     *
     * @private
     * @param {number} start The start of the range.
     * @param {number} end The end of the range.
     * @param {number} step The value to increment or decrement by.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the range of numbers.
     */
    function baseRange(start, end, step, fromRight) {
      var index = -1,
          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
          result = Array(length);

      while (length--) {
        result[fromRight ? length : ++index] = start;
        start += step;
      }
      return result;
    }

    /**
     * The base implementation of `_.repeat` which doesn't coerce arguments.
     *
     * @private
     * @param {string} string The string to repeat.
     * @param {number} n The number of times to repeat the string.
     * @returns {string} Returns the repeated string.
     */
    function baseRepeat(string, n) {
      var result = '';
      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
        return result;
      }
      // Leverage the exponentiation by squaring algorithm for a faster repeat.
      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
      do {
        if (n % 2) {
          result += string;
        }
        n = nativeFloor(n / 2);
        if (n) {
          string += string;
        }
      } while (n);

      return result;
    }

    /**
     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     */
    function baseRest(func, start) {
      return setToString(overRest(func, start, identity), func + '');
    }

    /**
     * The base implementation of `_.sample`.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     */
    function baseSample(collection) {
      return arraySample(values(collection));
    }

    /**
     * The base implementation of `_.sampleSize` without param guards.
     *
     * @private
     * @param {Array|Object} collection The collection to sample.
     * @param {number} n The number of elements to sample.
     * @returns {Array} Returns the random elements.
     */
    function baseSampleSize(collection, n) {
      var array = values(collection);
      return shuffleSelf(array, baseClamp(n, 0, array.length));
    }

    /**
     * The base implementation of `_.set`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseSet(object, path, value, customizer) {
      if (!isObject(object)) {
        return object;
      }
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          lastIndex = length - 1,
          nested = object;

      while (nested != null && ++index < length) {
        var key = toKey(path[index]),
            newValue = value;

        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
          return object;
        }

        if (index != lastIndex) {
          var objValue = nested[key];
          newValue = customizer ? customizer(objValue, key, nested) : undefined;
          if (newValue === undefined) {
            newValue = isObject(objValue)
              ? objValue
              : (isIndex(path[index + 1]) ? [] : {});
          }
        }
        assignValue(nested, key, newValue);
        nested = nested[key];
      }
      return object;
    }

    /**
     * The base implementation of `setData` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var baseSetData = !metaMap ? identity : function(func, data) {
      metaMap.set(func, data);
      return func;
    };

    /**
     * The base implementation of `setToString` without support for hot loop shorting.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var baseSetToString = !defineProperty ? identity : function(func, string) {
      return defineProperty(func, 'toString', {
        'configurable': true,
        'enumerable': false,
        'value': constant(string),
        'writable': true
      });
    };

    /**
     * The base implementation of `_.shuffle`.
     *
     * @private
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     */
    function baseShuffle(collection) {
      return shuffleSelf(values(collection));
    }

    /**
     * The base implementation of `_.slice` without an iteratee call guard.
     *
     * @private
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseSlice(array, start, end) {
      var index = -1,
          length = array.length;

      if (start < 0) {
        start = -start > length ? 0 : (length + start);
      }
      end = end > length ? length : end;
      if (end < 0) {
        end += length;
      }
      length = start > end ? 0 : ((end - start) >>> 0);
      start >>>= 0;

      var result = Array(length);
      while (++index < length) {
        result[index] = array[index + start];
      }
      return result;
    }

    /**
     * The base implementation of `_.some` without support for iteratee shorthands.
     *
     * @private
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} predicate The function invoked per iteration.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     */
    function baseSome(collection, predicate) {
      var result;

      baseEach(collection, function(value, index, collection) {
        result = predicate(value, index, collection);
        return !result;
      });
      return !!result;
    }

    /**
     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
     * performs a binary search of `array` to determine the index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndex(array, value, retHighest) {
      var low = 0,
          high = array == null ? low : array.length;

      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
        while (low < high) {
          var mid = (low + high) >>> 1,
              computed = array[mid];

          if (computed !== null && !isSymbol(computed) &&
              (retHighest ? (computed <= value) : (computed < value))) {
            low = mid + 1;
          } else {
            high = mid;
          }
        }
        return high;
      }
      return baseSortedIndexBy(array, value, identity, retHighest);
    }

    /**
     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
     * which invokes `iteratee` for `value` and each element of `array` to compute
     * their sort ranking. The iteratee is invoked with one argument; (value).
     *
     * @private
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} iteratee The iteratee invoked per element.
     * @param {boolean} [retHighest] Specify returning the highest qualified index.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     */
    function baseSortedIndexBy(array, value, iteratee, retHighest) {
      var low = 0,
          high = array == null ? 0 : array.length;
      if (high === 0) {
        return 0;
      }

      value = iteratee(value);
      var valIsNaN = value !== value,
          valIsNull = value === null,
          valIsSymbol = isSymbol(value),
          valIsUndefined = value === undefined;

      while (low < high) {
        var mid = nativeFloor((low + high) / 2),
            computed = iteratee(array[mid]),
            othIsDefined = computed !== undefined,
            othIsNull = computed === null,
            othIsReflexive = computed === computed,
            othIsSymbol = isSymbol(computed);

        if (valIsNaN) {
          var setLow = retHighest || othIsReflexive;
        } else if (valIsUndefined) {
          setLow = othIsReflexive && (retHighest || othIsDefined);
        } else if (valIsNull) {
          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
        } else if (valIsSymbol) {
          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
        } else if (othIsNull || othIsSymbol) {
          setLow = false;
        } else {
          setLow = retHighest ? (computed <= value) : (computed < value);
        }
        if (setLow) {
          low = mid + 1;
        } else {
          high = mid;
        }
      }
      return nativeMin(high, MAX_ARRAY_INDEX);
    }

    /**
     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
     * support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseSortedUniq(array, iteratee) {
      var index = -1,
          length = array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        if (!index || !eq(computed, seen)) {
          var seen = computed;
          result[resIndex++] = value === 0 ? 0 : value;
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.toNumber` which doesn't ensure correct
     * conversions of binary, hexadecimal, or octal string values.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     */
    function baseToNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      return +value;
    }

    /**
     * The base implementation of `_.toString` which doesn't convert nullish
     * values to empty strings.
     *
     * @private
     * @param {*} value The value to process.
     * @returns {string} Returns the string.
     */
    function baseToString(value) {
      // Exit early for strings to avoid a performance hit in some environments.
      if (typeof value == 'string') {
        return value;
      }
      if (isArray(value)) {
        // Recursively convert values (susceptible to call stack limits).
        return arrayMap(value, baseToString) + '';
      }
      if (isSymbol(value)) {
        return symbolToString ? symbolToString.call(value) : '';
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     */
    function baseUniq(array, iteratee, comparator) {
      var index = -1,
          includes = arrayIncludes,
          length = array.length,
          isCommon = true,
          result = [],
          seen = result;

      if (comparator) {
        isCommon = false;
        includes = arrayIncludesWith;
      }
      else if (length >= LARGE_ARRAY_SIZE) {
        var set = iteratee ? null : createSet(array);
        if (set) {
          return setToArray(set);
        }
        isCommon = false;
        includes = cacheHas;
        seen = new SetCache;
      }
      else {
        seen = iteratee ? [] : result;
      }
      outer:
      while (++index < length) {
        var value = array[index],
            computed = iteratee ? iteratee(value) : value;

        value = (comparator || value !== 0) ? value : 0;
        if (isCommon && computed === computed) {
          var seenIndex = seen.length;
          while (seenIndex--) {
            if (seen[seenIndex] === computed) {
              continue outer;
            }
          }
          if (iteratee) {
            seen.push(computed);
          }
          result.push(value);
        }
        else if (!includes(seen, computed, comparator)) {
          if (seen !== result) {
            seen.push(computed);
          }
          result.push(value);
        }
      }
      return result;
    }

    /**
     * The base implementation of `_.unset`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The property path to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     */
    function baseUnset(object, path) {
      path = castPath(path, object);
      object = parent(object, path);
      return object == null || delete object[toKey(last(path))];
    }

    /**
     * The base implementation of `_.update`.
     *
     * @private
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to update.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize path creation.
     * @returns {Object} Returns `object`.
     */
    function baseUpdate(object, path, updater, customizer) {
      return baseSet(object, path, updater(baseGet(object, path)), customizer);
    }

    /**
     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
     * without support for iteratee shorthands.
     *
     * @private
     * @param {Array} array The array to query.
     * @param {Function} predicate The function invoked per iteration.
     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Array} Returns the slice of `array`.
     */
    function baseWhile(array, predicate, isDrop, fromRight) {
      var length = array.length,
          index = fromRight ? length : -1;

      while ((fromRight ? index-- : ++index < length) &&
        predicate(array[index], index, array)) {}

      return isDrop
        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
    }

    /**
     * The base implementation of `wrapperValue` which returns the result of
     * performing a sequence of actions on the unwrapped `value`, where each
     * successive action is supplied the return value of the previous.
     *
     * @private
     * @param {*} value The unwrapped value.
     * @param {Array} actions Actions to perform to resolve the unwrapped value.
     * @returns {*} Returns the resolved value.
     */
    function baseWrapperValue(value, actions) {
      var result = value;
      if (result instanceof LazyWrapper) {
        result = result.value();
      }
      return arrayReduce(actions, function(result, action) {
        return action.func.apply(action.thisArg, arrayPush([result], action.args));
      }, result);
    }

    /**
     * The base implementation of methods like `_.xor`, without support for
     * iteratee shorthands, that accepts an array of arrays to inspect.
     *
     * @private
     * @param {Array} arrays The arrays to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of values.
     */
    function baseXor(arrays, iteratee, comparator) {
      var length = arrays.length;
      if (length < 2) {
        return length ? baseUniq(arrays[0]) : [];
      }
      var index = -1,
          result = Array(length);

      while (++index < length) {
        var array = arrays[index],
            othIndex = -1;

        while (++othIndex < length) {
          if (othIndex != index) {
            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
          }
        }
      }
      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
    }

    /**
     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
     *
     * @private
     * @param {Array} props The property identifiers.
     * @param {Array} values The property values.
     * @param {Function} assignFunc The function to assign values.
     * @returns {Object} Returns the new object.
     */
    function baseZipObject(props, values, assignFunc) {
      var index = -1,
          length = props.length,
          valsLength = values.length,
          result = {};

      while (++index < length) {
        var value = index < valsLength ? values[index] : undefined;
        assignFunc(result, props[index], value);
      }
      return result;
    }

    /**
     * Casts `value` to an empty array if it's not an array like object.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Array|Object} Returns the cast array-like object.
     */
    function castArrayLikeObject(value) {
      return isArrayLikeObject(value) ? value : [];
    }

    /**
     * Casts `value` to `identity` if it's not a function.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {Function} Returns cast function.
     */
    function castFunction(value) {
      return typeof value == 'function' ? value : identity;
    }

    /**
     * Casts `value` to a path array if it's not one.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {Object} [object] The object to query keys on.
     * @returns {Array} Returns the cast property path array.
     */
    function castPath(value, object) {
      if (isArray(value)) {
        return value;
      }
      return isKey(value, object) ? [value] : stringToPath(toString(value));
    }

    /**
     * A `baseRest` alias which can be replaced with `identity` by module
     * replacement plugins.
     *
     * @private
     * @type {Function}
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    var castRest = baseRest;

    /**
     * Casts `array` to a slice if it's needed.
     *
     * @private
     * @param {Array} array The array to inspect.
     * @param {number} start The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the cast slice.
     */
    function castSlice(array, start, end) {
      var length = array.length;
      end = end === undefined ? length : end;
      return (!start && end >= length) ? array : baseSlice(array, start, end);
    }

    /**
     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
     *
     * @private
     * @param {number|Object} id The timer id or timeout object of the timer to clear.
     */
    var clearTimeout = ctxClearTimeout || function(id) {
      return root.clearTimeout(id);
    };

    /**
     * Creates a clone of  `buffer`.
     *
     * @private
     * @param {Buffer} buffer The buffer to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Buffer} Returns the cloned buffer.
     */
    function cloneBuffer(buffer, isDeep) {
      if (isDeep) {
        return buffer.slice();
      }
      var length = buffer.length,
          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

      buffer.copy(result);
      return result;
    }

    /**
     * Creates a clone of `arrayBuffer`.
     *
     * @private
     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
     * @returns {ArrayBuffer} Returns the cloned array buffer.
     */
    function cloneArrayBuffer(arrayBuffer) {
      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
      return result;
    }

    /**
     * Creates a clone of `dataView`.
     *
     * @private
     * @param {Object} dataView The data view to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned data view.
     */
    function cloneDataView(dataView, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
    }

    /**
     * Creates a clone of `regexp`.
     *
     * @private
     * @param {Object} regexp The regexp to clone.
     * @returns {Object} Returns the cloned regexp.
     */
    function cloneRegExp(regexp) {
      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
      result.lastIndex = regexp.lastIndex;
      return result;
    }

    /**
     * Creates a clone of the `symbol` object.
     *
     * @private
     * @param {Object} symbol The symbol object to clone.
     * @returns {Object} Returns the cloned symbol object.
     */
    function cloneSymbol(symbol) {
      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
    }

    /**
     * Creates a clone of `typedArray`.
     *
     * @private
     * @param {Object} typedArray The typed array to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the cloned typed array.
     */
    function cloneTypedArray(typedArray, isDeep) {
      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
    }

    /**
     * Compares values to sort them in ascending order.
     *
     * @private
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {number} Returns the sort order indicator for `value`.
     */
    function compareAscending(value, other) {
      if (value !== other) {
        var valIsDefined = value !== undefined,
            valIsNull = value === null,
            valIsReflexive = value === value,
            valIsSymbol = isSymbol(value);

        var othIsDefined = other !== undefined,
            othIsNull = other === null,
            othIsReflexive = other === other,
            othIsSymbol = isSymbol(other);

        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
            (valIsNull && othIsDefined && othIsReflexive) ||
            (!valIsDefined && othIsReflexive) ||
            !valIsReflexive) {
          return 1;
        }
        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
            (othIsNull && valIsDefined && valIsReflexive) ||
            (!othIsDefined && valIsReflexive) ||
            !othIsReflexive) {
          return -1;
        }
      }
      return 0;
    }

    /**
     * Used by `_.orderBy` to compare multiple properties of a value to another
     * and stable sort them.
     *
     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
     * specify an order of "desc" for descending or "asc" for ascending sort order
     * of corresponding values.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {boolean[]|string[]} orders The order to sort by for each property.
     * @returns {number} Returns the sort order indicator for `object`.
     */
    function compareMultiple(object, other, orders) {
      var index = -1,
          objCriteria = object.criteria,
          othCriteria = other.criteria,
          length = objCriteria.length,
          ordersLength = orders.length;

      while (++index < length) {
        var result = compareAscending(objCriteria[index], othCriteria[index]);
        if (result) {
          if (index >= ordersLength) {
            return result;
          }
          var order = orders[index];
          return result * (order == 'desc' ? -1 : 1);
        }
      }
      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
      // that causes it, under certain circumstances, to provide the same value for
      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
      // for more details.
      //
      // This also ensures a stable sort in V8 and other engines.
      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
      return object.index - other.index;
    }

    /**
     * Creates an array that is the composition of partially applied arguments,
     * placeholders, and provided arguments into a single array of arguments.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to prepend to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgs(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersLength = holders.length,
          leftIndex = -1,
          leftLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(leftLength + rangeLength),
          isUncurried = !isCurried;

      while (++leftIndex < leftLength) {
        result[leftIndex] = partials[leftIndex];
      }
      while (++argsIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[holders[argsIndex]] = args[argsIndex];
        }
      }
      while (rangeLength--) {
        result[leftIndex++] = args[argsIndex++];
      }
      return result;
    }

    /**
     * This function is like `composeArgs` except that the arguments composition
     * is tailored for `_.partialRight`.
     *
     * @private
     * @param {Array} args The provided arguments.
     * @param {Array} partials The arguments to append to those provided.
     * @param {Array} holders The `partials` placeholder indexes.
     * @params {boolean} [isCurried] Specify composing for a curried function.
     * @returns {Array} Returns the new array of composed arguments.
     */
    function composeArgsRight(args, partials, holders, isCurried) {
      var argsIndex = -1,
          argsLength = args.length,
          holdersIndex = -1,
          holdersLength = holders.length,
          rightIndex = -1,
          rightLength = partials.length,
          rangeLength = nativeMax(argsLength - holdersLength, 0),
          result = Array(rangeLength + rightLength),
          isUncurried = !isCurried;

      while (++argsIndex < rangeLength) {
        result[argsIndex] = args[argsIndex];
      }
      var offset = argsIndex;
      while (++rightIndex < rightLength) {
        result[offset + rightIndex] = partials[rightIndex];
      }
      while (++holdersIndex < holdersLength) {
        if (isUncurried || argsIndex < argsLength) {
          result[offset + holders[holdersIndex]] = args[argsIndex++];
        }
      }
      return result;
    }

    /**
     * Copies the values of `source` to `array`.
     *
     * @private
     * @param {Array} source The array to copy values from.
     * @param {Array} [array=[]] The array to copy values to.
     * @returns {Array} Returns `array`.
     */
    function copyArray(source, array) {
      var index = -1,
          length = source.length;

      array || (array = Array(length));
      while (++index < length) {
        array[index] = source[index];
      }
      return array;
    }

    /**
     * Copies properties of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy properties from.
     * @param {Array} props The property identifiers to copy.
     * @param {Object} [object={}] The object to copy properties to.
     * @param {Function} [customizer] The function to customize copied values.
     * @returns {Object} Returns `object`.
     */
    function copyObject(source, props, object, customizer) {
      var isNew = !object;
      object || (object = {});

      var index = -1,
          length = props.length;

      while (++index < length) {
        var key = props[index];

        var newValue = customizer
          ? customizer(object[key], source[key], key, object, source)
          : undefined;

        if (newValue === undefined) {
          newValue = source[key];
        }
        if (isNew) {
          baseAssignValue(object, key, newValue);
        } else {
          assignValue(object, key, newValue);
        }
      }
      return object;
    }

    /**
     * Copies own symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbols(source, object) {
      return copyObject(source, getSymbols(source), object);
    }

    /**
     * Copies own and inherited symbols of `source` to `object`.
     *
     * @private
     * @param {Object} source The object to copy symbols from.
     * @param {Object} [object={}] The object to copy symbols to.
     * @returns {Object} Returns `object`.
     */
    function copySymbolsIn(source, object) {
      return copyObject(source, getSymbolsIn(source), object);
    }

    /**
     * Creates a function like `_.groupBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} [initializer] The accumulator object initializer.
     * @returns {Function} Returns the new aggregator function.
     */
    function createAggregator(setter, initializer) {
      return function(collection, iteratee) {
        var func = isArray(collection) ? arrayAggregator : baseAggregator,
            accumulator = initializer ? initializer() : {};

        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
      };
    }

    /**
     * Creates a function like `_.assign`.
     *
     * @private
     * @param {Function} assigner The function to assign values.
     * @returns {Function} Returns the new assigner function.
     */
    function createAssigner(assigner) {
      return baseRest(function(object, sources) {
        var index = -1,
            length = sources.length,
            customizer = length > 1 ? sources[length - 1] : undefined,
            guard = length > 2 ? sources[2] : undefined;

        customizer = (assigner.length > 3 && typeof customizer == 'function')
          ? (length--, customizer)
          : undefined;

        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
          customizer = length < 3 ? undefined : customizer;
          length = 1;
        }
        object = Object(object);
        while (++index < length) {
          var source = sources[index];
          if (source) {
            assigner(object, source, index, customizer);
          }
        }
        return object;
      });
    }

    /**
     * Creates a `baseEach` or `baseEachRight` function.
     *
     * @private
     * @param {Function} eachFunc The function to iterate over a collection.
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseEach(eachFunc, fromRight) {
      return function(collection, iteratee) {
        if (collection == null) {
          return collection;
        }
        if (!isArrayLike(collection)) {
          return eachFunc(collection, iteratee);
        }
        var length = collection.length,
            index = fromRight ? length : -1,
            iterable = Object(collection);

        while ((fromRight ? index-- : ++index < length)) {
          if (iteratee(iterable[index], index, iterable) === false) {
            break;
          }
        }
        return collection;
      };
    }

    /**
     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new base function.
     */
    function createBaseFor(fromRight) {
      return function(object, iteratee, keysFunc) {
        var index = -1,
            iterable = Object(object),
            props = keysFunc(object),
            length = props.length;

        while (length--) {
          var key = props[fromRight ? length : ++index];
          if (iteratee(iterable[key], key, iterable) === false) {
            break;
          }
        }
        return object;
      };
    }

    /**
     * Creates a function that wraps `func` to invoke it with the optional `this`
     * binding of `thisArg`.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createBind(func, bitmask, thisArg) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return fn.apply(isBind ? thisArg : this, arguments);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.lowerFirst`.
     *
     * @private
     * @param {string} methodName The name of the `String` case method to use.
     * @returns {Function} Returns the new case function.
     */
    function createCaseFirst(methodName) {
      return function(string) {
        string = toString(string);

        var strSymbols = hasUnicode(string)
          ? stringToArray(string)
          : undefined;

        var chr = strSymbols
          ? strSymbols[0]
          : string.charAt(0);

        var trailing = strSymbols
          ? castSlice(strSymbols, 1).join('')
          : string.slice(1);

        return chr[methodName]() + trailing;
      };
    }

    /**
     * Creates a function like `_.camelCase`.
     *
     * @private
     * @param {Function} callback The function to combine each word.
     * @returns {Function} Returns the new compounder function.
     */
    function createCompounder(callback) {
      return function(string) {
        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
      };
    }

    /**
     * Creates a function that produces an instance of `Ctor` regardless of
     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
     *
     * @private
     * @param {Function} Ctor The constructor to wrap.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCtor(Ctor) {
      return function() {
        // Use a `switch` statement to work with class constructors. See
        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
        // for more details.
        var args = arguments;
        switch (args.length) {
          case 0: return new Ctor;
          case 1: return new Ctor(args[0]);
          case 2: return new Ctor(args[0], args[1]);
          case 3: return new Ctor(args[0], args[1], args[2]);
          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
        }
        var thisBinding = baseCreate(Ctor.prototype),
            result = Ctor.apply(thisBinding, args);

        // Mimic the constructor's `return` behavior.
        // See https://es5.github.io/#x13.2.2 for more details.
        return isObject(result) ? result : thisBinding;
      };
    }

    /**
     * Creates a function that wraps `func` to enable currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {number} arity The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createCurry(func, bitmask, arity) {
      var Ctor = createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length,
            placeholder = getHolder(wrapper);

        while (index--) {
          args[index] = arguments[index];
        }
        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
          ? []
          : replaceHolders(args, placeholder);

        length -= holders.length;
        if (length < arity) {
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, undefined,
            args, holders, undefined, undefined, arity - length);
        }
        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
        return apply(fn, this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.find` or `_.findLast` function.
     *
     * @private
     * @param {Function} findIndexFunc The function to find the collection index.
     * @returns {Function} Returns the new find function.
     */
    function createFind(findIndexFunc) {
      return function(collection, predicate, fromIndex) {
        var iterable = Object(collection);
        if (!isArrayLike(collection)) {
          var iteratee = getIteratee(predicate, 3);
          collection = keys(collection);
          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
        }
        var index = findIndexFunc(collection, predicate, fromIndex);
        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined;
      };
    }

    /**
     * Creates a `_.flow` or `_.flowRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new flow function.
     */
    function createFlow(fromRight) {
      return flatRest(function(funcs) {
        var length = funcs.length,
            index = length,
            prereq = LodashWrapper.prototype.thru;

        if (fromRight) {
          funcs.reverse();
        }
        while (index--) {
          var func = funcs[index];
          if (typeof func != 'function') {
            throw new TypeError(FUNC_ERROR_TEXT);
          }
          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
            var wrapper = new LodashWrapper([], true);
          }
        }
        index = wrapper ? index : length;
        while (++index < length) {
          func = funcs[index];

          var funcName = getFuncName(func),
              data = funcName == 'wrapper' ? getData(func) : undefined;

          if (data && isLaziable(data[0]) &&
                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
                !data[4].length && data[9] == 1
              ) {
            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
          } else {
            wrapper = (func.length == 1 && isLaziable(func))
              ? wrapper[funcName]()
              : wrapper.thru(func);
          }
        }
        return function() {
          var args = arguments,
              value = args[0];

          if (wrapper && args.length == 1 && isArray(value)) {
            return wrapper.plant(value).value();
          }
          var index = 0,
              result = length ? funcs[index].apply(this, args) : value;

          while (++index < length) {
            result = funcs[index].call(this, result);
          }
          return result;
        };
      });
    }

    /**
     * Creates a function that wraps `func` to invoke it with optional `this`
     * binding of `thisArg`, partial application, and currying.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [partialsRight] The arguments to append to those provided
     *  to the new function.
     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
      var isAry = bitmask & WRAP_ARY_FLAG,
          isBind = bitmask & WRAP_BIND_FLAG,
          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
          isFlip = bitmask & WRAP_FLIP_FLAG,
          Ctor = isBindKey ? undefined : createCtor(func);

      function wrapper() {
        var length = arguments.length,
            args = Array(length),
            index = length;

        while (index--) {
          args[index] = arguments[index];
        }
        if (isCurried) {
          var placeholder = getHolder(wrapper),
              holdersCount = countHolders(args, placeholder);
        }
        if (partials) {
          args = composeArgs(args, partials, holders, isCurried);
        }
        if (partialsRight) {
          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
        }
        length -= holdersCount;
        if (isCurried && length < arity) {
          var newHolders = replaceHolders(args, placeholder);
          return createRecurry(
            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
            args, newHolders, argPos, ary, arity - length
          );
        }
        var thisBinding = isBind ? thisArg : this,
            fn = isBindKey ? thisBinding[func] : func;

        length = args.length;
        if (argPos) {
          args = reorder(args, argPos);
        } else if (isFlip && length > 1) {
          args.reverse();
        }
        if (isAry && ary < length) {
          args.length = ary;
        }
        if (this && this !== root && this instanceof wrapper) {
          fn = Ctor || createCtor(fn);
        }
        return fn.apply(thisBinding, args);
      }
      return wrapper;
    }

    /**
     * Creates a function like `_.invertBy`.
     *
     * @private
     * @param {Function} setter The function to set accumulator values.
     * @param {Function} toIteratee The function to resolve iteratees.
     * @returns {Function} Returns the new inverter function.
     */
    function createInverter(setter, toIteratee) {
      return function(object, iteratee) {
        return baseInverter(object, setter, toIteratee(iteratee), {});
      };
    }

    /**
     * Creates a function that performs a mathematical operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @param {number} [defaultValue] The value used for `undefined` arguments.
     * @returns {Function} Returns the new mathematical operation function.
     */
    function createMathOperation(operator, defaultValue) {
      return function(value, other) {
        var result;
        if (value === undefined && other === undefined) {
          return defaultValue;
        }
        if (value !== undefined) {
          result = value;
        }
        if (other !== undefined) {
          if (result === undefined) {
            return other;
          }
          if (typeof value == 'string' || typeof other == 'string') {
            value = baseToString(value);
            other = baseToString(other);
          } else {
            value = baseToNumber(value);
            other = baseToNumber(other);
          }
          result = operator(value, other);
        }
        return result;
      };
    }

    /**
     * Creates a function like `_.over`.
     *
     * @private
     * @param {Function} arrayFunc The function to iterate over iteratees.
     * @returns {Function} Returns the new over function.
     */
    function createOver(arrayFunc) {
      return flatRest(function(iteratees) {
        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
        return baseRest(function(args) {
          var thisArg = this;
          return arrayFunc(iteratees, function(iteratee) {
            return apply(iteratee, thisArg, args);
          });
        });
      });
    }

    /**
     * Creates the padding for `string` based on `length`. The `chars` string
     * is truncated if the number of characters exceeds `length`.
     *
     * @private
     * @param {number} length The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padding for `string`.
     */
    function createPadding(length, chars) {
      chars = chars === undefined ? ' ' : baseToString(chars);

      var charsLength = chars.length;
      if (charsLength < 2) {
        return charsLength ? baseRepeat(chars, length) : chars;
      }
      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
      return hasUnicode(chars)
        ? castSlice(stringToArray(result), 0, length).join('')
        : result.slice(0, length);
    }

    /**
     * Creates a function that wraps `func` to invoke it with the `this` binding
     * of `thisArg` and `partials` prepended to the arguments it receives.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {Array} partials The arguments to prepend to those provided to
     *  the new function.
     * @returns {Function} Returns the new wrapped function.
     */
    function createPartial(func, bitmask, thisArg, partials) {
      var isBind = bitmask & WRAP_BIND_FLAG,
          Ctor = createCtor(func);

      function wrapper() {
        var argsIndex = -1,
            argsLength = arguments.length,
            leftIndex = -1,
            leftLength = partials.length,
            args = Array(leftLength + argsLength),
            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

        while (++leftIndex < leftLength) {
          args[leftIndex] = partials[leftIndex];
        }
        while (argsLength--) {
          args[leftIndex++] = arguments[++argsIndex];
        }
        return apply(fn, isBind ? thisArg : this, args);
      }
      return wrapper;
    }

    /**
     * Creates a `_.range` or `_.rangeRight` function.
     *
     * @private
     * @param {boolean} [fromRight] Specify iterating from right to left.
     * @returns {Function} Returns the new range function.
     */
    function createRange(fromRight) {
      return function(start, end, step) {
        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
          end = step = undefined;
        }
        // Ensure the sign of `-0` is preserved.
        start = toFinite(start);
        if (end === undefined) {
          end = start;
          start = 0;
        } else {
          end = toFinite(end);
        }
        step = step === undefined ? (start < end ? 1 : -1) : toFinite(step);
        return baseRange(start, end, step, fromRight);
      };
    }

    /**
     * Creates a function that performs a relational operation on two values.
     *
     * @private
     * @param {Function} operator The function to perform the operation.
     * @returns {Function} Returns the new relational operation function.
     */
    function createRelationalOperation(operator) {
      return function(value, other) {
        if (!(typeof value == 'string' && typeof other == 'string')) {
          value = toNumber(value);
          other = toNumber(other);
        }
        return operator(value, other);
      };
    }

    /**
     * Creates a function that wraps `func` to continue currying.
     *
     * @private
     * @param {Function} func The function to wrap.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @param {Function} wrapFunc The function to create the `func` wrapper.
     * @param {*} placeholder The placeholder value.
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to prepend to those provided to
     *  the new function.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
      var isCurry = bitmask & WRAP_CURRY_FLAG,
          newHolders = isCurry ? holders : undefined,
          newHoldersRight = isCurry ? undefined : holders,
          newPartials = isCurry ? partials : undefined,
          newPartialsRight = isCurry ? undefined : partials;

      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
      }
      var newData = [
        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
        newHoldersRight, argPos, ary, arity
      ];

      var result = wrapFunc.apply(undefined, newData);
      if (isLaziable(func)) {
        setData(result, newData);
      }
      result.placeholder = placeholder;
      return setWrapToString(result, func, bitmask);
    }

    /**
     * Creates a function like `_.round`.
     *
     * @private
     * @param {string} methodName The name of the `Math` method to use when rounding.
     * @returns {Function} Returns the new round function.
     */
    function createRound(methodName) {
      var func = Math[methodName];
      return function(number, precision) {
        number = toNumber(number);
        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
        if (precision && nativeIsFinite(number)) {
          // Shift with exponential notation to avoid floating-point issues.
          // See [MDN](https://mdn.io/round#Examples) for more details.
          var pair = (toString(number) + 'e').split('e'),
              value = func(pair[0] + 'e' + (+pair[1] + precision));

          pair = (toString(value) + 'e').split('e');
          return +(pair[0] + 'e' + (+pair[1] - precision));
        }
        return func(number);
      };
    }

    /**
     * Creates a set object of `values`.
     *
     * @private
     * @param {Array} values The values to add to the set.
     * @returns {Object} Returns the new set.
     */
    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
      return new Set(values);
    };

    /**
     * Creates a `_.toPairs` or `_.toPairsIn` function.
     *
     * @private
     * @param {Function} keysFunc The function to get the keys of a given object.
     * @returns {Function} Returns the new pairs function.
     */
    function createToPairs(keysFunc) {
      return function(object) {
        var tag = getTag(object);
        if (tag == mapTag) {
          return mapToArray(object);
        }
        if (tag == setTag) {
          return setToPairs(object);
        }
        return baseToPairs(object, keysFunc(object));
      };
    }

    /**
     * Creates a function that either curries or invokes `func` with optional
     * `this` binding and partially applied arguments.
     *
     * @private
     * @param {Function|string} func The function or method name to wrap.
     * @param {number} bitmask The bitmask flags.
     *    1 - `_.bind`
     *    2 - `_.bindKey`
     *    4 - `_.curry` or `_.curryRight` of a bound function
     *    8 - `_.curry`
     *   16 - `_.curryRight`
     *   32 - `_.partial`
     *   64 - `_.partialRight`
     *  128 - `_.rearg`
     *  256 - `_.ary`
     *  512 - `_.flip`
     * @param {*} [thisArg] The `this` binding of `func`.
     * @param {Array} [partials] The arguments to be partially applied.
     * @param {Array} [holders] The `partials` placeholder indexes.
     * @param {Array} [argPos] The argument positions of the new function.
     * @param {number} [ary] The arity cap of `func`.
     * @param {number} [arity] The arity of `func`.
     * @returns {Function} Returns the new wrapped function.
     */
    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
      if (!isBindKey && typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var length = partials ? partials.length : 0;
      if (!length) {
        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
        partials = holders = undefined;
      }
      ary = ary === undefined ? ary : nativeMax(toInteger(ary), 0);
      arity = arity === undefined ? arity : toInteger(arity);
      length -= holders ? holders.length : 0;

      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
        var partialsRight = partials,
            holdersRight = holders;

        partials = holders = undefined;
      }
      var data = isBindKey ? undefined : getData(func);

      var newData = [
        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
        argPos, ary, arity
      ];

      if (data) {
        mergeData(newData, data);
      }
      func = newData[0];
      bitmask = newData[1];
      thisArg = newData[2];
      partials = newData[3];
      holders = newData[4];
      arity = newData[9] = newData[9] === undefined
        ? (isBindKey ? 0 : func.length)
        : nativeMax(newData[9] - length, 0);

      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
      }
      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
        var result = createBind(func, bitmask, thisArg);
      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
        result = createCurry(func, bitmask, arity);
      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
        result = createPartial(func, bitmask, thisArg, partials);
      } else {
        result = createHybrid.apply(undefined, newData);
      }
      var setter = data ? baseSetData : setData;
      return setWrapToString(setter(result, newData), func, bitmask);
    }

    /**
     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
     * of source objects to the destination object for all destination properties
     * that resolve to `undefined`.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to assign.
     * @param {Object} object The parent object of `objValue`.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsAssignIn(objValue, srcValue, key, object) {
      if (objValue === undefined ||
          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
        return srcValue;
      }
      return objValue;
    }

    /**
     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
     * objects into destination objects that are passed thru.
     *
     * @private
     * @param {*} objValue The destination value.
     * @param {*} srcValue The source value.
     * @param {string} key The key of the property to merge.
     * @param {Object} object The parent object of `objValue`.
     * @param {Object} source The parent object of `srcValue`.
     * @param {Object} [stack] Tracks traversed source values and their merged
     *  counterparts.
     * @returns {*} Returns the value to assign.
     */
    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
      if (isObject(objValue) && isObject(srcValue)) {
        // Recursively merge objects and arrays (susceptible to call stack limits).
        stack.set(srcValue, objValue);
        baseMerge(objValue, srcValue, undefined, customDefaultsMerge, stack);
        stack['delete'](srcValue);
      }
      return objValue;
    }

    /**
     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
     * objects.
     *
     * @private
     * @param {*} value The value to inspect.
     * @param {string} key The key of the property to inspect.
     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
     */
    function customOmitClone(value) {
      return isPlainObject(value) ? undefined : value;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for arrays with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Array} array The array to compare.
     * @param {Array} other The other array to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `array` and `other` objects.
     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
     */
    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          arrLength = array.length,
          othLength = other.length;

      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
        return false;
      }
      // Check that cyclic values are equal.
      var arrStacked = stack.get(array);
      var othStacked = stack.get(other);
      if (arrStacked && othStacked) {
        return arrStacked == other && othStacked == array;
      }
      var index = -1,
          result = true,
          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

      stack.set(array, other);
      stack.set(other, array);

      // Ignore non-index properties.
      while (++index < arrLength) {
        var arrValue = array[index],
            othValue = other[index];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, arrValue, index, other, array, stack)
            : customizer(arrValue, othValue, index, array, other, stack);
        }
        if (compared !== undefined) {
          if (compared) {
            continue;
          }
          result = false;
          break;
        }
        // Recursively compare arrays (susceptible to call stack limits).
        if (seen) {
          if (!arraySome(other, function(othValue, othIndex) {
                if (!cacheHas(seen, othIndex) &&
                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
                  return seen.push(othIndex);
                }
              })) {
            result = false;
            break;
          }
        } else if (!(
              arrValue === othValue ||
                equalFunc(arrValue, othValue, bitmask, customizer, stack)
            )) {
          result = false;
          break;
        }
      }
      stack['delete'](array);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for comparing objects of
     * the same `toStringTag`.
     *
     * **Note:** This function only supports comparing values with tags of
     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {string} tag The `toStringTag` of the objects to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
      switch (tag) {
        case dataViewTag:
          if ((object.byteLength != other.byteLength) ||
              (object.byteOffset != other.byteOffset)) {
            return false;
          }
          object = object.buffer;
          other = other.buffer;

        case arrayBufferTag:
          if ((object.byteLength != other.byteLength) ||
              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
            return false;
          }
          return true;

        case boolTag:
        case dateTag:
        case numberTag:
          // Coerce booleans to `1` or `0` and dates to milliseconds.
          // Invalid dates are coerced to `NaN`.
          return eq(+object, +other);

        case errorTag:
          return object.name == other.name && object.message == other.message;

        case regexpTag:
        case stringTag:
          // Coerce regexes to strings and treat strings, primitives and objects,
          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
          // for more details.
          return object == (other + '');

        case mapTag:
          var convert = mapToArray;

        case setTag:
          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
          convert || (convert = setToArray);

          if (object.size != other.size && !isPartial) {
            return false;
          }
          // Assume cyclic values are equal.
          var stacked = stack.get(object);
          if (stacked) {
            return stacked == other;
          }
          bitmask |= COMPARE_UNORDERED_FLAG;

          // Recursively compare objects (susceptible to call stack limits).
          stack.set(object, other);
          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
          stack['delete'](object);
          return result;

        case symbolTag:
          if (symbolValueOf) {
            return symbolValueOf.call(object) == symbolValueOf.call(other);
          }
      }
      return false;
    }

    /**
     * A specialized version of `baseIsEqualDeep` for objects with support for
     * partial deep comparisons.
     *
     * @private
     * @param {Object} object The object to compare.
     * @param {Object} other The other object to compare.
     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
     * @param {Function} customizer The function to customize comparisons.
     * @param {Function} equalFunc The function to determine equivalents of values.
     * @param {Object} stack Tracks traversed `object` and `other` objects.
     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
     */
    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
          objProps = getAllKeys(object),
          objLength = objProps.length,
          othProps = getAllKeys(other),
          othLength = othProps.length;

      if (objLength != othLength && !isPartial) {
        return false;
      }
      var index = objLength;
      while (index--) {
        var key = objProps[index];
        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
          return false;
        }
      }
      // Check that cyclic values are equal.
      var objStacked = stack.get(object);
      var othStacked = stack.get(other);
      if (objStacked && othStacked) {
        return objStacked == other && othStacked == object;
      }
      var result = true;
      stack.set(object, other);
      stack.set(other, object);

      var skipCtor = isPartial;
      while (++index < objLength) {
        key = objProps[index];
        var objValue = object[key],
            othValue = other[key];

        if (customizer) {
          var compared = isPartial
            ? customizer(othValue, objValue, key, other, object, stack)
            : customizer(objValue, othValue, key, object, other, stack);
        }
        // Recursively compare objects (susceptible to call stack limits).
        if (!(compared === undefined
              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
              : compared
            )) {
          result = false;
          break;
        }
        skipCtor || (skipCtor = key == 'constructor');
      }
      if (result && !skipCtor) {
        var objCtor = object.constructor,
            othCtor = other.constructor;

        // Non `Object` object instances with different constructors are not equal.
        if (objCtor != othCtor &&
            ('constructor' in object && 'constructor' in other) &&
            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
          result = false;
        }
      }
      stack['delete'](object);
      stack['delete'](other);
      return result;
    }

    /**
     * A specialized version of `baseRest` which flattens the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @returns {Function} Returns the new function.
     */
    function flatRest(func) {
      return setToString(overRest(func, undefined, flatten), func + '');
    }

    /**
     * Creates an array of own enumerable property names and symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeys(object) {
      return baseGetAllKeys(object, keys, getSymbols);
    }

    /**
     * Creates an array of own and inherited enumerable property names and
     * symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names and symbols.
     */
    function getAllKeysIn(object) {
      return baseGetAllKeys(object, keysIn, getSymbolsIn);
    }

    /**
     * Gets metadata for `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {*} Returns the metadata for `func`.
     */
    var getData = !metaMap ? noop : function(func) {
      return metaMap.get(func);
    };

    /**
     * Gets the name of `func`.
     *
     * @private
     * @param {Function} func The function to query.
     * @returns {string} Returns the function name.
     */
    function getFuncName(func) {
      var result = (func.name + ''),
          array = realNames[result],
          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

      while (length--) {
        var data = array[length],
            otherFunc = data.func;
        if (otherFunc == null || otherFunc == func) {
          return data.name;
        }
      }
      return result;
    }

    /**
     * Gets the argument placeholder value for `func`.
     *
     * @private
     * @param {Function} func The function to inspect.
     * @returns {*} Returns the placeholder value.
     */
    function getHolder(func) {
      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
      return object.placeholder;
    }

    /**
     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
     * this function returns the custom method, otherwise it returns `baseIteratee`.
     * If arguments are provided, the chosen function is invoked with them and
     * its result is returned.
     *
     * @private
     * @param {*} [value] The value to convert to an iteratee.
     * @param {number} [arity] The arity of the created iteratee.
     * @returns {Function} Returns the chosen function or its result.
     */
    function getIteratee() {
      var result = lodash.iteratee || iteratee;
      result = result === iteratee ? baseIteratee : result;
      return arguments.length ? result(arguments[0], arguments[1]) : result;
    }

    /**
     * Gets the data for `map`.
     *
     * @private
     * @param {Object} map The map to query.
     * @param {string} key The reference key.
     * @returns {*} Returns the map data.
     */
    function getMapData(map, key) {
      var data = map.__data__;
      return isKeyable(key)
        ? data[typeof key == 'string' ? 'string' : 'hash']
        : data.map;
    }

    /**
     * Gets the property names, values, and compare flags of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the match data of `object`.
     */
    function getMatchData(object) {
      var result = keys(object),
          length = result.length;

      while (length--) {
        var key = result[length],
            value = object[key];

        result[length] = [key, value, isStrictComparable(value)];
      }
      return result;
    }

    /**
     * Gets the native function at `key` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the method to get.
     * @returns {*} Returns the function if it's native, else `undefined`.
     */
    function getNative(object, key) {
      var value = getValue(object, key);
      return baseIsNative(value) ? value : undefined;
    }

    /**
     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the raw `toStringTag`.
     */
    function getRawTag(value) {
      var isOwn = hasOwnProperty.call(value, symToStringTag),
          tag = value[symToStringTag];

      try {
        value[symToStringTag] = undefined;
        var unmasked = true;
      } catch (e) {}

      var result = nativeObjectToString.call(value);
      if (unmasked) {
        if (isOwn) {
          value[symToStringTag] = tag;
        } else {
          delete value[symToStringTag];
        }
      }
      return result;
    }

    /**
     * Creates an array of the own enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
      if (object == null) {
        return [];
      }
      object = Object(object);
      return arrayFilter(nativeGetSymbols(object), function(symbol) {
        return propertyIsEnumerable.call(object, symbol);
      });
    };

    /**
     * Creates an array of the own and inherited enumerable symbols of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of symbols.
     */
    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
      var result = [];
      while (object) {
        arrayPush(result, getSymbols(object));
        object = getPrototype(object);
      }
      return result;
    };

    /**
     * Gets the `toStringTag` of `value`.
     *
     * @private
     * @param {*} value The value to query.
     * @returns {string} Returns the `toStringTag`.
     */
    var getTag = baseGetTag;

    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
        (Map && getTag(new Map) != mapTag) ||
        (Promise && getTag(Promise.resolve()) != promiseTag) ||
        (Set && getTag(new Set) != setTag) ||
        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
      getTag = function(value) {
        var result = baseGetTag(value),
            Ctor = result == objectTag ? value.constructor : undefined,
            ctorString = Ctor ? toSource(Ctor) : '';

        if (ctorString) {
          switch (ctorString) {
            case dataViewCtorString: return dataViewTag;
            case mapCtorString: return mapTag;
            case promiseCtorString: return promiseTag;
            case setCtorString: return setTag;
            case weakMapCtorString: return weakMapTag;
          }
        }
        return result;
      };
    }

    /**
     * Gets the view, applying any `transforms` to the `start` and `end` positions.
     *
     * @private
     * @param {number} start The start of the view.
     * @param {number} end The end of the view.
     * @param {Array} transforms The transformations to apply to the view.
     * @returns {Object} Returns an object containing the `start` and `end`
     *  positions of the view.
     */
    function getView(start, end, transforms) {
      var index = -1,
          length = transforms.length;

      while (++index < length) {
        var data = transforms[index],
            size = data.size;

        switch (data.type) {
          case 'drop':      start += size; break;
          case 'dropRight': end -= size; break;
          case 'take':      end = nativeMin(end, start + size); break;
          case 'takeRight': start = nativeMax(start, end - size); break;
        }
      }
      return { 'start': start, 'end': end };
    }

    /**
     * Extracts wrapper details from the `source` body comment.
     *
     * @private
     * @param {string} source The source to inspect.
     * @returns {Array} Returns the wrapper details.
     */
    function getWrapDetails(source) {
      var match = source.match(reWrapDetails);
      return match ? match[1].split(reSplitDetails) : [];
    }

    /**
     * Checks if `path` exists on `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @param {Function} hasFunc The function to check properties.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     */
    function hasPath(object, path, hasFunc) {
      path = castPath(path, object);

      var index = -1,
          length = path.length,
          result = false;

      while (++index < length) {
        var key = toKey(path[index]);
        if (!(result = object != null && hasFunc(object, key))) {
          break;
        }
        object = object[key];
      }
      if (result || ++index != length) {
        return result;
      }
      length = object == null ? 0 : object.length;
      return !!length && isLength(length) && isIndex(key, length) &&
        (isArray(object) || isArguments(object));
    }

    /**
     * Initializes an array clone.
     *
     * @private
     * @param {Array} array The array to clone.
     * @returns {Array} Returns the initialized clone.
     */
    function initCloneArray(array) {
      var length = array.length,
          result = new array.constructor(length);

      // Add properties assigned by `RegExp#exec`.
      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
        result.index = array.index;
        result.input = array.input;
      }
      return result;
    }

    /**
     * Initializes an object clone.
     *
     * @private
     * @param {Object} object The object to clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneObject(object) {
      return (typeof object.constructor == 'function' && !isPrototype(object))
        ? baseCreate(getPrototype(object))
        : {};
    }

    /**
     * Initializes an object clone based on its `toStringTag`.
     *
     * **Note:** This function only supports cloning values with tags of
     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
     *
     * @private
     * @param {Object} object The object to clone.
     * @param {string} tag The `toStringTag` of the object to clone.
     * @param {boolean} [isDeep] Specify a deep clone.
     * @returns {Object} Returns the initialized clone.
     */
    function initCloneByTag(object, tag, isDeep) {
      var Ctor = object.constructor;
      switch (tag) {
        case arrayBufferTag:
          return cloneArrayBuffer(object);

        case boolTag:
        case dateTag:
          return new Ctor(+object);

        case dataViewTag:
          return cloneDataView(object, isDeep);

        case float32Tag: case float64Tag:
        case int8Tag: case int16Tag: case int32Tag:
        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
          return cloneTypedArray(object, isDeep);

        case mapTag:
          return new Ctor;

        case numberTag:
        case stringTag:
          return new Ctor(object);

        case regexpTag:
          return cloneRegExp(object);

        case setTag:
          return new Ctor;

        case symbolTag:
          return cloneSymbol(object);
      }
    }

    /**
     * Inserts wrapper `details` in a comment at the top of the `source` body.
     *
     * @private
     * @param {string} source The source to modify.
     * @returns {Array} details The details to insert.
     * @returns {string} Returns the modified source.
     */
    function insertWrapDetails(source, details) {
      var length = details.length;
      if (!length) {
        return source;
      }
      var lastIndex = length - 1;
      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
      details = details.join(length > 2 ? ', ' : ' ');
      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
    }

    /**
     * Checks if `value` is a flattenable `arguments` object or array.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
     */
    function isFlattenable(value) {
      return isArray(value) || isArguments(value) ||
        !!(spreadableSymbol && value && value[spreadableSymbol]);
    }

    /**
     * Checks if `value` is a valid array-like index.
     *
     * @private
     * @param {*} value The value to check.
     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
     */
    function isIndex(value, length) {
      var type = typeof value;
      length = length == null ? MAX_SAFE_INTEGER : length;

      return !!length &&
        (type == 'number' ||
          (type != 'symbol' && reIsUint.test(value))) &&
            (value > -1 && value % 1 == 0 && value < length);
    }

    /**
     * Checks if the given arguments are from an iteratee call.
     *
     * @private
     * @param {*} value The potential iteratee value argument.
     * @param {*} index The potential iteratee index or key argument.
     * @param {*} object The potential iteratee object argument.
     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
     *  else `false`.
     */
    function isIterateeCall(value, index, object) {
      if (!isObject(object)) {
        return false;
      }
      var type = typeof index;
      if (type == 'number'
            ? (isArrayLike(object) && isIndex(index, object.length))
            : (type == 'string' && index in object)
          ) {
        return eq(object[index], value);
      }
      return false;
    }

    /**
     * Checks if `value` is a property name and not a property path.
     *
     * @private
     * @param {*} value The value to check.
     * @param {Object} [object] The object to query keys on.
     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
     */
    function isKey(value, object) {
      if (isArray(value)) {
        return false;
      }
      var type = typeof value;
      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
          value == null || isSymbol(value)) {
        return true;
      }
      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
        (object != null && value in Object(object));
    }

    /**
     * Checks if `value` is suitable for use as unique object key.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
     */
    function isKeyable(value) {
      var type = typeof value;
      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
        ? (value !== '__proto__')
        : (value === null);
    }

    /**
     * Checks if `func` has a lazy counterpart.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
     *  else `false`.
     */
    function isLaziable(func) {
      var funcName = getFuncName(func),
          other = lodash[funcName];

      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
        return false;
      }
      if (func === other) {
        return true;
      }
      var data = getData(other);
      return !!data && func === data[0];
    }

    /**
     * Checks if `func` has its source masked.
     *
     * @private
     * @param {Function} func The function to check.
     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
     */
    function isMasked(func) {
      return !!maskSrcKey && (maskSrcKey in func);
    }

    /**
     * Checks if `func` is capable of being masked.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
     */
    var isMaskable = coreJsData ? isFunction : stubFalse;

    /**
     * Checks if `value` is likely a prototype object.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
     */
    function isPrototype(value) {
      var Ctor = value && value.constructor,
          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

      return value === proto;
    }

    /**
     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` if suitable for strict
     *  equality comparisons, else `false`.
     */
    function isStrictComparable(value) {
      return value === value && !isObject(value);
    }

    /**
     * A specialized version of `matchesProperty` for source values suitable
     * for strict equality comparisons, i.e. `===`.
     *
     * @private
     * @param {string} key The key of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     */
    function matchesStrictComparable(key, srcValue) {
      return function(object) {
        if (object == null) {
          return false;
        }
        return object[key] === srcValue &&
          (srcValue !== undefined || (key in Object(object)));
      };
    }

    /**
     * A specialized version of `_.memoize` which clears the memoized function's
     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
     *
     * @private
     * @param {Function} func The function to have its output memoized.
     * @returns {Function} Returns the new memoized function.
     */
    function memoizeCapped(func) {
      var result = memoize(func, function(key) {
        if (cache.size === MAX_MEMOIZE_SIZE) {
          cache.clear();
        }
        return key;
      });

      var cache = result.cache;
      return result;
    }

    /**
     * Merges the function metadata of `source` into `data`.
     *
     * Merging metadata reduces the number of wrappers used to invoke a function.
     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
     * may be applied regardless of execution order. Methods like `_.ary` and
     * `_.rearg` modify function arguments, making the order in which they are
     * executed important, preventing the merging of metadata. However, we make
     * an exception for a safe combined case where curried functions have `_.ary`
     * and or `_.rearg` applied.
     *
     * @private
     * @param {Array} data The destination metadata.
     * @param {Array} source The source metadata.
     * @returns {Array} Returns `data`.
     */
    function mergeData(data, source) {
      var bitmask = data[1],
          srcBitmask = source[1],
          newBitmask = bitmask | srcBitmask,
          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

      var isCombo =
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

      // Exit early if metadata can't be merged.
      if (!(isCommon || isCombo)) {
        return data;
      }
      // Use source `thisArg` if available.
      if (srcBitmask & WRAP_BIND_FLAG) {
        data[2] = source[2];
        // Set when currying a bound function.
        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
      }
      // Compose partial arguments.
      var value = source[3];
      if (value) {
        var partials = data[3];
        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
      }
      // Compose partial right arguments.
      value = source[5];
      if (value) {
        partials = data[5];
        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
      }
      // Use source `argPos` if available.
      value = source[7];
      if (value) {
        data[7] = value;
      }
      // Use source `ary` if it's smaller.
      if (srcBitmask & WRAP_ARY_FLAG) {
        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
      }
      // Use source `arity` if one is not provided.
      if (data[9] == null) {
        data[9] = source[9];
      }
      // Use source `func` and merge bitmasks.
      data[0] = source[0];
      data[1] = newBitmask;

      return data;
    }

    /**
     * This function is like
     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * except that it includes inherited enumerable properties.
     *
     * @private
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     */
    function nativeKeysIn(object) {
      var result = [];
      if (object != null) {
        for (var key in Object(object)) {
          result.push(key);
        }
      }
      return result;
    }

    /**
     * Converts `value` to a string using `Object.prototype.toString`.
     *
     * @private
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     */
    function objectToString(value) {
      return nativeObjectToString.call(value);
    }

    /**
     * A specialized version of `baseRest` which transforms the rest array.
     *
     * @private
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @param {Function} transform The rest array transform.
     * @returns {Function} Returns the new function.
     */
    function overRest(func, start, transform) {
      start = nativeMax(start === undefined ? (func.length - 1) : start, 0);
      return function() {
        var args = arguments,
            index = -1,
            length = nativeMax(args.length - start, 0),
            array = Array(length);

        while (++index < length) {
          array[index] = args[start + index];
        }
        index = -1;
        var otherArgs = Array(start + 1);
        while (++index < start) {
          otherArgs[index] = args[index];
        }
        otherArgs[start] = transform(array);
        return apply(func, this, otherArgs);
      };
    }

    /**
     * Gets the parent value at `path` of `object`.
     *
     * @private
     * @param {Object} object The object to query.
     * @param {Array} path The path to get the parent value of.
     * @returns {*} Returns the parent value.
     */
    function parent(object, path) {
      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
    }

    /**
     * Reorder `array` according to the specified indexes where the element at
     * the first index is assigned as the first element, the element at
     * the second index is assigned as the second element, and so on.
     *
     * @private
     * @param {Array} array The array to reorder.
     * @param {Array} indexes The arranged array indexes.
     * @returns {Array} Returns `array`.
     */
    function reorder(array, indexes) {
      var arrLength = array.length,
          length = nativeMin(indexes.length, arrLength),
          oldArray = copyArray(array);

      while (length--) {
        var index = indexes[length];
        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined;
      }
      return array;
    }

    /**
     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
     *
     * @private
     * @param {Object} object The object to query.
     * @param {string} key The key of the property to get.
     * @returns {*} Returns the property value.
     */
    function safeGet(object, key) {
      if (key === 'constructor' && typeof object[key] === 'function') {
        return;
      }

      if (key == '__proto__') {
        return;
      }

      return object[key];
    }

    /**
     * Sets metadata for `func`.
     *
     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
     * period of time, it will trip its breaker and transition to an identity
     * function to avoid garbage collection pauses in V8. See
     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
     * for more details.
     *
     * @private
     * @param {Function} func The function to associate metadata with.
     * @param {*} data The metadata.
     * @returns {Function} Returns `func`.
     */
    var setData = shortOut(baseSetData);

    /**
     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
     *
     * @private
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @returns {number|Object} Returns the timer id or timeout object.
     */
    var setTimeout = ctxSetTimeout || function(func, wait) {
      return root.setTimeout(func, wait);
    };

    /**
     * Sets the `toString` method of `func` to return `string`.
     *
     * @private
     * @param {Function} func The function to modify.
     * @param {Function} string The `toString` result.
     * @returns {Function} Returns `func`.
     */
    var setToString = shortOut(baseSetToString);

    /**
     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
     * with wrapper details in a comment at the top of the source body.
     *
     * @private
     * @param {Function} wrapper The function to modify.
     * @param {Function} reference The reference function.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Function} Returns `wrapper`.
     */
    function setWrapToString(wrapper, reference, bitmask) {
      var source = (reference + '');
      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
    }

    /**
     * Creates a function that'll short out and invoke `identity` instead
     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
     * milliseconds.
     *
     * @private
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new shortable function.
     */
    function shortOut(func) {
      var count = 0,
          lastCalled = 0;

      return function() {
        var stamp = nativeNow(),
            remaining = HOT_SPAN - (stamp - lastCalled);

        lastCalled = stamp;
        if (remaining > 0) {
          if (++count >= HOT_COUNT) {
            return arguments[0];
          }
        } else {
          count = 0;
        }
        return func.apply(undefined, arguments);
      };
    }

    /**
     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
     *
     * @private
     * @param {Array} array The array to shuffle.
     * @param {number} [size=array.length] The size of `array`.
     * @returns {Array} Returns `array`.
     */
    function shuffleSelf(array, size) {
      var index = -1,
          length = array.length,
          lastIndex = length - 1;

      size = size === undefined ? length : size;
      while (++index < size) {
        var rand = baseRandom(index, lastIndex),
            value = array[rand];

        array[rand] = array[index];
        array[index] = value;
      }
      array.length = size;
      return array;
    }

    /**
     * Converts `string` to a property path array.
     *
     * @private
     * @param {string} string The string to convert.
     * @returns {Array} Returns the property path array.
     */
    var stringToPath = memoizeCapped(function(string) {
      var result = [];
      if (string.charCodeAt(0) === 46 /* . */) {
        result.push('');
      }
      string.replace(rePropName, function(match, number, quote, subString) {
        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
      });
      return result;
    });

    /**
     * Converts `value` to a string key if it's not a string or symbol.
     *
     * @private
     * @param {*} value The value to inspect.
     * @returns {string|symbol} Returns the key.
     */
    function toKey(value) {
      if (typeof value == 'string' || isSymbol(value)) {
        return value;
      }
      var result = (value + '');
      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
    }

    /**
     * Converts `func` to its source code.
     *
     * @private
     * @param {Function} func The function to convert.
     * @returns {string} Returns the source code.
     */
    function toSource(func) {
      if (func != null) {
        try {
          return funcToString.call(func);
        } catch (e) {}
        try {
          return (func + '');
        } catch (e) {}
      }
      return '';
    }

    /**
     * Updates wrapper `details` based on `bitmask` flags.
     *
     * @private
     * @returns {Array} details The details to modify.
     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
     * @returns {Array} Returns `details`.
     */
    function updateWrapDetails(details, bitmask) {
      arrayEach(wrapFlags, function(pair) {
        var value = '_.' + pair[0];
        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
          details.push(value);
        }
      });
      return details.sort();
    }

    /**
     * Creates a clone of `wrapper`.
     *
     * @private
     * @param {Object} wrapper The wrapper to clone.
     * @returns {Object} Returns the cloned wrapper.
     */
    function wrapperClone(wrapper) {
      if (wrapper instanceof LazyWrapper) {
        return wrapper.clone();
      }
      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
      result.__actions__ = copyArray(wrapper.__actions__);
      result.__index__  = wrapper.__index__;
      result.__values__ = wrapper.__values__;
      return result;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an array of elements split into groups the length of `size`.
     * If `array` can't be split evenly, the final chunk will be the remaining
     * elements.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to process.
     * @param {number} [size=1] The length of each chunk
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the new array of chunks.
     * @example
     *
     * _.chunk(['a', 'b', 'c', 'd'], 2);
     * // => [['a', 'b'], ['c', 'd']]
     *
     * _.chunk(['a', 'b', 'c', 'd'], 3);
     * // => [['a', 'b', 'c'], ['d']]
     */
    function chunk(array, size, guard) {
      if ((guard ? isIterateeCall(array, size, guard) : size === undefined)) {
        size = 1;
      } else {
        size = nativeMax(toInteger(size), 0);
      }
      var length = array == null ? 0 : array.length;
      if (!length || size < 1) {
        return [];
      }
      var index = 0,
          resIndex = 0,
          result = Array(nativeCeil(length / size));

      while (index < length) {
        result[resIndex++] = baseSlice(array, index, (index += size));
      }
      return result;
    }

    /**
     * Creates an array with all falsey values removed. The values `false`, `null`,
     * `0`, `""`, `undefined`, and `NaN` are falsey.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to compact.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.compact([0, 1, false, 2, '', 3]);
     * // => [1, 2, 3]
     */
    function compact(array) {
      var index = -1,
          length = array == null ? 0 : array.length,
          resIndex = 0,
          result = [];

      while (++index < length) {
        var value = array[index];
        if (value) {
          result[resIndex++] = value;
        }
      }
      return result;
    }

    /**
     * Creates a new array concatenating `array` with any additional arrays
     * and/or values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to concatenate.
     * @param {...*} [values] The values to concatenate.
     * @returns {Array} Returns the new concatenated array.
     * @example
     *
     * var array = [1];
     * var other = _.concat(array, 2, [3], [[4]]);
     *
     * console.log(other);
     * // => [1, 2, 3, [4]]
     *
     * console.log(array);
     * // => [1]
     */
    function concat() {
      var length = arguments.length;
      if (!length) {
        return [];
      }
      var args = Array(length - 1),
          array = arguments[0],
          index = length;

      while (index--) {
        args[index - 1] = arguments[index];
      }
      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
    }

    /**
     * Creates an array of `array` values not included in the other given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * **Note:** Unlike `_.pullAll`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.without, _.xor
     * @example
     *
     * _.difference([2, 1], [2, 3]);
     * // => [1]
     */
    var difference = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `iteratee` which
     * is invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var differenceBy = baseRest(function(array, values) {
      var iteratee = last(values);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.difference` except that it accepts `comparator`
     * which is invoked to compare elements of `array` to `values`. The order and
     * references of result values are determined by the first array. The comparator
     * is invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...Array} [values] The values to exclude.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     *
     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }]
     */
    var differenceWith = baseRest(function(array, values) {
      var comparator = last(values);
      if (isArrayLikeObject(comparator)) {
        comparator = undefined;
      }
      return isArrayLikeObject(array)
        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined, comparator)
        : [];
    });

    /**
     * Creates a slice of `array` with `n` elements dropped from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.drop([1, 2, 3]);
     * // => [2, 3]
     *
     * _.drop([1, 2, 3], 2);
     * // => [3]
     *
     * _.drop([1, 2, 3], 5);
     * // => []
     *
     * _.drop([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function drop(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with `n` elements dropped from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to drop.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.dropRight([1, 2, 3]);
     * // => [1, 2]
     *
     * _.dropRight([1, 2, 3], 2);
     * // => [1]
     *
     * _.dropRight([1, 2, 3], 5);
     * // => []
     *
     * _.dropRight([1, 2, 3], 0);
     * // => [1, 2, 3]
     */
    function dropRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the end.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.dropRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropRightWhile(users, ['active', false]);
     * // => objects for ['barney']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropRightWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true, true)
        : [];
    }

    /**
     * Creates a slice of `array` excluding elements dropped from the beginning.
     * Elements are dropped until `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.dropWhile(users, function(o) { return !o.active; });
     * // => objects for ['pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.dropWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.dropWhile(users, ['active', false]);
     * // => objects for ['pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.dropWhile(users, 'active');
     * // => objects for ['barney', 'fred', 'pebbles']
     */
    function dropWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), true)
        : [];
    }

    /**
     * Fills elements of `array` with `value` from `start` up to, but not
     * including, `end`.
     *
     * **Note:** This method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Array
     * @param {Array} array The array to fill.
     * @param {*} value The value to fill `array` with.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.fill(array, 'a');
     * console.log(array);
     * // => ['a', 'a', 'a']
     *
     * _.fill(Array(3), 2);
     * // => [2, 2, 2]
     *
     * _.fill([4, 6, 8, 10], '*', 1, 3);
     * // => [4, '*', '*', 10]
     */
    function fill(array, value, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
        start = 0;
        end = length;
      }
      return baseFill(array, value, start, end);
    }

    /**
     * This method is like `_.find` except that it returns the index of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.findIndex(users, function(o) { return o.user == 'barney'; });
     * // => 0
     *
     * // The `_.matches` iteratee shorthand.
     * _.findIndex(users, { 'user': 'fred', 'active': false });
     * // => 1
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findIndex(users, ['active', false]);
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.findIndex(users, 'active');
     * // => 2
     */
    function findIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index);
    }

    /**
     * This method is like `_.findIndex` except that it iterates over elements
     * of `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the found element, else `-1`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
     * // => 2
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
     * // => 0
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastIndex(users, ['active', false]);
     * // => 2
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastIndex(users, 'active');
     * // => 0
     */
    function findLastIndex(array, predicate, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length - 1;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = fromIndex < 0
          ? nativeMax(length + index, 0)
          : nativeMin(index, length - 1);
      }
      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
    }

    /**
     * Flattens `array` a single level deep.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flatten([1, [2, [3, [4]], 5]]);
     * // => [1, 2, [3, [4]], 5]
     */
    function flatten(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, 1) : [];
    }

    /**
     * Recursively flattens `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * _.flattenDeep([1, [2, [3, [4]], 5]]);
     * // => [1, 2, 3, 4, 5]
     */
    function flattenDeep(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseFlatten(array, INFINITY) : [];
    }

    /**
     * Recursively flatten `array` up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Array
     * @param {Array} array The array to flatten.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * var array = [1, [2, [3, [4]], 5]];
     *
     * _.flattenDepth(array, 1);
     * // => [1, 2, [3, [4]], 5]
     *
     * _.flattenDepth(array, 2);
     * // => [1, 2, 3, [4], 5]
     */
    function flattenDepth(array, depth) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(array, depth);
    }

    /**
     * The inverse of `_.toPairs`; this method returns an object composed
     * from key-value `pairs`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} pairs The key-value pairs.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.fromPairs([['a', 1], ['b', 2]]);
     * // => { 'a': 1, 'b': 2 }
     */
    function fromPairs(pairs) {
      var index = -1,
          length = pairs == null ? 0 : pairs.length,
          result = {};

      while (++index < length) {
        var pair = pairs[index];
        result[pair[0]] = pair[1];
      }
      return result;
    }

    /**
     * Gets the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias first
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the first element of `array`.
     * @example
     *
     * _.head([1, 2, 3]);
     * // => 1
     *
     * _.head([]);
     * // => undefined
     */
    function head(array) {
      return (array && array.length) ? array[0] : undefined;
    }

    /**
     * Gets the index at which the first occurrence of `value` is found in `array`
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. If `fromIndex` is negative, it's used as the
     * offset from the end of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.indexOf([1, 2, 1, 2], 2);
     * // => 1
     *
     * // Search from the `fromIndex`.
     * _.indexOf([1, 2, 1, 2], 2, 2);
     * // => 3
     */
    function indexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = fromIndex == null ? 0 : toInteger(fromIndex);
      if (index < 0) {
        index = nativeMax(length + index, 0);
      }
      return baseIndexOf(array, value, index);
    }

    /**
     * Gets all but the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.initial([1, 2, 3]);
     * // => [1, 2]
     */
    function initial(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 0, -1) : [];
    }

    /**
     * Creates an array of unique values that are included in all given arrays
     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons. The order and references of result values are
     * determined by the first array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersection([2, 1], [2, 3]);
     * // => [2]
     */
    var intersection = baseRest(function(arrays) {
      var mapped = arrayMap(arrays, castArrayLikeObject);
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped)
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `iteratee`
     * which is invoked for each element of each `arrays` to generate the criterion
     * by which they're compared. The order and references of result values are
     * determined by the first array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [2.1]
     *
     * // The `_.property` iteratee shorthand.
     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }]
     */
    var intersectionBy = baseRest(function(arrays) {
      var iteratee = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      if (iteratee === last(mapped)) {
        iteratee = undefined;
      } else {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, getIteratee(iteratee, 2))
        : [];
    });

    /**
     * This method is like `_.intersection` except that it accepts `comparator`
     * which is invoked to compare elements of `arrays`. The order and references
     * of result values are determined by the first array. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of intersecting values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.intersectionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }]
     */
    var intersectionWith = baseRest(function(arrays) {
      var comparator = last(arrays),
          mapped = arrayMap(arrays, castArrayLikeObject);

      comparator = typeof comparator == 'function' ? comparator : undefined;
      if (comparator) {
        mapped.pop();
      }
      return (mapped.length && mapped[0] === arrays[0])
        ? baseIntersection(mapped, undefined, comparator)
        : [];
    });

    /**
     * Converts all elements in `array` into a string separated by `separator`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to convert.
     * @param {string} [separator=','] The element separator.
     * @returns {string} Returns the joined string.
     * @example
     *
     * _.join(['a', 'b', 'c'], '~');
     * // => 'a~b~c'
     */
    function join(array, separator) {
      return array == null ? '' : nativeJoin.call(array, separator);
    }

    /**
     * Gets the last element of `array`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {*} Returns the last element of `array`.
     * @example
     *
     * _.last([1, 2, 3]);
     * // => 3
     */
    function last(array) {
      var length = array == null ? 0 : array.length;
      return length ? array[length - 1] : undefined;
    }

    /**
     * This method is like `_.indexOf` except that it iterates over elements of
     * `array` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=array.length-1] The index to search from.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.lastIndexOf([1, 2, 1, 2], 2);
     * // => 3
     *
     * // Search from the `fromIndex`.
     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
     * // => 1
     */
    function lastIndexOf(array, value, fromIndex) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return -1;
      }
      var index = length;
      if (fromIndex !== undefined) {
        index = toInteger(fromIndex);
        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
      }
      return value === value
        ? strictLastIndexOf(array, value, index)
        : baseFindIndex(array, baseIsNaN, index, true);
    }

    /**
     * Gets the element at index `n` of `array`. If `n` is negative, the nth
     * element from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.11.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=0] The index of the element to return.
     * @returns {*} Returns the nth element of `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     *
     * _.nth(array, 1);
     * // => 'b'
     *
     * _.nth(array, -2);
     * // => 'c';
     */
    function nth(array, n) {
      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined;
    }

    /**
     * Removes all given values from `array` using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
     * to remove elements from an array by predicate.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...*} [values] The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pull(array, 'a', 'c');
     * console.log(array);
     * // => ['b', 'b']
     */
    var pull = baseRest(pullAll);

    /**
     * This method is like `_.pull` except that it accepts an array of values to remove.
     *
     * **Note:** Unlike `_.difference`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
     *
     * _.pullAll(array, ['a', 'c']);
     * console.log(array);
     * // => ['b', 'b']
     */
    function pullAll(array, values) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values)
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `iteratee` which is
     * invoked for each element of `array` and `values` to generate the criterion
     * by which they're compared. The iteratee is invoked with one argument: (value).
     *
     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
     *
     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
     * console.log(array);
     * // => [{ 'x': 2 }]
     */
    function pullAllBy(array, values, iteratee) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, getIteratee(iteratee, 2))
        : array;
    }

    /**
     * This method is like `_.pullAll` except that it accepts `comparator` which
     * is invoked to compare elements of `array` to `values`. The comparator is
     * invoked with two arguments: (arrVal, othVal).
     *
     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Array} values The values to remove.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
     *
     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
     * console.log(array);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
     */
    function pullAllWith(array, values, comparator) {
      return (array && array.length && values && values.length)
        ? basePullAll(array, values, undefined, comparator)
        : array;
    }

    /**
     * Removes elements from `array` corresponding to `indexes` and returns an
     * array of removed elements.
     *
     * **Note:** Unlike `_.at`, this method mutates `array`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = ['a', 'b', 'c', 'd'];
     * var pulled = _.pullAt(array, [1, 3]);
     *
     * console.log(array);
     * // => ['a', 'c']
     *
     * console.log(pulled);
     * // => ['b', 'd']
     */
    var pullAt = flatRest(function(array, indexes) {
      var length = array == null ? 0 : array.length,
          result = baseAt(array, indexes);

      basePullAt(array, arrayMap(indexes, function(index) {
        return isIndex(index, length) ? +index : index;
      }).sort(compareAscending));

      return result;
    });

    /**
     * Removes all elements from `array` that `predicate` returns truthy for
     * and returns an array of the removed elements. The predicate is invoked
     * with three arguments: (value, index, array).
     *
     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
     * to pull elements from an array by value.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new array of removed elements.
     * @example
     *
     * var array = [1, 2, 3, 4];
     * var evens = _.remove(array, function(n) {
     *   return n % 2 == 0;
     * });
     *
     * console.log(array);
     * // => [1, 3]
     *
     * console.log(evens);
     * // => [2, 4]
     */
    function remove(array, predicate) {
      var result = [];
      if (!(array && array.length)) {
        return result;
      }
      var index = -1,
          indexes = [],
          length = array.length;

      predicate = getIteratee(predicate, 3);
      while (++index < length) {
        var value = array[index];
        if (predicate(value, index, array)) {
          result.push(value);
          indexes.push(index);
        }
      }
      basePullAt(array, indexes);
      return result;
    }

    /**
     * Reverses `array` so that the first element becomes the last, the second
     * element becomes the second to last, and so on.
     *
     * **Note:** This method mutates `array` and is based on
     * [`Array#reverse`](https://mdn.io/Array/reverse).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to modify.
     * @returns {Array} Returns `array`.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _.reverse(array);
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function reverse(array) {
      return array == null ? array : nativeReverse.call(array);
    }

    /**
     * Creates a slice of `array` from `start` up to, but not including, `end`.
     *
     * **Note:** This method is used instead of
     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
     * returned.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to slice.
     * @param {number} [start=0] The start position.
     * @param {number} [end=array.length] The end position.
     * @returns {Array} Returns the slice of `array`.
     */
    function slice(array, start, end) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
        start = 0;
        end = length;
      }
      else {
        start = start == null ? 0 : toInteger(start);
        end = end === undefined ? length : toInteger(end);
      }
      return baseSlice(array, start, end);
    }

    /**
     * Uses a binary search to determine the lowest index at which `value`
     * should be inserted into `array` in order to maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedIndex([30, 50], 40);
     * // => 1
     */
    function sortedIndex(array, value) {
      return baseSortedIndex(array, value);
    }

    /**
     * This method is like `_.sortedIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 0
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
     * // => 0
     */
    function sortedIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
    }

    /**
     * This method is like `_.indexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
     * // => 1
     */
    function sortedIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value);
        if (index < length && eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.sortedIndex` except that it returns the highest
     * index at which `value` should be inserted into `array` in order to
     * maintain its sort order.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
     * // => 4
     */
    function sortedLastIndex(array, value) {
      return baseSortedIndex(array, value, true);
    }

    /**
     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
     * which is invoked for `value` and each element of `array` to compute their
     * sort ranking. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The sorted array to inspect.
     * @param {*} value The value to evaluate.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the index at which `value` should be inserted
     *  into `array`.
     * @example
     *
     * var objects = [{ 'x': 4 }, { 'x': 5 }];
     *
     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
     * // => 1
     *
     * // The `_.property` iteratee shorthand.
     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
     * // => 1
     */
    function sortedLastIndexBy(array, value, iteratee) {
      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
    }

    /**
     * This method is like `_.lastIndexOf` except that it performs a binary
     * search on a sorted `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {*} value The value to search for.
     * @returns {number} Returns the index of the matched value, else `-1`.
     * @example
     *
     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
     * // => 3
     */
    function sortedLastIndexOf(array, value) {
      var length = array == null ? 0 : array.length;
      if (length) {
        var index = baseSortedIndex(array, value, true) - 1;
        if (eq(array[index], value)) {
          return index;
        }
      }
      return -1;
    }

    /**
     * This method is like `_.uniq` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniq([1, 1, 2]);
     * // => [1, 2]
     */
    function sortedUniq(array) {
      return (array && array.length)
        ? baseSortedUniq(array)
        : [];
    }

    /**
     * This method is like `_.uniqBy` except that it's designed and optimized
     * for sorted arrays.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
     * // => [1.1, 2.3]
     */
    function sortedUniqBy(array, iteratee) {
      return (array && array.length)
        ? baseSortedUniq(array, getIteratee(iteratee, 2))
        : [];
    }

    /**
     * Gets all but the first element of `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.tail([1, 2, 3]);
     * // => [2, 3]
     */
    function tail(array) {
      var length = array == null ? 0 : array.length;
      return length ? baseSlice(array, 1, length) : [];
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the beginning.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.take([1, 2, 3]);
     * // => [1]
     *
     * _.take([1, 2, 3], 2);
     * // => [1, 2]
     *
     * _.take([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.take([1, 2, 3], 0);
     * // => []
     */
    function take(array, n, guard) {
      if (!(array && array.length)) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      return baseSlice(array, 0, n < 0 ? 0 : n);
    }

    /**
     * Creates a slice of `array` with `n` elements taken from the end.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {number} [n=1] The number of elements to take.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * _.takeRight([1, 2, 3]);
     * // => [3]
     *
     * _.takeRight([1, 2, 3], 2);
     * // => [2, 3]
     *
     * _.takeRight([1, 2, 3], 5);
     * // => [1, 2, 3]
     *
     * _.takeRight([1, 2, 3], 0);
     * // => []
     */
    function takeRight(array, n, guard) {
      var length = array == null ? 0 : array.length;
      if (!length) {
        return [];
      }
      n = (guard || n === undefined) ? 1 : toInteger(n);
      n = length - n;
      return baseSlice(array, n < 0 ? 0 : n, length);
    }

    /**
     * Creates a slice of `array` with elements taken from the end. Elements are
     * taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': true },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': false }
     * ];
     *
     * _.takeRightWhile(users, function(o) { return !o.active; });
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
     * // => objects for ['pebbles']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeRightWhile(users, ['active', false]);
     * // => objects for ['fred', 'pebbles']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeRightWhile(users, 'active');
     * // => []
     */
    function takeRightWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3), false, true)
        : [];
    }

    /**
     * Creates a slice of `array` with elements taken from the beginning. Elements
     * are taken until `predicate` returns falsey. The predicate is invoked with
     * three arguments: (value, index, array).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Array
     * @param {Array} array The array to query.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the slice of `array`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'active': false },
     *   { 'user': 'fred',    'active': false },
     *   { 'user': 'pebbles', 'active': true }
     * ];
     *
     * _.takeWhile(users, function(o) { return !o.active; });
     * // => objects for ['barney', 'fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.takeWhile(users, { 'user': 'barney', 'active': false });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.takeWhile(users, ['active', false]);
     * // => objects for ['barney', 'fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.takeWhile(users, 'active');
     * // => []
     */
    function takeWhile(array, predicate) {
      return (array && array.length)
        ? baseWhile(array, getIteratee(predicate, 3))
        : [];
    }

    /**
     * Creates an array of unique values, in order, from all given arrays using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.union([2], [1, 2]);
     * // => [2, 1]
     */
    var union = baseRest(function(arrays) {
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
    });

    /**
     * This method is like `_.union` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which uniqueness is computed. Result values are chosen from the first
     * array in which the value occurs. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    var unionBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.union` except that it accepts `comparator` which
     * is invoked to compare elements of `arrays`. Result values are chosen from
     * the first array in which the value occurs. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of combined values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.unionWith(objects, others, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var unionWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined, comparator);
    });

    /**
     * Creates a duplicate-free version of an array, using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons, in which only the first occurrence of each element
     * is kept. The order of result values is determined by the order they occur
     * in the array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniq([2, 1, 2]);
     * // => [2, 1]
     */
    function uniq(array) {
      return (array && array.length) ? baseUniq(array) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * uniqueness is computed. The order of result values is determined by the
     * order they occur in the array. The iteratee is invoked with one argument:
     * (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
     * // => [2.1, 1.2]
     *
     * // The `_.property` iteratee shorthand.
     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 1 }, { 'x': 2 }]
     */
    function uniqBy(array, iteratee) {
      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
    }

    /**
     * This method is like `_.uniq` except that it accepts `comparator` which
     * is invoked to compare elements of `array`. The order of result values is
     * determined by the order they occur in the array.The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new duplicate free array.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.uniqWith(objects, _.isEqual);
     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
     */
    function uniqWith(array, comparator) {
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return (array && array.length) ? baseUniq(array, undefined, comparator) : [];
    }

    /**
     * This method is like `_.zip` except that it accepts an array of grouped
     * elements and creates an array regrouping the elements to their pre-zip
     * configuration.
     *
     * @static
     * @memberOf _
     * @since 1.2.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     *
     * _.unzip(zipped);
     * // => [['a', 'b'], [1, 2], [true, false]]
     */
    function unzip(array) {
      if (!(array && array.length)) {
        return [];
      }
      var length = 0;
      array = arrayFilter(array, function(group) {
        if (isArrayLikeObject(group)) {
          length = nativeMax(group.length, length);
          return true;
        }
      });
      return baseTimes(length, function(index) {
        return arrayMap(array, baseProperty(index));
      });
    }

    /**
     * This method is like `_.unzip` except that it accepts `iteratee` to specify
     * how regrouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {Array} array The array of grouped elements to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  regrouped values.
     * @returns {Array} Returns the new array of regrouped elements.
     * @example
     *
     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
     * // => [[1, 10, 100], [2, 20, 200]]
     *
     * _.unzipWith(zipped, _.add);
     * // => [3, 30, 300]
     */
    function unzipWith(array, iteratee) {
      if (!(array && array.length)) {
        return [];
      }
      var result = unzip(array);
      if (iteratee == null) {
        return result;
      }
      return arrayMap(result, function(group) {
        return apply(iteratee, undefined, group);
      });
    }

    /**
     * Creates an array excluding all given values using
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * for equality comparisons.
     *
     * **Note:** Unlike `_.pull`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {Array} array The array to inspect.
     * @param {...*} [values] The values to exclude.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.xor
     * @example
     *
     * _.without([2, 1, 2, 3], 1, 2);
     * // => [3]
     */
    var without = baseRest(function(array, values) {
      return isArrayLikeObject(array)
        ? baseDifference(array, values)
        : [];
    });

    /**
     * Creates an array of unique values that is the
     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
     * of the given arrays. The order of result values is determined by the order
     * they occur in the arrays.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @returns {Array} Returns the new array of filtered values.
     * @see _.difference, _.without
     * @example
     *
     * _.xor([2, 1], [2, 3]);
     * // => [1, 3]
     */
    var xor = baseRest(function(arrays) {
      return baseXor(arrayFilter(arrays, isArrayLikeObject));
    });

    /**
     * This method is like `_.xor` except that it accepts `iteratee` which is
     * invoked for each element of each `arrays` to generate the criterion by
     * which by which they're compared. The order of result values is determined
     * by the order they occur in the arrays. The iteratee is invoked with one
     * argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
     * // => [1.2, 3.4]
     *
     * // The `_.property` iteratee shorthand.
     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
     * // => [{ 'x': 2 }]
     */
    var xorBy = baseRest(function(arrays) {
      var iteratee = last(arrays);
      if (isArrayLikeObject(iteratee)) {
        iteratee = undefined;
      }
      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
    });

    /**
     * This method is like `_.xor` except that it accepts `comparator` which is
     * invoked to compare elements of `arrays`. The order of result values is
     * determined by the order they occur in the arrays. The comparator is invoked
     * with two arguments: (arrVal, othVal).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Array
     * @param {...Array} [arrays] The arrays to inspect.
     * @param {Function} [comparator] The comparator invoked per element.
     * @returns {Array} Returns the new array of filtered values.
     * @example
     *
     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
     *
     * _.xorWith(objects, others, _.isEqual);
     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
     */
    var xorWith = baseRest(function(arrays) {
      var comparator = last(arrays);
      comparator = typeof comparator == 'function' ? comparator : undefined;
      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined, comparator);
    });

    /**
     * Creates an array of grouped elements, the first of which contains the
     * first elements of the given arrays, the second of which contains the
     * second elements of the given arrays, and so on.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zip(['a', 'b'], [1, 2], [true, false]);
     * // => [['a', 1, true], ['b', 2, false]]
     */
    var zip = baseRest(unzip);

    /**
     * This method is like `_.fromPairs` except that it accepts two arrays,
     * one of property identifiers and one of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 0.4.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObject(['a', 'b'], [1, 2]);
     * // => { 'a': 1, 'b': 2 }
     */
    function zipObject(props, values) {
      return baseZipObject(props || [], values || [], assignValue);
    }

    /**
     * This method is like `_.zipObject` except that it supports property paths.
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Array
     * @param {Array} [props=[]] The property identifiers.
     * @param {Array} [values=[]] The property values.
     * @returns {Object} Returns the new object.
     * @example
     *
     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
     */
    function zipObjectDeep(props, values) {
      return baseZipObject(props || [], values || [], baseSet);
    }

    /**
     * This method is like `_.zip` except that it accepts `iteratee` to specify
     * how grouped values should be combined. The iteratee is invoked with the
     * elements of each group: (...group).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Array
     * @param {...Array} [arrays] The arrays to process.
     * @param {Function} [iteratee=_.identity] The function to combine
     *  grouped values.
     * @returns {Array} Returns the new array of grouped elements.
     * @example
     *
     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
     *   return a + b + c;
     * });
     * // => [111, 222]
     */
    var zipWith = baseRest(function(arrays) {
      var length = arrays.length,
          iteratee = length > 1 ? arrays[length - 1] : undefined;

      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined;
      return unzipWith(arrays, iteratee);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
     * chain sequences enabled. The result of such sequences must be unwrapped
     * with `_#value`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Seq
     * @param {*} value The value to wrap.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36 },
     *   { 'user': 'fred',    'age': 40 },
     *   { 'user': 'pebbles', 'age': 1 }
     * ];
     *
     * var youngest = _
     *   .chain(users)
     *   .sortBy('age')
     *   .map(function(o) {
     *     return o.user + ' is ' + o.age;
     *   })
     *   .head()
     *   .value();
     * // => 'pebbles is 1'
     */
    function chain(value) {
      var result = lodash(value);
      result.__chain__ = true;
      return result;
    }

    /**
     * This method invokes `interceptor` and returns `value`. The interceptor
     * is invoked with one argument; (value). The purpose of this method is to
     * "tap into" a method chain sequence in order to modify intermediate results.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns `value`.
     * @example
     *
     * _([1, 2, 3])
     *  .tap(function(array) {
     *    // Mutate input array.
     *    array.pop();
     *  })
     *  .reverse()
     *  .value();
     * // => [2, 1]
     */
    function tap(value, interceptor) {
      interceptor(value);
      return value;
    }

    /**
     * This method is like `_.tap` except that it returns the result of `interceptor`.
     * The purpose of this method is to "pass thru" values replacing intermediate
     * results in a method chain sequence.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Seq
     * @param {*} value The value to provide to `interceptor`.
     * @param {Function} interceptor The function to invoke.
     * @returns {*} Returns the result of `interceptor`.
     * @example
     *
     * _('  abc  ')
     *  .chain()
     *  .trim()
     *  .thru(function(value) {
     *    return [value];
     *  })
     *  .value();
     * // => ['abc']
     */
    function thru(value, interceptor) {
      return interceptor(value);
    }

    /**
     * This method is the wrapper version of `_.at`.
     *
     * @name at
     * @memberOf _
     * @since 1.0.0
     * @category Seq
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _(object).at(['a[0].b.c', 'a[1]']).value();
     * // => [3, 4]
     */
    var wrapperAt = flatRest(function(paths) {
      var length = paths.length,
          start = length ? paths[0] : 0,
          value = this.__wrapped__,
          interceptor = function(object) { return baseAt(object, paths); };

      if (length > 1 || this.__actions__.length ||
          !(value instanceof LazyWrapper) || !isIndex(start)) {
        return this.thru(interceptor);
      }
      value = value.slice(start, +start + (length ? 1 : 0));
      value.__actions__.push({
        'func': thru,
        'args': [interceptor],
        'thisArg': undefined
      });
      return new LodashWrapper(value, this.__chain__).thru(function(array) {
        if (length && !array.length) {
          array.push(undefined);
        }
        return array;
      });
    });

    /**
     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
     *
     * @name chain
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 40 }
     * ];
     *
     * // A sequence without explicit chaining.
     * _(users).head();
     * // => { 'user': 'barney', 'age': 36 }
     *
     * // A sequence with explicit chaining.
     * _(users)
     *   .chain()
     *   .head()
     *   .pick('user')
     *   .value();
     * // => { 'user': 'barney' }
     */
    function wrapperChain() {
      return chain(this);
    }

    /**
     * Executes the chain sequence and returns the wrapped result.
     *
     * @name commit
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2];
     * var wrapped = _(array).push(3);
     *
     * console.log(array);
     * // => [1, 2]
     *
     * wrapped = wrapped.commit();
     * console.log(array);
     * // => [1, 2, 3]
     *
     * wrapped.last();
     * // => 3
     *
     * console.log(array);
     * // => [1, 2, 3]
     */
    function wrapperCommit() {
      return new LodashWrapper(this.value(), this.__chain__);
    }

    /**
     * Gets the next value on a wrapped object following the
     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
     *
     * @name next
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the next iterator value.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 1 }
     *
     * wrapped.next();
     * // => { 'done': false, 'value': 2 }
     *
     * wrapped.next();
     * // => { 'done': true, 'value': undefined }
     */
    function wrapperNext() {
      if (this.__values__ === undefined) {
        this.__values__ = toArray(this.value());
      }
      var done = this.__index__ >= this.__values__.length,
          value = done ? undefined : this.__values__[this.__index__++];

      return { 'done': done, 'value': value };
    }

    /**
     * Enables the wrapper to be iterable.
     *
     * @name Symbol.iterator
     * @memberOf _
     * @since 4.0.0
     * @category Seq
     * @returns {Object} Returns the wrapper object.
     * @example
     *
     * var wrapped = _([1, 2]);
     *
     * wrapped[Symbol.iterator]() === wrapped;
     * // => true
     *
     * Array.from(wrapped);
     * // => [1, 2]
     */
    function wrapperToIterator() {
      return this;
    }

    /**
     * Creates a clone of the chain sequence planting `value` as the wrapped value.
     *
     * @name plant
     * @memberOf _
     * @since 3.2.0
     * @category Seq
     * @param {*} value The value to plant.
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var wrapped = _([1, 2]).map(square);
     * var other = wrapped.plant([3, 4]);
     *
     * other.value();
     * // => [9, 16]
     *
     * wrapped.value();
     * // => [1, 4]
     */
    function wrapperPlant(value) {
      var result,
          parent = this;

      while (parent instanceof baseLodash) {
        var clone = wrapperClone(parent);
        clone.__index__ = 0;
        clone.__values__ = undefined;
        if (result) {
          previous.__wrapped__ = clone;
        } else {
          result = clone;
        }
        var previous = clone;
        parent = parent.__wrapped__;
      }
      previous.__wrapped__ = value;
      return result;
    }

    /**
     * This method is the wrapper version of `_.reverse`.
     *
     * **Note:** This method mutates the wrapped array.
     *
     * @name reverse
     * @memberOf _
     * @since 0.1.0
     * @category Seq
     * @returns {Object} Returns the new `lodash` wrapper instance.
     * @example
     *
     * var array = [1, 2, 3];
     *
     * _(array).reverse().value()
     * // => [3, 2, 1]
     *
     * console.log(array);
     * // => [3, 2, 1]
     */
    function wrapperReverse() {
      var value = this.__wrapped__;
      if (value instanceof LazyWrapper) {
        var wrapped = value;
        if (this.__actions__.length) {
          wrapped = new LazyWrapper(this);
        }
        wrapped = wrapped.reverse();
        wrapped.__actions__.push({
          'func': thru,
          'args': [reverse],
          'thisArg': undefined
        });
        return new LodashWrapper(wrapped, this.__chain__);
      }
      return this.thru(reverse);
    }

    /**
     * Executes the chain sequence to resolve the unwrapped value.
     *
     * @name value
     * @memberOf _
     * @since 0.1.0
     * @alias toJSON, valueOf
     * @category Seq
     * @returns {*} Returns the resolved unwrapped value.
     * @example
     *
     * _([1, 2, 3]).value();
     * // => [1, 2, 3]
     */
    function wrapperValue() {
      return baseWrapperValue(this.__wrapped__, this.__actions__);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the number of times the key was returned by `iteratee`. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.countBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': 1, '6': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.countBy(['one', 'two', 'three'], 'length');
     * // => { '3': 2, '5': 1 }
     */
    var countBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        ++result[key];
      } else {
        baseAssignValue(result, key, 1);
      }
    });

    /**
     * Checks if `predicate` returns truthy for **all** elements of `collection`.
     * Iteration is stopped once `predicate` returns falsey. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * **Note:** This method returns `true` for
     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
     * elements of empty collections.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if all elements pass the predicate check,
     *  else `false`.
     * @example
     *
     * _.every([true, 1, null, 'yes'], Boolean);
     * // => false
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.every(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.every(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.every(users, 'active');
     * // => false
     */
    function every(collection, predicate, guard) {
      var func = isArray(collection) ? arrayEvery : baseEvery;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning an array of all elements
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * **Note:** Unlike `_.remove`, this method returns a new array.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.reject
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * _.filter(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, { 'age': 36, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.filter(users, 'active');
     * // => objects for ['barney']
     *
     * // Combining several predicates using `_.overEvery` or `_.overSome`.
     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
     * // => objects for ['fred', 'barney']
     */
    function filter(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Iterates over elements of `collection`, returning the first element
     * `predicate` returns truthy for. The predicate is invoked with three
     * arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=0] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': true },
     *   { 'user': 'fred',    'age': 40, 'active': false },
     *   { 'user': 'pebbles', 'age': 1,  'active': true }
     * ];
     *
     * _.find(users, function(o) { return o.age < 40; });
     * // => object for 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.find(users, { 'age': 1, 'active': true });
     * // => object for 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.find(users, ['active', false]);
     * // => object for 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.find(users, 'active');
     * // => object for 'barney'
     */
    var find = createFind(findIndex);

    /**
     * This method is like `_.find` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param {number} [fromIndex=collection.length-1] The index to search from.
     * @returns {*} Returns the matched element, else `undefined`.
     * @example
     *
     * _.findLast([1, 2, 3, 4], function(n) {
     *   return n % 2 == 1;
     * });
     * // => 3
     */
    var findLast = createFind(findLastIndex);

    /**
     * Creates a flattened array of values by running each element in `collection`
     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
     * with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [n, n];
     * }
     *
     * _.flatMap([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMap(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), 1);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDeep([1, 2], duplicate);
     * // => [1, 1, 2, 2]
     */
    function flatMapDeep(collection, iteratee) {
      return baseFlatten(map(collection, iteratee), INFINITY);
    }

    /**
     * This method is like `_.flatMap` except that it recursively flattens the
     * mapped results up to `depth` times.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {number} [depth=1] The maximum recursion depth.
     * @returns {Array} Returns the new flattened array.
     * @example
     *
     * function duplicate(n) {
     *   return [[[n, n]]];
     * }
     *
     * _.flatMapDepth([1, 2], duplicate, 2);
     * // => [[1, 1], [2, 2]]
     */
    function flatMapDepth(collection, iteratee, depth) {
      depth = depth === undefined ? 1 : toInteger(depth);
      return baseFlatten(map(collection, iteratee), depth);
    }

    /**
     * Iterates over elements of `collection` and invokes `iteratee` for each element.
     * The iteratee is invoked with three arguments: (value, index|key, collection).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * **Note:** As with other "Collections" methods, objects with a "length"
     * property are iterated like arrays. To avoid this behavior use `_.forIn`
     * or `_.forOwn` for object iteration.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @alias each
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEachRight
     * @example
     *
     * _.forEach([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `1` then `2`.
     *
     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forEach(collection, iteratee) {
      var func = isArray(collection) ? arrayEach : baseEach;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forEach` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @alias eachRight
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array|Object} Returns `collection`.
     * @see _.forEach
     * @example
     *
     * _.forEachRight([1, 2], function(value) {
     *   console.log(value);
     * });
     * // => Logs `2` then `1`.
     */
    function forEachRight(collection, iteratee) {
      var func = isArray(collection) ? arrayEachRight : baseEachRight;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The order of grouped values
     * is determined by the order they occur in `collection`. The corresponding
     * value of each key is an array of elements responsible for generating the
     * key. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
     * // => { '4': [4.2], '6': [6.1, 6.3] }
     *
     * // The `_.property` iteratee shorthand.
     * _.groupBy(['one', 'two', 'three'], 'length');
     * // => { '3': ['one', 'two'], '5': ['three'] }
     */
    var groupBy = createAggregator(function(result, value, key) {
      if (hasOwnProperty.call(result, key)) {
        result[key].push(value);
      } else {
        baseAssignValue(result, key, [value]);
      }
    });

    /**
     * Checks if `value` is in `collection`. If `collection` is a string, it's
     * checked for a substring of `value`, otherwise
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * is used for equality comparisons. If `fromIndex` is negative, it's used as
     * the offset from the end of `collection`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @param {*} value The value to search for.
     * @param {number} [fromIndex=0] The index to search from.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {boolean} Returns `true` if `value` is found, else `false`.
     * @example
     *
     * _.includes([1, 2, 3], 1);
     * // => true
     *
     * _.includes([1, 2, 3], 1, 2);
     * // => false
     *
     * _.includes({ 'a': 1, 'b': 2 }, 1);
     * // => true
     *
     * _.includes('abcd', 'bc');
     * // => true
     */
    function includes(collection, value, fromIndex, guard) {
      collection = isArrayLike(collection) ? collection : values(collection);
      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

      var length = collection.length;
      if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
      }
      return isString(collection)
        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
    }

    /**
     * Invokes the method at `path` of each element in `collection`, returning
     * an array of the results of each invoked method. Any additional arguments
     * are provided to each invoked method. If `path` is a function, it's invoked
     * for, and `this` bound to, each element in `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array|Function|string} path The path of the method to invoke or
     *  the function invoked per iteration.
     * @param {...*} [args] The arguments to invoke each method with.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
     * // => [[1, 5, 7], [1, 2, 3]]
     *
     * _.invokeMap([123, 456], String.prototype.split, '');
     * // => [['1', '2', '3'], ['4', '5', '6']]
     */
    var invokeMap = baseRest(function(collection, path, args) {
      var index = -1,
          isFunc = typeof path == 'function',
          result = isArrayLike(collection) ? Array(collection.length) : [];

      baseEach(collection, function(value) {
        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
      });
      return result;
    });

    /**
     * Creates an object composed of keys generated from the results of running
     * each element of `collection` thru `iteratee`. The corresponding value of
     * each key is the last element responsible for generating the key. The
     * iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
     * @returns {Object} Returns the composed aggregate object.
     * @example
     *
     * var array = [
     *   { 'dir': 'left', 'code': 97 },
     *   { 'dir': 'right', 'code': 100 }
     * ];
     *
     * _.keyBy(array, function(o) {
     *   return String.fromCharCode(o.code);
     * });
     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
     *
     * _.keyBy(array, 'dir');
     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
     */
    var keyBy = createAggregator(function(result, value, key) {
      baseAssignValue(result, key, value);
    });

    /**
     * Creates an array of values by running each element in `collection` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
     *
     * The guarded methods are:
     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new mapped array.
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * _.map([4, 8], square);
     * // => [16, 64]
     *
     * _.map({ 'a': 4, 'b': 8 }, square);
     * // => [16, 64] (iteration order is not guaranteed)
     *
     * var users = [
     *   { 'user': 'barney' },
     *   { 'user': 'fred' }
     * ];
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, 'user');
     * // => ['barney', 'fred']
     */
    function map(collection, iteratee) {
      var func = isArray(collection) ? arrayMap : baseMap;
      return func(collection, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.sortBy` except that it allows specifying the sort
     * orders of the iteratees to sort by. If `orders` is unspecified, all values
     * are sorted in ascending order. Otherwise, specify an order of "desc" for
     * descending or "asc" for ascending sort order of corresponding values.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @param {string[]} [orders] The sort orders of `iteratees`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 34 },
     *   { 'user': 'fred',   'age': 40 },
     *   { 'user': 'barney', 'age': 36 }
     * ];
     *
     * // Sort by `user` in ascending order and by `age` in descending order.
     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
     */
    function orderBy(collection, iteratees, orders, guard) {
      if (collection == null) {
        return [];
      }
      if (!isArray(iteratees)) {
        iteratees = iteratees == null ? [] : [iteratees];
      }
      orders = guard ? undefined : orders;
      if (!isArray(orders)) {
        orders = orders == null ? [] : [orders];
      }
      return baseOrderBy(collection, iteratees, orders);
    }

    /**
     * Creates an array of elements split into two groups, the first of which
     * contains elements `predicate` returns truthy for, the second of which
     * contains elements `predicate` returns falsey for. The predicate is
     * invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of grouped elements.
     * @example
     *
     * var users = [
     *   { 'user': 'barney',  'age': 36, 'active': false },
     *   { 'user': 'fred',    'age': 40, 'active': true },
     *   { 'user': 'pebbles', 'age': 1,  'active': false }
     * ];
     *
     * _.partition(users, function(o) { return o.active; });
     * // => objects for [['fred'], ['barney', 'pebbles']]
     *
     * // The `_.matches` iteratee shorthand.
     * _.partition(users, { 'age': 1, 'active': false });
     * // => objects for [['pebbles'], ['barney', 'fred']]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.partition(users, ['active', false]);
     * // => objects for [['barney', 'pebbles'], ['fred']]
     *
     * // The `_.property` iteratee shorthand.
     * _.partition(users, 'active');
     * // => objects for [['fred'], ['barney', 'pebbles']]
     */
    var partition = createAggregator(function(result, value, key) {
      result[key ? 0 : 1].push(value);
    }, function() { return [[], []]; });

    /**
     * Reduces `collection` to a value which is the accumulated result of running
     * each element in `collection` thru `iteratee`, where each successive
     * invocation is supplied the return value of the previous. If `accumulator`
     * is not given, the first element of `collection` is used as the initial
     * value. The iteratee is invoked with four arguments:
     * (accumulator, value, index|key, collection).
     *
     * Many lodash methods are guarded to work as iteratees for methods like
     * `_.reduce`, `_.reduceRight`, and `_.transform`.
     *
     * The guarded methods are:
     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
     * and `sortBy`
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduceRight
     * @example
     *
     * _.reduce([1, 2], function(sum, n) {
     *   return sum + n;
     * }, 0);
     * // => 3
     *
     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     *   return result;
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
     */
    function reduce(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduce : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
    }

    /**
     * This method is like `_.reduce` except that it iterates over elements of
     * `collection` from right to left.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The initial value.
     * @returns {*} Returns the accumulated value.
     * @see _.reduce
     * @example
     *
     * var array = [[0, 1], [2, 3], [4, 5]];
     *
     * _.reduceRight(array, function(flattened, other) {
     *   return flattened.concat(other);
     * }, []);
     * // => [4, 5, 2, 3, 0, 1]
     */
    function reduceRight(collection, iteratee, accumulator) {
      var func = isArray(collection) ? arrayReduceRight : baseReduce,
          initAccum = arguments.length < 3;

      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
    }

    /**
     * The opposite of `_.filter`; this method returns the elements of `collection`
     * that `predicate` does **not** return truthy for.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the new filtered array.
     * @see _.filter
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': false },
     *   { 'user': 'fred',   'age': 40, 'active': true }
     * ];
     *
     * _.reject(users, function(o) { return !o.active; });
     * // => objects for ['fred']
     *
     * // The `_.matches` iteratee shorthand.
     * _.reject(users, { 'age': 40, 'active': true });
     * // => objects for ['barney']
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.reject(users, ['active', false]);
     * // => objects for ['fred']
     *
     * // The `_.property` iteratee shorthand.
     * _.reject(users, 'active');
     * // => objects for ['barney']
     */
    function reject(collection, predicate) {
      var func = isArray(collection) ? arrayFilter : baseFilter;
      return func(collection, negate(getIteratee(predicate, 3)));
    }

    /**
     * Gets a random element from `collection`.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @returns {*} Returns the random element.
     * @example
     *
     * _.sample([1, 2, 3, 4]);
     * // => 2
     */
    function sample(collection) {
      var func = isArray(collection) ? arraySample : baseSample;
      return func(collection);
    }

    /**
     * Gets `n` random elements at unique keys from `collection` up to the
     * size of `collection`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Collection
     * @param {Array|Object} collection The collection to sample.
     * @param {number} [n=1] The number of elements to sample.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the random elements.
     * @example
     *
     * _.sampleSize([1, 2, 3], 2);
     * // => [3, 1]
     *
     * _.sampleSize([1, 2, 3], 4);
     * // => [2, 3, 1]
     */
    function sampleSize(collection, n, guard) {
      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
      return func(collection, n);
    }

    /**
     * Creates an array of shuffled values, using a version of the
     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to shuffle.
     * @returns {Array} Returns the new shuffled array.
     * @example
     *
     * _.shuffle([1, 2, 3, 4]);
     * // => [4, 1, 3, 2]
     */
    function shuffle(collection) {
      var func = isArray(collection) ? arrayShuffle : baseShuffle;
      return func(collection);
    }

    /**
     * Gets the size of `collection` by returning its length for array-like
     * values or the number of own enumerable string keyed properties for objects.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object|string} collection The collection to inspect.
     * @returns {number} Returns the collection size.
     * @example
     *
     * _.size([1, 2, 3]);
     * // => 3
     *
     * _.size({ 'a': 1, 'b': 2 });
     * // => 2
     *
     * _.size('pebbles');
     * // => 7
     */
    function size(collection) {
      if (collection == null) {
        return 0;
      }
      if (isArrayLike(collection)) {
        return isString(collection) ? stringSize(collection) : collection.length;
      }
      var tag = getTag(collection);
      if (tag == mapTag || tag == setTag) {
        return collection.size;
      }
      return baseKeys(collection).length;
    }

    /**
     * Checks if `predicate` returns truthy for **any** element of `collection`.
     * Iteration is stopped once `predicate` returns truthy. The predicate is
     * invoked with three arguments: (value, index|key, collection).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {boolean} Returns `true` if any element passes the predicate check,
     *  else `false`.
     * @example
     *
     * _.some([null, 0, 'yes', false], Boolean);
     * // => true
     *
     * var users = [
     *   { 'user': 'barney', 'active': true },
     *   { 'user': 'fred',   'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.some(users, { 'user': 'barney', 'active': false });
     * // => false
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.some(users, ['active', false]);
     * // => true
     *
     * // The `_.property` iteratee shorthand.
     * _.some(users, 'active');
     * // => true
     */
    function some(collection, predicate, guard) {
      var func = isArray(collection) ? arraySome : baseSome;
      if (guard && isIterateeCall(collection, predicate, guard)) {
        predicate = undefined;
      }
      return func(collection, getIteratee(predicate, 3));
    }

    /**
     * Creates an array of elements, sorted in ascending order by the results of
     * running each element in a collection thru each iteratee. This method
     * performs a stable sort, that is, it preserves the original sort order of
     * equal elements. The iteratees are invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Collection
     * @param {Array|Object} collection The collection to iterate over.
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to sort by.
     * @returns {Array} Returns the new sorted array.
     * @example
     *
     * var users = [
     *   { 'user': 'fred',   'age': 48 },
     *   { 'user': 'barney', 'age': 36 },
     *   { 'user': 'fred',   'age': 30 },
     *   { 'user': 'barney', 'age': 34 }
     * ];
     *
     * _.sortBy(users, [function(o) { return o.user; }]);
     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
     *
     * _.sortBy(users, ['user', 'age']);
     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
     */
    var sortBy = baseRest(function(collection, iteratees) {
      if (collection == null) {
        return [];
      }
      var length = iteratees.length;
      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
        iteratees = [];
      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
        iteratees = [iteratees[0]];
      }
      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
    });

    /*------------------------------------------------------------------------*/

    /**
     * Gets the timestamp of the number of milliseconds that have elapsed since
     * the Unix epoch (1 January 1970 00:00:00 UTC).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Date
     * @returns {number} Returns the timestamp.
     * @example
     *
     * _.defer(function(stamp) {
     *   console.log(_.now() - stamp);
     * }, _.now());
     * // => Logs the number of milliseconds it took for the deferred invocation.
     */
    var now = ctxNow || function() {
      return root.Date.now();
    };

    /*------------------------------------------------------------------------*/

    /**
     * The opposite of `_.before`; this method creates a function that invokes
     * `func` once it's called `n` or more times.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {number} n The number of calls before `func` is invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var saves = ['profile', 'settings'];
     *
     * var done = _.after(saves.length, function() {
     *   console.log('done saving!');
     * });
     *
     * _.forEach(saves, function(type) {
     *   asyncSave({ 'type': type, 'complete': done });
     * });
     * // => Logs 'done saving!' after the two async saves have completed.
     */
    function after(n, func) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n < 1) {
          return func.apply(this, arguments);
        }
      };
    }

    /**
     * Creates a function that invokes `func`, with up to `n` arguments,
     * ignoring any additional arguments.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @param {number} [n=func.length] The arity cap.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
     * // => [6, 8, 10]
     */
    function ary(func, n, guard) {
      n = guard ? undefined : n;
      n = (func && n == null) ? func.length : n;
      return createWrap(func, WRAP_ARY_FLAG, undefined, undefined, undefined, undefined, n);
    }

    /**
     * Creates a function that invokes `func`, with the `this` binding and arguments
     * of the created function, while it's called less than `n` times. Subsequent
     * calls to the created function return the result of the last `func` invocation.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {number} n The number of calls at which `func` is no longer invoked.
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * jQuery(element).on('click', _.before(5, addContactToList));
     * // => Allows adding up to 4 contacts to the list.
     */
    function before(n, func) {
      var result;
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      n = toInteger(n);
      return function() {
        if (--n > 0) {
          result = func.apply(this, arguments);
        }
        if (n <= 1) {
          func = undefined;
        }
        return result;
      };
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of `thisArg`
     * and `partials` prepended to the arguments it receives.
     *
     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for partially applied arguments.
     *
     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
     * property of bound functions.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to bind.
     * @param {*} thisArg The `this` binding of `func`.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * function greet(greeting, punctuation) {
     *   return greeting + ' ' + this.user + punctuation;
     * }
     *
     * var object = { 'user': 'fred' };
     *
     * var bound = _.bind(greet, object, 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bind(greet, object, _, '!');
     * bound('hi');
     * // => 'hi fred!'
     */
    var bind = baseRest(function(func, thisArg, partials) {
      var bitmask = WRAP_BIND_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bind));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(func, bitmask, thisArg, partials, holders);
    });

    /**
     * Creates a function that invokes the method at `object[key]` with `partials`
     * prepended to the arguments it receives.
     *
     * This method differs from `_.bind` by allowing bound functions to reference
     * methods that may be redefined or don't yet exist. See
     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
     * for more details.
     *
     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Function
     * @param {Object} object The object to invoke the method on.
     * @param {string} key The key of the method.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new bound function.
     * @example
     *
     * var object = {
     *   'user': 'fred',
     *   'greet': function(greeting, punctuation) {
     *     return greeting + ' ' + this.user + punctuation;
     *   }
     * };
     *
     * var bound = _.bindKey(object, 'greet', 'hi');
     * bound('!');
     * // => 'hi fred!'
     *
     * object.greet = function(greeting, punctuation) {
     *   return greeting + 'ya ' + this.user + punctuation;
     * };
     *
     * bound('!');
     * // => 'hiya fred!'
     *
     * // Bound with placeholders.
     * var bound = _.bindKey(object, 'greet', _, '!');
     * bound('hi');
     * // => 'hiya fred!'
     */
    var bindKey = baseRest(function(object, key, partials) {
      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
      if (partials.length) {
        var holders = replaceHolders(partials, getHolder(bindKey));
        bitmask |= WRAP_PARTIAL_FLAG;
      }
      return createWrap(key, bitmask, object, partials, holders);
    });

    /**
     * Creates a function that accepts arguments of `func` and either invokes
     * `func` returning its result, if at least `arity` number of arguments have
     * been provided, or returns a function that accepts the remaining `func`
     * arguments, and so on. The arity of `func` may be specified if `func.length`
     * is not sufficient.
     *
     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
     * may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curry(abc);
     *
     * curried(1)(2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2)(3);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(1)(_, 3)(2);
     * // => [1, 2, 3]
     */
    function curry(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curry.placeholder;
      return result;
    }

    /**
     * This method is like `_.curry` except that arguments are applied to `func`
     * in the manner of `_.partialRight` instead of `_.partial`.
     *
     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for provided arguments.
     *
     * **Note:** This method doesn't set the "length" property of curried functions.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to curry.
     * @param {number} [arity=func.length] The arity of `func`.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the new curried function.
     * @example
     *
     * var abc = function(a, b, c) {
     *   return [a, b, c];
     * };
     *
     * var curried = _.curryRight(abc);
     *
     * curried(3)(2)(1);
     * // => [1, 2, 3]
     *
     * curried(2, 3)(1);
     * // => [1, 2, 3]
     *
     * curried(1, 2, 3);
     * // => [1, 2, 3]
     *
     * // Curried with placeholders.
     * curried(3)(1, _)(2);
     * // => [1, 2, 3]
     */
    function curryRight(func, arity, guard) {
      arity = guard ? undefined : arity;
      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined, undefined, undefined, undefined, undefined, arity);
      result.placeholder = curryRight.placeholder;
      return result;
    }

    /**
     * Creates a debounced function that delays invoking `func` until after `wait`
     * milliseconds have elapsed since the last time the debounced function was
     * invoked. The debounced function comes with a `cancel` method to cancel
     * delayed `func` invocations and a `flush` method to immediately invoke them.
     * Provide `options` to indicate whether `func` should be invoked on the
     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
     * with the last arguments provided to the debounced function. Subsequent
     * calls to the debounced function return the result of the last `func`
     * invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the debounced function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.debounce` and `_.throttle`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to debounce.
     * @param {number} [wait=0] The number of milliseconds to delay.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=false]
     *  Specify invoking on the leading edge of the timeout.
     * @param {number} [options.maxWait]
     *  The maximum time `func` is allowed to be delayed before it's invoked.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new debounced function.
     * @example
     *
     * // Avoid costly calculations while the window size is in flux.
     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
     *
     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
     * jQuery(element).on('click', _.debounce(sendMail, 300, {
     *   'leading': true,
     *   'trailing': false
     * }));
     *
     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
     * var source = new EventSource('/stream');
     * jQuery(source).on('message', debounced);
     *
     * // Cancel the trailing debounced invocation.
     * jQuery(window).on('popstate', debounced.cancel);
     */
    function debounce(func, wait, options) {
      var lastArgs,
          lastThis,
          maxWait,
          result,
          timerId,
          lastCallTime,
          lastInvokeTime = 0,
          leading = false,
          maxing = false,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      wait = toNumber(wait) || 0;
      if (isObject(options)) {
        leading = !!options.leading;
        maxing = 'maxWait' in options;
        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }

      function invokeFunc(time) {
        var args = lastArgs,
            thisArg = lastThis;

        lastArgs = lastThis = undefined;
        lastInvokeTime = time;
        result = func.apply(thisArg, args);
        return result;
      }

      function leadingEdge(time) {
        // Reset any `maxWait` timer.
        lastInvokeTime = time;
        // Start the timer for the trailing edge.
        timerId = setTimeout(timerExpired, wait);
        // Invoke the leading edge.
        return leading ? invokeFunc(time) : result;
      }

      function remainingWait(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime,
            timeWaiting = wait - timeSinceLastCall;

        return maxing
          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
          : timeWaiting;
      }

      function shouldInvoke(time) {
        var timeSinceLastCall = time - lastCallTime,
            timeSinceLastInvoke = time - lastInvokeTime;

        // Either this is the first call, activity has stopped and we're at the
        // trailing edge, the system time has gone backwards and we're treating
        // it as the trailing edge, or we've hit the `maxWait` limit.
        return (lastCallTime === undefined || (timeSinceLastCall >= wait) ||
          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
      }

      function timerExpired() {
        var time = now();
        if (shouldInvoke(time)) {
          return trailingEdge(time);
        }
        // Restart the timer.
        timerId = setTimeout(timerExpired, remainingWait(time));
      }

      function trailingEdge(time) {
        timerId = undefined;

        // Only invoke if we have `lastArgs` which means `func` has been
        // debounced at least once.
        if (trailing && lastArgs) {
          return invokeFunc(time);
        }
        lastArgs = lastThis = undefined;
        return result;
      }

      function cancel() {
        if (timerId !== undefined) {
          clearTimeout(timerId);
        }
        lastInvokeTime = 0;
        lastArgs = lastCallTime = lastThis = timerId = undefined;
      }

      function flush() {
        return timerId === undefined ? result : trailingEdge(now());
      }

      function debounced() {
        var time = now(),
            isInvoking = shouldInvoke(time);

        lastArgs = arguments;
        lastThis = this;
        lastCallTime = time;

        if (isInvoking) {
          if (timerId === undefined) {
            return leadingEdge(lastCallTime);
          }
          if (maxing) {
            // Handle invocations in a tight loop.
            clearTimeout(timerId);
            timerId = setTimeout(timerExpired, wait);
            return invokeFunc(lastCallTime);
          }
        }
        if (timerId === undefined) {
          timerId = setTimeout(timerExpired, wait);
        }
        return result;
      }
      debounced.cancel = cancel;
      debounced.flush = flush;
      return debounced;
    }

    /**
     * Defers invoking the `func` until the current call stack has cleared. Any
     * additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to defer.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.defer(function(text) {
     *   console.log(text);
     * }, 'deferred');
     * // => Logs 'deferred' after one millisecond.
     */
    var defer = baseRest(function(func, args) {
      return baseDelay(func, 1, args);
    });

    /**
     * Invokes `func` after `wait` milliseconds. Any additional arguments are
     * provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to delay.
     * @param {number} wait The number of milliseconds to delay invocation.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {number} Returns the timer id.
     * @example
     *
     * _.delay(function(text) {
     *   console.log(text);
     * }, 1000, 'later');
     * // => Logs 'later' after one second.
     */
    var delay = baseRest(function(func, wait, args) {
      return baseDelay(func, toNumber(wait) || 0, args);
    });

    /**
     * Creates a function that invokes `func` with arguments reversed.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to flip arguments for.
     * @returns {Function} Returns the new flipped function.
     * @example
     *
     * var flipped = _.flip(function() {
     *   return _.toArray(arguments);
     * });
     *
     * flipped('a', 'b', 'c', 'd');
     * // => ['d', 'c', 'b', 'a']
     */
    function flip(func) {
      return createWrap(func, WRAP_FLIP_FLAG);
    }

    /**
     * Creates a function that memoizes the result of `func`. If `resolver` is
     * provided, it determines the cache key for storing the result based on the
     * arguments provided to the memoized function. By default, the first argument
     * provided to the memoized function is used as the map cache key. The `func`
     * is invoked with the `this` binding of the memoized function.
     *
     * **Note:** The cache is exposed as the `cache` property on the memoized
     * function. Its creation may be customized by replacing the `_.memoize.Cache`
     * constructor with one whose instances implement the
     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to have its output memoized.
     * @param {Function} [resolver] The function to resolve the cache key.
     * @returns {Function} Returns the new memoized function.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     * var other = { 'c': 3, 'd': 4 };
     *
     * var values = _.memoize(_.values);
     * values(object);
     * // => [1, 2]
     *
     * values(other);
     * // => [3, 4]
     *
     * object.a = 2;
     * values(object);
     * // => [1, 2]
     *
     * // Modify the result cache.
     * values.cache.set(object, ['a', 'b']);
     * values(object);
     * // => ['a', 'b']
     *
     * // Replace `_.memoize.Cache`.
     * _.memoize.Cache = WeakMap;
     */
    function memoize(func, resolver) {
      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      var memoized = function() {
        var args = arguments,
            key = resolver ? resolver.apply(this, args) : args[0],
            cache = memoized.cache;

        if (cache.has(key)) {
          return cache.get(key);
        }
        var result = func.apply(this, args);
        memoized.cache = cache.set(key, result) || cache;
        return result;
      };
      memoized.cache = new (memoize.Cache || MapCache);
      return memoized;
    }

    // Expose `MapCache`.
    memoize.Cache = MapCache;

    /**
     * Creates a function that negates the result of the predicate `func`. The
     * `func` predicate is invoked with the `this` binding and arguments of the
     * created function.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} predicate The predicate to negate.
     * @returns {Function} Returns the new negated function.
     * @example
     *
     * function isEven(n) {
     *   return n % 2 == 0;
     * }
     *
     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
     * // => [1, 3, 5]
     */
    function negate(predicate) {
      if (typeof predicate != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      return function() {
        var args = arguments;
        switch (args.length) {
          case 0: return !predicate.call(this);
          case 1: return !predicate.call(this, args[0]);
          case 2: return !predicate.call(this, args[0], args[1]);
          case 3: return !predicate.call(this, args[0], args[1], args[2]);
        }
        return !predicate.apply(this, args);
      };
    }

    /**
     * Creates a function that is restricted to invoking `func` once. Repeat calls
     * to the function return the value of the first invocation. The `func` is
     * invoked with the `this` binding and arguments of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to restrict.
     * @returns {Function} Returns the new restricted function.
     * @example
     *
     * var initialize = _.once(createApplication);
     * initialize();
     * initialize();
     * // => `createApplication` is invoked once
     */
    function once(func) {
      return before(2, func);
    }

    /**
     * Creates a function that invokes `func` with its arguments transformed.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Function
     * @param {Function} func The function to wrap.
     * @param {...(Function|Function[])} [transforms=[_.identity]]
     *  The argument transforms.
     * @returns {Function} Returns the new function.
     * @example
     *
     * function doubled(n) {
     *   return n * 2;
     * }
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var func = _.overArgs(function(x, y) {
     *   return [x, y];
     * }, [square, doubled]);
     *
     * func(9, 3);
     * // => [81, 6]
     *
     * func(10, 5);
     * // => [100, 10]
     */
    var overArgs = castRest(function(func, transforms) {
      transforms = (transforms.length == 1 && isArray(transforms[0]))
        ? arrayMap(transforms[0], baseUnary(getIteratee()))
        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

      var funcsLength = transforms.length;
      return baseRest(function(args) {
        var index = -1,
            length = nativeMin(args.length, funcsLength);

        while (++index < length) {
          args[index] = transforms[index].call(this, args[index]);
        }
        return apply(func, this, args);
      });
    });

    /**
     * Creates a function that invokes `func` with `partials` prepended to the
     * arguments it receives. This method is like `_.bind` except it does **not**
     * alter the `this` binding.
     *
     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 0.2.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var sayHelloTo = _.partial(greet, 'hello');
     * sayHelloTo('fred');
     * // => 'hello fred'
     *
     * // Partially applied with placeholders.
     * var greetFred = _.partial(greet, _, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     */
    var partial = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partial));
      return createWrap(func, WRAP_PARTIAL_FLAG, undefined, partials, holders);
    });

    /**
     * This method is like `_.partial` except that partially applied arguments
     * are appended to the arguments it receives.
     *
     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
     * builds, may be used as a placeholder for partially applied arguments.
     *
     * **Note:** This method doesn't set the "length" property of partially
     * applied functions.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Function
     * @param {Function} func The function to partially apply arguments to.
     * @param {...*} [partials] The arguments to be partially applied.
     * @returns {Function} Returns the new partially applied function.
     * @example
     *
     * function greet(greeting, name) {
     *   return greeting + ' ' + name;
     * }
     *
     * var greetFred = _.partialRight(greet, 'fred');
     * greetFred('hi');
     * // => 'hi fred'
     *
     * // Partially applied with placeholders.
     * var sayHelloTo = _.partialRight(greet, 'hello', _);
     * sayHelloTo('fred');
     * // => 'hello fred'
     */
    var partialRight = baseRest(function(func, partials) {
      var holders = replaceHolders(partials, getHolder(partialRight));
      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined, partials, holders);
    });

    /**
     * Creates a function that invokes `func` with arguments arranged according
     * to the specified `indexes` where the argument value at the first index is
     * provided as the first argument, the argument value at the second index is
     * provided as the second argument, and so on.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Function
     * @param {Function} func The function to rearrange arguments for.
     * @param {...(number|number[])} indexes The arranged argument indexes.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var rearged = _.rearg(function(a, b, c) {
     *   return [a, b, c];
     * }, [2, 0, 1]);
     *
     * rearged('b', 'c', 'a')
     * // => ['a', 'b', 'c']
     */
    var rearg = flatRest(function(func, indexes) {
      return createWrap(func, WRAP_REARG_FLAG, undefined, undefined, undefined, indexes);
    });

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * created function and arguments from `start` and beyond provided as
     * an array.
     *
     * **Note:** This method is based on the
     * [rest parameter](https://mdn.io/rest_parameters).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to apply a rest parameter to.
     * @param {number} [start=func.length-1] The start position of the rest parameter.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.rest(function(what, names) {
     *   return what + ' ' + _.initial(names).join(', ') +
     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
     * });
     *
     * say('hello', 'fred', 'barney', 'pebbles');
     * // => 'hello fred, barney, & pebbles'
     */
    function rest(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start === undefined ? start : toInteger(start);
      return baseRest(func, start);
    }

    /**
     * Creates a function that invokes `func` with the `this` binding of the
     * create function and an array of arguments much like
     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
     *
     * **Note:** This method is based on the
     * [spread operator](https://mdn.io/spread_operator).
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Function
     * @param {Function} func The function to spread arguments over.
     * @param {number} [start=0] The start position of the spread.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var say = _.spread(function(who, what) {
     *   return who + ' says ' + what;
     * });
     *
     * say(['fred', 'hello']);
     * // => 'fred says hello'
     *
     * var numbers = Promise.all([
     *   Promise.resolve(40),
     *   Promise.resolve(36)
     * ]);
     *
     * numbers.then(_.spread(function(x, y) {
     *   return x + y;
     * }));
     * // => a Promise of 76
     */
    function spread(func, start) {
      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      start = start == null ? 0 : nativeMax(toInteger(start), 0);
      return baseRest(function(args) {
        var array = args[start],
            otherArgs = castSlice(args, 0, start);

        if (array) {
          arrayPush(otherArgs, array);
        }
        return apply(func, this, otherArgs);
      });
    }

    /**
     * Creates a throttled function that only invokes `func` at most once per
     * every `wait` milliseconds. The throttled function comes with a `cancel`
     * method to cancel delayed `func` invocations and a `flush` method to
     * immediately invoke them. Provide `options` to indicate whether `func`
     * should be invoked on the leading and/or trailing edge of the `wait`
     * timeout. The `func` is invoked with the last arguments provided to the
     * throttled function. Subsequent calls to the throttled function return the
     * result of the last `func` invocation.
     *
     * **Note:** If `leading` and `trailing` options are `true`, `func` is
     * invoked on the trailing edge of the timeout only if the throttled function
     * is invoked more than once during the `wait` timeout.
     *
     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
     *
     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
     * for details over the differences between `_.throttle` and `_.debounce`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {Function} func The function to throttle.
     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.leading=true]
     *  Specify invoking on the leading edge of the timeout.
     * @param {boolean} [options.trailing=true]
     *  Specify invoking on the trailing edge of the timeout.
     * @returns {Function} Returns the new throttled function.
     * @example
     *
     * // Avoid excessively updating the position while scrolling.
     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
     *
     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
     * jQuery(element).on('click', throttled);
     *
     * // Cancel the trailing throttled invocation.
     * jQuery(window).on('popstate', throttled.cancel);
     */
    function throttle(func, wait, options) {
      var leading = true,
          trailing = true;

      if (typeof func != 'function') {
        throw new TypeError(FUNC_ERROR_TEXT);
      }
      if (isObject(options)) {
        leading = 'leading' in options ? !!options.leading : leading;
        trailing = 'trailing' in options ? !!options.trailing : trailing;
      }
      return debounce(func, wait, {
        'leading': leading,
        'maxWait': wait,
        'trailing': trailing
      });
    }

    /**
     * Creates a function that accepts up to one argument, ignoring any
     * additional arguments.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Function
     * @param {Function} func The function to cap arguments for.
     * @returns {Function} Returns the new capped function.
     * @example
     *
     * _.map(['6', '8', '10'], _.unary(parseInt));
     * // => [6, 8, 10]
     */
    function unary(func) {
      return ary(func, 1);
    }

    /**
     * Creates a function that provides `value` to `wrapper` as its first
     * argument. Any additional arguments provided to the function are appended
     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
     * binding of the created function.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Function
     * @param {*} value The value to wrap.
     * @param {Function} [wrapper=identity] The wrapper function.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var p = _.wrap(_.escape, function(func, text) {
     *   return '<p>' + func(text) + '</p>';
     * });
     *
     * p('fred, barney, & pebbles');
     * // => '<p>fred, barney, &amp; pebbles</p>'
     */
    function wrap(value, wrapper) {
      return partial(castFunction(wrapper), value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Casts `value` as an array if it's not one.
     *
     * @static
     * @memberOf _
     * @since 4.4.0
     * @category Lang
     * @param {*} value The value to inspect.
     * @returns {Array} Returns the cast array.
     * @example
     *
     * _.castArray(1);
     * // => [1]
     *
     * _.castArray({ 'a': 1 });
     * // => [{ 'a': 1 }]
     *
     * _.castArray('abc');
     * // => ['abc']
     *
     * _.castArray(null);
     * // => [null]
     *
     * _.castArray(undefined);
     * // => [undefined]
     *
     * _.castArray();
     * // => []
     *
     * var array = [1, 2, 3];
     * console.log(_.castArray(array) === array);
     * // => true
     */
    function castArray() {
      if (!arguments.length) {
        return [];
      }
      var value = arguments[0];
      return isArray(value) ? value : [value];
    }

    /**
     * Creates a shallow clone of `value`.
     *
     * **Note:** This method is loosely based on the
     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
     * and supports cloning arrays, array buffers, booleans, date objects, maps,
     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
     * arrays. The own enumerable properties of `arguments` objects are cloned
     * as plain objects. An empty object is returned for uncloneable values such
     * as error objects, functions, DOM nodes, and WeakMaps.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to clone.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeep
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var shallow = _.clone(objects);
     * console.log(shallow[0] === objects[0]);
     * // => true
     */
    function clone(value) {
      return baseClone(value, CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.clone` except that it accepts `customizer` which
     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
     * cloning is handled by the method instead. The `customizer` is invoked with
     * up to four arguments; (value [, index|key, object, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the cloned value.
     * @see _.cloneDeepWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(false);
     *   }
     * }
     *
     * var el = _.cloneWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 0
     */
    function cloneWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * This method is like `_.clone` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @returns {*} Returns the deep cloned value.
     * @see _.clone
     * @example
     *
     * var objects = [{ 'a': 1 }, { 'b': 2 }];
     *
     * var deep = _.cloneDeep(objects);
     * console.log(deep[0] === objects[0]);
     * // => false
     */
    function cloneDeep(value) {
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
    }

    /**
     * This method is like `_.cloneWith` except that it recursively clones `value`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to recursively clone.
     * @param {Function} [customizer] The function to customize cloning.
     * @returns {*} Returns the deep cloned value.
     * @see _.cloneWith
     * @example
     *
     * function customizer(value) {
     *   if (_.isElement(value)) {
     *     return value.cloneNode(true);
     *   }
     * }
     *
     * var el = _.cloneDeepWith(document.body, customizer);
     *
     * console.log(el === document.body);
     * // => false
     * console.log(el.nodeName);
     * // => 'BODY'
     * console.log(el.childNodes.length);
     * // => 20
     */
    function cloneDeepWith(value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
    }

    /**
     * Checks if `object` conforms to `source` by invoking the predicate
     * properties of `source` with the corresponding property values of `object`.
     *
     * **Note:** This method is equivalent to `_.conforms` when `source` is
     * partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property predicates to conform to.
     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
     * // => true
     *
     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
     * // => false
     */
    function conformsTo(object, source) {
      return source == null || baseConformsTo(object, source, keys(source));
    }

    /**
     * Performs a
     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
     * comparison between two values to determine if they are equivalent.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.eq(object, object);
     * // => true
     *
     * _.eq(object, other);
     * // => false
     *
     * _.eq('a', 'a');
     * // => true
     *
     * _.eq('a', Object('a'));
     * // => false
     *
     * _.eq(NaN, NaN);
     * // => true
     */
    function eq(value, other) {
      return value === other || (value !== value && other !== other);
    }

    /**
     * Checks if `value` is greater than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than `other`,
     *  else `false`.
     * @see _.lt
     * @example
     *
     * _.gt(3, 1);
     * // => true
     *
     * _.gt(3, 3);
     * // => false
     *
     * _.gt(1, 3);
     * // => false
     */
    var gt = createRelationalOperation(baseGt);

    /**
     * Checks if `value` is greater than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is greater than or equal to
     *  `other`, else `false`.
     * @see _.lte
     * @example
     *
     * _.gte(3, 1);
     * // => true
     *
     * _.gte(3, 3);
     * // => true
     *
     * _.gte(1, 3);
     * // => false
     */
    var gte = createRelationalOperation(function(value, other) {
      return value >= other;
    });

    /**
     * Checks if `value` is likely an `arguments` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
     *  else `false`.
     * @example
     *
     * _.isArguments(function() { return arguments; }());
     * // => true
     *
     * _.isArguments([1, 2, 3]);
     * // => false
     */
    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
        !propertyIsEnumerable.call(value, 'callee');
    };

    /**
     * Checks if `value` is classified as an `Array` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
     * @example
     *
     * _.isArray([1, 2, 3]);
     * // => true
     *
     * _.isArray(document.body.children);
     * // => false
     *
     * _.isArray('abc');
     * // => false
     *
     * _.isArray(_.noop);
     * // => false
     */
    var isArray = Array.isArray;

    /**
     * Checks if `value` is classified as an `ArrayBuffer` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
     * @example
     *
     * _.isArrayBuffer(new ArrayBuffer(2));
     * // => true
     *
     * _.isArrayBuffer(new Array(2));
     * // => false
     */
    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

    /**
     * Checks if `value` is array-like. A value is considered array-like if it's
     * not a function and has a `value.length` that's an integer greater than or
     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
     * @example
     *
     * _.isArrayLike([1, 2, 3]);
     * // => true
     *
     * _.isArrayLike(document.body.children);
     * // => true
     *
     * _.isArrayLike('abc');
     * // => true
     *
     * _.isArrayLike(_.noop);
     * // => false
     */
    function isArrayLike(value) {
      return value != null && isLength(value.length) && !isFunction(value);
    }

    /**
     * This method is like `_.isArrayLike` except that it also checks if `value`
     * is an object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an array-like object,
     *  else `false`.
     * @example
     *
     * _.isArrayLikeObject([1, 2, 3]);
     * // => true
     *
     * _.isArrayLikeObject(document.body.children);
     * // => true
     *
     * _.isArrayLikeObject('abc');
     * // => false
     *
     * _.isArrayLikeObject(_.noop);
     * // => false
     */
    function isArrayLikeObject(value) {
      return isObjectLike(value) && isArrayLike(value);
    }

    /**
     * Checks if `value` is classified as a boolean primitive or object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
     * @example
     *
     * _.isBoolean(false);
     * // => true
     *
     * _.isBoolean(null);
     * // => false
     */
    function isBoolean(value) {
      return value === true || value === false ||
        (isObjectLike(value) && baseGetTag(value) == boolTag);
    }

    /**
     * Checks if `value` is a buffer.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
     * @example
     *
     * _.isBuffer(new Buffer(2));
     * // => true
     *
     * _.isBuffer(new Uint8Array(2));
     * // => false
     */
    var isBuffer = nativeIsBuffer || stubFalse;

    /**
     * Checks if `value` is classified as a `Date` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
     * @example
     *
     * _.isDate(new Date);
     * // => true
     *
     * _.isDate('Mon April 23 2012');
     * // => false
     */
    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

    /**
     * Checks if `value` is likely a DOM element.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
     * @example
     *
     * _.isElement(document.body);
     * // => true
     *
     * _.isElement('<body>');
     * // => false
     */
    function isElement(value) {
      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
    }

    /**
     * Checks if `value` is an empty object, collection, map, or set.
     *
     * Objects are considered empty if they have no own enumerable string keyed
     * properties.
     *
     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
     * jQuery-like collections are considered empty if they have a `length` of `0`.
     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
     * @example
     *
     * _.isEmpty(null);
     * // => true
     *
     * _.isEmpty(true);
     * // => true
     *
     * _.isEmpty(1);
     * // => true
     *
     * _.isEmpty([1, 2, 3]);
     * // => false
     *
     * _.isEmpty({ 'a': 1 });
     * // => false
     */
    function isEmpty(value) {
      if (value == null) {
        return true;
      }
      if (isArrayLike(value) &&
          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
        return !value.length;
      }
      var tag = getTag(value);
      if (tag == mapTag || tag == setTag) {
        return !value.size;
      }
      if (isPrototype(value)) {
        return !baseKeys(value).length;
      }
      for (var key in value) {
        if (hasOwnProperty.call(value, key)) {
          return false;
        }
      }
      return true;
    }

    /**
     * Performs a deep comparison between two values to determine if they are
     * equivalent.
     *
     * **Note:** This method supports comparing arrays, array buffers, booleans,
     * date objects, error objects, maps, numbers, `Object` objects, regexes,
     * sets, strings, symbols, and typed arrays. `Object` objects are compared
     * by their own, not inherited, enumerable properties. Functions and DOM
     * nodes are compared by strict equality, i.e. `===`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * var object = { 'a': 1 };
     * var other = { 'a': 1 };
     *
     * _.isEqual(object, other);
     * // => true
     *
     * object === other;
     * // => false
     */
    function isEqual(value, other) {
      return baseIsEqual(value, other);
    }

    /**
     * This method is like `_.isEqual` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with up to
     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, othValue) {
     *   if (isGreeting(objValue) && isGreeting(othValue)) {
     *     return true;
     *   }
     * }
     *
     * var array = ['hello', 'goodbye'];
     * var other = ['hi', 'goodbye'];
     *
     * _.isEqualWith(array, other, customizer);
     * // => true
     */
    function isEqualWith(value, other, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      var result = customizer ? customizer(value, other) : undefined;
      return result === undefined ? baseIsEqual(value, other, undefined, customizer) : !!result;
    }

    /**
     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
     * `SyntaxError`, `TypeError`, or `URIError` object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
     * @example
     *
     * _.isError(new Error);
     * // => true
     *
     * _.isError(Error);
     * // => false
     */
    function isError(value) {
      if (!isObjectLike(value)) {
        return false;
      }
      var tag = baseGetTag(value);
      return tag == errorTag || tag == domExcTag ||
        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
    }

    /**
     * Checks if `value` is a finite primitive number.
     *
     * **Note:** This method is based on
     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
     * @example
     *
     * _.isFinite(3);
     * // => true
     *
     * _.isFinite(Number.MIN_VALUE);
     * // => true
     *
     * _.isFinite(Infinity);
     * // => false
     *
     * _.isFinite('3');
     * // => false
     */
    function isFinite(value) {
      return typeof value == 'number' && nativeIsFinite(value);
    }

    /**
     * Checks if `value` is classified as a `Function` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
     * @example
     *
     * _.isFunction(_);
     * // => true
     *
     * _.isFunction(/abc/);
     * // => false
     */
    function isFunction(value) {
      if (!isObject(value)) {
        return false;
      }
      // The use of `Object#toString` avoids issues with the `typeof` operator
      // in Safari 9 which returns 'object' for typed arrays and other constructors.
      var tag = baseGetTag(value);
      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
    }

    /**
     * Checks if `value` is an integer.
     *
     * **Note:** This method is based on
     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
     * @example
     *
     * _.isInteger(3);
     * // => true
     *
     * _.isInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isInteger(Infinity);
     * // => false
     *
     * _.isInteger('3');
     * // => false
     */
    function isInteger(value) {
      return typeof value == 'number' && value == toInteger(value);
    }

    /**
     * Checks if `value` is a valid array-like length.
     *
     * **Note:** This method is loosely based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
     * @example
     *
     * _.isLength(3);
     * // => true
     *
     * _.isLength(Number.MIN_VALUE);
     * // => false
     *
     * _.isLength(Infinity);
     * // => false
     *
     * _.isLength('3');
     * // => false
     */
    function isLength(value) {
      return typeof value == 'number' &&
        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is the
     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
     * @example
     *
     * _.isObject({});
     * // => true
     *
     * _.isObject([1, 2, 3]);
     * // => true
     *
     * _.isObject(_.noop);
     * // => true
     *
     * _.isObject(null);
     * // => false
     */
    function isObject(value) {
      var type = typeof value;
      return value != null && (type == 'object' || type == 'function');
    }

    /**
     * Checks if `value` is object-like. A value is object-like if it's not `null`
     * and has a `typeof` result of "object".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
     * @example
     *
     * _.isObjectLike({});
     * // => true
     *
     * _.isObjectLike([1, 2, 3]);
     * // => true
     *
     * _.isObjectLike(_.noop);
     * // => false
     *
     * _.isObjectLike(null);
     * // => false
     */
    function isObjectLike(value) {
      return value != null && typeof value == 'object';
    }

    /**
     * Checks if `value` is classified as a `Map` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
     * @example
     *
     * _.isMap(new Map);
     * // => true
     *
     * _.isMap(new WeakMap);
     * // => false
     */
    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

    /**
     * Performs a partial deep comparison between `object` and `source` to
     * determine if `object` contains equivalent property values.
     *
     * **Note:** This method is equivalent to `_.matches` when `source` is
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * var object = { 'a': 1, 'b': 2 };
     *
     * _.isMatch(object, { 'b': 2 });
     * // => true
     *
     * _.isMatch(object, { 'b': 1 });
     * // => false
     */
    function isMatch(object, source) {
      return object === source || baseIsMatch(object, source, getMatchData(source));
    }

    /**
     * This method is like `_.isMatch` except that it accepts `customizer` which
     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
     * are handled by the method instead. The `customizer` is invoked with five
     * arguments: (objValue, srcValue, index|key, object, source).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {Object} object The object to inspect.
     * @param {Object} source The object of property values to match.
     * @param {Function} [customizer] The function to customize comparisons.
     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
     * @example
     *
     * function isGreeting(value) {
     *   return /^h(?:i|ello)$/.test(value);
     * }
     *
     * function customizer(objValue, srcValue) {
     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
     *     return true;
     *   }
     * }
     *
     * var object = { 'greeting': 'hello' };
     * var source = { 'greeting': 'hi' };
     *
     * _.isMatchWith(object, source, customizer);
     * // => true
     */
    function isMatchWith(object, source, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return baseIsMatch(object, source, getMatchData(source), customizer);
    }

    /**
     * Checks if `value` is `NaN`.
     *
     * **Note:** This method is based on
     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
     * `undefined` and other non-number values.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
     * @example
     *
     * _.isNaN(NaN);
     * // => true
     *
     * _.isNaN(new Number(NaN));
     * // => true
     *
     * isNaN(undefined);
     * // => true
     *
     * _.isNaN(undefined);
     * // => false
     */
    function isNaN(value) {
      // An `NaN` primitive is the only value that is not equal to itself.
      // Perform the `toStringTag` check first to avoid errors with some
      // ActiveX objects in IE.
      return isNumber(value) && value != +value;
    }

    /**
     * Checks if `value` is a pristine native function.
     *
     * **Note:** This method can't reliably detect native functions in the presence
     * of the core-js package because core-js circumvents this kind of detection.
     * Despite multiple requests, the core-js maintainer has made it clear: any
     * attempt to fix the detection will be obstructed. As a result, we're left
     * with little choice but to throw an error. Unfortunately, this also affects
     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
     * which rely on core-js.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a native function,
     *  else `false`.
     * @example
     *
     * _.isNative(Array.prototype.push);
     * // => true
     *
     * _.isNative(_);
     * // => false
     */
    function isNative(value) {
      if (isMaskable(value)) {
        throw new Error(CORE_ERROR_TEXT);
      }
      return baseIsNative(value);
    }

    /**
     * Checks if `value` is `null`.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
     * @example
     *
     * _.isNull(null);
     * // => true
     *
     * _.isNull(void 0);
     * // => false
     */
    function isNull(value) {
      return value === null;
    }

    /**
     * Checks if `value` is `null` or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
     * @example
     *
     * _.isNil(null);
     * // => true
     *
     * _.isNil(void 0);
     * // => true
     *
     * _.isNil(NaN);
     * // => false
     */
    function isNil(value) {
      return value == null;
    }

    /**
     * Checks if `value` is classified as a `Number` primitive or object.
     *
     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
     * classified as numbers, use the `_.isFinite` method.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
     * @example
     *
     * _.isNumber(3);
     * // => true
     *
     * _.isNumber(Number.MIN_VALUE);
     * // => true
     *
     * _.isNumber(Infinity);
     * // => true
     *
     * _.isNumber('3');
     * // => false
     */
    function isNumber(value) {
      return typeof value == 'number' ||
        (isObjectLike(value) && baseGetTag(value) == numberTag);
    }

    /**
     * Checks if `value` is a plain object, that is, an object created by the
     * `Object` constructor or one with a `[[Prototype]]` of `null`.
     *
     * @static
     * @memberOf _
     * @since 0.8.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * _.isPlainObject(new Foo);
     * // => false
     *
     * _.isPlainObject([1, 2, 3]);
     * // => false
     *
     * _.isPlainObject({ 'x': 0, 'y': 0 });
     * // => true
     *
     * _.isPlainObject(Object.create(null));
     * // => true
     */
    function isPlainObject(value) {
      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
        return false;
      }
      var proto = getPrototype(value);
      if (proto === null) {
        return true;
      }
      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
        funcToString.call(Ctor) == objectCtorString;
    }

    /**
     * Checks if `value` is classified as a `RegExp` object.
     *
     * @static
     * @memberOf _
     * @since 0.1.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
     * @example
     *
     * _.isRegExp(/abc/);
     * // => true
     *
     * _.isRegExp('/abc/');
     * // => false
     */
    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

    /**
     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
     * double precision number which isn't the result of a rounded unsafe integer.
     *
     * **Note:** This method is based on
     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
     * @example
     *
     * _.isSafeInteger(3);
     * // => true
     *
     * _.isSafeInteger(Number.MIN_VALUE);
     * // => false
     *
     * _.isSafeInteger(Infinity);
     * // => false
     *
     * _.isSafeInteger('3');
     * // => false
     */
    function isSafeInteger(value) {
      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
    }

    /**
     * Checks if `value` is classified as a `Set` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
     * @example
     *
     * _.isSet(new Set);
     * // => true
     *
     * _.isSet(new WeakSet);
     * // => false
     */
    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

    /**
     * Checks if `value` is classified as a `String` primitive or object.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
     * @example
     *
     * _.isString('abc');
     * // => true
     *
     * _.isString(1);
     * // => false
     */
    function isString(value) {
      return typeof value == 'string' ||
        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
    }

    /**
     * Checks if `value` is classified as a `Symbol` primitive or object.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
     * @example
     *
     * _.isSymbol(Symbol.iterator);
     * // => true
     *
     * _.isSymbol('abc');
     * // => false
     */
    function isSymbol(value) {
      return typeof value == 'symbol' ||
        (isObjectLike(value) && baseGetTag(value) == symbolTag);
    }

    /**
     * Checks if `value` is classified as a typed array.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
     * @example
     *
     * _.isTypedArray(new Uint8Array);
     * // => true
     *
     * _.isTypedArray([]);
     * // => false
     */
    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

    /**
     * Checks if `value` is `undefined`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
     * @example
     *
     * _.isUndefined(void 0);
     * // => true
     *
     * _.isUndefined(null);
     * // => false
     */
    function isUndefined(value) {
      return value === undefined;
    }

    /**
     * Checks if `value` is classified as a `WeakMap` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
     * @example
     *
     * _.isWeakMap(new WeakMap);
     * // => true
     *
     * _.isWeakMap(new Map);
     * // => false
     */
    function isWeakMap(value) {
      return isObjectLike(value) && getTag(value) == weakMapTag;
    }

    /**
     * Checks if `value` is classified as a `WeakSet` object.
     *
     * @static
     * @memberOf _
     * @since 4.3.0
     * @category Lang
     * @param {*} value The value to check.
     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
     * @example
     *
     * _.isWeakSet(new WeakSet);
     * // => true
     *
     * _.isWeakSet(new Set);
     * // => false
     */
    function isWeakSet(value) {
      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
    }

    /**
     * Checks if `value` is less than `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than `other`,
     *  else `false`.
     * @see _.gt
     * @example
     *
     * _.lt(1, 3);
     * // => true
     *
     * _.lt(3, 3);
     * // => false
     *
     * _.lt(3, 1);
     * // => false
     */
    var lt = createRelationalOperation(baseLt);

    /**
     * Checks if `value` is less than or equal to `other`.
     *
     * @static
     * @memberOf _
     * @since 3.9.0
     * @category Lang
     * @param {*} value The value to compare.
     * @param {*} other The other value to compare.
     * @returns {boolean} Returns `true` if `value` is less than or equal to
     *  `other`, else `false`.
     * @see _.gte
     * @example
     *
     * _.lte(1, 3);
     * // => true
     *
     * _.lte(3, 3);
     * // => true
     *
     * _.lte(3, 1);
     * // => false
     */
    var lte = createRelationalOperation(function(value, other) {
      return value <= other;
    });

    /**
     * Converts `value` to an array.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Array} Returns the converted array.
     * @example
     *
     * _.toArray({ 'a': 1, 'b': 2 });
     * // => [1, 2]
     *
     * _.toArray('abc');
     * // => ['a', 'b', 'c']
     *
     * _.toArray(1);
     * // => []
     *
     * _.toArray(null);
     * // => []
     */
    function toArray(value) {
      if (!value) {
        return [];
      }
      if (isArrayLike(value)) {
        return isString(value) ? stringToArray(value) : copyArray(value);
      }
      if (symIterator && value[symIterator]) {
        return iteratorToArray(value[symIterator]());
      }
      var tag = getTag(value),
          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

      return func(value);
    }

    /**
     * Converts `value` to a finite number.
     *
     * @static
     * @memberOf _
     * @since 4.12.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted number.
     * @example
     *
     * _.toFinite(3.2);
     * // => 3.2
     *
     * _.toFinite(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toFinite(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toFinite('3.2');
     * // => 3.2
     */
    function toFinite(value) {
      if (!value) {
        return value === 0 ? value : 0;
      }
      value = toNumber(value);
      if (value === INFINITY || value === -INFINITY) {
        var sign = (value < 0 ? -1 : 1);
        return sign * MAX_INTEGER;
      }
      return value === value ? value : 0;
    }

    /**
     * Converts `value` to an integer.
     *
     * **Note:** This method is loosely based on
     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toInteger(3.2);
     * // => 3
     *
     * _.toInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toInteger(Infinity);
     * // => 1.7976931348623157e+308
     *
     * _.toInteger('3.2');
     * // => 3
     */
    function toInteger(value) {
      var result = toFinite(value),
          remainder = result % 1;

      return result === result ? (remainder ? result - remainder : result) : 0;
    }

    /**
     * Converts `value` to an integer suitable for use as the length of an
     * array-like object.
     *
     * **Note:** This method is based on
     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toLength(3.2);
     * // => 3
     *
     * _.toLength(Number.MIN_VALUE);
     * // => 0
     *
     * _.toLength(Infinity);
     * // => 4294967295
     *
     * _.toLength('3.2');
     * // => 3
     */
    function toLength(value) {
      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
    }

    /**
     * Converts `value` to a number.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to process.
     * @returns {number} Returns the number.
     * @example
     *
     * _.toNumber(3.2);
     * // => 3.2
     *
     * _.toNumber(Number.MIN_VALUE);
     * // => 5e-324
     *
     * _.toNumber(Infinity);
     * // => Infinity
     *
     * _.toNumber('3.2');
     * // => 3.2
     */
    function toNumber(value) {
      if (typeof value == 'number') {
        return value;
      }
      if (isSymbol(value)) {
        return NAN;
      }
      if (isObject(value)) {
        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
        value = isObject(other) ? (other + '') : other;
      }
      if (typeof value != 'string') {
        return value === 0 ? value : +value;
      }
      value = baseTrim(value);
      var isBinary = reIsBinary.test(value);
      return (isBinary || reIsOctal.test(value))
        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
        : (reIsBadHex.test(value) ? NAN : +value);
    }

    /**
     * Converts `value` to a plain object flattening inherited enumerable string
     * keyed properties of `value` to own properties of the plain object.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {Object} Returns the converted plain object.
     * @example
     *
     * function Foo() {
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.assign({ 'a': 1 }, new Foo);
     * // => { 'a': 1, 'b': 2 }
     *
     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
     * // => { 'a': 1, 'b': 2, 'c': 3 }
     */
    function toPlainObject(value) {
      return copyObject(value, keysIn(value));
    }

    /**
     * Converts `value` to a safe integer. A safe integer can be compared and
     * represented correctly.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.toSafeInteger(3.2);
     * // => 3
     *
     * _.toSafeInteger(Number.MIN_VALUE);
     * // => 0
     *
     * _.toSafeInteger(Infinity);
     * // => 9007199254740991
     *
     * _.toSafeInteger('3.2');
     * // => 3
     */
    function toSafeInteger(value) {
      return value
        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
        : (value === 0 ? value : 0);
    }

    /**
     * Converts `value` to a string. An empty string is returned for `null`
     * and `undefined` values. The sign of `-0` is preserved.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Lang
     * @param {*} value The value to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.toString(null);
     * // => ''
     *
     * _.toString(-0);
     * // => '-0'
     *
     * _.toString([1, 2, 3]);
     * // => '1,2,3'
     */
    function toString(value) {
      return value == null ? '' : baseToString(value);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Assigns own enumerable string keyed properties of source objects to the
     * destination object. Source objects are applied from left to right.
     * Subsequent sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object` and is loosely based on
     * [`Object.assign`](https://mdn.io/Object/assign).
     *
     * @static
     * @memberOf _
     * @since 0.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assignIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assign({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'c': 3 }
     */
    var assign = createAssigner(function(object, source) {
      if (isPrototype(source) || isArrayLike(source)) {
        copyObject(source, keys(source), object);
        return;
      }
      for (var key in source) {
        if (hasOwnProperty.call(source, key)) {
          assignValue(object, key, source[key]);
        }
      }
    });

    /**
     * This method is like `_.assign` except that it iterates over own and
     * inherited source properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extend
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.assign
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     * }
     *
     * function Bar() {
     *   this.c = 3;
     * }
     *
     * Foo.prototype.b = 2;
     * Bar.prototype.d = 4;
     *
     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
     */
    var assignIn = createAssigner(function(object, source) {
      copyObject(source, keysIn(source), object);
    });

    /**
     * This method is like `_.assignIn` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias extendWith
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignInWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keysIn(source), object, customizer);
    });

    /**
     * This method is like `_.assign` except that it accepts `customizer`
     * which is invoked to produce the assigned values. If `customizer` returns
     * `undefined`, assignment is handled by the method instead. The `customizer`
     * is invoked with five arguments: (objValue, srcValue, key, object, source).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @see _.assignInWith
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   return _.isUndefined(objValue) ? srcValue : objValue;
     * }
     *
     * var defaults = _.partialRight(_.assignWith, customizer);
     *
     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
      copyObject(source, keys(source), object, customizer);
    });

    /**
     * Creates an array of values corresponding to `paths` of `object`.
     *
     * @static
     * @memberOf _
     * @since 1.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Array} Returns the picked values.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
     *
     * _.at(object, ['a[0].b.c', 'a[1]']);
     * // => [3, 4]
     */
    var at = flatRest(baseAt);

    /**
     * Creates an object that inherits from the `prototype` object. If a
     * `properties` object is given, its own enumerable string keyed properties
     * are assigned to the created object.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Object
     * @param {Object} prototype The object to inherit from.
     * @param {Object} [properties] The properties to assign to the object.
     * @returns {Object} Returns the new object.
     * @example
     *
     * function Shape() {
     *   this.x = 0;
     *   this.y = 0;
     * }
     *
     * function Circle() {
     *   Shape.call(this);
     * }
     *
     * Circle.prototype = _.create(Shape.prototype, {
     *   'constructor': Circle
     * });
     *
     * var circle = new Circle;
     * circle instanceof Circle;
     * // => true
     *
     * circle instanceof Shape;
     * // => true
     */
    function create(prototype, properties) {
      var result = baseCreate(prototype);
      return properties == null ? result : baseAssign(result, properties);
    }

    /**
     * Assigns own and inherited enumerable string keyed properties of source
     * objects to the destination object for all destination properties that
     * resolve to `undefined`. Source objects are applied from left to right.
     * Once a property is set, additional values of the same property are ignored.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaultsDeep
     * @example
     *
     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
     * // => { 'a': 1, 'b': 2 }
     */
    var defaults = baseRest(function(object, sources) {
      object = Object(object);

      var index = -1;
      var length = sources.length;
      var guard = length > 2 ? sources[2] : undefined;

      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
        length = 1;
      }

      while (++index < length) {
        var source = sources[index];
        var props = keysIn(source);
        var propsIndex = -1;
        var propsLength = props.length;

        while (++propsIndex < propsLength) {
          var key = props[propsIndex];
          var value = object[key];

          if (value === undefined ||
              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
            object[key] = source[key];
          }
        }
      }

      return object;
    });

    /**
     * This method is like `_.defaults` except that it recursively assigns
     * default properties.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @see _.defaults
     * @example
     *
     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
     * // => { 'a': { 'b': 2, 'c': 3 } }
     */
    var defaultsDeep = baseRest(function(args) {
      args.push(undefined, customDefaultsMerge);
      return apply(mergeWith, undefined, args);
    });

    /**
     * This method is like `_.find` except that it returns the key of the first
     * element `predicate` returns truthy for instead of the element itself.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findKey(users, function(o) { return o.age < 40; });
     * // => 'barney' (iteration order is not guaranteed)
     *
     * // The `_.matches` iteratee shorthand.
     * _.findKey(users, { 'age': 1, 'active': true });
     * // => 'pebbles'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findKey(users, 'active');
     * // => 'barney'
     */
    function findKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
    }

    /**
     * This method is like `_.findKey` except that it iterates over elements of
     * a collection in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @param {Function} [predicate=_.identity] The function invoked per iteration.
     * @returns {string|undefined} Returns the key of the matched element,
     *  else `undefined`.
     * @example
     *
     * var users = {
     *   'barney':  { 'age': 36, 'active': true },
     *   'fred':    { 'age': 40, 'active': false },
     *   'pebbles': { 'age': 1,  'active': true }
     * };
     *
     * _.findLastKey(users, function(o) { return o.age < 40; });
     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
     *
     * // The `_.matches` iteratee shorthand.
     * _.findLastKey(users, { 'age': 36, 'active': true });
     * // => 'barney'
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.findLastKey(users, ['active', false]);
     * // => 'fred'
     *
     * // The `_.property` iteratee shorthand.
     * _.findLastKey(users, 'active');
     * // => 'pebbles'
     */
    function findLastKey(object, predicate) {
      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
    }

    /**
     * Iterates over own and inherited enumerable string keyed properties of an
     * object and invokes `iteratee` for each property. The iteratee is invoked
     * with three arguments: (value, key, object). Iteratee functions may exit
     * iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forInRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forIn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
     */
    function forIn(object, iteratee) {
      return object == null
        ? object
        : baseFor(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * This method is like `_.forIn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forIn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forInRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
     */
    function forInRight(object, iteratee) {
      return object == null
        ? object
        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
    }

    /**
     * Iterates over own enumerable string keyed properties of an object and
     * invokes `iteratee` for each property. The iteratee is invoked with three
     * arguments: (value, key, object). Iteratee functions may exit iteration
     * early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 0.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwnRight
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwn(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
     */
    function forOwn(object, iteratee) {
      return object && baseForOwn(object, getIteratee(iteratee, 3));
    }

    /**
     * This method is like `_.forOwn` except that it iterates over properties of
     * `object` in the opposite order.
     *
     * @static
     * @memberOf _
     * @since 2.0.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns `object`.
     * @see _.forOwn
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.forOwnRight(new Foo, function(value, key) {
     *   console.log(key);
     * });
     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
     */
    function forOwnRight(object, iteratee) {
      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
    }

    /**
     * Creates an array of function property names from own enumerable properties
     * of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functionsIn
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functions(new Foo);
     * // => ['a', 'b']
     */
    function functions(object) {
      return object == null ? [] : baseFunctions(object, keys(object));
    }

    /**
     * Creates an array of function property names from own and inherited
     * enumerable properties of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to inspect.
     * @returns {Array} Returns the function names.
     * @see _.functions
     * @example
     *
     * function Foo() {
     *   this.a = _.constant('a');
     *   this.b = _.constant('b');
     * }
     *
     * Foo.prototype.c = _.constant('c');
     *
     * _.functionsIn(new Foo);
     * // => ['a', 'b', 'c']
     */
    function functionsIn(object) {
      return object == null ? [] : baseFunctions(object, keysIn(object));
    }

    /**
     * Gets the value at `path` of `object`. If the resolved value is
     * `undefined`, the `defaultValue` is returned in its place.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to get.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.get(object, 'a[0].b.c');
     * // => 3
     *
     * _.get(object, ['a', '0', 'b', 'c']);
     * // => 3
     *
     * _.get(object, 'a.b.c', 'default');
     * // => 'default'
     */
    function get(object, path, defaultValue) {
      var result = object == null ? undefined : baseGet(object, path);
      return result === undefined ? defaultValue : result;
    }

    /**
     * Checks if `path` is a direct property of `object`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = { 'a': { 'b': 2 } };
     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.has(object, 'a');
     * // => true
     *
     * _.has(object, 'a.b');
     * // => true
     *
     * _.has(object, ['a', 'b']);
     * // => true
     *
     * _.has(other, 'a');
     * // => false
     */
    function has(object, path) {
      return object != null && hasPath(object, path, baseHas);
    }

    /**
     * Checks if `path` is a direct or inherited property of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path to check.
     * @returns {boolean} Returns `true` if `path` exists, else `false`.
     * @example
     *
     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
     *
     * _.hasIn(object, 'a');
     * // => true
     *
     * _.hasIn(object, 'a.b');
     * // => true
     *
     * _.hasIn(object, ['a', 'b']);
     * // => true
     *
     * _.hasIn(object, 'b');
     * // => false
     */
    function hasIn(object, path) {
      return object != null && hasPath(object, path, baseHasIn);
    }

    /**
     * Creates an object composed of the inverted keys and values of `object`.
     * If `object` contains duplicate values, subsequent values overwrite
     * property assignments of previous values.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Object
     * @param {Object} object The object to invert.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invert(object);
     * // => { '1': 'c', '2': 'b' }
     */
    var invert = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      result[value] = key;
    }, constant(identity));

    /**
     * This method is like `_.invert` except that the inverted object is generated
     * from the results of running each element of `object` thru `iteratee`. The
     * corresponding inverted value of each inverted key is an array of keys
     * responsible for generating the inverted value. The iteratee is invoked
     * with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.1.0
     * @category Object
     * @param {Object} object The object to invert.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {Object} Returns the new inverted object.
     * @example
     *
     * var object = { 'a': 1, 'b': 2, 'c': 1 };
     *
     * _.invertBy(object);
     * // => { '1': ['a', 'c'], '2': ['b'] }
     *
     * _.invertBy(object, function(value) {
     *   return 'group' + value;
     * });
     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
     */
    var invertBy = createInverter(function(result, value, key) {
      if (value != null &&
          typeof value.toString != 'function') {
        value = nativeObjectToString.call(value);
      }

      if (hasOwnProperty.call(result, value)) {
        result[value].push(key);
      } else {
        result[value] = [key];
      }
    }, getIteratee);

    /**
     * Invokes the method at `path` of `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {*} Returns the result of the invoked method.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
     *
     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
     * // => [2, 3]
     */
    var invoke = baseRest(baseInvoke);

    /**
     * Creates an array of the own enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects. See the
     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
     * for more details.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keys(new Foo);
     * // => ['a', 'b'] (iteration order is not guaranteed)
     *
     * _.keys('hi');
     * // => ['0', '1']
     */
    function keys(object) {
      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
    }

    /**
     * Creates an array of the own and inherited enumerable property names of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property names.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.keysIn(new Foo);
     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
     */
    function keysIn(object) {
      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
    }

    /**
     * The opposite of `_.mapValues`; this method creates an object with the
     * same values as `object` and keys generated by running each own enumerable
     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
     * with three arguments: (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 3.8.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapValues
     * @example
     *
     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
     *   return key + value;
     * });
     * // => { 'a1': 1, 'b2': 2 }
     */
    function mapKeys(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, iteratee(value, key, object), value);
      });
      return result;
    }

    /**
     * Creates an object with the same keys as `object` and values generated
     * by running each own enumerable string keyed property of `object` thru
     * `iteratee`. The iteratee is invoked with three arguments:
     * (value, key, object).
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Object} Returns the new mapped object.
     * @see _.mapKeys
     * @example
     *
     * var users = {
     *   'fred':    { 'user': 'fred',    'age': 40 },
     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
     * };
     *
     * _.mapValues(users, function(o) { return o.age; });
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     *
     * // The `_.property` iteratee shorthand.
     * _.mapValues(users, 'age');
     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
     */
    function mapValues(object, iteratee) {
      var result = {};
      iteratee = getIteratee(iteratee, 3);

      baseForOwn(object, function(value, key, object) {
        baseAssignValue(result, key, iteratee(value, key, object));
      });
      return result;
    }

    /**
     * This method is like `_.assign` except that it recursively merges own and
     * inherited enumerable string keyed properties of source objects into the
     * destination object. Source properties that resolve to `undefined` are
     * skipped if a destination value exists. Array and plain object properties
     * are merged recursively. Other objects and value types are overridden by
     * assignment. Source objects are applied from left to right. Subsequent
     * sources overwrite property assignments of previous sources.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 0.5.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} [sources] The source objects.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {
     *   'a': [{ 'b': 2 }, { 'd': 4 }]
     * };
     *
     * var other = {
     *   'a': [{ 'c': 3 }, { 'e': 5 }]
     * };
     *
     * _.merge(object, other);
     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
     */
    var merge = createAssigner(function(object, source, srcIndex) {
      baseMerge(object, source, srcIndex);
    });

    /**
     * This method is like `_.merge` except that it accepts `customizer` which
     * is invoked to produce the merged values of the destination and source
     * properties. If `customizer` returns `undefined`, merging is handled by the
     * method instead. The `customizer` is invoked with six arguments:
     * (objValue, srcValue, key, object, source, stack).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The destination object.
     * @param {...Object} sources The source objects.
     * @param {Function} customizer The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * function customizer(objValue, srcValue) {
     *   if (_.isArray(objValue)) {
     *     return objValue.concat(srcValue);
     *   }
     * }
     *
     * var object = { 'a': [1], 'b': [2] };
     * var other = { 'a': [3], 'b': [4] };
     *
     * _.mergeWith(object, other, customizer);
     * // => { 'a': [1, 3], 'b': [2, 4] }
     */
    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
      baseMerge(object, source, srcIndex, customizer);
    });

    /**
     * The opposite of `_.pick`; this method creates an object composed of the
     * own and inherited enumerable property paths of `object` that are not omitted.
     *
     * **Note:** This method is considerably slower than `_.pick`.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to omit.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omit(object, ['a', 'c']);
     * // => { 'b': '2' }
     */
    var omit = flatRest(function(object, paths) {
      var result = {};
      if (object == null) {
        return result;
      }
      var isDeep = false;
      paths = arrayMap(paths, function(path) {
        path = castPath(path, object);
        isDeep || (isDeep = path.length > 1);
        return path;
      });
      copyObject(object, getAllKeysIn(object), result);
      if (isDeep) {
        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
      }
      var length = paths.length;
      while (length--) {
        baseUnset(result, paths[length]);
      }
      return result;
    });

    /**
     * The opposite of `_.pickBy`; this method creates an object composed of
     * the own and inherited enumerable string keyed properties of `object` that
     * `predicate` doesn't return truthy for. The predicate is invoked with two
     * arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.omitBy(object, _.isNumber);
     * // => { 'b': '2' }
     */
    function omitBy(object, predicate) {
      return pickBy(object, negate(getIteratee(predicate)));
    }

    /**
     * Creates an object composed of the picked `object` properties.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The source object.
     * @param {...(string|string[])} [paths] The property paths to pick.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pick(object, ['a', 'c']);
     * // => { 'a': 1, 'c': 3 }
     */
    var pick = flatRest(function(object, paths) {
      return object == null ? {} : basePick(object, paths);
    });

    /**
     * Creates an object composed of the `object` properties `predicate` returns
     * truthy for. The predicate is invoked with two arguments: (value, key).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The source object.
     * @param {Function} [predicate=_.identity] The function invoked per property.
     * @returns {Object} Returns the new object.
     * @example
     *
     * var object = { 'a': 1, 'b': '2', 'c': 3 };
     *
     * _.pickBy(object, _.isNumber);
     * // => { 'a': 1, 'c': 3 }
     */
    function pickBy(object, predicate) {
      if (object == null) {
        return {};
      }
      var props = arrayMap(getAllKeysIn(object), function(prop) {
        return [prop];
      });
      predicate = getIteratee(predicate);
      return basePickBy(object, props, function(value, path) {
        return predicate(value, path[0]);
      });
    }

    /**
     * This method is like `_.get` except that if the resolved value is a
     * function it's invoked with the `this` binding of its parent object and
     * its result is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @param {Array|string} path The path of the property to resolve.
     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
     *
     * _.result(object, 'a[0].b.c1');
     * // => 3
     *
     * _.result(object, 'a[0].b.c2');
     * // => 4
     *
     * _.result(object, 'a[0].b.c3', 'default');
     * // => 'default'
     *
     * _.result(object, 'a[0].b.c3', _.constant('default'));
     * // => 'default'
     */
    function result(object, path, defaultValue) {
      path = castPath(path, object);

      var index = -1,
          length = path.length;

      // Ensure the loop is entered when path is empty.
      if (!length) {
        length = 1;
        object = undefined;
      }
      while (++index < length) {
        var value = object == null ? undefined : object[toKey(path[index])];
        if (value === undefined) {
          index = length;
          value = defaultValue;
        }
        object = isFunction(value) ? value.call(object) : value;
      }
      return object;
    }

    /**
     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
     * it's created. Arrays are created for missing index properties while objects
     * are created for all other missing properties. Use `_.setWith` to customize
     * `path` creation.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.set(object, 'a[0].b.c', 4);
     * console.log(object.a[0].b.c);
     * // => 4
     *
     * _.set(object, ['x', '0', 'y', 'z'], 5);
     * console.log(object.x[0].y.z);
     * // => 5
     */
    function set(object, path, value) {
      return object == null ? object : baseSet(object, path, value);
    }

    /**
     * This method is like `_.set` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {*} value The value to set.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.setWith(object, '[0][1]', 'a', Object);
     * // => { '0': { '1': 'a' } }
     */
    function setWith(object, path, value, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseSet(object, path, value, customizer);
    }

    /**
     * Creates an array of own enumerable string keyed-value pairs for `object`
     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
     * entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entries
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairs(new Foo);
     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
     */
    var toPairs = createToPairs(keys);

    /**
     * Creates an array of own and inherited enumerable string keyed-value pairs
     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
     * or set, its entries are returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @alias entriesIn
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the key-value pairs.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.toPairsIn(new Foo);
     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
     */
    var toPairsIn = createToPairs(keysIn);

    /**
     * An alternative to `_.reduce`; this method transforms `object` to a new
     * `accumulator` object which is the result of running each of its own
     * enumerable string keyed properties thru `iteratee`, with each invocation
     * potentially mutating the `accumulator` object. If `accumulator` is not
     * provided, a new object with the same `[[Prototype]]` will be used. The
     * iteratee is invoked with four arguments: (accumulator, value, key, object).
     * Iteratee functions may exit iteration early by explicitly returning `false`.
     *
     * @static
     * @memberOf _
     * @since 1.3.0
     * @category Object
     * @param {Object} object The object to iterate over.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @param {*} [accumulator] The custom accumulator value.
     * @returns {*} Returns the accumulated value.
     * @example
     *
     * _.transform([2, 3, 4], function(result, n) {
     *   result.push(n *= n);
     *   return n % 2 == 0;
     * }, []);
     * // => [4, 9]
     *
     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
     *   (result[value] || (result[value] = [])).push(key);
     * }, {});
     * // => { '1': ['a', 'c'], '2': ['b'] }
     */
    function transform(object, iteratee, accumulator) {
      var isArr = isArray(object),
          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

      iteratee = getIteratee(iteratee, 4);
      if (accumulator == null) {
        var Ctor = object && object.constructor;
        if (isArrLike) {
          accumulator = isArr ? new Ctor : [];
        }
        else if (isObject(object)) {
          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
        }
        else {
          accumulator = {};
        }
      }
      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
        return iteratee(accumulator, value, index, object);
      });
      return accumulator;
    }

    /**
     * Removes the property at `path` of `object`.
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to unset.
     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
     * _.unset(object, 'a[0].b.c');
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     *
     * _.unset(object, ['a', '0', 'b', 'c']);
     * // => true
     *
     * console.log(object);
     * // => { 'a': [{ 'b': {} }] };
     */
    function unset(object, path) {
      return object == null ? true : baseUnset(object, path);
    }

    /**
     * This method is like `_.set` except that accepts `updater` to produce the
     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
     * is invoked with one argument: (value).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
     *
     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
     * console.log(object.a[0].b.c);
     * // => 9
     *
     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
     * console.log(object.x[0].y.z);
     * // => 0
     */
    function update(object, path, updater) {
      return object == null ? object : baseUpdate(object, path, castFunction(updater));
    }

    /**
     * This method is like `_.update` except that it accepts `customizer` which is
     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
     * path creation is handled by the method instead. The `customizer` is invoked
     * with three arguments: (nsValue, key, nsObject).
     *
     * **Note:** This method mutates `object`.
     *
     * @static
     * @memberOf _
     * @since 4.6.0
     * @category Object
     * @param {Object} object The object to modify.
     * @param {Array|string} path The path of the property to set.
     * @param {Function} updater The function to produce the updated value.
     * @param {Function} [customizer] The function to customize assigned values.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var object = {};
     *
     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
     * // => { '0': { '1': 'a' } }
     */
    function updateWith(object, path, updater, customizer) {
      customizer = typeof customizer == 'function' ? customizer : undefined;
      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
    }

    /**
     * Creates an array of the own enumerable string keyed property values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.values(new Foo);
     * // => [1, 2] (iteration order is not guaranteed)
     *
     * _.values('hi');
     * // => ['h', 'i']
     */
    function values(object) {
      return object == null ? [] : baseValues(object, keys(object));
    }

    /**
     * Creates an array of the own and inherited enumerable string keyed property
     * values of `object`.
     *
     * **Note:** Non-object values are coerced to objects.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Object
     * @param {Object} object The object to query.
     * @returns {Array} Returns the array of property values.
     * @example
     *
     * function Foo() {
     *   this.a = 1;
     *   this.b = 2;
     * }
     *
     * Foo.prototype.c = 3;
     *
     * _.valuesIn(new Foo);
     * // => [1, 2, 3] (iteration order is not guaranteed)
     */
    function valuesIn(object) {
      return object == null ? [] : baseValues(object, keysIn(object));
    }

    /*------------------------------------------------------------------------*/

    /**
     * Clamps `number` within the inclusive `lower` and `upper` bounds.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Number
     * @param {number} number The number to clamp.
     * @param {number} [lower] The lower bound.
     * @param {number} upper The upper bound.
     * @returns {number} Returns the clamped number.
     * @example
     *
     * _.clamp(-10, -5, 5);
     * // => -5
     *
     * _.clamp(10, -5, 5);
     * // => 5
     */
    function clamp(number, lower, upper) {
      if (upper === undefined) {
        upper = lower;
        lower = undefined;
      }
      if (upper !== undefined) {
        upper = toNumber(upper);
        upper = upper === upper ? upper : 0;
      }
      if (lower !== undefined) {
        lower = toNumber(lower);
        lower = lower === lower ? lower : 0;
      }
      return baseClamp(toNumber(number), lower, upper);
    }

    /**
     * Checks if `n` is between `start` and up to, but not including, `end`. If
     * `end` is not specified, it's set to `start` with `start` then set to `0`.
     * If `start` is greater than `end` the params are swapped to support
     * negative ranges.
     *
     * @static
     * @memberOf _
     * @since 3.3.0
     * @category Number
     * @param {number} number The number to check.
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
     * @see _.range, _.rangeRight
     * @example
     *
     * _.inRange(3, 2, 4);
     * // => true
     *
     * _.inRange(4, 8);
     * // => true
     *
     * _.inRange(4, 2);
     * // => false
     *
     * _.inRange(2, 2);
     * // => false
     *
     * _.inRange(1.2, 2);
     * // => true
     *
     * _.inRange(5.2, 4);
     * // => false
     *
     * _.inRange(-3, -2, -6);
     * // => true
     */
    function inRange(number, start, end) {
      start = toFinite(start);
      if (end === undefined) {
        end = start;
        start = 0;
      } else {
        end = toFinite(end);
      }
      number = toNumber(number);
      return baseInRange(number, start, end);
    }

    /**
     * Produces a random number between the inclusive `lower` and `upper` bounds.
     * If only one argument is provided a number between `0` and the given number
     * is returned. If `floating` is `true`, or either `lower` or `upper` are
     * floats, a floating-point number is returned instead of an integer.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @memberOf _
     * @since 0.7.0
     * @category Number
     * @param {number} [lower=0] The lower bound.
     * @param {number} [upper=1] The upper bound.
     * @param {boolean} [floating] Specify returning a floating-point number.
     * @returns {number} Returns the random number.
     * @example
     *
     * _.random(0, 5);
     * // => an integer between 0 and 5
     *
     * _.random(5);
     * // => also an integer between 0 and 5
     *
     * _.random(5, true);
     * // => a floating-point number between 0 and 5
     *
     * _.random(1.2, 5.2);
     * // => a floating-point number between 1.2 and 5.2
     */
    function random(lower, upper, floating) {
      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
        upper = floating = undefined;
      }
      if (floating === undefined) {
        if (typeof upper == 'boolean') {
          floating = upper;
          upper = undefined;
        }
        else if (typeof lower == 'boolean') {
          floating = lower;
          lower = undefined;
        }
      }
      if (lower === undefined && upper === undefined) {
        lower = 0;
        upper = 1;
      }
      else {
        lower = toFinite(lower);
        if (upper === undefined) {
          upper = lower;
          lower = 0;
        } else {
          upper = toFinite(upper);
        }
      }
      if (lower > upper) {
        var temp = lower;
        lower = upper;
        upper = temp;
      }
      if (floating || lower % 1 || upper % 1) {
        var rand = nativeRandom();
        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
      }
      return baseRandom(lower, upper);
    }

    /*------------------------------------------------------------------------*/

    /**
     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the camel cased string.
     * @example
     *
     * _.camelCase('Foo Bar');
     * // => 'fooBar'
     *
     * _.camelCase('--foo-bar--');
     * // => 'fooBar'
     *
     * _.camelCase('__FOO_BAR__');
     * // => 'fooBar'
     */
    var camelCase = createCompounder(function(result, word, index) {
      word = word.toLowerCase();
      return result + (index ? capitalize(word) : word);
    });

    /**
     * Converts the first character of `string` to upper case and the remaining
     * to lower case.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to capitalize.
     * @returns {string} Returns the capitalized string.
     * @example
     *
     * _.capitalize('FRED');
     * // => 'Fred'
     */
    function capitalize(string) {
      return upperFirst(toString(string).toLowerCase());
    }

    /**
     * Deburrs `string` by converting
     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
     * letters to basic Latin letters and removing
     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to deburr.
     * @returns {string} Returns the deburred string.
     * @example
     *
     * _.deburr('déjà vu');
     * // => 'deja vu'
     */
    function deburr(string) {
      string = toString(string);
      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
    }

    /**
     * Checks if `string` ends with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=string.length] The position to search up to.
     * @returns {boolean} Returns `true` if `string` ends with `target`,
     *  else `false`.
     * @example
     *
     * _.endsWith('abc', 'c');
     * // => true
     *
     * _.endsWith('abc', 'b');
     * // => false
     *
     * _.endsWith('abc', 'b', 2);
     * // => true
     */
    function endsWith(string, target, position) {
      string = toString(string);
      target = baseToString(target);

      var length = string.length;
      position = position === undefined
        ? length
        : baseClamp(toInteger(position), 0, length);

      var end = position;
      position -= target.length;
      return position >= 0 && string.slice(position, end) == target;
    }

    /**
     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
     * corresponding HTML entities.
     *
     * **Note:** No other characters are escaped. To escape additional
     * characters use a third-party library like [_he_](https://mths.be/he).
     *
     * Though the ">" character is escaped for symmetry, characters like
     * ">" and "/" don't need escaping in HTML and have no special meaning
     * unless they're part of a tag or unquoted attribute value. See
     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
     * (under "semi-related fun fact") for more details.
     *
     * When working with HTML you should always
     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
     * XSS vectors.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escape('fred, barney, & pebbles');
     * // => 'fred, barney, &amp; pebbles'
     */
    function escape(string) {
      string = toString(string);
      return (string && reHasUnescapedHtml.test(string))
        ? string.replace(reUnescapedHtml, escapeHtmlChar)
        : string;
    }

    /**
     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to escape.
     * @returns {string} Returns the escaped string.
     * @example
     *
     * _.escapeRegExp('[lodash](https://lodash.com/)');
     * // => '\[lodash\]\(https://lodash\.com/\)'
     */
    function escapeRegExp(string) {
      string = toString(string);
      return (string && reHasRegExpChar.test(string))
        ? string.replace(reRegExpChar, '\\$&')
        : string;
    }

    /**
     * Converts `string` to
     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the kebab cased string.
     * @example
     *
     * _.kebabCase('Foo Bar');
     * // => 'foo-bar'
     *
     * _.kebabCase('fooBar');
     * // => 'foo-bar'
     *
     * _.kebabCase('__FOO_BAR__');
     * // => 'foo-bar'
     */
    var kebabCase = createCompounder(function(result, word, index) {
      return result + (index ? '-' : '') + word.toLowerCase();
    });

    /**
     * Converts `string`, as space separated words, to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.lowerCase('--Foo-Bar--');
     * // => 'foo bar'
     *
     * _.lowerCase('fooBar');
     * // => 'foo bar'
     *
     * _.lowerCase('__FOO_BAR__');
     * // => 'foo bar'
     */
    var lowerCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toLowerCase();
    });

    /**
     * Converts the first character of `string` to lower case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.lowerFirst('Fred');
     * // => 'fred'
     *
     * _.lowerFirst('FRED');
     * // => 'fRED'
     */
    var lowerFirst = createCaseFirst('toLowerCase');

    /**
     * Pads `string` on the left and right sides if it's shorter than `length`.
     * Padding characters are truncated if they can't be evenly divided by `length`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.pad('abc', 8);
     * // => '  abc   '
     *
     * _.pad('abc', 8, '_-');
     * // => '_-abc_-_'
     *
     * _.pad('abc', 3);
     * // => 'abc'
     */
    function pad(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      if (!length || strLength >= length) {
        return string;
      }
      var mid = (length - strLength) / 2;
      return (
        createPadding(nativeFloor(mid), chars) +
        string +
        createPadding(nativeCeil(mid), chars)
      );
    }

    /**
     * Pads `string` on the right side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padEnd('abc', 6);
     * // => 'abc   '
     *
     * _.padEnd('abc', 6, '_-');
     * // => 'abc_-_'
     *
     * _.padEnd('abc', 3);
     * // => 'abc'
     */
    function padEnd(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (string + createPadding(length - strLength, chars))
        : string;
    }

    /**
     * Pads `string` on the left side if it's shorter than `length`. Padding
     * characters are truncated if they exceed `length`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to pad.
     * @param {number} [length=0] The padding length.
     * @param {string} [chars=' '] The string used as padding.
     * @returns {string} Returns the padded string.
     * @example
     *
     * _.padStart('abc', 6);
     * // => '   abc'
     *
     * _.padStart('abc', 6, '_-');
     * // => '_-_abc'
     *
     * _.padStart('abc', 3);
     * // => 'abc'
     */
    function padStart(string, length, chars) {
      string = toString(string);
      length = toInteger(length);

      var strLength = length ? stringSize(string) : 0;
      return (length && strLength < length)
        ? (createPadding(length - strLength, chars) + string)
        : string;
    }

    /**
     * Converts `string` to an integer of the specified radix. If `radix` is
     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
     * hexadecimal, in which case a `radix` of `16` is used.
     *
     * **Note:** This method aligns with the
     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
     *
     * @static
     * @memberOf _
     * @since 1.1.0
     * @category String
     * @param {string} string The string to convert.
     * @param {number} [radix=10] The radix to interpret `value` by.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {number} Returns the converted integer.
     * @example
     *
     * _.parseInt('08');
     * // => 8
     *
     * _.map(['6', '08', '10'], _.parseInt);
     * // => [6, 8, 10]
     */
    function parseInt(string, radix, guard) {
      if (guard || radix == null) {
        radix = 0;
      } else if (radix) {
        radix = +radix;
      }
      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
    }

    /**
     * Repeats the given string `n` times.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to repeat.
     * @param {number} [n=1] The number of times to repeat the string.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the repeated string.
     * @example
     *
     * _.repeat('*', 3);
     * // => '***'
     *
     * _.repeat('abc', 2);
     * // => 'abcabc'
     *
     * _.repeat('abc', 0);
     * // => ''
     */
    function repeat(string, n, guard) {
      if ((guard ? isIterateeCall(string, n, guard) : n === undefined)) {
        n = 1;
      } else {
        n = toInteger(n);
      }
      return baseRepeat(toString(string), n);
    }

    /**
     * Replaces matches for `pattern` in `string` with `replacement`.
     *
     * **Note:** This method is based on
     * [`String#replace`](https://mdn.io/String/replace).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to modify.
     * @param {RegExp|string} pattern The pattern to replace.
     * @param {Function|string} replacement The match replacement.
     * @returns {string} Returns the modified string.
     * @example
     *
     * _.replace('Hi Fred', 'Fred', 'Barney');
     * // => 'Hi Barney'
     */
    function replace() {
      var args = arguments,
          string = toString(args[0]);

      return args.length < 3 ? string : string.replace(args[1], args[2]);
    }

    /**
     * Converts `string` to
     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the snake cased string.
     * @example
     *
     * _.snakeCase('Foo Bar');
     * // => 'foo_bar'
     *
     * _.snakeCase('fooBar');
     * // => 'foo_bar'
     *
     * _.snakeCase('--FOO-BAR--');
     * // => 'foo_bar'
     */
    var snakeCase = createCompounder(function(result, word, index) {
      return result + (index ? '_' : '') + word.toLowerCase();
    });

    /**
     * Splits `string` by `separator`.
     *
     * **Note:** This method is based on
     * [`String#split`](https://mdn.io/String/split).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to split.
     * @param {RegExp|string} separator The separator pattern to split by.
     * @param {number} [limit] The length to truncate results to.
     * @returns {Array} Returns the string segments.
     * @example
     *
     * _.split('a-b-c', '-', 2);
     * // => ['a', 'b']
     */
    function split(string, separator, limit) {
      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
        separator = limit = undefined;
      }
      limit = limit === undefined ? MAX_ARRAY_LENGTH : limit >>> 0;
      if (!limit) {
        return [];
      }
      string = toString(string);
      if (string && (
            typeof separator == 'string' ||
            (separator != null && !isRegExp(separator))
          )) {
        separator = baseToString(separator);
        if (!separator && hasUnicode(string)) {
          return castSlice(stringToArray(string), 0, limit);
        }
      }
      return string.split(separator, limit);
    }

    /**
     * Converts `string` to
     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
     *
     * @static
     * @memberOf _
     * @since 3.1.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the start cased string.
     * @example
     *
     * _.startCase('--foo-bar--');
     * // => 'Foo Bar'
     *
     * _.startCase('fooBar');
     * // => 'Foo Bar'
     *
     * _.startCase('__FOO_BAR__');
     * // => 'FOO BAR'
     */
    var startCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + upperFirst(word);
    });

    /**
     * Checks if `string` starts with the given target string.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {string} [target] The string to search for.
     * @param {number} [position=0] The position to search from.
     * @returns {boolean} Returns `true` if `string` starts with `target`,
     *  else `false`.
     * @example
     *
     * _.startsWith('abc', 'a');
     * // => true
     *
     * _.startsWith('abc', 'b');
     * // => false
     *
     * _.startsWith('abc', 'b', 1);
     * // => true
     */
    function startsWith(string, target, position) {
      string = toString(string);
      position = position == null
        ? 0
        : baseClamp(toInteger(position), 0, string.length);

      target = baseToString(target);
      return string.slice(position, position + target.length) == target;
    }

    /**
     * Creates a compiled template function that can interpolate data properties
     * in "interpolate" delimiters, HTML-escape interpolated data properties in
     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
     * properties may be accessed as free variables in the template. If a setting
     * object is given, it takes precedence over `_.templateSettings` values.
     *
     * **Note:** In the development build `_.template` utilizes
     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
     * for easier debugging.
     *
     * For more information on precompiling templates see
     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
     *
     * For more information on Chrome extension sandboxes see
     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category String
     * @param {string} [string=''] The template string.
     * @param {Object} [options={}] The options object.
     * @param {RegExp} [options.escape=_.templateSettings.escape]
     *  The HTML "escape" delimiter.
     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
     *  The "evaluate" delimiter.
     * @param {Object} [options.imports=_.templateSettings.imports]
     *  An object to import into the template as free variables.
     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
     *  The "interpolate" delimiter.
     * @param {string} [options.sourceURL='lodash.templateSources[n]']
     *  The sourceURL of the compiled template.
     * @param {string} [options.variable='obj']
     *  The data object variable name.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Function} Returns the compiled template function.
     * @example
     *
     * // Use the "interpolate" delimiter to create a compiled template.
     * var compiled = _.template('hello <%= user %>!');
     * compiled({ 'user': 'fred' });
     * // => 'hello fred!'
     *
     * // Use the HTML "escape" delimiter to escape data property values.
     * var compiled = _.template('<b><%- value %></b>');
     * compiled({ 'value': '<script>' });
     * // => '<b>&lt;script&gt;</b>'
     *
     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the internal `print` function in "evaluate" delimiters.
     * var compiled = _.template('<% print("hello " + user); %>!');
     * compiled({ 'user': 'barney' });
     * // => 'hello barney!'
     *
     * // Use the ES template literal delimiter as an "interpolate" delimiter.
     * // Disable support by replacing the "interpolate" delimiter.
     * var compiled = _.template('hello ${ user }!');
     * compiled({ 'user': 'pebbles' });
     * // => 'hello pebbles!'
     *
     * // Use backslashes to treat delimiters as plain text.
     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
     * compiled({ 'value': 'ignored' });
     * // => '<%- value %>'
     *
     * // Use the `imports` option to import `jQuery` as `jq`.
     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
     * compiled({ 'users': ['fred', 'barney'] });
     * // => '<li>fred</li><li>barney</li>'
     *
     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
     * compiled(data);
     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
     *
     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
     * compiled.source;
     * // => function(data) {
     * //   var __t, __p = '';
     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
     * //   return __p;
     * // }
     *
     * // Use custom template delimiters.
     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
     * var compiled = _.template('hello {{ user }}!');
     * compiled({ 'user': 'mustache' });
     * // => 'hello mustache!'
     *
     * // Use the `source` property to inline compiled templates for meaningful
     * // line numbers in error messages and stack traces.
     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
     *   var JST = {\
     *     "main": ' + _.template(mainText).source + '\
     *   };\
     * ');
     */
    function template(string, options, guard) {
      // Based on John Resig's `tmpl` implementation
      // (http://ejohn.org/blog/javascript-micro-templating/)
      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
      var settings = lodash.templateSettings;

      if (guard && isIterateeCall(string, options, guard)) {
        options = undefined;
      }
      string = toString(string);
      options = assignInWith({}, options, settings, customDefaultsAssignIn);

      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
          importsKeys = keys(imports),
          importsValues = baseValues(imports, importsKeys);

      var isEscaping,
          isEvaluating,
          index = 0,
          interpolate = options.interpolate || reNoMatch,
          source = "__p += '";

      // Compile the regexp to match each delimiter.
      var reDelimiters = RegExp(
        (options.escape || reNoMatch).source + '|' +
        interpolate.source + '|' +
        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
        (options.evaluate || reNoMatch).source + '|$'
      , 'g');

      // Use a sourceURL for easier debugging.
      // The sourceURL gets injected into the source that's eval-ed, so be careful
      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
      // and escape the comment, thus injecting code that gets evaled.
      var sourceURL = '//# sourceURL=' +
        (hasOwnProperty.call(options, 'sourceURL')
          ? (options.sourceURL + '').replace(/\s/g, ' ')
          : ('lodash.templateSources[' + (++templateCounter) + ']')
        ) + '\n';

      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
        interpolateValue || (interpolateValue = esTemplateValue);

        // Escape characters that can't be included in string literals.
        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

        // Replace delimiters with snippets.
        if (escapeValue) {
          isEscaping = true;
          source += "' +\n__e(" + escapeValue + ") +\n'";
        }
        if (evaluateValue) {
          isEvaluating = true;
          source += "';\n" + evaluateValue + ";\n__p += '";
        }
        if (interpolateValue) {
          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
        }
        index = offset + match.length;

        // The JS engine embedded in Adobe products needs `match` returned in
        // order to produce the correct `offset` value.
        return match;
      });

      source += "';\n";

      // If `variable` is not specified wrap a with-statement around the generated
      // code to add the data object to the top of the scope chain.
      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
      if (!variable) {
        source = 'with (obj) {\n' + source + '\n}\n';
      }
      // Throw an error if a forbidden character was found in `variable`, to prevent
      // potential command injection attacks.
      else if (reForbiddenIdentifierChars.test(variable)) {
        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
      }

      // Cleanup code by stripping empty strings.
      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
        .replace(reEmptyStringMiddle, '$1')
        .replace(reEmptyStringTrailing, '$1;');

      // Frame code as the function body.
      source = 'function(' + (variable || 'obj') + ') {\n' +
        (variable
          ? ''
          : 'obj || (obj = {});\n'
        ) +
        "var __t, __p = ''" +
        (isEscaping
           ? ', __e = _.escape'
           : ''
        ) +
        (isEvaluating
          ? ', __j = Array.prototype.join;\n' +
            "function print() { __p += __j.call(arguments, '') }\n"
          : ';\n'
        ) +
        source +
        'return __p\n}';

      var result = attempt(function() {
        return Function(importsKeys, sourceURL + 'return ' + source)
          .apply(undefined, importsValues);
      });

      // Provide the compiled function's source by its `toString` method or
      // the `source` property as a convenience for inlining compiled templates.
      result.source = source;
      if (isError(result)) {
        throw result;
      }
      return result;
    }

    /**
     * Converts `string`, as a whole, to lower case just like
     * [String#toLowerCase](https://mdn.io/toLowerCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the lower cased string.
     * @example
     *
     * _.toLower('--Foo-Bar--');
     * // => '--foo-bar--'
     *
     * _.toLower('fooBar');
     * // => 'foobar'
     *
     * _.toLower('__FOO_BAR__');
     * // => '__foo_bar__'
     */
    function toLower(value) {
      return toString(value).toLowerCase();
    }

    /**
     * Converts `string`, as a whole, to upper case just like
     * [String#toUpperCase](https://mdn.io/toUpperCase).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.toUpper('--foo-bar--');
     * // => '--FOO-BAR--'
     *
     * _.toUpper('fooBar');
     * // => 'FOOBAR'
     *
     * _.toUpper('__foo_bar__');
     * // => '__FOO_BAR__'
     */
    function toUpper(value) {
      return toString(value).toUpperCase();
    }

    /**
     * Removes leading and trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trim('  abc  ');
     * // => 'abc'
     *
     * _.trim('-_-abc-_-', '_-');
     * // => 'abc'
     *
     * _.map(['  foo  ', '  bar  '], _.trim);
     * // => ['foo', 'bar']
     */
    function trim(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return baseTrim(string);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          chrSymbols = stringToArray(chars),
          start = charsStartIndex(strSymbols, chrSymbols),
          end = charsEndIndex(strSymbols, chrSymbols) + 1;

      return castSlice(strSymbols, start, end).join('');
    }

    /**
     * Removes trailing whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimEnd('  abc  ');
     * // => '  abc'
     *
     * _.trimEnd('-_-abc-_-', '_-');
     * // => '-_-abc'
     */
    function trimEnd(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.slice(0, trimmedEndIndex(string) + 1);
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

      return castSlice(strSymbols, 0, end).join('');
    }

    /**
     * Removes leading whitespace or specified characters from `string`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to trim.
     * @param {string} [chars=whitespace] The characters to trim.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {string} Returns the trimmed string.
     * @example
     *
     * _.trimStart('  abc  ');
     * // => 'abc  '
     *
     * _.trimStart('-_-abc-_-', '_-');
     * // => 'abc-_-'
     */
    function trimStart(string, chars, guard) {
      string = toString(string);
      if (string && (guard || chars === undefined)) {
        return string.replace(reTrimStart, '');
      }
      if (!string || !(chars = baseToString(chars))) {
        return string;
      }
      var strSymbols = stringToArray(string),
          start = charsStartIndex(strSymbols, stringToArray(chars));

      return castSlice(strSymbols, start).join('');
    }

    /**
     * Truncates `string` if it's longer than the given maximum string length.
     * The last characters of the truncated string are replaced with the omission
     * string which defaults to "...".
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to truncate.
     * @param {Object} [options={}] The options object.
     * @param {number} [options.length=30] The maximum string length.
     * @param {string} [options.omission='...'] The string to indicate text is omitted.
     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
     * @returns {string} Returns the truncated string.
     * @example
     *
     * _.truncate('hi-diddly-ho there, neighborino');
     * // => 'hi-diddly-ho there, neighbo...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': ' '
     * });
     * // => 'hi-diddly-ho there,...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'length': 24,
     *   'separator': /,? +/
     * });
     * // => 'hi-diddly-ho there...'
     *
     * _.truncate('hi-diddly-ho there, neighborino', {
     *   'omission': ' [...]'
     * });
     * // => 'hi-diddly-ho there, neig [...]'
     */
    function truncate(string, options) {
      var length = DEFAULT_TRUNC_LENGTH,
          omission = DEFAULT_TRUNC_OMISSION;

      if (isObject(options)) {
        var separator = 'separator' in options ? options.separator : separator;
        length = 'length' in options ? toInteger(options.length) : length;
        omission = 'omission' in options ? baseToString(options.omission) : omission;
      }
      string = toString(string);

      var strLength = string.length;
      if (hasUnicode(string)) {
        var strSymbols = stringToArray(string);
        strLength = strSymbols.length;
      }
      if (length >= strLength) {
        return string;
      }
      var end = length - stringSize(omission);
      if (end < 1) {
        return omission;
      }
      var result = strSymbols
        ? castSlice(strSymbols, 0, end).join('')
        : string.slice(0, end);

      if (separator === undefined) {
        return result + omission;
      }
      if (strSymbols) {
        end += (result.length - end);
      }
      if (isRegExp(separator)) {
        if (string.slice(end).search(separator)) {
          var match,
              substring = result;

          if (!separator.global) {
            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
          }
          separator.lastIndex = 0;
          while ((match = separator.exec(substring))) {
            var newEnd = match.index;
          }
          result = result.slice(0, newEnd === undefined ? end : newEnd);
        }
      } else if (string.indexOf(baseToString(separator), end) != end) {
        var index = result.lastIndexOf(separator);
        if (index > -1) {
          result = result.slice(0, index);
        }
      }
      return result + omission;
    }

    /**
     * The inverse of `_.escape`; this method converts the HTML entities
     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
     * their corresponding characters.
     *
     * **Note:** No other HTML entities are unescaped. To unescape additional
     * HTML entities use a third-party library like [_he_](https://mths.be/he).
     *
     * @static
     * @memberOf _
     * @since 0.6.0
     * @category String
     * @param {string} [string=''] The string to unescape.
     * @returns {string} Returns the unescaped string.
     * @example
     *
     * _.unescape('fred, barney, &amp; pebbles');
     * // => 'fred, barney, & pebbles'
     */
    function unescape(string) {
      string = toString(string);
      return (string && reHasEscapedHtml.test(string))
        ? string.replace(reEscapedHtml, unescapeHtmlChar)
        : string;
    }

    /**
     * Converts `string`, as space separated words, to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the upper cased string.
     * @example
     *
     * _.upperCase('--foo-bar');
     * // => 'FOO BAR'
     *
     * _.upperCase('fooBar');
     * // => 'FOO BAR'
     *
     * _.upperCase('__foo_bar__');
     * // => 'FOO BAR'
     */
    var upperCase = createCompounder(function(result, word, index) {
      return result + (index ? ' ' : '') + word.toUpperCase();
    });

    /**
     * Converts the first character of `string` to upper case.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category String
     * @param {string} [string=''] The string to convert.
     * @returns {string} Returns the converted string.
     * @example
     *
     * _.upperFirst('fred');
     * // => 'Fred'
     *
     * _.upperFirst('FRED');
     * // => 'FRED'
     */
    var upperFirst = createCaseFirst('toUpperCase');

    /**
     * Splits `string` into an array of its words.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category String
     * @param {string} [string=''] The string to inspect.
     * @param {RegExp|string} [pattern] The pattern to match words.
     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
     * @returns {Array} Returns the words of `string`.
     * @example
     *
     * _.words('fred, barney, & pebbles');
     * // => ['fred', 'barney', 'pebbles']
     *
     * _.words('fred, barney, & pebbles', /[^, ]+/g);
     * // => ['fred', 'barney', '&', 'pebbles']
     */
    function words(string, pattern, guard) {
      string = toString(string);
      pattern = guard ? undefined : pattern;

      if (pattern === undefined) {
        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
      }
      return string.match(pattern) || [];
    }

    /*------------------------------------------------------------------------*/

    /**
     * Attempts to invoke `func`, returning either the result or the caught error
     * object. Any additional arguments are provided to `func` when it's invoked.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Function} func The function to attempt.
     * @param {...*} [args] The arguments to invoke `func` with.
     * @returns {*} Returns the `func` result or error object.
     * @example
     *
     * // Avoid throwing errors for invalid selectors.
     * var elements = _.attempt(function(selector) {
     *   return document.querySelectorAll(selector);
     * }, '>_>');
     *
     * if (_.isError(elements)) {
     *   elements = [];
     * }
     */
    var attempt = baseRest(function(func, args) {
      try {
        return apply(func, undefined, args);
      } catch (e) {
        return isError(e) ? e : new Error(e);
      }
    });

    /**
     * Binds methods of an object to the object itself, overwriting the existing
     * method.
     *
     * **Note:** This method doesn't set the "length" property of bound functions.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Object} object The object to bind and assign the bound methods to.
     * @param {...(string|string[])} methodNames The object method names to bind.
     * @returns {Object} Returns `object`.
     * @example
     *
     * var view = {
     *   'label': 'docs',
     *   'click': function() {
     *     console.log('clicked ' + this.label);
     *   }
     * };
     *
     * _.bindAll(view, ['click']);
     * jQuery(element).on('click', view.click);
     * // => Logs 'clicked docs' when clicked.
     */
    var bindAll = flatRest(function(object, methodNames) {
      arrayEach(methodNames, function(key) {
        key = toKey(key);
        baseAssignValue(object, key, bind(object[key], object));
      });
      return object;
    });

    /**
     * Creates a function that iterates over `pairs` and invokes the corresponding
     * function of the first predicate to return truthy. The predicate-function
     * pairs are invoked with the `this` binding and arguments of the created
     * function.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Array} pairs The predicate-function pairs.
     * @returns {Function} Returns the new composite function.
     * @example
     *
     * var func = _.cond([
     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
     *   [_.stubTrue,                      _.constant('no match')]
     * ]);
     *
     * func({ 'a': 1, 'b': 2 });
     * // => 'matches A'
     *
     * func({ 'a': 0, 'b': 1 });
     * // => 'matches B'
     *
     * func({ 'a': '1', 'b': '2' });
     * // => 'no match'
     */
    function cond(pairs) {
      var length = pairs == null ? 0 : pairs.length,
          toIteratee = getIteratee();

      pairs = !length ? [] : arrayMap(pairs, function(pair) {
        if (typeof pair[1] != 'function') {
          throw new TypeError(FUNC_ERROR_TEXT);
        }
        return [toIteratee(pair[0]), pair[1]];
      });

      return baseRest(function(args) {
        var index = -1;
        while (++index < length) {
          var pair = pairs[index];
          if (apply(pair[0], this, args)) {
            return apply(pair[1], this, args);
          }
        }
      });
    }

    /**
     * Creates a function that invokes the predicate properties of `source` with
     * the corresponding property values of a given object, returning `true` if
     * all predicates return truthy, else `false`.
     *
     * **Note:** The created function is equivalent to `_.conformsTo` with
     * `source` partially applied.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {Object} source The object of property predicates to conform to.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 2, 'b': 1 },
     *   { 'a': 1, 'b': 2 }
     * ];
     *
     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
     * // => [{ 'a': 1, 'b': 2 }]
     */
    function conforms(source) {
      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that returns `value`.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {*} value The value to return from the new function.
     * @returns {Function} Returns the new constant function.
     * @example
     *
     * var objects = _.times(2, _.constant({ 'a': 1 }));
     *
     * console.log(objects);
     * // => [{ 'a': 1 }, { 'a': 1 }]
     *
     * console.log(objects[0] === objects[1]);
     * // => true
     */
    function constant(value) {
      return function() {
        return value;
      };
    }

    /**
     * Checks `value` to determine whether a default value should be returned in
     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
     * or `undefined`.
     *
     * @static
     * @memberOf _
     * @since 4.14.0
     * @category Util
     * @param {*} value The value to check.
     * @param {*} defaultValue The default value.
     * @returns {*} Returns the resolved value.
     * @example
     *
     * _.defaultTo(1, 10);
     * // => 1
     *
     * _.defaultTo(undefined, 10);
     * // => 10
     */
    function defaultTo(value, defaultValue) {
      return (value == null || value !== value) ? defaultValue : value;
    }

    /**
     * Creates a function that returns the result of invoking the given functions
     * with the `this` binding of the created function, where each successive
     * invocation is supplied the return value of the previous.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flowRight
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flow([_.add, square]);
     * addSquare(1, 2);
     * // => 9
     */
    var flow = createFlow();

    /**
     * This method is like `_.flow` except that it creates a function that
     * invokes the given functions from right to left.
     *
     * @static
     * @since 3.0.0
     * @memberOf _
     * @category Util
     * @param {...(Function|Function[])} [funcs] The functions to invoke.
     * @returns {Function} Returns the new composite function.
     * @see _.flow
     * @example
     *
     * function square(n) {
     *   return n * n;
     * }
     *
     * var addSquare = _.flowRight([square, _.add]);
     * addSquare(1, 2);
     * // => 9
     */
    var flowRight = createFlow(true);

    /**
     * This method returns the first argument it receives.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {*} value Any value.
     * @returns {*} Returns `value`.
     * @example
     *
     * var object = { 'a': 1 };
     *
     * console.log(_.identity(object) === object);
     * // => true
     */
    function identity(value) {
      return value;
    }

    /**
     * Creates a function that invokes `func` with the arguments of the created
     * function. If `func` is a property name, the created function returns the
     * property value for a given element. If `func` is an array or object, the
     * created function returns `true` for elements that contain the equivalent
     * source properties, otherwise it returns `false`.
     *
     * @static
     * @since 4.0.0
     * @memberOf _
     * @category Util
     * @param {*} [func=_.identity] The value to convert to a callback.
     * @returns {Function} Returns the callback.
     * @example
     *
     * var users = [
     *   { 'user': 'barney', 'age': 36, 'active': true },
     *   { 'user': 'fred',   'age': 40, 'active': false }
     * ];
     *
     * // The `_.matches` iteratee shorthand.
     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
     *
     * // The `_.matchesProperty` iteratee shorthand.
     * _.filter(users, _.iteratee(['user', 'fred']));
     * // => [{ 'user': 'fred', 'age': 40 }]
     *
     * // The `_.property` iteratee shorthand.
     * _.map(users, _.iteratee('user'));
     * // => ['barney', 'fred']
     *
     * // Create custom iteratee shorthands.
     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
     *     return func.test(string);
     *   };
     * });
     *
     * _.filter(['abc', 'def'], /ef/);
     * // => ['def']
     */
    function iteratee(func) {
      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between a given
     * object and `source`, returning `true` if the given object has equivalent
     * property values, else `false`.
     *
     * **Note:** The created function is equivalent to `_.isMatch` with `source`
     * partially applied.
     *
     * Partial comparisons will match empty array and empty object `source`
     * values against any array or object value, respectively. See `_.isEqual`
     * for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} source The object of property values to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matches(source) {
      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that performs a partial deep comparison between the
     * value at `path` of a given object to `srcValue`, returning `true` if the
     * object value is equivalent, else `false`.
     *
     * **Note:** Partial comparisons will match empty array and empty object
     * `srcValue` values against any array or object value, respectively. See
     * `_.isEqual` for a list of supported value comparisons.
     *
     * **Note:** Multiple values can be checked by combining several matchers
     * using `_.overSome`
     *
     * @static
     * @memberOf _
     * @since 3.2.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @param {*} srcValue The value to match.
     * @returns {Function} Returns the new spec function.
     * @example
     *
     * var objects = [
     *   { 'a': 1, 'b': 2, 'c': 3 },
     *   { 'a': 4, 'b': 5, 'c': 6 }
     * ];
     *
     * _.find(objects, _.matchesProperty('a', 4));
     * // => { 'a': 4, 'b': 5, 'c': 6 }
     *
     * // Checking for several possible values
     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
     */
    function matchesProperty(path, srcValue) {
      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
    }

    /**
     * Creates a function that invokes the method at `path` of a given object.
     * Any additional arguments are provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Array|string} path The path of the method to invoke.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': _.constant(2) } },
     *   { 'a': { 'b': _.constant(1) } }
     * ];
     *
     * _.map(objects, _.method('a.b'));
     * // => [2, 1]
     *
     * _.map(objects, _.method(['a', 'b']));
     * // => [2, 1]
     */
    var method = baseRest(function(path, args) {
      return function(object) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * The opposite of `_.method`; this method creates a function that invokes
     * the method at a given path of `object`. Any additional arguments are
     * provided to the invoked method.
     *
     * @static
     * @memberOf _
     * @since 3.7.0
     * @category Util
     * @param {Object} object The object to query.
     * @param {...*} [args] The arguments to invoke the method with.
     * @returns {Function} Returns the new invoker function.
     * @example
     *
     * var array = _.times(3, _.constant),
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
     * // => [2, 0]
     */
    var methodOf = baseRest(function(object, args) {
      return function(path) {
        return baseInvoke(object, path, args);
      };
    });

    /**
     * Adds all own enumerable string keyed function properties of a source
     * object to the destination object. If `object` is a function, then methods
     * are added to its prototype as well.
     *
     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
     * avoid conflicts caused by modifying the original.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {Function|Object} [object=lodash] The destination object.
     * @param {Object} source The object of functions to add.
     * @param {Object} [options={}] The options object.
     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
     * @returns {Function|Object} Returns `object`.
     * @example
     *
     * function vowels(string) {
     *   return _.filter(string, function(v) {
     *     return /[aeiou]/i.test(v);
     *   });
     * }
     *
     * _.mixin({ 'vowels': vowels });
     * _.vowels('fred');
     * // => ['e']
     *
     * _('fred').vowels().value();
     * // => ['e']
     *
     * _.mixin({ 'vowels': vowels }, { 'chain': false });
     * _('fred').vowels();
     * // => ['e']
     */
    function mixin(object, source, options) {
      var props = keys(source),
          methodNames = baseFunctions(source, props);

      if (options == null &&
          !(isObject(source) && (methodNames.length || !props.length))) {
        options = source;
        source = object;
        object = this;
        methodNames = baseFunctions(source, keys(source));
      }
      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
          isFunc = isFunction(object);

      arrayEach(methodNames, function(methodName) {
        var func = source[methodName];
        object[methodName] = func;
        if (isFunc) {
          object.prototype[methodName] = function() {
            var chainAll = this.__chain__;
            if (chain || chainAll) {
              var result = object(this.__wrapped__),
                  actions = result.__actions__ = copyArray(this.__actions__);

              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
              result.__chain__ = chainAll;
              return result;
            }
            return func.apply(object, arrayPush([this.value()], arguments));
          };
        }
      });

      return object;
    }

    /**
     * Reverts the `_` variable to its previous value and returns a reference to
     * the `lodash` function.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @returns {Function} Returns the `lodash` function.
     * @example
     *
     * var lodash = _.noConflict();
     */
    function noConflict() {
      if (root._ === this) {
        root._ = oldDash;
      }
      return this;
    }

    /**
     * This method returns `undefined`.
     *
     * @static
     * @memberOf _
     * @since 2.3.0
     * @category Util
     * @example
     *
     * _.times(2, _.noop);
     * // => [undefined, undefined]
     */
    function noop() {
      // No operation performed.
    }

    /**
     * Creates a function that gets the argument at index `n`. If `n` is negative,
     * the nth argument from the end is returned.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [n=0] The index of the argument to return.
     * @returns {Function} Returns the new pass-thru function.
     * @example
     *
     * var func = _.nthArg(1);
     * func('a', 'b', 'c', 'd');
     * // => 'b'
     *
     * var func = _.nthArg(-2);
     * func('a', 'b', 'c', 'd');
     * // => 'c'
     */
    function nthArg(n) {
      n = toInteger(n);
      return baseRest(function(args) {
        return baseNth(args, n);
      });
    }

    /**
     * Creates a function that invokes `iteratees` with the arguments it receives
     * and returns their results.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [iteratees=[_.identity]]
     *  The iteratees to invoke.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.over([Math.max, Math.min]);
     *
     * func(1, 2, 3, 4);
     * // => [4, 1]
     */
    var over = createOver(arrayMap);

    /**
     * Creates a function that checks if **all** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overEvery([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => false
     *
     * func(NaN);
     * // => false
     */
    var overEvery = createOver(arrayEvery);

    /**
     * Creates a function that checks if **any** of the `predicates` return
     * truthy when invoked with the arguments it receives.
     *
     * Following shorthands are possible for providing predicates.
     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {...(Function|Function[])} [predicates=[_.identity]]
     *  The predicates to check.
     * @returns {Function} Returns the new function.
     * @example
     *
     * var func = _.overSome([Boolean, isFinite]);
     *
     * func('1');
     * // => true
     *
     * func(null);
     * // => true
     *
     * func(NaN);
     * // => false
     *
     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
     */
    var overSome = createOver(arraySome);

    /**
     * Creates a function that returns the value at `path` of a given object.
     *
     * @static
     * @memberOf _
     * @since 2.4.0
     * @category Util
     * @param {Array|string} path The path of the property to get.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var objects = [
     *   { 'a': { 'b': 2 } },
     *   { 'a': { 'b': 1 } }
     * ];
     *
     * _.map(objects, _.property('a.b'));
     * // => [2, 1]
     *
     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
     * // => [1, 2]
     */
    function property(path) {
      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
    }

    /**
     * The opposite of `_.property`; this method creates a function that returns
     * the value at a given path of `object`.
     *
     * @static
     * @memberOf _
     * @since 3.0.0
     * @category Util
     * @param {Object} object The object to query.
     * @returns {Function} Returns the new accessor function.
     * @example
     *
     * var array = [0, 1, 2],
     *     object = { 'a': array, 'b': array, 'c': array };
     *
     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
     * // => [2, 0]
     *
     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
     * // => [2, 0]
     */
    function propertyOf(object) {
      return function(path) {
        return object == null ? undefined : baseGet(object, path);
      };
    }

    /**
     * Creates an array of numbers (positive and/or negative) progressing from
     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
     * `start` is specified without an `end` or `step`. If `end` is not specified,
     * it's set to `start` with `start` then set to `0`.
     *
     * **Note:** JavaScript follows the IEEE-754 standard for resolving
     * floating-point values which can produce unexpected results.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.rangeRight
     * @example
     *
     * _.range(4);
     * // => [0, 1, 2, 3]
     *
     * _.range(-4);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 5);
     * // => [1, 2, 3, 4]
     *
     * _.range(0, 20, 5);
     * // => [0, 5, 10, 15]
     *
     * _.range(0, -4, -1);
     * // => [0, -1, -2, -3]
     *
     * _.range(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.range(0);
     * // => []
     */
    var range = createRange();

    /**
     * This method is like `_.range` except that it populates values in
     * descending order.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {number} [start=0] The start of the range.
     * @param {number} end The end of the range.
     * @param {number} [step=1] The value to increment or decrement by.
     * @returns {Array} Returns the range of numbers.
     * @see _.inRange, _.range
     * @example
     *
     * _.rangeRight(4);
     * // => [3, 2, 1, 0]
     *
     * _.rangeRight(-4);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 5);
     * // => [4, 3, 2, 1]
     *
     * _.rangeRight(0, 20, 5);
     * // => [15, 10, 5, 0]
     *
     * _.rangeRight(0, -4, -1);
     * // => [-3, -2, -1, 0]
     *
     * _.rangeRight(1, 4, 0);
     * // => [1, 1, 1]
     *
     * _.rangeRight(0);
     * // => []
     */
    var rangeRight = createRange(true);

    /**
     * This method returns a new empty array.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Array} Returns the new empty array.
     * @example
     *
     * var arrays = _.times(2, _.stubArray);
     *
     * console.log(arrays);
     * // => [[], []]
     *
     * console.log(arrays[0] === arrays[1]);
     * // => false
     */
    function stubArray() {
      return [];
    }

    /**
     * This method returns `false`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `false`.
     * @example
     *
     * _.times(2, _.stubFalse);
     * // => [false, false]
     */
    function stubFalse() {
      return false;
    }

    /**
     * This method returns a new empty object.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {Object} Returns the new empty object.
     * @example
     *
     * var objects = _.times(2, _.stubObject);
     *
     * console.log(objects);
     * // => [{}, {}]
     *
     * console.log(objects[0] === objects[1]);
     * // => false
     */
    function stubObject() {
      return {};
    }

    /**
     * This method returns an empty string.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {string} Returns the empty string.
     * @example
     *
     * _.times(2, _.stubString);
     * // => ['', '']
     */
    function stubString() {
      return '';
    }

    /**
     * This method returns `true`.
     *
     * @static
     * @memberOf _
     * @since 4.13.0
     * @category Util
     * @returns {boolean} Returns `true`.
     * @example
     *
     * _.times(2, _.stubTrue);
     * // => [true, true]
     */
    function stubTrue() {
      return true;
    }

    /**
     * Invokes the iteratee `n` times, returning an array of the results of
     * each invocation. The iteratee is invoked with one argument; (index).
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {number} n The number of times to invoke `iteratee`.
     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
     * @returns {Array} Returns the array of results.
     * @example
     *
     * _.times(3, String);
     * // => ['0', '1', '2']
     *
     *  _.times(4, _.constant(0));
     * // => [0, 0, 0, 0]
     */
    function times(n, iteratee) {
      n = toInteger(n);
      if (n < 1 || n > MAX_SAFE_INTEGER) {
        return [];
      }
      var index = MAX_ARRAY_LENGTH,
          length = nativeMin(n, MAX_ARRAY_LENGTH);

      iteratee = getIteratee(iteratee);
      n -= MAX_ARRAY_LENGTH;

      var result = baseTimes(length, iteratee);
      while (++index < n) {
        iteratee(index);
      }
      return result;
    }

    /**
     * Converts `value` to a property path array.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Util
     * @param {*} value The value to convert.
     * @returns {Array} Returns the new property path array.
     * @example
     *
     * _.toPath('a.b.c');
     * // => ['a', 'b', 'c']
     *
     * _.toPath('a[0].b.c');
     * // => ['a', '0', 'b', 'c']
     */
    function toPath(value) {
      if (isArray(value)) {
        return arrayMap(value, toKey);
      }
      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
    }

    /**
     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Util
     * @param {string} [prefix=''] The value to prefix the ID with.
     * @returns {string} Returns the unique ID.
     * @example
     *
     * _.uniqueId('contact_');
     * // => 'contact_104'
     *
     * _.uniqueId();
     * // => '105'
     */
    function uniqueId(prefix) {
      var id = ++idCounter;
      return toString(prefix) + id;
    }

    /*------------------------------------------------------------------------*/

    /**
     * Adds two numbers.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {number} augend The first number in an addition.
     * @param {number} addend The second number in an addition.
     * @returns {number} Returns the total.
     * @example
     *
     * _.add(6, 4);
     * // => 10
     */
    var add = createMathOperation(function(augend, addend) {
      return augend + addend;
    }, 0);

    /**
     * Computes `number` rounded up to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round up.
     * @param {number} [precision=0] The precision to round up to.
     * @returns {number} Returns the rounded up number.
     * @example
     *
     * _.ceil(4.006);
     * // => 5
     *
     * _.ceil(6.004, 2);
     * // => 6.01
     *
     * _.ceil(6040, -2);
     * // => 6100
     */
    var ceil = createRound('ceil');

    /**
     * Divide two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} dividend The first number in a division.
     * @param {number} divisor The second number in a division.
     * @returns {number} Returns the quotient.
     * @example
     *
     * _.divide(6, 4);
     * // => 1.5
     */
    var divide = createMathOperation(function(dividend, divisor) {
      return dividend / divisor;
    }, 1);

    /**
     * Computes `number` rounded down to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round down.
     * @param {number} [precision=0] The precision to round down to.
     * @returns {number} Returns the rounded down number.
     * @example
     *
     * _.floor(4.006);
     * // => 4
     *
     * _.floor(0.046, 2);
     * // => 0.04
     *
     * _.floor(4060, -2);
     * // => 4000
     */
    var floor = createRound('floor');

    /**
     * Computes the maximum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * _.max([4, 2, 8, 6]);
     * // => 8
     *
     * _.max([]);
     * // => undefined
     */
    function max(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseGt)
        : undefined;
    }

    /**
     * This method is like `_.max` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the maximum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.maxBy(objects, function(o) { return o.n; });
     * // => { 'n': 2 }
     *
     * // The `_.property` iteratee shorthand.
     * _.maxBy(objects, 'n');
     * // => { 'n': 2 }
     */
    function maxBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
        : undefined;
    }

    /**
     * Computes the mean of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the mean.
     * @example
     *
     * _.mean([4, 2, 8, 6]);
     * // => 5
     */
    function mean(array) {
      return baseMean(array, identity);
    }

    /**
     * This method is like `_.mean` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be averaged.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the mean.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.meanBy(objects, function(o) { return o.n; });
     * // => 5
     *
     * // The `_.property` iteratee shorthand.
     * _.meanBy(objects, 'n');
     * // => 5
     */
    function meanBy(array, iteratee) {
      return baseMean(array, getIteratee(iteratee, 2));
    }

    /**
     * Computes the minimum value of `array`. If `array` is empty or falsey,
     * `undefined` is returned.
     *
     * @static
     * @since 0.1.0
     * @memberOf _
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * _.min([4, 2, 8, 6]);
     * // => 2
     *
     * _.min([]);
     * // => undefined
     */
    function min(array) {
      return (array && array.length)
        ? baseExtremum(array, identity, baseLt)
        : undefined;
    }

    /**
     * This method is like `_.min` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the criterion by which
     * the value is ranked. The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {*} Returns the minimum value.
     * @example
     *
     * var objects = [{ 'n': 1 }, { 'n': 2 }];
     *
     * _.minBy(objects, function(o) { return o.n; });
     * // => { 'n': 1 }
     *
     * // The `_.property` iteratee shorthand.
     * _.minBy(objects, 'n');
     * // => { 'n': 1 }
     */
    function minBy(array, iteratee) {
      return (array && array.length)
        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
        : undefined;
    }

    /**
     * Multiply two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.7.0
     * @category Math
     * @param {number} multiplier The first number in a multiplication.
     * @param {number} multiplicand The second number in a multiplication.
     * @returns {number} Returns the product.
     * @example
     *
     * _.multiply(6, 4);
     * // => 24
     */
    var multiply = createMathOperation(function(multiplier, multiplicand) {
      return multiplier * multiplicand;
    }, 1);

    /**
     * Computes `number` rounded to `precision`.
     *
     * @static
     * @memberOf _
     * @since 3.10.0
     * @category Math
     * @param {number} number The number to round.
     * @param {number} [precision=0] The precision to round to.
     * @returns {number} Returns the rounded number.
     * @example
     *
     * _.round(4.006);
     * // => 4
     *
     * _.round(4.006, 2);
     * // => 4.01
     *
     * _.round(4060, -2);
     * // => 4100
     */
    var round = createRound('round');

    /**
     * Subtract two numbers.
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {number} minuend The first number in a subtraction.
     * @param {number} subtrahend The second number in a subtraction.
     * @returns {number} Returns the difference.
     * @example
     *
     * _.subtract(6, 4);
     * // => 2
     */
    var subtract = createMathOperation(function(minuend, subtrahend) {
      return minuend - subtrahend;
    }, 0);

    /**
     * Computes the sum of the values in `array`.
     *
     * @static
     * @memberOf _
     * @since 3.4.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @returns {number} Returns the sum.
     * @example
     *
     * _.sum([4, 2, 8, 6]);
     * // => 20
     */
    function sum(array) {
      return (array && array.length)
        ? baseSum(array, identity)
        : 0;
    }

    /**
     * This method is like `_.sum` except that it accepts `iteratee` which is
     * invoked for each element in `array` to generate the value to be summed.
     * The iteratee is invoked with one argument: (value).
     *
     * @static
     * @memberOf _
     * @since 4.0.0
     * @category Math
     * @param {Array} array The array to iterate over.
     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
     * @returns {number} Returns the sum.
     * @example
     *
     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
     *
     * _.sumBy(objects, function(o) { return o.n; });
     * // => 20
     *
     * // The `_.property` iteratee shorthand.
     * _.sumBy(objects, 'n');
     * // => 20
     */
    function sumBy(array, iteratee) {
      return (array && array.length)
        ? baseSum(array, getIteratee(iteratee, 2))
        : 0;
    }

    /*------------------------------------------------------------------------*/

    // Add methods that return wrapped values in chain sequences.
    lodash.after = after;
    lodash.ary = ary;
    lodash.assign = assign;
    lodash.assignIn = assignIn;
    lodash.assignInWith = assignInWith;
    lodash.assignWith = assignWith;
    lodash.at = at;
    lodash.before = before;
    lodash.bind = bind;
    lodash.bindAll = bindAll;
    lodash.bindKey = bindKey;
    lodash.castArray = castArray;
    lodash.chain = chain;
    lodash.chunk = chunk;
    lodash.compact = compact;
    lodash.concat = concat;
    lodash.cond = cond;
    lodash.conforms = conforms;
    lodash.constant = constant;
    lodash.countBy = countBy;
    lodash.create = create;
    lodash.curry = curry;
    lodash.curryRight = curryRight;
    lodash.debounce = debounce;
    lodash.defaults = defaults;
    lodash.defaultsDeep = defaultsDeep;
    lodash.defer = defer;
    lodash.delay = delay;
    lodash.difference = difference;
    lodash.differenceBy = differenceBy;
    lodash.differenceWith = differenceWith;
    lodash.drop = drop;
    lodash.dropRight = dropRight;
    lodash.dropRightWhile = dropRightWhile;
    lodash.dropWhile = dropWhile;
    lodash.fill = fill;
    lodash.filter = filter;
    lodash.flatMap = flatMap;
    lodash.flatMapDeep = flatMapDeep;
    lodash.flatMapDepth = flatMapDepth;
    lodash.flatten = flatten;
    lodash.flattenDeep = flattenDeep;
    lodash.flattenDepth = flattenDepth;
    lodash.flip = flip;
    lodash.flow = flow;
    lodash.flowRight = flowRight;
    lodash.fromPairs = fromPairs;
    lodash.functions = functions;
    lodash.functionsIn = functionsIn;
    lodash.groupBy = groupBy;
    lodash.initial = initial;
    lodash.intersection = intersection;
    lodash.intersectionBy = intersectionBy;
    lodash.intersectionWith = intersectionWith;
    lodash.invert = invert;
    lodash.invertBy = invertBy;
    lodash.invokeMap = invokeMap;
    lodash.iteratee = iteratee;
    lodash.keyBy = keyBy;
    lodash.keys = keys;
    lodash.keysIn = keysIn;
    lodash.map = map;
    lodash.mapKeys = mapKeys;
    lodash.mapValues = mapValues;
    lodash.matches = matches;
    lodash.matchesProperty = matchesProperty;
    lodash.memoize = memoize;
    lodash.merge = merge;
    lodash.mergeWith = mergeWith;
    lodash.method = method;
    lodash.methodOf = methodOf;
    lodash.mixin = mixin;
    lodash.negate = negate;
    lodash.nthArg = nthArg;
    lodash.omit = omit;
    lodash.omitBy = omitBy;
    lodash.once = once;
    lodash.orderBy = orderBy;
    lodash.over = over;
    lodash.overArgs = overArgs;
    lodash.overEvery = overEvery;
    lodash.overSome = overSome;
    lodash.partial = partial;
    lodash.partialRight = partialRight;
    lodash.partition = partition;
    lodash.pick = pick;
    lodash.pickBy = pickBy;
    lodash.property = property;
    lodash.propertyOf = propertyOf;
    lodash.pull = pull;
    lodash.pullAll = pullAll;
    lodash.pullAllBy = pullAllBy;
    lodash.pullAllWith = pullAllWith;
    lodash.pullAt = pullAt;
    lodash.range = range;
    lodash.rangeRight = rangeRight;
    lodash.rearg = rearg;
    lodash.reject = reject;
    lodash.remove = remove;
    lodash.rest = rest;
    lodash.reverse = reverse;
    lodash.sampleSize = sampleSize;
    lodash.set = set;
    lodash.setWith = setWith;
    lodash.shuffle = shuffle;
    lodash.slice = slice;
    lodash.sortBy = sortBy;
    lodash.sortedUniq = sortedUniq;
    lodash.sortedUniqBy = sortedUniqBy;
    lodash.split = split;
    lodash.spread = spread;
    lodash.tail = tail;
    lodash.take = take;
    lodash.takeRight = takeRight;
    lodash.takeRightWhile = takeRightWhile;
    lodash.takeWhile = takeWhile;
    lodash.tap = tap;
    lodash.throttle = throttle;
    lodash.thru = thru;
    lodash.toArray = toArray;
    lodash.toPairs = toPairs;
    lodash.toPairsIn = toPairsIn;
    lodash.toPath = toPath;
    lodash.toPlainObject = toPlainObject;
    lodash.transform = transform;
    lodash.unary = unary;
    lodash.union = union;
    lodash.unionBy = unionBy;
    lodash.unionWith = unionWith;
    lodash.uniq = uniq;
    lodash.uniqBy = uniqBy;
    lodash.uniqWith = uniqWith;
    lodash.unset = unset;
    lodash.unzip = unzip;
    lodash.unzipWith = unzipWith;
    lodash.update = update;
    lodash.updateWith = updateWith;
    lodash.values = values;
    lodash.valuesIn = valuesIn;
    lodash.without = without;
    lodash.words = words;
    lodash.wrap = wrap;
    lodash.xor = xor;
    lodash.xorBy = xorBy;
    lodash.xorWith = xorWith;
    lodash.zip = zip;
    lodash.zipObject = zipObject;
    lodash.zipObjectDeep = zipObjectDeep;
    lodash.zipWith = zipWith;

    // Add aliases.
    lodash.entries = toPairs;
    lodash.entriesIn = toPairsIn;
    lodash.extend = assignIn;
    lodash.extendWith = assignInWith;

    // Add methods to `lodash.prototype`.
    mixin(lodash, lodash);

    /*------------------------------------------------------------------------*/

    // Add methods that return unwrapped values in chain sequences.
    lodash.add = add;
    lodash.attempt = attempt;
    lodash.camelCase = camelCase;
    lodash.capitalize = capitalize;
    lodash.ceil = ceil;
    lodash.clamp = clamp;
    lodash.clone = clone;
    lodash.cloneDeep = cloneDeep;
    lodash.cloneDeepWith = cloneDeepWith;
    lodash.cloneWith = cloneWith;
    lodash.conformsTo = conformsTo;
    lodash.deburr = deburr;
    lodash.defaultTo = defaultTo;
    lodash.divide = divide;
    lodash.endsWith = endsWith;
    lodash.eq = eq;
    lodash.escape = escape;
    lodash.escapeRegExp = escapeRegExp;
    lodash.every = every;
    lodash.find = find;
    lodash.findIndex = findIndex;
    lodash.findKey = findKey;
    lodash.findLast = findLast;
    lodash.findLastIndex = findLastIndex;
    lodash.findLastKey = findLastKey;
    lodash.floor = floor;
    lodash.forEach = forEach;
    lodash.forEachRight = forEachRight;
    lodash.forIn = forIn;
    lodash.forInRight = forInRight;
    lodash.forOwn = forOwn;
    lodash.forOwnRight = forOwnRight;
    lodash.get = get;
    lodash.gt = gt;
    lodash.gte = gte;
    lodash.has = has;
    lodash.hasIn = hasIn;
    lodash.head = head;
    lodash.identity = identity;
    lodash.includes = includes;
    lodash.indexOf = indexOf;
    lodash.inRange = inRange;
    lodash.invoke = invoke;
    lodash.isArguments = isArguments;
    lodash.isArray = isArray;
    lodash.isArrayBuffer = isArrayBuffer;
    lodash.isArrayLike = isArrayLike;
    lodash.isArrayLikeObject = isArrayLikeObject;
    lodash.isBoolean = isBoolean;
    lodash.isBuffer = isBuffer;
    lodash.isDate = isDate;
    lodash.isElement = isElement;
    lodash.isEmpty = isEmpty;
    lodash.isEqual = isEqual;
    lodash.isEqualWith = isEqualWith;
    lodash.isError = isError;
    lodash.isFinite = isFinite;
    lodash.isFunction = isFunction;
    lodash.isInteger = isInteger;
    lodash.isLength = isLength;
    lodash.isMap = isMap;
    lodash.isMatch = isMatch;
    lodash.isMatchWith = isMatchWith;
    lodash.isNaN = isNaN;
    lodash.isNative = isNative;
    lodash.isNil = isNil;
    lodash.isNull = isNull;
    lodash.isNumber = isNumber;
    lodash.isObject = isObject;
    lodash.isObjectLike = isObjectLike;
    lodash.isPlainObject = isPlainObject;
    lodash.isRegExp = isRegExp;
    lodash.isSafeInteger = isSafeInteger;
    lodash.isSet = isSet;
    lodash.isString = isString;
    lodash.isSymbol = isSymbol;
    lodash.isTypedArray = isTypedArray;
    lodash.isUndefined = isUndefined;
    lodash.isWeakMap = isWeakMap;
    lodash.isWeakSet = isWeakSet;
    lodash.join = join;
    lodash.kebabCase = kebabCase;
    lodash.last = last;
    lodash.lastIndexOf = lastIndexOf;
    lodash.lowerCase = lowerCase;
    lodash.lowerFirst = lowerFirst;
    lodash.lt = lt;
    lodash.lte = lte;
    lodash.max = max;
    lodash.maxBy = maxBy;
    lodash.mean = mean;
    lodash.meanBy = meanBy;
    lodash.min = min;
    lodash.minBy = minBy;
    lodash.stubArray = stubArray;
    lodash.stubFalse = stubFalse;
    lodash.stubObject = stubObject;
    lodash.stubString = stubString;
    lodash.stubTrue = stubTrue;
    lodash.multiply = multiply;
    lodash.nth = nth;
    lodash.noConflict = noConflict;
    lodash.noop = noop;
    lodash.now = now;
    lodash.pad = pad;
    lodash.padEnd = padEnd;
    lodash.padStart = padStart;
    lodash.parseInt = parseInt;
    lodash.random = random;
    lodash.reduce = reduce;
    lodash.reduceRight = reduceRight;
    lodash.repeat = repeat;
    lodash.replace = replace;
    lodash.result = result;
    lodash.round = round;
    lodash.runInContext = runInContext;
    lodash.sample = sample;
    lodash.size = size;
    lodash.snakeCase = snakeCase;
    lodash.some = some;
    lodash.sortedIndex = sortedIndex;
    lodash.sortedIndexBy = sortedIndexBy;
    lodash.sortedIndexOf = sortedIndexOf;
    lodash.sortedLastIndex = sortedLastIndex;
    lodash.sortedLastIndexBy = sortedLastIndexBy;
    lodash.sortedLastIndexOf = sortedLastIndexOf;
    lodash.startCase = startCase;
    lodash.startsWith = startsWith;
    lodash.subtract = subtract;
    lodash.sum = sum;
    lodash.sumBy = sumBy;
    lodash.template = template;
    lodash.times = times;
    lodash.toFinite = toFinite;
    lodash.toInteger = toInteger;
    lodash.toLength = toLength;
    lodash.toLower = toLower;
    lodash.toNumber = toNumber;
    lodash.toSafeInteger = toSafeInteger;
    lodash.toString = toString;
    lodash.toUpper = toUpper;
    lodash.trim = trim;
    lodash.trimEnd = trimEnd;
    lodash.trimStart = trimStart;
    lodash.truncate = truncate;
    lodash.unescape = unescape;
    lodash.uniqueId = uniqueId;
    lodash.upperCase = upperCase;
    lodash.upperFirst = upperFirst;

    // Add aliases.
    lodash.each = forEach;
    lodash.eachRight = forEachRight;
    lodash.first = head;

    mixin(lodash, (function() {
      var source = {};
      baseForOwn(lodash, function(func, methodName) {
        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
          source[methodName] = func;
        }
      });
      return source;
    }()), { 'chain': false });

    /*------------------------------------------------------------------------*/

    /**
     * The semantic version number.
     *
     * @static
     * @memberOf _
     * @type {string}
     */
    lodash.VERSION = VERSION;

    // Assign default placeholders.
    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
      lodash[methodName].placeholder = lodash;
    });

    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
    arrayEach(['drop', 'take'], function(methodName, index) {
      LazyWrapper.prototype[methodName] = function(n) {
        n = n === undefined ? 1 : nativeMax(toInteger(n), 0);

        var result = (this.__filtered__ && !index)
          ? new LazyWrapper(this)
          : this.clone();

        if (result.__filtered__) {
          result.__takeCount__ = nativeMin(n, result.__takeCount__);
        } else {
          result.__views__.push({
            'size': nativeMin(n, MAX_ARRAY_LENGTH),
            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
          });
        }
        return result;
      };

      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
        return this.reverse()[methodName](n).reverse();
      };
    });

    // Add `LazyWrapper` methods that accept an `iteratee` value.
    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
      var type = index + 1,
          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

      LazyWrapper.prototype[methodName] = function(iteratee) {
        var result = this.clone();
        result.__iteratees__.push({
          'iteratee': getIteratee(iteratee, 3),
          'type': type
        });
        result.__filtered__ = result.__filtered__ || isFilter;
        return result;
      };
    });

    // Add `LazyWrapper` methods for `_.head` and `_.last`.
    arrayEach(['head', 'last'], function(methodName, index) {
      var takeName = 'take' + (index ? 'Right' : '');

      LazyWrapper.prototype[methodName] = function() {
        return this[takeName](1).value()[0];
      };
    });

    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
    arrayEach(['initial', 'tail'], function(methodName, index) {
      var dropName = 'drop' + (index ? '' : 'Right');

      LazyWrapper.prototype[methodName] = function() {
        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
      };
    });

    LazyWrapper.prototype.compact = function() {
      return this.filter(identity);
    };

    LazyWrapper.prototype.find = function(predicate) {
      return this.filter(predicate).head();
    };

    LazyWrapper.prototype.findLast = function(predicate) {
      return this.reverse().find(predicate);
    };

    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
      if (typeof path == 'function') {
        return new LazyWrapper(this);
      }
      return this.map(function(value) {
        return baseInvoke(value, path, args);
      });
    });

    LazyWrapper.prototype.reject = function(predicate) {
      return this.filter(negate(getIteratee(predicate)));
    };

    LazyWrapper.prototype.slice = function(start, end) {
      start = toInteger(start);

      var result = this;
      if (result.__filtered__ && (start > 0 || end < 0)) {
        return new LazyWrapper(result);
      }
      if (start < 0) {
        result = result.takeRight(-start);
      } else if (start) {
        result = result.drop(start);
      }
      if (end !== undefined) {
        end = toInteger(end);
        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
      }
      return result;
    };

    LazyWrapper.prototype.takeRightWhile = function(predicate) {
      return this.reverse().takeWhile(predicate).reverse();
    };

    LazyWrapper.prototype.toArray = function() {
      return this.take(MAX_ARRAY_LENGTH);
    };

    // Add `LazyWrapper` methods to `lodash.prototype`.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
          isTaker = /^(?:head|last)$/.test(methodName),
          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
          retUnwrapped = isTaker || /^find/.test(methodName);

      if (!lodashFunc) {
        return;
      }
      lodash.prototype[methodName] = function() {
        var value = this.__wrapped__,
            args = isTaker ? [1] : arguments,
            isLazy = value instanceof LazyWrapper,
            iteratee = args[0],
            useLazy = isLazy || isArray(value);

        var interceptor = function(value) {
          var result = lodashFunc.apply(lodash, arrayPush([value], args));
          return (isTaker && chainAll) ? result[0] : result;
        };

        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
          // Avoid lazy use if the iteratee has a "length" value other than `1`.
          isLazy = useLazy = false;
        }
        var chainAll = this.__chain__,
            isHybrid = !!this.__actions__.length,
            isUnwrapped = retUnwrapped && !chainAll,
            onlyLazy = isLazy && !isHybrid;

        if (!retUnwrapped && useLazy) {
          value = onlyLazy ? value : new LazyWrapper(this);
          var result = func.apply(value, args);
          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined });
          return new LodashWrapper(result, chainAll);
        }
        if (isUnwrapped && onlyLazy) {
          return func.apply(this, args);
        }
        result = this.thru(interceptor);
        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
      };
    });

    // Add `Array` methods to `lodash.prototype`.
    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
      var func = arrayProto[methodName],
          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

      lodash.prototype[methodName] = function() {
        var args = arguments;
        if (retUnwrapped && !this.__chain__) {
          var value = this.value();
          return func.apply(isArray(value) ? value : [], args);
        }
        return this[chainName](function(value) {
          return func.apply(isArray(value) ? value : [], args);
        });
      };
    });

    // Map minified method names to their real names.
    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
      var lodashFunc = lodash[methodName];
      if (lodashFunc) {
        var key = lodashFunc.name + '';
        if (!hasOwnProperty.call(realNames, key)) {
          realNames[key] = [];
        }
        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
      }
    });

    realNames[createHybrid(undefined, WRAP_BIND_KEY_FLAG).name] = [{
      'name': 'wrapper',
      'func': undefined
    }];

    // Add methods to `LazyWrapper`.
    LazyWrapper.prototype.clone = lazyClone;
    LazyWrapper.prototype.reverse = lazyReverse;
    LazyWrapper.prototype.value = lazyValue;

    // Add chain sequence methods to the `lodash` wrapper.
    lodash.prototype.at = wrapperAt;
    lodash.prototype.chain = wrapperChain;
    lodash.prototype.commit = wrapperCommit;
    lodash.prototype.next = wrapperNext;
    lodash.prototype.plant = wrapperPlant;
    lodash.prototype.reverse = wrapperReverse;
    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

    // Add lazy aliases.
    lodash.prototype.first = lodash.prototype.head;

    if (symIterator) {
      lodash.prototype[symIterator] = wrapperToIterator;
    }
    return lodash;
  });

  /*--------------------------------------------------------------------------*/

  // Export lodash.
  var _ = runInContext();

  // Some AMD build optimizers, like r.js, check for condition patterns like:
  if (true) {
    // Expose Lodash on the global object to prevent errors when Lodash is
    // loaded by a script tag in the presence of an AMD loader.
    // See http://requirejs.org/docs/errors.html#mismatch for more details.
    // Use `_.noConflict` to remove Lodash from the global object.
    root._ = _;

    // Define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module.
    !(__WEBPACK_AMD_DEFINE_RESULT__ = (function() {
      return _;
    }).call(exports, __webpack_require__, exports, module),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
  // Check for `exports` after `define` in case a build optimizer adds it.
  else {}
}.call(this));


/***/ }),

/***/ "./node_modules/prettier/standalone.js":
/*!*********************************************!*\
  !*** ./node_modules/prettier/standalone.js ***!
  \*********************************************/
/***/ ((module, exports, __webpack_require__) => {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;(function(e){if(true)module.exports=e();else { var f; }})(function(){"use strict";var xe=(e,r)=>()=>(r||e((r={exports:{}}).exports,r),r.exports);var pt=xe((t0,pu)=>{var ir=function(e){return e&&e.Math==Math&&e};pu.exports=ir(typeof globalThis=="object"&&globalThis)||ir(typeof window=="object"&&window)||ir(typeof self=="object"&&self)||ir(typeof __webpack_require__.g=="object"&&__webpack_require__.g)||function(){return this}()||Function("return this")()});var Dt=xe((r0,fu)=>{fu.exports=function(e){try{return!!e()}catch{return!0}}});var yt=xe((n0,Du)=>{var Mo=Dt();Du.exports=!Mo(function(){return Object.defineProperty({},1,{get:function(){return 7}})[1]!=7})});var ar=xe((u0,mu)=>{var Ro=Dt();mu.exports=!Ro(function(){var e=function(){}.bind();return typeof e!="function"||e.hasOwnProperty("prototype")})});var At=xe((s0,du)=>{var $o=ar(),or=Function.prototype.call;du.exports=$o?or.bind(or):function(){return or.apply(or,arguments)}});var vu=xe(hu=>{"use strict";var gu={}.propertyIsEnumerable,yu=Object.getOwnPropertyDescriptor,Vo=yu&&!gu.call({1:2},1);hu.f=Vo?function(r){var t=yu(this,r);return!!t&&t.enumerable}:gu});var lr=xe((a0,Cu)=>{Cu.exports=function(e,r){return{enumerable:!(e&1),configurable:!(e&2),writable:!(e&4),value:r}}});var mt=xe((o0,Au)=>{var Eu=ar(),Fu=Function.prototype,Wr=Fu.call,Wo=Eu&&Fu.bind.bind(Wr,Wr);Au.exports=Eu?Wo:function(e){return function(){return Wr.apply(e,arguments)}}});var Vt=xe((l0,xu)=>{var Su=mt(),Ho=Su({}.toString),Go=Su("".slice);xu.exports=function(e){return Go(Ho(e),8,-1)}});var Tu=xe((c0,bu)=>{var Uo=mt(),Jo=Dt(),zo=Vt(),Hr=Object,Xo=Uo("".split);bu.exports=Jo(function(){return!Hr("z").propertyIsEnumerable(0)})?function(e){return zo(e)=="String"?Xo(e,""):Hr(e)}:Hr});var cr=xe((p0,Bu)=>{Bu.exports=function(e){return e==null}});var Gr=xe((f0,Nu)=>{var Ko=cr(),Yo=TypeError;Nu.exports=function(e){if(Ko(e))throw Yo("Can't call method on "+e);return e}});var pr=xe((D0,wu)=>{var Qo=Tu(),Zo=Gr();wu.exports=function(e){return Qo(Zo(e))}});var Jr=xe((m0,_u)=>{var Ur=typeof document=="object"&&document.all,el=typeof Ur>"u"&&Ur!==void 0;_u.exports={all:Ur,IS_HTMLDDA:el}});var ot=xe((d0,Iu)=>{var Pu=Jr(),tl=Pu.all;Iu.exports=Pu.IS_HTMLDDA?function(e){return typeof e=="function"||e===tl}:function(e){return typeof e=="function"}});var St=xe((g0,Ou)=>{var ku=ot(),Lu=Jr(),rl=Lu.all;Ou.exports=Lu.IS_HTMLDDA?function(e){return typeof e=="object"?e!==null:ku(e)||e===rl}:function(e){return typeof e=="object"?e!==null:ku(e)}});var Wt=xe((y0,ju)=>{var zr=pt(),nl=ot(),ul=function(e){return nl(e)?e:void 0};ju.exports=function(e,r){return arguments.length<2?ul(zr[e]):zr[e]&&zr[e][r]}});var Xr=xe((h0,qu)=>{var sl=mt();qu.exports=sl({}.isPrototypeOf)});var Ru=xe((v0,Mu)=>{var il=Wt();Mu.exports=il("navigator","userAgent")||""});var Ju=xe((C0,Uu)=>{var Gu=pt(),Kr=Ru(),$u=Gu.process,Vu=Gu.Deno,Wu=$u&&$u.versions||Vu&&Vu.version,Hu=Wu&&Wu.v8,dt,fr;Hu&&(dt=Hu.split("."),fr=dt[0]>0&&dt[0]<4?1:+(dt[0]+dt[1]));!fr&&Kr&&(dt=Kr.match(/Edge\/(\d+)/),(!dt||dt[1]>=74)&&(dt=Kr.match(/Chrome\/(\d+)/),dt&&(fr=+dt[1])));Uu.exports=fr});var Yr=xe((E0,Xu)=>{var zu=Ju(),al=Dt();Xu.exports=!!Object.getOwnPropertySymbols&&!al(function(){var e=Symbol();return!String(e)||!(Object(e)instanceof Symbol)||!Symbol.sham&&zu&&zu<41})});var Qr=xe((F0,Ku)=>{var ol=Yr();Ku.exports=ol&&!Symbol.sham&&typeof Symbol.iterator=="symbol"});var Zr=xe((A0,Yu)=>{var ll=Wt(),cl=ot(),pl=Xr(),fl=Qr(),Dl=Object;Yu.exports=fl?function(e){return typeof e=="symbol"}:function(e){var r=ll("Symbol");return cl(r)&&pl(r.prototype,Dl(e))}});var Dr=xe((S0,Qu)=>{var ml=String;Qu.exports=function(e){try{return ml(e)}catch{return"Object"}}});var Ht=xe((x0,Zu)=>{var dl=ot(),gl=Dr(),yl=TypeError;Zu.exports=function(e){if(dl(e))return e;throw yl(gl(e)+" is not a function")}});var mr=xe((b0,es)=>{var hl=Ht(),vl=cr();es.exports=function(e,r){var t=e[r];return vl(t)?void 0:hl(t)}});var rs=xe((T0,ts)=>{var en=At(),tn=ot(),rn=St(),Cl=TypeError;ts.exports=function(e,r){var t,s;if(r==="string"&&tn(t=e.toString)&&!rn(s=en(t,e))||tn(t=e.valueOf)&&!rn(s=en(t,e))||r!=="string"&&tn(t=e.toString)&&!rn(s=en(t,e)))return s;throw Cl("Can't convert object to primitive value")}});var us=xe((B0,ns)=>{ns.exports=!1});var dr=xe((N0,is)=>{var ss=pt(),El=Object.defineProperty;is.exports=function(e,r){try{El(ss,e,{value:r,configurable:!0,writable:!0})}catch{ss[e]=r}return r}});var gr=xe((w0,os)=>{var Fl=pt(),Al=dr(),as="__core-js_shared__",Sl=Fl[as]||Al(as,{});os.exports=Sl});var nn=xe((_0,cs)=>{var xl=us(),ls=gr();(cs.exports=function(e,r){return ls[e]||(ls[e]=r!==void 0?r:{})})("versions",[]).push({version:"3.26.1",mode:xl?"pure":"global",copyright:"\xA9 2014-2022 Denis Pushkarev (zloirock.ru)",license:"https://github.com/zloirock/core-js/blob/v3.26.1/LICENSE",source:"https://github.com/zloirock/core-js"})});var yr=xe((P0,ps)=>{var bl=Gr(),Tl=Object;ps.exports=function(e){return Tl(bl(e))}});var Ct=xe((I0,fs)=>{var Bl=mt(),Nl=yr(),wl=Bl({}.hasOwnProperty);fs.exports=Object.hasOwn||function(r,t){return wl(Nl(r),t)}});var un=xe((k0,Ds)=>{var _l=mt(),Pl=0,Il=Math.random(),kl=_l(1 .toString);Ds.exports=function(e){return"Symbol("+(e===void 0?"":e)+")_"+kl(++Pl+Il,36)}});var bt=xe((L0,hs)=>{var Ll=pt(),Ol=nn(),ms=Ct(),jl=un(),ds=Yr(),ys=Qr(),Pt=Ol("wks"),xt=Ll.Symbol,gs=xt&&xt.for,ql=ys?xt:xt&&xt.withoutSetter||jl;hs.exports=function(e){if(!ms(Pt,e)||!(ds||typeof Pt[e]=="string")){var r="Symbol."+e;ds&&ms(xt,e)?Pt[e]=xt[e]:ys&&gs?Pt[e]=gs(r):Pt[e]=ql(r)}return Pt[e]}});var Fs=xe((O0,Es)=>{var Ml=At(),vs=St(),Cs=Zr(),Rl=mr(),$l=rs(),Vl=bt(),Wl=TypeError,Hl=Vl("toPrimitive");Es.exports=function(e,r){if(!vs(e)||Cs(e))return e;var t=Rl(e,Hl),s;if(t){if(r===void 0&&(r="default"),s=Ml(t,e,r),!vs(s)||Cs(s))return s;throw Wl("Can't convert object to primitive value")}return r===void 0&&(r="number"),$l(e,r)}});var hr=xe((j0,As)=>{var Gl=Fs(),Ul=Zr();As.exports=function(e){var r=Gl(e,"string");return Ul(r)?r:r+""}});var bs=xe((q0,xs)=>{var Jl=pt(),Ss=St(),sn=Jl.document,zl=Ss(sn)&&Ss(sn.createElement);xs.exports=function(e){return zl?sn.createElement(e):{}}});var an=xe((M0,Ts)=>{var Xl=yt(),Kl=Dt(),Yl=bs();Ts.exports=!Xl&&!Kl(function(){return Object.defineProperty(Yl("div"),"a",{get:function(){return 7}}).a!=7})});var on=xe(Ns=>{var Ql=yt(),Zl=At(),ec=vu(),tc=lr(),rc=pr(),nc=hr(),uc=Ct(),sc=an(),Bs=Object.getOwnPropertyDescriptor;Ns.f=Ql?Bs:function(r,t){if(r=rc(r),t=nc(t),sc)try{return Bs(r,t)}catch{}if(uc(r,t))return tc(!Zl(ec.f,r,t),r[t])}});var _s=xe(($0,ws)=>{var ic=yt(),ac=Dt();ws.exports=ic&&ac(function(){return Object.defineProperty(function(){},"prototype",{value:42,writable:!1}).prototype!=42})});var Tt=xe((V0,Ps)=>{var oc=St(),lc=String,cc=TypeError;Ps.exports=function(e){if(oc(e))return e;throw cc(lc(e)+" is not an object")}});var It=xe(ks=>{var pc=yt(),fc=an(),Dc=_s(),vr=Tt(),Is=hr(),mc=TypeError,ln=Object.defineProperty,dc=Object.getOwnPropertyDescriptor,cn="enumerable",pn="configurable",fn="writable";ks.f=pc?Dc?function(r,t,s){if(vr(r),t=Is(t),vr(s),typeof r=="function"&&t==="prototype"&&"value"in s&&fn in s&&!s[fn]){var a=dc(r,t);a&&a[fn]&&(r[t]=s.value,s={configurable:pn in s?s[pn]:a[pn],enumerable:cn in s?s[cn]:a[cn],writable:!1})}return ln(r,t,s)}:ln:function(r,t,s){if(vr(r),t=Is(t),vr(s),fc)try{return ln(r,t,s)}catch{}if("get"in s||"set"in s)throw mc("Accessors not supported");return"value"in s&&(r[t]=s.value),r}});var Dn=xe((H0,Ls)=>{var gc=yt(),yc=It(),hc=lr();Ls.exports=gc?function(e,r,t){return yc.f(e,r,hc(1,t))}:function(e,r,t){return e[r]=t,e}});var qs=xe((G0,js)=>{var mn=yt(),vc=Ct(),Os=Function.prototype,Cc=mn&&Object.getOwnPropertyDescriptor,dn=vc(Os,"name"),Ec=dn&&function(){}.name==="something",Fc=dn&&(!mn||mn&&Cc(Os,"name").configurable);js.exports={EXISTS:dn,PROPER:Ec,CONFIGURABLE:Fc}});var yn=xe((U0,Ms)=>{var Ac=mt(),Sc=ot(),gn=gr(),xc=Ac(Function.toString);Sc(gn.inspectSource)||(gn.inspectSource=function(e){return xc(e)});Ms.exports=gn.inspectSource});var Vs=xe((J0,$s)=>{var bc=pt(),Tc=ot(),Rs=bc.WeakMap;$s.exports=Tc(Rs)&&/native code/.test(String(Rs))});var Gs=xe((z0,Hs)=>{var Bc=nn(),Nc=un(),Ws=Bc("keys");Hs.exports=function(e){return Ws[e]||(Ws[e]=Nc(e))}});var hn=xe((X0,Us)=>{Us.exports={}});var Ks=xe((K0,Xs)=>{var wc=Vs(),zs=pt(),_c=St(),Pc=Dn(),vn=Ct(),Cn=gr(),Ic=Gs(),kc=hn(),Js="Object already initialized",En=zs.TypeError,Lc=zs.WeakMap,Cr,Gt,Er,Oc=function(e){return Er(e)?Gt(e):Cr(e,{})},jc=function(e){return function(r){var t;if(!_c(r)||(t=Gt(r)).type!==e)throw En("Incompatible receiver, "+e+" required");return t}};wc||Cn.state?(gt=Cn.state||(Cn.state=new Lc),gt.get=gt.get,gt.has=gt.has,gt.set=gt.set,Cr=function(e,r){if(gt.has(e))throw En(Js);return r.facade=e,gt.set(e,r),r},Gt=function(e){return gt.get(e)||{}},Er=function(e){return gt.has(e)}):(Bt=Ic("state"),kc[Bt]=!0,Cr=function(e,r){if(vn(e,Bt))throw En(Js);return r.facade=e,Pc(e,Bt,r),r},Gt=function(e){return vn(e,Bt)?e[Bt]:{}},Er=function(e){return vn(e,Bt)});var gt,Bt;Xs.exports={set:Cr,get:Gt,has:Er,enforce:Oc,getterFor:jc}});var An=xe((Y0,Qs)=>{var qc=Dt(),Mc=ot(),Fr=Ct(),Fn=yt(),Rc=qs().CONFIGURABLE,$c=yn(),Ys=Ks(),Vc=Ys.enforce,Wc=Ys.get,Ar=Object.defineProperty,Hc=Fn&&!qc(function(){return Ar(function(){},"length",{value:8}).length!==8}),Gc=String(String).split("String"),Uc=Qs.exports=function(e,r,t){String(r).slice(0,7)==="Symbol("&&(r="["+String(r).replace(/^Symbol\(([^)]*)\)/,"$1")+"]"),t&&t.getter&&(r="get "+r),t&&t.setter&&(r="set "+r),(!Fr(e,"name")||Rc&&e.name!==r)&&(Fn?Ar(e,"name",{value:r,configurable:!0}):e.name=r),Hc&&t&&Fr(t,"arity")&&e.length!==t.arity&&Ar(e,"length",{value:t.arity});try{t&&Fr(t,"constructor")&&t.constructor?Fn&&Ar(e,"prototype",{writable:!1}):e.prototype&&(e.prototype=void 0)}catch{}var s=Vc(e);return Fr(s,"source")||(s.source=Gc.join(typeof r=="string"?r:"")),e};Function.prototype.toString=Uc(function(){return Mc(this)&&Wc(this).source||$c(this)},"toString")});var ei=xe((Q0,Zs)=>{var Jc=ot(),zc=It(),Xc=An(),Kc=dr();Zs.exports=function(e,r,t,s){s||(s={});var a=s.enumerable,n=s.name!==void 0?s.name:r;if(Jc(t)&&Xc(t,n,s),s.global)a?e[r]=t:Kc(r,t);else{try{s.unsafe?e[r]&&(a=!0):delete e[r]}catch{}a?e[r]=t:zc.f(e,r,{value:t,enumerable:!1,configurable:!s.nonConfigurable,writable:!s.nonWritable})}return e}});var ri=xe((Z0,ti)=>{var Yc=Math.ceil,Qc=Math.floor;ti.exports=Math.trunc||function(r){var t=+r;return(t>0?Qc:Yc)(t)}});var Sr=xe((ey,ni)=>{var Zc=ri();ni.exports=function(e){var r=+e;return r!==r||r===0?0:Zc(r)}});var si=xe((ty,ui)=>{var ep=Sr(),tp=Math.max,rp=Math.min;ui.exports=function(e,r){var t=ep(e);return t<0?tp(t+r,0):rp(t,r)}});var ai=xe((ry,ii)=>{var np=Sr(),up=Math.min;ii.exports=function(e){return e>0?up(np(e),9007199254740991):0}});var kt=xe((ny,oi)=>{var sp=ai();oi.exports=function(e){return sp(e.length)}});var pi=xe((uy,ci)=>{var ip=pr(),ap=si(),op=kt(),li=function(e){return function(r,t,s){var a=ip(r),n=op(a),u=ap(s,n),i;if(e&&t!=t){for(;n>u;)if(i=a[u++],i!=i)return!0}else for(;n>u;u++)if((e||u in a)&&a[u]===t)return e||u||0;return!e&&-1}};ci.exports={includes:li(!0),indexOf:li(!1)}});var mi=xe((sy,Di)=>{var lp=mt(),Sn=Ct(),cp=pr(),pp=pi().indexOf,fp=hn(),fi=lp([].push);Di.exports=function(e,r){var t=cp(e),s=0,a=[],n;for(n in t)!Sn(fp,n)&&Sn(t,n)&&fi(a,n);for(;r.length>s;)Sn(t,n=r[s++])&&(~pp(a,n)||fi(a,n));return a}});var gi=xe((iy,di)=>{di.exports=["constructor","hasOwnProperty","isPrototypeOf","propertyIsEnumerable","toLocaleString","toString","valueOf"]});var hi=xe(yi=>{var Dp=mi(),mp=gi(),dp=mp.concat("length","prototype");yi.f=Object.getOwnPropertyNames||function(r){return Dp(r,dp)}});var Ci=xe(vi=>{vi.f=Object.getOwnPropertySymbols});var Fi=xe((ly,Ei)=>{var gp=Wt(),yp=mt(),hp=hi(),vp=Ci(),Cp=Tt(),Ep=yp([].concat);Ei.exports=gp("Reflect","ownKeys")||function(r){var t=hp.f(Cp(r)),s=vp.f;return s?Ep(t,s(r)):t}});var xi=xe((cy,Si)=>{var Ai=Ct(),Fp=Fi(),Ap=on(),Sp=It();Si.exports=function(e,r,t){for(var s=Fp(r),a=Sp.f,n=Ap.f,u=0;u<s.length;u++){var i=s[u];!Ai(e,i)&&!(t&&Ai(t,i))&&a(e,i,n(r,i))}}});var Ti=xe((py,bi)=>{var xp=Dt(),bp=ot(),Tp=/#|\.prototype\./,Ut=function(e,r){var t=Np[Bp(e)];return t==_p?!0:t==wp?!1:bp(r)?xp(r):!!r},Bp=Ut.normalize=function(e){return String(e).replace(Tp,".").toLowerCase()},Np=Ut.data={},wp=Ut.NATIVE="N",_p=Ut.POLYFILL="P";bi.exports=Ut});var Jt=xe((fy,Bi)=>{var xn=pt(),Pp=on().f,Ip=Dn(),kp=ei(),Lp=dr(),Op=xi(),jp=Ti();Bi.exports=function(e,r){var t=e.target,s=e.global,a=e.stat,n,u,i,l,p,d;if(s?u=xn:a?u=xn[t]||Lp(t,{}):u=(xn[t]||{}).prototype,u)for(i in r){if(p=r[i],e.dontCallGetSet?(d=Pp(u,i),l=d&&d.value):l=u[i],n=jp(s?i:t+(a?".":"#")+i,e.forced),!n&&l!==void 0){if(typeof p==typeof l)continue;Op(p,l)}(e.sham||l&&l.sham)&&Ip(p,"sham",!0),kp(u,i,p,e)}}});var bn=xe((Dy,Ni)=>{var qp=Vt();Ni.exports=Array.isArray||function(r){return qp(r)=="Array"}});var _i=xe((my,wi)=>{var Mp=TypeError,Rp=9007199254740991;wi.exports=function(e){if(e>Rp)throw Mp("Maximum allowed index exceeded");return e}});var Ii=xe((dy,Pi)=>{var $p=Vt(),Vp=mt();Pi.exports=function(e){if($p(e)==="Function")return Vp(e)}});var Tn=xe((gy,Li)=>{var ki=Ii(),Wp=Ht(),Hp=ar(),Gp=ki(ki.bind);Li.exports=function(e,r){return Wp(e),r===void 0?e:Hp?Gp(e,r):function(){return e.apply(r,arguments)}}});var Bn=xe((yy,ji)=>{"use strict";var Up=bn(),Jp=kt(),zp=_i(),Xp=Tn(),Oi=function(e,r,t,s,a,n,u,i){for(var l=a,p=0,d=u?Xp(u,i):!1,y,g;p<s;)p in t&&(y=d?d(t[p],p,r):t[p],n>0&&Up(y)?(g=Jp(y),l=Oi(e,r,y,g,l,n-1)-1):(zp(l+1),e[l]=y),l++),p++;return l};ji.exports=Oi});var Ri=xe((hy,Mi)=>{var Kp=bt(),Yp=Kp("toStringTag"),qi={};qi[Yp]="z";Mi.exports=String(qi)==="[object z]"});var Nn=xe((vy,$i)=>{var Qp=Ri(),Zp=ot(),xr=Vt(),ef=bt(),tf=ef("toStringTag"),rf=Object,nf=xr(function(){return arguments}())=="Arguments",uf=function(e,r){try{return e[r]}catch{}};$i.exports=Qp?xr:function(e){var r,t,s;return e===void 0?"Undefined":e===null?"Null":typeof(t=uf(r=rf(e),tf))=="string"?t:nf?xr(r):(s=xr(r))=="Object"&&Zp(r.callee)?"Arguments":s}});var Ji=xe((Cy,Ui)=>{var sf=mt(),af=Dt(),Vi=ot(),of=Nn(),lf=Wt(),cf=yn(),Wi=function(){},pf=[],Hi=lf("Reflect","construct"),wn=/^\s*(?:class|function)\b/,ff=sf(wn.exec),Df=!wn.exec(Wi),zt=function(r){if(!Vi(r))return!1;try{return Hi(Wi,pf,r),!0}catch{return!1}},Gi=function(r){if(!Vi(r))return!1;switch(of(r)){case"AsyncFunction":case"GeneratorFunction":case"AsyncGeneratorFunction":return!1}try{return Df||!!ff(wn,cf(r))}catch{return!0}};Gi.sham=!0;Ui.exports=!Hi||af(function(){var e;return zt(zt.call)||!zt(Object)||!zt(function(){e=!0})||e})?Gi:zt});var Yi=xe((Ey,Ki)=>{var zi=bn(),mf=Ji(),df=St(),gf=bt(),yf=gf("species"),Xi=Array;Ki.exports=function(e){var r;return zi(e)&&(r=e.constructor,mf(r)&&(r===Xi||zi(r.prototype))?r=void 0:df(r)&&(r=r[yf],r===null&&(r=void 0))),r===void 0?Xi:r}});var _n=xe((Fy,Qi)=>{var hf=Yi();Qi.exports=function(e,r){return new(hf(e))(r===0?0:r)}});var Zi=xe(()=>{"use strict";var vf=Jt(),Cf=Bn(),Ef=Ht(),Ff=yr(),Af=kt(),Sf=_n();vf({target:"Array",proto:!0},{flatMap:function(r){var t=Ff(this),s=Af(t),a;return Ef(r),a=Sf(t,0),a.length=Cf(a,t,t,s,0,1,r,arguments.length>1?arguments[1]:void 0),a}})});var Pn=xe((xy,ea)=>{ea.exports={}});var ra=xe((by,ta)=>{var xf=bt(),bf=Pn(),Tf=xf("iterator"),Bf=Array.prototype;ta.exports=function(e){return e!==void 0&&(bf.Array===e||Bf[Tf]===e)}});var In=xe((Ty,ua)=>{var Nf=Nn(),na=mr(),wf=cr(),_f=Pn(),Pf=bt(),If=Pf("iterator");ua.exports=function(e){if(!wf(e))return na(e,If)||na(e,"@@iterator")||_f[Nf(e)]}});var ia=xe((By,sa)=>{var kf=At(),Lf=Ht(),Of=Tt(),jf=Dr(),qf=In(),Mf=TypeError;sa.exports=function(e,r){var t=arguments.length<2?qf(e):r;if(Lf(t))return Of(kf(t,e));throw Mf(jf(e)+" is not iterable")}});var la=xe((Ny,oa)=>{var Rf=At(),aa=Tt(),$f=mr();oa.exports=function(e,r,t){var s,a;aa(e);try{if(s=$f(e,"return"),!s){if(r==="throw")throw t;return t}s=Rf(s,e)}catch(n){a=!0,s=n}if(r==="throw")throw t;if(a)throw s;return aa(s),t}});var ma=xe((wy,Da)=>{var Vf=Tn(),Wf=At(),Hf=Tt(),Gf=Dr(),Uf=ra(),Jf=kt(),ca=Xr(),zf=ia(),Xf=In(),pa=la(),Kf=TypeError,br=function(e,r){this.stopped=e,this.result=r},fa=br.prototype;Da.exports=function(e,r,t){var s=t&&t.that,a=!!(t&&t.AS_ENTRIES),n=!!(t&&t.IS_RECORD),u=!!(t&&t.IS_ITERATOR),i=!!(t&&t.INTERRUPTED),l=Vf(r,s),p,d,y,g,c,D,E,_=function(F){return p&&pa(p,"normal",F),new br(!0,F)},w=function(F){return a?(Hf(F),i?l(F[0],F[1],_):l(F[0],F[1])):i?l(F,_):l(F)};if(n)p=e.iterator;else if(u)p=e;else{if(d=Xf(e),!d)throw Kf(Gf(e)+" is not iterable");if(Uf(d)){for(y=0,g=Jf(e);g>y;y++)if(c=w(e[y]),c&&ca(fa,c))return c;return new br(!1)}p=zf(e,d)}for(D=n?e.next:p.next;!(E=Wf(D,p)).done;){try{c=w(E.value)}catch(F){pa(p,"throw",F)}if(typeof c=="object"&&c&&ca(fa,c))return c}return new br(!1)}});var ga=xe((_y,da)=>{"use strict";var Yf=hr(),Qf=It(),Zf=lr();da.exports=function(e,r,t){var s=Yf(r);s in e?Qf.f(e,s,Zf(0,t)):e[s]=t}});var ya=xe(()=>{var eD=Jt(),tD=ma(),rD=ga();eD({target:"Object",stat:!0},{fromEntries:function(r){var t={};return tD(r,function(s,a){rD(t,s,a)},{AS_ENTRIES:!0}),t}})});var Ca=xe((ky,va)=>{var ha=An(),nD=It();va.exports=function(e,r,t){return t.get&&ha(t.get,r,{getter:!0}),t.set&&ha(t.set,r,{setter:!0}),nD.f(e,r,t)}});var Fa=xe((Ly,Ea)=>{"use strict";var uD=Tt();Ea.exports=function(){var e=uD(this),r="";return e.hasIndices&&(r+="d"),e.global&&(r+="g"),e.ignoreCase&&(r+="i"),e.multiline&&(r+="m"),e.dotAll&&(r+="s"),e.unicode&&(r+="u"),e.unicodeSets&&(r+="v"),e.sticky&&(r+="y"),r}});var xa=xe(()=>{var sD=pt(),iD=yt(),aD=Ca(),oD=Fa(),lD=Dt(),Aa=sD.RegExp,Sa=Aa.prototype,cD=iD&&lD(function(){var e=!0;try{Aa(".","d")}catch{e=!1}var r={},t="",s=e?"dgimsy":"gimsy",a=function(l,p){Object.defineProperty(r,l,{get:function(){return t+=p,!0}})},n={dotAll:"s",global:"g",ignoreCase:"i",multiline:"m",sticky:"y"};e&&(n.hasIndices="d");for(var u in n)a(u,n[u]);var i=Object.getOwnPropertyDescriptor(Sa,"flags").get.call(r);return i!==s||t!==s});cD&&aD(Sa,"flags",{configurable:!0,get:oD})});var ba=xe(()=>{var pD=Jt(),kn=pt();pD({global:!0,forced:kn.globalThis!==kn},{globalThis:kn})});var Ta=xe(()=>{ba()});var Ba=xe(()=>{"use strict";var fD=Jt(),DD=Bn(),mD=yr(),dD=kt(),gD=Sr(),yD=_n();fD({target:"Array",proto:!0},{flat:function(){var r=arguments.length?arguments[0]:void 0,t=mD(this),s=dD(t),a=yD(t,0);return a.length=DD(a,t,t,s,0,r===void 0?1:gD(r)),a}})});var Zg=xe((Gy,jo)=>{var hD=["cliName","cliCategory","cliDescription"],vD=["_"],CD=["languageId"];function Hn(e,r){if(e==null)return{};var t=ED(e,r),s,a;if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(a=0;a<n.length;a++)s=n[a],!(r.indexOf(s)>=0)&&Object.prototype.propertyIsEnumerable.call(e,s)&&(t[s]=e[s])}return t}function ED(e,r){if(e==null)return{};var t={},s=Object.keys(e),a,n;for(n=0;n<s.length;n++)a=s[n],!(r.indexOf(a)>=0)&&(t[a]=e[a]);return t}Zi();ya();xa();Ta();Ba();var FD=Object.create,_r=Object.defineProperty,AD=Object.getOwnPropertyDescriptor,Gn=Object.getOwnPropertyNames,SD=Object.getPrototypeOf,xD=Object.prototype.hasOwnProperty,ht=(e,r)=>function(){return e&&(r=(0,e[Gn(e)[0]])(e=0)),r},te=(e,r)=>function(){return r||(0,e[Gn(e)[0]])((r={exports:{}}).exports,r),r.exports},Kt=(e,r)=>{for(var t in r)_r(e,t,{get:r[t],enumerable:!0})},Pa=(e,r,t,s)=>{if(r&&typeof r=="object"||typeof r=="function")for(let a of Gn(r))!xD.call(e,a)&&a!==t&&_r(e,a,{get:()=>r[a],enumerable:!(s=AD(r,a))||s.enumerable});return e},bD=(e,r,t)=>(t=e!=null?FD(SD(e)):{},Pa(r||!e||!e.__esModule?_r(t,"default",{value:e,enumerable:!0}):t,e)),ft=e=>Pa(_r({},"__esModule",{value:!0}),e),wt,ne=ht({"<define:process>"(){wt={env:{},argv:[]}}}),Ia=te({"package.json"(e,r){r.exports={version:"2.8.3"}}}),TD=te({"node_modules/diff/lib/diff/base.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0}),e.default=r;function r(){}r.prototype={diff:function(n,u){var i=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},l=i.callback;typeof i=="function"&&(l=i,i={}),this.options=i;var p=this;function d(S){return l?(setTimeout(function(){l(void 0,S)},0),!0):S}n=this.castInput(n),u=this.castInput(u),n=this.removeEmpty(this.tokenize(n)),u=this.removeEmpty(this.tokenize(u));var y=u.length,g=n.length,c=1,D=y+g,E=[{newPos:-1,components:[]}],_=this.extractCommon(E[0],u,n,0);if(E[0].newPos+1>=y&&_+1>=g)return d([{value:this.join(u),count:u.length}]);function w(){for(var S=-1*c;S<=c;S+=2){var N=void 0,I=E[S-1],P=E[S+1],$=(P?P.newPos:0)-S;I&&(E[S-1]=void 0);var f=I&&I.newPos+1<y,T=P&&0<=$&&$<g;if(!f&&!T){E[S]=void 0;continue}if(!f||T&&I.newPos<P.newPos?(N=s(P),p.pushComponent(N.components,void 0,!0)):(N=I,N.newPos++,p.pushComponent(N.components,!0,void 0)),$=p.extractCommon(N,u,n,S),N.newPos+1>=y&&$+1>=g)return d(t(p,N.components,u,n,p.useLongestToken));E[S]=N}c++}if(l)(function S(){setTimeout(function(){if(c>D)return l();w()||S()},0)})();else for(;c<=D;){var F=w();if(F)return F}},pushComponent:function(n,u,i){var l=n[n.length-1];l&&l.added===u&&l.removed===i?n[n.length-1]={count:l.count+1,added:u,removed:i}:n.push({count:1,added:u,removed:i})},extractCommon:function(n,u,i,l){for(var p=u.length,d=i.length,y=n.newPos,g=y-l,c=0;y+1<p&&g+1<d&&this.equals(u[y+1],i[g+1]);)y++,g++,c++;return c&&n.components.push({count:c}),n.newPos=y,g},equals:function(n,u){return this.options.comparator?this.options.comparator(n,u):n===u||this.options.ignoreCase&&n.toLowerCase()===u.toLowerCase()},removeEmpty:function(n){for(var u=[],i=0;i<n.length;i++)n[i]&&u.push(n[i]);return u},castInput:function(n){return n},tokenize:function(n){return n.split("")},join:function(n){return n.join("")}};function t(a,n,u,i,l){for(var p=0,d=n.length,y=0,g=0;p<d;p++){var c=n[p];if(c.removed){if(c.value=a.join(i.slice(g,g+c.count)),g+=c.count,p&&n[p-1].added){var E=n[p-1];n[p-1]=n[p],n[p]=E}}else{if(!c.added&&l){var D=u.slice(y,y+c.count);D=D.map(function(w,F){var S=i[g+F];return S.length>w.length?S:w}),c.value=a.join(D)}else c.value=a.join(u.slice(y,y+c.count));y+=c.count,c.added||(g+=c.count)}}var _=n[d-1];return d>1&&typeof _.value=="string"&&(_.added||_.removed)&&a.equals("",_.value)&&(n[d-2].value+=_.value,n.pop()),n}function s(a){return{newPos:a.newPos,components:a.components.slice(0)}}}}),BD=te({"node_modules/diff/lib/diff/array.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0}),e.diffArrays=a,e.arrayDiff=void 0;var r=t(TD());function t(n){return n&&n.__esModule?n:{default:n}}var s=new r.default;e.arrayDiff=s,s.tokenize=function(n){return n.slice()},s.join=s.removeEmpty=function(n){return n};function a(n,u,i){return s.diff(n,u,i)}}}),Un=te({"src/document/doc-builders.js"(e,r){"use strict";ne();function t(v){return{type:"concat",parts:v}}function s(v){return{type:"indent",contents:v}}function a(v,o){return{type:"align",contents:o,n:v}}function n(v){let o=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{};return{type:"group",id:o.id,contents:v,break:Boolean(o.shouldBreak),expandedStates:o.expandedStates}}function u(v){return a(Number.NEGATIVE_INFINITY,v)}function i(v){return a({type:"root"},v)}function l(v){return a(-1,v)}function p(v,o){return n(v[0],Object.assign(Object.assign({},o),{},{expandedStates:v}))}function d(v){return{type:"fill",parts:v}}function y(v,o){let h=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return{type:"if-break",breakContents:v,flatContents:o,groupId:h.groupId}}function g(v,o){return{type:"indent-if-break",contents:v,groupId:o.groupId,negate:o.negate}}function c(v){return{type:"line-suffix",contents:v}}var D={type:"line-suffix-boundary"},E={type:"break-parent"},_={type:"trim"},w={type:"line",hard:!0},F={type:"line",hard:!0,literal:!0},S={type:"line"},N={type:"line",soft:!0},I=t([w,E]),P=t([F,E]),$={type:"cursor",placeholder:Symbol("cursor")};function f(v,o){let h=[];for(let C=0;C<o.length;C++)C!==0&&h.push(v),h.push(o[C]);return t(h)}function T(v,o,h){let C=v;if(o>0){for(let x=0;x<Math.floor(o/h);++x)C=s(C);C=a(o%h,C),C=a(Number.NEGATIVE_INFINITY,C)}return C}function m(v,o){return{type:"label",label:v,contents:o}}r.exports={concat:t,join:f,line:S,softline:N,hardline:I,literalline:P,group:n,conditionalGroup:p,fill:d,lineSuffix:c,lineSuffixBoundary:D,cursor:$,breakParent:E,ifBreak:y,trim:_,indent:s,indentIfBreak:g,align:a,addAlignmentToDoc:T,markAsRoot:i,dedentToRoot:u,dedent:l,hardlineWithoutBreakParent:w,literallineWithoutBreakParent:F,label:m}}}),Jn=te({"src/common/end-of-line.js"(e,r){"use strict";ne();function t(u){let i=u.indexOf("\r");return i>=0?u.charAt(i+1)===`
`?"crlf":"cr":"lf"}function s(u){switch(u){case"cr":return"\r";case"crlf":return`\r
`;default:return`
`}}function a(u,i){let l;switch(i){case`
`:l=/\n/g;break;case"\r":l=/\r/g;break;case`\r
`:l=/\r\n/g;break;default:throw new Error(`Unexpected "eol" ${JSON.stringify(i)}.`)}let p=u.match(l);return p?p.length:0}function n(u){return u.replace(/\r\n?/g,`
`)}r.exports={guessEndOfLine:t,convertEndOfLineToChars:s,countEndOfLineChars:a,normalizeEndOfLine:n}}}),lt=te({"src/utils/get-last.js"(e,r){"use strict";ne();var t=s=>s[s.length-1];r.exports=t}});function ND(){let{onlyFirst:e=!1}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},r=["[\\u001B\\u009B][[\\]()#;?]*(?:(?:(?:(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]+)*|[a-zA-Z\\d]+(?:;[-a-zA-Z\\d\\/#&.:=?%@~_]*)*)?\\u0007)","(?:(?:\\d{1,4}(?:;\\d{0,4})*)?[\\dA-PR-TZcf-ntqry=><~]))"].join("|");return new RegExp(r,e?void 0:"g")}var wD=ht({"node_modules/strip-ansi/node_modules/ansi-regex/index.js"(){ne()}});function _D(e){if(typeof e!="string")throw new TypeError(`Expected a \`string\`, got \`${typeof e}\``);return e.replace(ND(),"")}var PD=ht({"node_modules/strip-ansi/index.js"(){ne(),wD()}});function ID(e){return Number.isInteger(e)?e>=4352&&(e<=4447||e===9001||e===9002||11904<=e&&e<=12871&&e!==12351||12880<=e&&e<=19903||19968<=e&&e<=42182||43360<=e&&e<=43388||44032<=e&&e<=55203||63744<=e&&e<=64255||65040<=e&&e<=65049||65072<=e&&e<=65131||65281<=e&&e<=65376||65504<=e&&e<=65510||110592<=e&&e<=110593||127488<=e&&e<=127569||131072<=e&&e<=262141):!1}var kD=ht({"node_modules/is-fullwidth-code-point/index.js"(){ne()}}),LD=te({"node_modules/emoji-regex/index.js"(e,r){"use strict";ne(),r.exports=function(){return/\uD83C\uDFF4\uDB40\uDC67\uDB40\uDC62(?:\uDB40\uDC77\uDB40\uDC6C\uDB40\uDC73|\uDB40\uDC73\uDB40\uDC63\uDB40\uDC74|\uDB40\uDC65\uDB40\uDC6E\uDB40\uDC67)\uDB40\uDC7F|(?:\uD83E\uDDD1\uD83C\uDFFF\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFF\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFE])|(?:\uD83E\uDDD1\uD83C\uDFFE\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFE\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFD\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFD\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFC\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFC\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|(?:\uD83E\uDDD1\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83E\uDDD1|\uD83D\uDC69\uD83C\uDFFB\u200D\uD83E\uDD1D\u200D(?:\uD83D[\uDC68\uDC69]))(?:\uD83C[\uDFFC-\uDFFF])|\uD83D\uDC68(?:\uD83C\uDFFB(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFC-\uDFFF])|[\u2695\u2696\u2708]\uFE0F|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))?|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFF]))|\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D)?\uD83D\uDC68|(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFE])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB-\uDFFD\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFC\uDFFE\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83E\uDD1D\u200D\uD83D\uDC68(?:\uD83C[\uDFFB\uDFFD-\uDFFF])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])\uFE0F|\u200D(?:(?:\uD83D[\uDC68\uDC69])\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D[\uDC66\uDC67])|\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC)?|(?:\uD83D\uDC69(?:\uD83C\uDFFB\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|(?:\uD83C[\uDFFC-\uDFFF])\u200D\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69]))|\uD83E\uDDD1(?:\uD83C[\uDFFB-\uDFFF])\u200D\uD83E\uDD1D\u200D\uD83E\uDDD1)(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67]))|\uD83D\uDC69(?:\u200D(?:\u2764\uFE0F\u200D(?:\uD83D\uDC8B\u200D(?:\uD83D[\uDC68\uDC69])|\uD83D[\uDC68\uDC69])|\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83E\uDDD1(?:\u200D(?:\uD83E\uDD1D\u200D\uD83E\uDDD1|\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFF\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFE\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFD\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFC\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD])|\uD83C\uDFFB\u200D(?:\uD83C[\uDF3E\uDF73\uDF7C\uDF84\uDF93\uDFA4\uDFA8\uDFEB\uDFED]|\uD83D[\uDCBB\uDCBC\uDD27\uDD2C\uDE80\uDE92]|\uD83E[\uDDAF-\uDDB3\uDDBC\uDDBD]))|\uD83D\uDC69\u200D\uD83D\uDC66\u200D\uD83D\uDC66|\uD83D\uDC69\u200D\uD83D\uDC69\u200D(?:\uD83D[\uDC66\uDC67])|\uD83D\uDC69\u200D\uD83D\uDC67\u200D(?:\uD83D[\uDC66\uDC67])|(?:\uD83D\uDC41\uFE0F\u200D\uD83D\uDDE8|\uD83E\uDDD1(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDC69(?:\uD83C\uDFFF\u200D[\u2695\u2696\u2708]|\uD83C\uDFFE\u200D[\u2695\u2696\u2708]|\uD83C\uDFFD\u200D[\u2695\u2696\u2708]|\uD83C\uDFFC\u200D[\u2695\u2696\u2708]|\uD83C\uDFFB\u200D[\u2695\u2696\u2708]|\u200D[\u2695\u2696\u2708])|\uD83D\uDE36\u200D\uD83C\uDF2B|\uD83C\uDFF3\uFE0F\u200D\u26A7|\uD83D\uDC3B\u200D\u2744|(?:(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF])\u200D[\u2640\u2642]|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])\u200D[\u2640\u2642]|\uD83C\uDFF4\u200D\u2620|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])\u200D[\u2640\u2642]|[\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u2328\u23CF\u23ED-\u23EF\u23F1\u23F2\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB\u25FC\u2600-\u2604\u260E\u2611\u2618\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u2692\u2694-\u2697\u2699\u269B\u269C\u26A0\u26A7\u26B0\u26B1\u26C8\u26CF\u26D1\u26D3\u26E9\u26F0\u26F1\u26F4\u26F7\u26F8\u2702\u2708\u2709\u270F\u2712\u2714\u2716\u271D\u2721\u2733\u2734\u2744\u2747\u2763\u27A1\u2934\u2935\u2B05-\u2B07\u3030\u303D\u3297\u3299]|\uD83C[\uDD70\uDD71\uDD7E\uDD7F\uDE02\uDE37\uDF21\uDF24-\uDF2C\uDF36\uDF7D\uDF96\uDF97\uDF99-\uDF9B\uDF9E\uDF9F\uDFCD\uDFCE\uDFD4-\uDFDF\uDFF5\uDFF7]|\uD83D[\uDC3F\uDCFD\uDD49\uDD4A\uDD6F\uDD70\uDD73\uDD76-\uDD79\uDD87\uDD8A-\uDD8D\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA\uDECB\uDECD-\uDECF\uDEE0-\uDEE5\uDEE9\uDEF0\uDEF3])\uFE0F|\uD83C\uDFF3\uFE0F\u200D\uD83C\uDF08|\uD83D\uDC69\u200D\uD83D\uDC67|\uD83D\uDC69\u200D\uD83D\uDC66|\uD83D\uDE35\u200D\uD83D\uDCAB|\uD83D\uDE2E\u200D\uD83D\uDCA8|\uD83D\uDC15\u200D\uD83E\uDDBA|\uD83E\uDDD1(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83D\uDC69(?:\uD83C\uDFFF|\uD83C\uDFFE|\uD83C\uDFFD|\uD83C\uDFFC|\uD83C\uDFFB)?|\uD83C\uDDFD\uD83C\uDDF0|\uD83C\uDDF6\uD83C\uDDE6|\uD83C\uDDF4\uD83C\uDDF2|\uD83D\uDC08\u200D\u2B1B|\u2764\uFE0F\u200D(?:\uD83D\uDD25|\uD83E\uDE79)|\uD83D\uDC41\uFE0F|\uD83C\uDFF3\uFE0F|\uD83C\uDDFF(?:\uD83C[\uDDE6\uDDF2\uDDFC])|\uD83C\uDDFE(?:\uD83C[\uDDEA\uDDF9])|\uD83C\uDDFC(?:\uD83C[\uDDEB\uDDF8])|\uD83C\uDDFB(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDEE\uDDF3\uDDFA])|\uD83C\uDDFA(?:\uD83C[\uDDE6\uDDEC\uDDF2\uDDF3\uDDF8\uDDFE\uDDFF])|\uD83C\uDDF9(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDED\uDDEF-\uDDF4\uDDF7\uDDF9\uDDFB\uDDFC\uDDFF])|\uD83C\uDDF8(?:\uD83C[\uDDE6-\uDDEA\uDDEC-\uDDF4\uDDF7-\uDDF9\uDDFB\uDDFD-\uDDFF])|\uD83C\uDDF7(?:\uD83C[\uDDEA\uDDF4\uDDF8\uDDFA\uDDFC])|\uD83C\uDDF5(?:\uD83C[\uDDE6\uDDEA-\uDDED\uDDF0-\uDDF3\uDDF7-\uDDF9\uDDFC\uDDFE])|\uD83C\uDDF3(?:\uD83C[\uDDE6\uDDE8\uDDEA-\uDDEC\uDDEE\uDDF1\uDDF4\uDDF5\uDDF7\uDDFA\uDDFF])|\uD83C\uDDF2(?:\uD83C[\uDDE6\uDDE8-\uDDED\uDDF0-\uDDFF])|\uD83C\uDDF1(?:\uD83C[\uDDE6-\uDDE8\uDDEE\uDDF0\uDDF7-\uDDFB\uDDFE])|\uD83C\uDDF0(?:\uD83C[\uDDEA\uDDEC-\uDDEE\uDDF2\uDDF3\uDDF5\uDDF7\uDDFC\uDDFE\uDDFF])|\uD83C\uDDEF(?:\uD83C[\uDDEA\uDDF2\uDDF4\uDDF5])|\uD83C\uDDEE(?:\uD83C[\uDDE8-\uDDEA\uDDF1-\uDDF4\uDDF6-\uDDF9])|\uD83C\uDDED(?:\uD83C[\uDDF0\uDDF2\uDDF3\uDDF7\uDDF9\uDDFA])|\uD83C\uDDEC(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEE\uDDF1-\uDDF3\uDDF5-\uDDFA\uDDFC\uDDFE])|\uD83C\uDDEB(?:\uD83C[\uDDEE-\uDDF0\uDDF2\uDDF4\uDDF7])|\uD83C\uDDEA(?:\uD83C[\uDDE6\uDDE8\uDDEA\uDDEC\uDDED\uDDF7-\uDDFA])|\uD83C\uDDE9(?:\uD83C[\uDDEA\uDDEC\uDDEF\uDDF0\uDDF2\uDDF4\uDDFF])|\uD83C\uDDE8(?:\uD83C[\uDDE6\uDDE8\uDDE9\uDDEB-\uDDEE\uDDF0-\uDDF5\uDDF7\uDDFA-\uDDFF])|\uD83C\uDDE7(?:\uD83C[\uDDE6\uDDE7\uDDE9-\uDDEF\uDDF1-\uDDF4\uDDF6-\uDDF9\uDDFB\uDDFC\uDDFE\uDDFF])|\uD83C\uDDE6(?:\uD83C[\uDDE8-\uDDEC\uDDEE\uDDF1\uDDF2\uDDF4\uDDF6-\uDDFA\uDDFC\uDDFD\uDDFF])|[#\*0-9]\uFE0F\u20E3|\u2764\uFE0F|(?:\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD])(?:\uD83C[\uDFFB-\uDFFF])|(?:\u26F9|\uD83C[\uDFCB\uDFCC]|\uD83D\uDD75)(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|\uD83C\uDFF4|(?:[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5])(?:\uD83C[\uDFFB-\uDFFF])|(?:[\u261D\u270C\u270D]|\uD83D[\uDD74\uDD90])(?:\uFE0F|\uD83C[\uDFFB-\uDFFF])|[\u270A\u270B]|\uD83C[\uDF85\uDFC2\uDFC7]|\uD83D[\uDC08\uDC15\uDC3B\uDC42\uDC43\uDC46-\uDC50\uDC66\uDC67\uDC6B-\uDC6D\uDC72\uDC74-\uDC76\uDC78\uDC7C\uDC83\uDC85\uDC8F\uDC91\uDCAA\uDD7A\uDD95\uDD96\uDE2E\uDE35\uDE36\uDE4C\uDE4F\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1C\uDD1E\uDD1F\uDD30-\uDD34\uDD36\uDD77\uDDB5\uDDB6\uDDBB\uDDD2\uDDD3\uDDD5]|\uD83C[\uDFC3\uDFC4\uDFCA]|\uD83D[\uDC6E\uDC70\uDC71\uDC73\uDC77\uDC81\uDC82\uDC86\uDC87\uDE45-\uDE47\uDE4B\uDE4D\uDE4E\uDEA3\uDEB4-\uDEB6]|\uD83E[\uDD26\uDD35\uDD37-\uDD39\uDD3D\uDD3E\uDDB8\uDDB9\uDDCD-\uDDCF\uDDD4\uDDD6-\uDDDD]|\uD83D\uDC6F|\uD83E[\uDD3C\uDDDE\uDDDF]|[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF84\uDF86-\uDF93\uDFA0-\uDFC1\uDFC5\uDFC6\uDFC8\uDFC9\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC07\uDC09-\uDC14\uDC16-\uDC3A\uDC3C-\uDC3E\uDC40\uDC44\uDC45\uDC51-\uDC65\uDC6A\uDC79-\uDC7B\uDC7D-\uDC80\uDC84\uDC88-\uDC8E\uDC90\uDC92-\uDCA9\uDCAB-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDDA4\uDDFB-\uDE2D\uDE2F-\uDE34\uDE37-\uDE44\uDE48-\uDE4A\uDE80-\uDEA2\uDEA4-\uDEB3\uDEB7-\uDEBF\uDEC1-\uDEC5\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0D\uDD0E\uDD10-\uDD17\uDD1D\uDD20-\uDD25\uDD27-\uDD2F\uDD3A\uDD3F-\uDD45\uDD47-\uDD76\uDD78\uDD7A-\uDDB4\uDDB7\uDDBA\uDDBC-\uDDCB\uDDD0\uDDE0-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6]|(?:[\u231A\u231B\u23E9-\u23EC\u23F0\u23F3\u25FD\u25FE\u2614\u2615\u2648-\u2653\u267F\u2693\u26A1\u26AA\u26AB\u26BD\u26BE\u26C4\u26C5\u26CE\u26D4\u26EA\u26F2\u26F3\u26F5\u26FA\u26FD\u2705\u270A\u270B\u2728\u274C\u274E\u2753-\u2755\u2757\u2795-\u2797\u27B0\u27BF\u2B1B\u2B1C\u2B50\u2B55]|\uD83C[\uDC04\uDCCF\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE1A\uDE2F\uDE32-\uDE36\uDE38-\uDE3A\uDE50\uDE51\uDF00-\uDF20\uDF2D-\uDF35\uDF37-\uDF7C\uDF7E-\uDF93\uDFA0-\uDFCA\uDFCF-\uDFD3\uDFE0-\uDFF0\uDFF4\uDFF8-\uDFFF]|\uD83D[\uDC00-\uDC3E\uDC40\uDC42-\uDCFC\uDCFF-\uDD3D\uDD4B-\uDD4E\uDD50-\uDD67\uDD7A\uDD95\uDD96\uDDA4\uDDFB-\uDE4F\uDE80-\uDEC5\uDECC\uDED0-\uDED2\uDED5-\uDED7\uDEEB\uDEEC\uDEF4-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])|(?:[#\*0-9\xA9\xAE\u203C\u2049\u2122\u2139\u2194-\u2199\u21A9\u21AA\u231A\u231B\u2328\u23CF\u23E9-\u23F3\u23F8-\u23FA\u24C2\u25AA\u25AB\u25B6\u25C0\u25FB-\u25FE\u2600-\u2604\u260E\u2611\u2614\u2615\u2618\u261D\u2620\u2622\u2623\u2626\u262A\u262E\u262F\u2638-\u263A\u2640\u2642\u2648-\u2653\u265F\u2660\u2663\u2665\u2666\u2668\u267B\u267E\u267F\u2692-\u2697\u2699\u269B\u269C\u26A0\u26A1\u26A7\u26AA\u26AB\u26B0\u26B1\u26BD\u26BE\u26C4\u26C5\u26C8\u26CE\u26CF\u26D1\u26D3\u26D4\u26E9\u26EA\u26F0-\u26F5\u26F7-\u26FA\u26FD\u2702\u2705\u2708-\u270D\u270F\u2712\u2714\u2716\u271D\u2721\u2728\u2733\u2734\u2744\u2747\u274C\u274E\u2753-\u2755\u2757\u2763\u2764\u2795-\u2797\u27A1\u27B0\u27BF\u2934\u2935\u2B05-\u2B07\u2B1B\u2B1C\u2B50\u2B55\u3030\u303D\u3297\u3299]|\uD83C[\uDC04\uDCCF\uDD70\uDD71\uDD7E\uDD7F\uDD8E\uDD91-\uDD9A\uDDE6-\uDDFF\uDE01\uDE02\uDE1A\uDE2F\uDE32-\uDE3A\uDE50\uDE51\uDF00-\uDF21\uDF24-\uDF93\uDF96\uDF97\uDF99-\uDF9B\uDF9E-\uDFF0\uDFF3-\uDFF5\uDFF7-\uDFFF]|\uD83D[\uDC00-\uDCFD\uDCFF-\uDD3D\uDD49-\uDD4E\uDD50-\uDD67\uDD6F\uDD70\uDD73-\uDD7A\uDD87\uDD8A-\uDD8D\uDD90\uDD95\uDD96\uDDA4\uDDA5\uDDA8\uDDB1\uDDB2\uDDBC\uDDC2-\uDDC4\uDDD1-\uDDD3\uDDDC-\uDDDE\uDDE1\uDDE3\uDDE8\uDDEF\uDDF3\uDDFA-\uDE4F\uDE80-\uDEC5\uDECB-\uDED2\uDED5-\uDED7\uDEE0-\uDEE5\uDEE9\uDEEB\uDEEC\uDEF0\uDEF3-\uDEFC\uDFE0-\uDFEB]|\uD83E[\uDD0C-\uDD3A\uDD3C-\uDD45\uDD47-\uDD78\uDD7A-\uDDCB\uDDCD-\uDDFF\uDE70-\uDE74\uDE78-\uDE7A\uDE80-\uDE86\uDE90-\uDEA8\uDEB0-\uDEB6\uDEC0-\uDEC2\uDED0-\uDED6])\uFE0F|(?:[\u261D\u26F9\u270A-\u270D]|\uD83C[\uDF85\uDFC2-\uDFC4\uDFC7\uDFCA-\uDFCC]|\uD83D[\uDC42\uDC43\uDC46-\uDC50\uDC66-\uDC78\uDC7C\uDC81-\uDC83\uDC85-\uDC87\uDC8F\uDC91\uDCAA\uDD74\uDD75\uDD7A\uDD90\uDD95\uDD96\uDE45-\uDE47\uDE4B-\uDE4F\uDEA3\uDEB4-\uDEB6\uDEC0\uDECC]|\uD83E[\uDD0C\uDD0F\uDD18-\uDD1F\uDD26\uDD30-\uDD39\uDD3C-\uDD3E\uDD77\uDDB5\uDDB6\uDDB8\uDDB9\uDDBB\uDDCD-\uDDCF\uDDD1-\uDDDD])/g}}}),ka={};Kt(ka,{default:()=>OD});function OD(e){if(typeof e!="string"||e.length===0||(e=_D(e),e.length===0))return 0;e=e.replace((0,La.default)(),"  ");let r=0;for(let t=0;t<e.length;t++){let s=e.codePointAt(t);s<=31||s>=127&&s<=159||s>=768&&s<=879||(s>65535&&t++,r+=ID(s)?2:1)}return r}var La,jD=ht({"node_modules/string-width/index.js"(){ne(),PD(),kD(),La=bD(LD())}}),Oa=te({"src/utils/get-string-width.js"(e,r){"use strict";ne();var t=(jD(),ft(ka)).default,s=/[^\x20-\x7F]/;function a(n){return n?s.test(n)?t(n):n.length:0}r.exports=a}}),Yt=te({"src/document/doc-utils.js"(e,r){"use strict";ne();var t=lt(),{literalline:s,join:a}=Un(),n=o=>Array.isArray(o)||o&&o.type==="concat",u=o=>{if(Array.isArray(o))return o;if(o.type!=="concat"&&o.type!=="fill")throw new Error("Expect doc type to be `concat` or `fill`.");return o.parts},i={};function l(o,h,C,x){let b=[o];for(;b.length>0;){let B=b.pop();if(B===i){C(b.pop());continue}if(C&&b.push(B,i),!h||h(B)!==!1)if(n(B)||B.type==="fill"){let k=u(B);for(let M=k.length,R=M-1;R>=0;--R)b.push(k[R])}else if(B.type==="if-break")B.flatContents&&b.push(B.flatContents),B.breakContents&&b.push(B.breakContents);else if(B.type==="group"&&B.expandedStates)if(x)for(let k=B.expandedStates.length,M=k-1;M>=0;--M)b.push(B.expandedStates[M]);else b.push(B.contents);else B.contents&&b.push(B.contents)}}function p(o,h){let C=new Map;return x(o);function x(B){if(C.has(B))return C.get(B);let k=b(B);return C.set(B,k),k}function b(B){if(Array.isArray(B))return h(B.map(x));if(B.type==="concat"||B.type==="fill"){let k=B.parts.map(x);return h(Object.assign(Object.assign({},B),{},{parts:k}))}if(B.type==="if-break"){let k=B.breakContents&&x(B.breakContents),M=B.flatContents&&x(B.flatContents);return h(Object.assign(Object.assign({},B),{},{breakContents:k,flatContents:M}))}if(B.type==="group"&&B.expandedStates){let k=B.expandedStates.map(x),M=k[0];return h(Object.assign(Object.assign({},B),{},{contents:M,expandedStates:k}))}if(B.contents){let k=x(B.contents);return h(Object.assign(Object.assign({},B),{},{contents:k}))}return h(B)}}function d(o,h,C){let x=C,b=!1;function B(k){let M=h(k);if(M!==void 0&&(b=!0,x=M),b)return!1}return l(o,B),x}function y(o){if(o.type==="group"&&o.break||o.type==="line"&&o.hard||o.type==="break-parent")return!0}function g(o){return d(o,y,!1)}function c(o){if(o.length>0){let h=t(o);!h.expandedStates&&!h.break&&(h.break="propagated")}return null}function D(o){let h=new Set,C=[];function x(B){if(B.type==="break-parent"&&c(C),B.type==="group"){if(C.push(B),h.has(B))return!1;h.add(B)}}function b(B){B.type==="group"&&C.pop().break&&c(C)}l(o,x,b,!0)}function E(o){return o.type==="line"&&!o.hard?o.soft?"":" ":o.type==="if-break"?o.flatContents||"":o}function _(o){return p(o,E)}var w=(o,h)=>o&&o.type==="line"&&o.hard&&h&&h.type==="break-parent";function F(o){if(!o)return o;if(n(o)||o.type==="fill"){let h=u(o);for(;h.length>1&&w(...h.slice(-2));)h.length-=2;if(h.length>0){let C=F(t(h));h[h.length-1]=C}return Array.isArray(o)?h:Object.assign(Object.assign({},o),{},{parts:h})}switch(o.type){case"align":case"indent":case"indent-if-break":case"group":case"line-suffix":case"label":{let h=F(o.contents);return Object.assign(Object.assign({},o),{},{contents:h})}case"if-break":{let h=F(o.breakContents),C=F(o.flatContents);return Object.assign(Object.assign({},o),{},{breakContents:h,flatContents:C})}}return o}function S(o){return F(I(o))}function N(o){switch(o.type){case"fill":if(o.parts.every(C=>C===""))return"";break;case"group":if(!o.contents&&!o.id&&!o.break&&!o.expandedStates)return"";if(o.contents.type==="group"&&o.contents.id===o.id&&o.contents.break===o.break&&o.contents.expandedStates===o.expandedStates)return o.contents;break;case"align":case"indent":case"indent-if-break":case"line-suffix":if(!o.contents)return"";break;case"if-break":if(!o.flatContents&&!o.breakContents)return"";break}if(!n(o))return o;let h=[];for(let C of u(o)){if(!C)continue;let[x,...b]=n(C)?u(C):[C];typeof x=="string"&&typeof t(h)=="string"?h[h.length-1]+=x:h.push(x),h.push(...b)}return h.length===0?"":h.length===1?h[0]:Array.isArray(o)?h:Object.assign(Object.assign({},o),{},{parts:h})}function I(o){return p(o,h=>N(h))}function P(o){let h=[],C=o.filter(Boolean);for(;C.length>0;){let x=C.shift();if(x){if(n(x)){C.unshift(...u(x));continue}if(h.length>0&&typeof t(h)=="string"&&typeof x=="string"){h[h.length-1]+=x;continue}h.push(x)}}return h}function $(o){return p(o,h=>Array.isArray(h)?P(h):h.parts?Object.assign(Object.assign({},h),{},{parts:P(h.parts)}):h)}function f(o){return p(o,h=>typeof h=="string"&&h.includes(`
`)?T(h):h)}function T(o){let h=arguments.length>1&&arguments[1]!==void 0?arguments[1]:s;return a(h,o.split(`
`)).parts}function m(o){if(o.type==="line")return!0}function v(o){return d(o,m,!1)}r.exports={isConcat:n,getDocParts:u,willBreak:g,traverseDoc:l,findInDoc:d,mapDoc:p,propagateBreaks:D,removeLines:_,stripTrailingHardline:S,normalizeParts:P,normalizeDoc:$,cleanDoc:I,replaceTextEndOfLine:T,replaceEndOfLine:f,canBreak:v}}}),qD=te({"src/document/doc-printer.js"(e,r){"use strict";ne();var{convertEndOfLineToChars:t}=Jn(),s=lt(),a=Oa(),{fill:n,cursor:u,indent:i}=Un(),{isConcat:l,getDocParts:p}=Yt(),d,y=1,g=2;function c(){return{value:"",length:0,queue:[]}}function D(N,I){return _(N,{type:"indent"},I)}function E(N,I,P){return I===Number.NEGATIVE_INFINITY?N.root||c():I<0?_(N,{type:"dedent"},P):I?I.type==="root"?Object.assign(Object.assign({},N),{},{root:N}):_(N,{type:typeof I=="string"?"stringAlign":"numberAlign",n:I},P):N}function _(N,I,P){let $=I.type==="dedent"?N.queue.slice(0,-1):[...N.queue,I],f="",T=0,m=0,v=0;for(let k of $)switch(k.type){case"indent":C(),P.useTabs?o(1):h(P.tabWidth);break;case"stringAlign":C(),f+=k.n,T+=k.n.length;break;case"numberAlign":m+=1,v+=k.n;break;default:throw new Error(`Unexpected type '${k.type}'`)}return b(),Object.assign(Object.assign({},N),{},{value:f,length:T,queue:$});function o(k){f+="	".repeat(k),T+=P.tabWidth*k}function h(k){f+=" ".repeat(k),T+=k}function C(){P.useTabs?x():b()}function x(){m>0&&o(m),B()}function b(){v>0&&h(v),B()}function B(){m=0,v=0}}function w(N){if(N.length===0)return 0;let I=0;for(;N.length>0&&typeof s(N)=="string"&&/^[\t ]*$/.test(s(N));)I+=N.pop().length;if(N.length>0&&typeof s(N)=="string"){let P=s(N).replace(/[\t ]*$/,"");I+=s(N).length-P.length,N[N.length-1]=P}return I}function F(N,I,P,$,f){let T=I.length,m=[N],v=[];for(;P>=0;){if(m.length===0){if(T===0)return!0;m.push(I[--T]);continue}let{mode:o,doc:h}=m.pop();if(typeof h=="string")v.push(h),P-=a(h);else if(l(h)||h.type==="fill"){let C=p(h);for(let x=C.length-1;x>=0;x--)m.push({mode:o,doc:C[x]})}else switch(h.type){case"indent":case"align":case"indent-if-break":case"label":m.push({mode:o,doc:h.contents});break;case"trim":P+=w(v);break;case"group":{if(f&&h.break)return!1;let C=h.break?y:o,x=h.expandedStates&&C===y?s(h.expandedStates):h.contents;m.push({mode:C,doc:x});break}case"if-break":{let x=(h.groupId?d[h.groupId]||g:o)===y?h.breakContents:h.flatContents;x&&m.push({mode:o,doc:x});break}case"line":if(o===y||h.hard)return!0;h.soft||(v.push(" "),P--);break;case"line-suffix":$=!0;break;case"line-suffix-boundary":if($)return!1;break}}return!1}function S(N,I){d={};let P=I.printWidth,$=t(I.endOfLine),f=0,T=[{ind:c(),mode:y,doc:N}],m=[],v=!1,o=[];for(;T.length>0;){let{ind:C,mode:x,doc:b}=T.pop();if(typeof b=="string"){let B=$!==`
`?b.replace(/\n/g,$):b;m.push(B),f+=a(B)}else if(l(b)){let B=p(b);for(let k=B.length-1;k>=0;k--)T.push({ind:C,mode:x,doc:B[k]})}else switch(b.type){case"cursor":m.push(u.placeholder);break;case"indent":T.push({ind:D(C,I),mode:x,doc:b.contents});break;case"align":T.push({ind:E(C,b.n,I),mode:x,doc:b.contents});break;case"trim":f-=w(m);break;case"group":switch(x){case g:if(!v){T.push({ind:C,mode:b.break?y:g,doc:b.contents});break}case y:{v=!1;let B={ind:C,mode:g,doc:b.contents},k=P-f,M=o.length>0;if(!b.break&&F(B,T,k,M))T.push(B);else if(b.expandedStates){let R=s(b.expandedStates);if(b.break){T.push({ind:C,mode:y,doc:R});break}else for(let q=1;q<b.expandedStates.length+1;q++)if(q>=b.expandedStates.length){T.push({ind:C,mode:y,doc:R});break}else{let J=b.expandedStates[q],L={ind:C,mode:g,doc:J};if(F(L,T,k,M)){T.push(L);break}}}else T.push({ind:C,mode:y,doc:b.contents});break}}b.id&&(d[b.id]=s(T).mode);break;case"fill":{let B=P-f,{parts:k}=b;if(k.length===0)break;let[M,R]=k,q={ind:C,mode:g,doc:M},J={ind:C,mode:y,doc:M},L=F(q,[],B,o.length>0,!0);if(k.length===1){L?T.push(q):T.push(J);break}let Q={ind:C,mode:g,doc:R},V={ind:C,mode:y,doc:R};if(k.length===2){L?T.push(Q,q):T.push(V,J);break}k.splice(0,2);let j={ind:C,mode:x,doc:n(k)},Y=k[0];F({ind:C,mode:g,doc:[M,R,Y]},[],B,o.length>0,!0)?T.push(j,Q,q):L?T.push(j,V,q):T.push(j,V,J);break}case"if-break":case"indent-if-break":{let B=b.groupId?d[b.groupId]:x;if(B===y){let k=b.type==="if-break"?b.breakContents:b.negate?b.contents:i(b.contents);k&&T.push({ind:C,mode:x,doc:k})}if(B===g){let k=b.type==="if-break"?b.flatContents:b.negate?i(b.contents):b.contents;k&&T.push({ind:C,mode:x,doc:k})}break}case"line-suffix":o.push({ind:C,mode:x,doc:b.contents});break;case"line-suffix-boundary":o.length>0&&T.push({ind:C,mode:x,doc:{type:"line",hard:!0}});break;case"line":switch(x){case g:if(b.hard)v=!0;else{b.soft||(m.push(" "),f+=1);break}case y:if(o.length>0){T.push({ind:C,mode:x,doc:b},...o.reverse()),o.length=0;break}b.literal?C.root?(m.push($,C.root.value),f=C.root.length):(m.push($),f=0):(f-=w(m),m.push($+C.value),f=C.length);break}break;case"label":T.push({ind:C,mode:x,doc:b.contents});break;default:}T.length===0&&o.length>0&&(T.push(...o.reverse()),o.length=0)}let h=m.indexOf(u.placeholder);if(h!==-1){let C=m.indexOf(u.placeholder,h+1),x=m.slice(0,h).join(""),b=m.slice(h+1,C).join(""),B=m.slice(C+1).join("");return{formatted:x+b+B,cursorNodeStart:x.length,cursorNodeText:b}}return{formatted:m.join("")}}r.exports={printDocToString:S}}}),MD=te({"src/document/doc-debug.js"(e,r){"use strict";ne();var{isConcat:t,getDocParts:s}=Yt();function a(u){if(!u)return"";if(t(u)){let i=[];for(let l of s(u))if(t(l))i.push(...a(l).parts);else{let p=a(l);p!==""&&i.push(p)}return{type:"concat",parts:i}}return u.type==="if-break"?Object.assign(Object.assign({},u),{},{breakContents:a(u.breakContents),flatContents:a(u.flatContents)}):u.type==="group"?Object.assign(Object.assign({},u),{},{contents:a(u.contents),expandedStates:u.expandedStates&&u.expandedStates.map(a)}):u.type==="fill"?{type:"fill",parts:u.parts.map(a)}:u.contents?Object.assign(Object.assign({},u),{},{contents:a(u.contents)}):u}function n(u){let i=Object.create(null),l=new Set;return p(a(u));function p(y,g,c){if(typeof y=="string")return JSON.stringify(y);if(t(y)){let D=s(y).map(p).filter(Boolean);return D.length===1?D[0]:`[${D.join(", ")}]`}if(y.type==="line"){let D=Array.isArray(c)&&c[g+1]&&c[g+1].type==="break-parent";return y.literal?D?"literalline":"literallineWithoutBreakParent":y.hard?D?"hardline":"hardlineWithoutBreakParent":y.soft?"softline":"line"}if(y.type==="break-parent")return Array.isArray(c)&&c[g-1]&&c[g-1].type==="line"&&c[g-1].hard?void 0:"breakParent";if(y.type==="trim")return"trim";if(y.type==="indent")return"indent("+p(y.contents)+")";if(y.type==="align")return y.n===Number.NEGATIVE_INFINITY?"dedentToRoot("+p(y.contents)+")":y.n<0?"dedent("+p(y.contents)+")":y.n.type==="root"?"markAsRoot("+p(y.contents)+")":"align("+JSON.stringify(y.n)+", "+p(y.contents)+")";if(y.type==="if-break")return"ifBreak("+p(y.breakContents)+(y.flatContents?", "+p(y.flatContents):"")+(y.groupId?(y.flatContents?"":', ""')+`, { groupId: ${d(y.groupId)} }`:"")+")";if(y.type==="indent-if-break"){let D=[];y.negate&&D.push("negate: true"),y.groupId&&D.push(`groupId: ${d(y.groupId)}`);let E=D.length>0?`, { ${D.join(", ")} }`:"";return`indentIfBreak(${p(y.contents)}${E})`}if(y.type==="group"){let D=[];y.break&&y.break!=="propagated"&&D.push("shouldBreak: true"),y.id&&D.push(`id: ${d(y.id)}`);let E=D.length>0?`, { ${D.join(", ")} }`:"";return y.expandedStates?`conditionalGroup([${y.expandedStates.map(_=>p(_)).join(",")}]${E})`:`group(${p(y.contents)}${E})`}if(y.type==="fill")return`fill([${y.parts.map(D=>p(D)).join(", ")}])`;if(y.type==="line-suffix")return"lineSuffix("+p(y.contents)+")";if(y.type==="line-suffix-boundary")return"lineSuffixBoundary";if(y.type==="label")return`label(${JSON.stringify(y.label)}, ${p(y.contents)})`;throw new Error("Unknown doc type "+y.type)}function d(y){if(typeof y!="symbol")return JSON.stringify(String(y));if(y in i)return i[y];let g=String(y).slice(7,-1)||"symbol";for(let c=0;;c++){let D=g+(c>0?` #${c}`:"");if(!l.has(D))return l.add(D),i[y]=`Symbol.for(${JSON.stringify(D)})`}}}r.exports={printDocToDebug:n}}}),qe=te({"src/document/index.js"(e,r){"use strict";ne(),r.exports={builders:Un(),printer:qD(),utils:Yt(),debug:MD()}}}),ja={};Kt(ja,{default:()=>RD});function RD(e){if(typeof e!="string")throw new TypeError("Expected a string");return e.replace(/[|\\{}()[\]^$+*?.]/g,"\\$&").replace(/-/g,"\\x2d")}var $D=ht({"node_modules/escape-string-regexp/index.js"(){ne()}}),qa=te({"node_modules/semver/internal/debug.js"(e,r){ne();var t=typeof wt=="object"&&wt.env&&wt.env.NODE_DEBUG&&/\bsemver\b/i.test(wt.env.NODE_DEBUG)?function(){for(var s=arguments.length,a=new Array(s),n=0;n<s;n++)a[n]=arguments[n];return console.error("SEMVER",...a)}:()=>{};r.exports=t}}),Ma=te({"node_modules/semver/internal/constants.js"(e,r){ne();var t="2.0.0",s=256,a=Number.MAX_SAFE_INTEGER||9007199254740991,n=16;r.exports={SEMVER_SPEC_VERSION:t,MAX_LENGTH:s,MAX_SAFE_INTEGER:a,MAX_SAFE_COMPONENT_LENGTH:n}}}),VD=te({"node_modules/semver/internal/re.js"(e,r){ne();var{MAX_SAFE_COMPONENT_LENGTH:t}=Ma(),s=qa();e=r.exports={};var a=e.re=[],n=e.src=[],u=e.t={},i=0,l=(p,d,y)=>{let g=i++;s(p,g,d),u[p]=g,n[g]=d,a[g]=new RegExp(d,y?"g":void 0)};l("NUMERICIDENTIFIER","0|[1-9]\\d*"),l("NUMERICIDENTIFIERLOOSE","[0-9]+"),l("NONNUMERICIDENTIFIER","\\d*[a-zA-Z-][a-zA-Z0-9-]*"),l("MAINVERSION",`(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})\\.(${n[u.NUMERICIDENTIFIER]})`),l("MAINVERSIONLOOSE",`(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})\\.(${n[u.NUMERICIDENTIFIERLOOSE]})`),l("PRERELEASEIDENTIFIER",`(?:${n[u.NUMERICIDENTIFIER]}|${n[u.NONNUMERICIDENTIFIER]})`),l("PRERELEASEIDENTIFIERLOOSE",`(?:${n[u.NUMERICIDENTIFIERLOOSE]}|${n[u.NONNUMERICIDENTIFIER]})`),l("PRERELEASE",`(?:-(${n[u.PRERELEASEIDENTIFIER]}(?:\\.${n[u.PRERELEASEIDENTIFIER]})*))`),l("PRERELEASELOOSE",`(?:-?(${n[u.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${n[u.PRERELEASEIDENTIFIERLOOSE]})*))`),l("BUILDIDENTIFIER","[0-9A-Za-z-]+"),l("BUILD",`(?:\\+(${n[u.BUILDIDENTIFIER]}(?:\\.${n[u.BUILDIDENTIFIER]})*))`),l("FULLPLAIN",`v?${n[u.MAINVERSION]}${n[u.PRERELEASE]}?${n[u.BUILD]}?`),l("FULL",`^${n[u.FULLPLAIN]}$`),l("LOOSEPLAIN",`[v=\\s]*${n[u.MAINVERSIONLOOSE]}${n[u.PRERELEASELOOSE]}?${n[u.BUILD]}?`),l("LOOSE",`^${n[u.LOOSEPLAIN]}$`),l("GTLT","((?:<|>)?=?)"),l("XRANGEIDENTIFIERLOOSE",`${n[u.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`),l("XRANGEIDENTIFIER",`${n[u.NUMERICIDENTIFIER]}|x|X|\\*`),l("XRANGEPLAIN",`[v=\\s]*(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:\\.(${n[u.XRANGEIDENTIFIER]})(?:${n[u.PRERELEASE]})?${n[u.BUILD]}?)?)?`),l("XRANGEPLAINLOOSE",`[v=\\s]*(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:\\.(${n[u.XRANGEIDENTIFIERLOOSE]})(?:${n[u.PRERELEASELOOSE]})?${n[u.BUILD]}?)?)?`),l("XRANGE",`^${n[u.GTLT]}\\s*${n[u.XRANGEPLAIN]}$`),l("XRANGELOOSE",`^${n[u.GTLT]}\\s*${n[u.XRANGEPLAINLOOSE]}$`),l("COERCE",`(^|[^\\d])(\\d{1,${t}})(?:\\.(\\d{1,${t}}))?(?:\\.(\\d{1,${t}}))?(?:$|[^\\d])`),l("COERCERTL",n[u.COERCE],!0),l("LONETILDE","(?:~>?)"),l("TILDETRIM",`(\\s*)${n[u.LONETILDE]}\\s+`,!0),e.tildeTrimReplace="$1~",l("TILDE",`^${n[u.LONETILDE]}${n[u.XRANGEPLAIN]}$`),l("TILDELOOSE",`^${n[u.LONETILDE]}${n[u.XRANGEPLAINLOOSE]}$`),l("LONECARET","(?:\\^)"),l("CARETTRIM",`(\\s*)${n[u.LONECARET]}\\s+`,!0),e.caretTrimReplace="$1^",l("CARET",`^${n[u.LONECARET]}${n[u.XRANGEPLAIN]}$`),l("CARETLOOSE",`^${n[u.LONECARET]}${n[u.XRANGEPLAINLOOSE]}$`),l("COMPARATORLOOSE",`^${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]})$|^$`),l("COMPARATOR",`^${n[u.GTLT]}\\s*(${n[u.FULLPLAIN]})$|^$`),l("COMPARATORTRIM",`(\\s*)${n[u.GTLT]}\\s*(${n[u.LOOSEPLAIN]}|${n[u.XRANGEPLAIN]})`,!0),e.comparatorTrimReplace="$1$2$3",l("HYPHENRANGE",`^\\s*(${n[u.XRANGEPLAIN]})\\s+-\\s+(${n[u.XRANGEPLAIN]})\\s*$`),l("HYPHENRANGELOOSE",`^\\s*(${n[u.XRANGEPLAINLOOSE]})\\s+-\\s+(${n[u.XRANGEPLAINLOOSE]})\\s*$`),l("STAR","(<|>)?=?\\s*\\*"),l("GTE0","^\\s*>=\\s*0\\.0\\.0\\s*$"),l("GTE0PRE","^\\s*>=\\s*0\\.0\\.0-0\\s*$")}}),WD=te({"node_modules/semver/internal/parse-options.js"(e,r){ne();var t=["includePrerelease","loose","rtl"],s=a=>a?typeof a!="object"?{loose:!0}:t.filter(n=>a[n]).reduce((n,u)=>(n[u]=!0,n),{}):{};r.exports=s}}),HD=te({"node_modules/semver/internal/identifiers.js"(e,r){ne();var t=/^[0-9]+$/,s=(n,u)=>{let i=t.test(n),l=t.test(u);return i&&l&&(n=+n,u=+u),n===u?0:i&&!l?-1:l&&!i?1:n<u?-1:1},a=(n,u)=>s(u,n);r.exports={compareIdentifiers:s,rcompareIdentifiers:a}}}),GD=te({"node_modules/semver/classes/semver.js"(e,r){ne();var t=qa(),{MAX_LENGTH:s,MAX_SAFE_INTEGER:a}=Ma(),{re:n,t:u}=VD(),i=WD(),{compareIdentifiers:l}=HD(),p=class{constructor(d,y){if(y=i(y),d instanceof p){if(d.loose===!!y.loose&&d.includePrerelease===!!y.includePrerelease)return d;d=d.version}else if(typeof d!="string")throw new TypeError(`Invalid Version: ${d}`);if(d.length>s)throw new TypeError(`version is longer than ${s} characters`);t("SemVer",d,y),this.options=y,this.loose=!!y.loose,this.includePrerelease=!!y.includePrerelease;let g=d.trim().match(y.loose?n[u.LOOSE]:n[u.FULL]);if(!g)throw new TypeError(`Invalid Version: ${d}`);if(this.raw=d,this.major=+g[1],this.minor=+g[2],this.patch=+g[3],this.major>a||this.major<0)throw new TypeError("Invalid major version");if(this.minor>a||this.minor<0)throw new TypeError("Invalid minor version");if(this.patch>a||this.patch<0)throw new TypeError("Invalid patch version");g[4]?this.prerelease=g[4].split(".").map(c=>{if(/^[0-9]+$/.test(c)){let D=+c;if(D>=0&&D<a)return D}return c}):this.prerelease=[],this.build=g[5]?g[5].split("."):[],this.format()}format(){return this.version=`${this.major}.${this.minor}.${this.patch}`,this.prerelease.length&&(this.version+=`-${this.prerelease.join(".")}`),this.version}toString(){return this.version}compare(d){if(t("SemVer.compare",this.version,this.options,d),!(d instanceof p)){if(typeof d=="string"&&d===this.version)return 0;d=new p(d,this.options)}return d.version===this.version?0:this.compareMain(d)||this.comparePre(d)}compareMain(d){return d instanceof p||(d=new p(d,this.options)),l(this.major,d.major)||l(this.minor,d.minor)||l(this.patch,d.patch)}comparePre(d){if(d instanceof p||(d=new p(d,this.options)),this.prerelease.length&&!d.prerelease.length)return-1;if(!this.prerelease.length&&d.prerelease.length)return 1;if(!this.prerelease.length&&!d.prerelease.length)return 0;let y=0;do{let g=this.prerelease[y],c=d.prerelease[y];if(t("prerelease compare",y,g,c),g===void 0&&c===void 0)return 0;if(c===void 0)return 1;if(g===void 0)return-1;if(g===c)continue;return l(g,c)}while(++y)}compareBuild(d){d instanceof p||(d=new p(d,this.options));let y=0;do{let g=this.build[y],c=d.build[y];if(t("prerelease compare",y,g,c),g===void 0&&c===void 0)return 0;if(c===void 0)return 1;if(g===void 0)return-1;if(g===c)continue;return l(g,c)}while(++y)}inc(d,y){switch(d){case"premajor":this.prerelease.length=0,this.patch=0,this.minor=0,this.major++,this.inc("pre",y);break;case"preminor":this.prerelease.length=0,this.patch=0,this.minor++,this.inc("pre",y);break;case"prepatch":this.prerelease.length=0,this.inc("patch",y),this.inc("pre",y);break;case"prerelease":this.prerelease.length===0&&this.inc("patch",y),this.inc("pre",y);break;case"major":(this.minor!==0||this.patch!==0||this.prerelease.length===0)&&this.major++,this.minor=0,this.patch=0,this.prerelease=[];break;case"minor":(this.patch!==0||this.prerelease.length===0)&&this.minor++,this.patch=0,this.prerelease=[];break;case"patch":this.prerelease.length===0&&this.patch++,this.prerelease=[];break;case"pre":if(this.prerelease.length===0)this.prerelease=[0];else{let g=this.prerelease.length;for(;--g>=0;)typeof this.prerelease[g]=="number"&&(this.prerelease[g]++,g=-2);g===-1&&this.prerelease.push(0)}y&&(l(this.prerelease[0],y)===0?isNaN(this.prerelease[1])&&(this.prerelease=[y,0]):this.prerelease=[y,0]);break;default:throw new Error(`invalid increment argument: ${d}`)}return this.format(),this.raw=this.version,this}};r.exports=p}}),zn=te({"node_modules/semver/functions/compare.js"(e,r){ne();var t=GD(),s=(a,n,u)=>new t(a,u).compare(new t(n,u));r.exports=s}}),UD=te({"node_modules/semver/functions/lt.js"(e,r){ne();var t=zn(),s=(a,n,u)=>t(a,n,u)<0;r.exports=s}}),JD=te({"node_modules/semver/functions/gte.js"(e,r){ne();var t=zn(),s=(a,n,u)=>t(a,n,u)>=0;r.exports=s}}),zD=te({"src/utils/arrayify.js"(e,r){"use strict";ne(),r.exports=(t,s)=>Object.entries(t).map(a=>{let[n,u]=a;return Object.assign({[s]:n},u)})}}),XD=te({"node_modules/outdent/lib/index.js"(e,r){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0}),e.outdent=void 0;function t(){for(var F=[],S=0;S<arguments.length;S++)F[S]=arguments[S]}function s(){return typeof WeakMap<"u"?new WeakMap:a()}function a(){return{add:t,delete:t,get:t,set:t,has:function(F){return!1}}}var n=Object.prototype.hasOwnProperty,u=function(F,S){return n.call(F,S)};function i(F,S){for(var N in S)u(S,N)&&(F[N]=S[N]);return F}var l=/^[ \t]*(?:\r\n|\r|\n)/,p=/(?:\r\n|\r|\n)[ \t]*$/,d=/^(?:[\r\n]|$)/,y=/(?:\r\n|\r|\n)([ \t]*)(?:[^ \t\r\n]|$)/,g=/^[ \t]*[\r\n][ \t\r\n]*$/;function c(F,S,N){var I=0,P=F[0].match(y);P&&(I=P[1].length);var $="(\\r\\n|\\r|\\n).{0,"+I+"}",f=new RegExp($,"g");S&&(F=F.slice(1));var T=N.newline,m=N.trimLeadingNewline,v=N.trimTrailingNewline,o=typeof T=="string",h=F.length,C=F.map(function(x,b){return x=x.replace(f,"$1"),b===0&&m&&(x=x.replace(l,"")),b===h-1&&v&&(x=x.replace(p,"")),o&&(x=x.replace(/\r\n|\n|\r/g,function(B){return T})),x});return C}function D(F,S){for(var N="",I=0,P=F.length;I<P;I++)N+=F[I],I<P-1&&(N+=S[I]);return N}function E(F){return u(F,"raw")&&u(F,"length")}function _(F){var S=s(),N=s();function I($){for(var f=[],T=1;T<arguments.length;T++)f[T-1]=arguments[T];if(E($)){var m=$,v=(f[0]===I||f[0]===w)&&g.test(m[0])&&d.test(m[1]),o=v?N:S,h=o.get(m);if(h||(h=c(m,v,F),o.set(m,h)),f.length===0)return h[0];var C=D(h,v?f.slice(1):f);return C}else return _(i(i({},F),$||{}))}var P=i(I,{string:function($){return c([$],!1,F)[0]}});return P}var w=_({trimLeadingNewline:!0,trimTrailingNewline:!0});if(e.outdent=w,e.default=w,typeof r<"u")try{r.exports=w,Object.defineProperty(w,"__esModule",{value:!0}),w.default=w,w.outdent=w}catch{}}}),KD=te({"src/main/core-options.js"(e,r){"use strict";ne();var{outdent:t}=XD(),s="Config",a="Editor",n="Format",u="Other",i="Output",l="Global",p="Special",d={cursorOffset:{since:"1.4.0",category:p,type:"int",default:-1,range:{start:-1,end:Number.POSITIVE_INFINITY,step:1},description:t`
      Print (to stderr) where a cursor at the given position would move to after formatting.
      This option cannot be used with --range-start and --range-end.
    `,cliCategory:a},endOfLine:{since:"1.15.0",category:l,type:"choice",default:[{since:"1.15.0",value:"auto"},{since:"2.0.0",value:"lf"}],description:"Which end of line characters to apply.",choices:[{value:"lf",description:"Line Feed only (\\n), common on Linux and macOS as well as inside git repos"},{value:"crlf",description:"Carriage Return + Line Feed characters (\\r\\n), common on Windows"},{value:"cr",description:"Carriage Return character only (\\r), used very rarely"},{value:"auto",description:t`
          Maintain existing
          (mixed values within one file are normalised by looking at what's used after the first line)
        `}]},filepath:{since:"1.4.0",category:p,type:"path",description:"Specify the input filepath. This will be used to do parser inference.",cliName:"stdin-filepath",cliCategory:u,cliDescription:"Path to the file to pretend that stdin comes from."},insertPragma:{since:"1.8.0",category:p,type:"boolean",default:!1,description:"Insert @format pragma into file's first docblock comment.",cliCategory:u},parser:{since:"0.0.10",category:l,type:"choice",default:[{since:"0.0.10",value:"babylon"},{since:"1.13.0",value:void 0}],description:"Which parser to use.",exception:y=>typeof y=="string"||typeof y=="function",choices:[{value:"flow",description:"Flow"},{value:"babel",since:"1.16.0",description:"JavaScript"},{value:"babel-flow",since:"1.16.0",description:"Flow"},{value:"babel-ts",since:"2.0.0",description:"TypeScript"},{value:"typescript",since:"1.4.0",description:"TypeScript"},{value:"acorn",since:"2.6.0",description:"JavaScript"},{value:"espree",since:"2.2.0",description:"JavaScript"},{value:"meriyah",since:"2.2.0",description:"JavaScript"},{value:"css",since:"1.7.1",description:"CSS"},{value:"less",since:"1.7.1",description:"Less"},{value:"scss",since:"1.7.1",description:"SCSS"},{value:"json",since:"1.5.0",description:"JSON"},{value:"json5",since:"1.13.0",description:"JSON5"},{value:"json-stringify",since:"1.13.0",description:"JSON.stringify"},{value:"graphql",since:"1.5.0",description:"GraphQL"},{value:"markdown",since:"1.8.0",description:"Markdown"},{value:"mdx",since:"1.15.0",description:"MDX"},{value:"vue",since:"1.10.0",description:"Vue"},{value:"yaml",since:"1.14.0",description:"YAML"},{value:"glimmer",since:"2.3.0",description:"Ember / Handlebars"},{value:"html",since:"1.15.0",description:"HTML"},{value:"angular",since:"1.15.0",description:"Angular"},{value:"lwc",since:"1.17.0",description:"Lightning Web Components"}]},plugins:{since:"1.10.0",type:"path",array:!0,default:[{value:[]}],category:l,description:"Add a plugin. Multiple plugins can be passed as separate `--plugin`s.",exception:y=>typeof y=="string"||typeof y=="object",cliName:"plugin",cliCategory:s},pluginSearchDirs:{since:"1.13.0",type:"path",array:!0,default:[{value:[]}],category:l,description:t`
      Custom directory that contains prettier plugins in node_modules subdirectory.
      Overrides default behavior when plugins are searched relatively to the location of Prettier.
      Multiple values are accepted.
    `,exception:y=>typeof y=="string"||typeof y=="object",cliName:"plugin-search-dir",cliCategory:s},printWidth:{since:"0.0.0",category:l,type:"int",default:80,description:"The line length where Prettier will try wrap.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},rangeEnd:{since:"1.4.0",category:p,type:"int",default:Number.POSITIVE_INFINITY,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:t`
      Format code ending at a given character offset (exclusive).
      The range will extend forwards to the end of the selected statement.
      This option cannot be used with --cursor-offset.
    `,cliCategory:a},rangeStart:{since:"1.4.0",category:p,type:"int",default:0,range:{start:0,end:Number.POSITIVE_INFINITY,step:1},description:t`
      Format code starting at a given character offset.
      The range will extend backwards to the start of the first line containing the selected statement.
      This option cannot be used with --cursor-offset.
    `,cliCategory:a},requirePragma:{since:"1.7.0",category:p,type:"boolean",default:!1,description:t`
      Require either '@prettier' or '@format' to be present in the file's first docblock comment
      in order for it to be formatted.
    `,cliCategory:u},tabWidth:{type:"int",category:l,default:2,description:"Number of spaces per indentation level.",range:{start:0,end:Number.POSITIVE_INFINITY,step:1}},useTabs:{since:"1.0.0",category:l,type:"boolean",default:!1,description:"Indent with tabs instead of spaces."},embeddedLanguageFormatting:{since:"2.1.0",category:l,type:"choice",default:[{since:"2.1.0",value:"auto"}],description:"Control how Prettier formats quoted code embedded in the file.",choices:[{value:"auto",description:"Format embedded code if Prettier can automatically identify it."},{value:"off",description:"Never automatically format embedded code."}]}};r.exports={CATEGORY_CONFIG:s,CATEGORY_EDITOR:a,CATEGORY_FORMAT:n,CATEGORY_OTHER:u,CATEGORY_OUTPUT:i,CATEGORY_GLOBAL:l,CATEGORY_SPECIAL:p,options:d}}}),Xn=te({"src/main/support.js"(e,r){"use strict";ne();var t={compare:zn(),lt:UD(),gte:JD()},s=zD(),a=Ia().version,n=KD().options;function u(){let{plugins:l=[],showUnreleased:p=!1,showDeprecated:d=!1,showInternal:y=!1}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{},g=a.split("-",1)[0],c=l.flatMap(F=>F.languages||[]).filter(E),D=s(Object.assign({},...l.map(F=>{let{options:S}=F;return S}),n),"name").filter(F=>E(F)&&_(F)).sort((F,S)=>F.name===S.name?0:F.name<S.name?-1:1).map(w).map(F=>{F=Object.assign({},F),Array.isArray(F.default)&&(F.default=F.default.length===1?F.default[0].value:F.default.filter(E).sort((N,I)=>t.compare(I.since,N.since))[0].value),Array.isArray(F.choices)&&(F.choices=F.choices.filter(N=>E(N)&&_(N)),F.name==="parser"&&i(F,c,l));let S=Object.fromEntries(l.filter(N=>N.defaultOptions&&N.defaultOptions[F.name]!==void 0).map(N=>[N.name,N.defaultOptions[F.name]]));return Object.assign(Object.assign({},F),{},{pluginDefaults:S})});return{languages:c,options:D};function E(F){return p||!("since"in F)||F.since&&t.gte(g,F.since)}function _(F){return d||!("deprecated"in F)||F.deprecated&&t.lt(g,F.deprecated)}function w(F){if(y)return F;let{cliName:S,cliCategory:N,cliDescription:I}=F;return Hn(F,hD)}}function i(l,p,d){let y=new Set(l.choices.map(g=>g.value));for(let g of p)if(g.parsers){for(let c of g.parsers)if(!y.has(c)){y.add(c);let D=d.find(_=>_.parsers&&_.parsers[c]),E=g.name;D&&D.name&&(E+=` (plugin: ${D.name})`),l.choices.push({value:c,description:E})}}}r.exports={getSupportInfo:u}}}),Kn=te({"src/utils/is-non-empty-array.js"(e,r){"use strict";ne();function t(s){return Array.isArray(s)&&s.length>0}r.exports=t}}),Pr=te({"src/utils/text/skip.js"(e,r){"use strict";ne();function t(i){return(l,p,d)=>{let y=d&&d.backwards;if(p===!1)return!1;let{length:g}=l,c=p;for(;c>=0&&c<g;){let D=l.charAt(c);if(i instanceof RegExp){if(!i.test(D))return c}else if(!i.includes(D))return c;y?c--:c++}return c===-1||c===g?c:!1}}var s=t(/\s/),a=t(" 	"),n=t(",; 	"),u=t(/[^\n\r]/);r.exports={skipWhitespace:s,skipSpaces:a,skipToLineEnd:n,skipEverythingButNewLine:u}}}),Ra=te({"src/utils/text/skip-inline-comment.js"(e,r){"use strict";ne();function t(s,a){if(a===!1)return!1;if(s.charAt(a)==="/"&&s.charAt(a+1)==="*"){for(let n=a+2;n<s.length;++n)if(s.charAt(n)==="*"&&s.charAt(n+1)==="/")return n+2}return a}r.exports=t}}),$a=te({"src/utils/text/skip-trailing-comment.js"(e,r){"use strict";ne();var{skipEverythingButNewLine:t}=Pr();function s(a,n){return n===!1?!1:a.charAt(n)==="/"&&a.charAt(n+1)==="/"?t(a,n):n}r.exports=s}}),Va=te({"src/utils/text/skip-newline.js"(e,r){"use strict";ne();function t(s,a,n){let u=n&&n.backwards;if(a===!1)return!1;let i=s.charAt(a);if(u){if(s.charAt(a-1)==="\r"&&i===`
`)return a-2;if(i===`
`||i==="\r"||i==="\u2028"||i==="\u2029")return a-1}else{if(i==="\r"&&s.charAt(a+1)===`
`)return a+2;if(i===`
`||i==="\r"||i==="\u2028"||i==="\u2029")return a+1}return a}r.exports=t}}),YD=te({"src/utils/text/get-next-non-space-non-comment-character-index-with-start-index.js"(e,r){"use strict";ne();var t=Ra(),s=Va(),a=$a(),{skipSpaces:n}=Pr();function u(i,l){let p=null,d=l;for(;d!==p;)p=d,d=n(i,d),d=t(i,d),d=a(i,d),d=s(i,d);return d}r.exports=u}}),Ue=te({"src/common/util.js"(e,r){"use strict";ne();var{default:t}=($D(),ft(ja)),s=lt(),{getSupportInfo:a}=Xn(),n=Kn(),u=Oa(),{skipWhitespace:i,skipSpaces:l,skipToLineEnd:p,skipEverythingButNewLine:d}=Pr(),y=Ra(),g=$a(),c=Va(),D=YD(),E=V=>V[V.length-2];function _(V){return(j,Y,ie)=>{let ee=ie&&ie.backwards;if(Y===!1)return!1;let{length:le}=j,W=Y;for(;W>=0&&W<le;){let K=j.charAt(W);if(V instanceof RegExp){if(!V.test(K))return W}else if(!V.includes(K))return W;ee?W--:W++}return W===-1||W===le?W:!1}}function w(V,j){let Y=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},ie=l(V,Y.backwards?j-1:j,Y),ee=c(V,ie,Y);return ie!==ee}function F(V,j,Y){for(let ie=j;ie<Y;++ie)if(V.charAt(ie)===`
`)return!0;return!1}function S(V,j,Y){let ie=Y(j)-1;ie=l(V,ie,{backwards:!0}),ie=c(V,ie,{backwards:!0}),ie=l(V,ie,{backwards:!0});let ee=c(V,ie,{backwards:!0});return ie!==ee}function N(V,j){let Y=null,ie=j;for(;ie!==Y;)Y=ie,ie=p(V,ie),ie=y(V,ie),ie=l(V,ie);return ie=g(V,ie),ie=c(V,ie),ie!==!1&&w(V,ie)}function I(V,j,Y){return N(V,Y(j))}function P(V,j,Y){return D(V,Y(j))}function $(V,j,Y){return V.charAt(P(V,j,Y))}function f(V,j){let Y=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{};return l(V,Y.backwards?j-1:j,Y)!==j}function T(V,j){let Y=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0,ie=0;for(let ee=Y;ee<V.length;++ee)V[ee]==="	"?ie=ie+j-ie%j:ie++;return ie}function m(V,j){let Y=V.lastIndexOf(`
`);return Y===-1?0:T(V.slice(Y+1).match(/^[\t ]*/)[0],j)}function v(V,j){let Y={quote:'"',regex:/"/g,escaped:"&quot;"},ie={quote:"'",regex:/'/g,escaped:"&apos;"},ee=j==="'"?ie:Y,le=ee===ie?Y:ie,W=ee;if(V.includes(ee.quote)||V.includes(le.quote)){let K=(V.match(ee.regex)||[]).length,de=(V.match(le.regex)||[]).length;W=K>de?le:ee}return W}function o(V,j){let Y=V.slice(1,-1),ie=j.parser==="json"||j.parser==="json5"&&j.quoteProps==="preserve"&&!j.singleQuote?'"':j.__isInHtmlAttribute?"'":v(Y,j.singleQuote?"'":'"').quote;return h(Y,ie,!(j.parser==="css"||j.parser==="less"||j.parser==="scss"||j.__embeddedInHtml))}function h(V,j,Y){let ie=j==='"'?"'":'"',ee=/\\(.)|(["'])/gs,le=V.replace(ee,(W,K,de)=>K===ie?K:de===j?"\\"+de:de||(Y&&/^[^\n\r"'0-7\\bfnrt-vx\u2028\u2029]$/.test(K)?K:"\\"+K));return j+le+j}function C(V){return V.toLowerCase().replace(/^([+-]?[\d.]+e)(?:\+|(-))?0*(\d)/,"$1$2$3").replace(/^([+-]?[\d.]+)e[+-]?0+$/,"$1").replace(/^([+-])?\./,"$10.").replace(/(\.\d+?)0+(?=e|$)/,"$1").replace(/\.(?=e|$)/,"")}function x(V,j){let Y=V.match(new RegExp(`(${t(j)})+`,"g"));return Y===null?0:Y.reduce((ie,ee)=>Math.max(ie,ee.length/j.length),0)}function b(V,j){let Y=V.match(new RegExp(`(${t(j)})+`,"g"));if(Y===null)return 0;let ie=new Map,ee=0;for(let le of Y){let W=le.length/j.length;ie.set(W,!0),W>ee&&(ee=W)}for(let le=1;le<ee;le++)if(!ie.get(le))return le;return ee+1}function B(V,j){(V.comments||(V.comments=[])).push(j),j.printed=!1,j.nodeDescription=Q(V)}function k(V,j){j.leading=!0,j.trailing=!1,B(V,j)}function M(V,j,Y){j.leading=!1,j.trailing=!1,Y&&(j.marker=Y),B(V,j)}function R(V,j){j.leading=!1,j.trailing=!0,B(V,j)}function q(V,j){let{languages:Y}=a({plugins:j.plugins}),ie=Y.find(ee=>{let{name:le}=ee;return le.toLowerCase()===V})||Y.find(ee=>{let{aliases:le}=ee;return Array.isArray(le)&&le.includes(V)})||Y.find(ee=>{let{extensions:le}=ee;return Array.isArray(le)&&le.includes(`.${V}`)});return ie&&ie.parsers[0]}function J(V){return V&&V.type==="front-matter"}function L(V){let j=new WeakMap;return function(Y){return j.has(Y)||j.set(Y,Symbol(V)),j.get(Y)}}function Q(V){let j=V.type||V.kind||"(unknown type)",Y=String(V.name||V.id&&(typeof V.id=="object"?V.id.name:V.id)||V.key&&(typeof V.key=="object"?V.key.name:V.key)||V.value&&(typeof V.value=="object"?"":String(V.value))||V.operator||"");return Y.length>20&&(Y=Y.slice(0,19)+"\u2026"),j+(Y?" "+Y:"")}r.exports={inferParserByLanguage:q,getStringWidth:u,getMaxContinuousCount:x,getMinNotPresentContinuousCount:b,getPenultimate:E,getLast:s,getNextNonSpaceNonCommentCharacterIndexWithStartIndex:D,getNextNonSpaceNonCommentCharacterIndex:P,getNextNonSpaceNonCommentCharacter:$,skip:_,skipWhitespace:i,skipSpaces:l,skipToLineEnd:p,skipEverythingButNewLine:d,skipInlineComment:y,skipTrailingComment:g,skipNewline:c,isNextLineEmptyAfterIndex:N,isNextLineEmpty:I,isPreviousLineEmpty:S,hasNewline:w,hasNewlineInRange:F,hasSpaces:f,getAlignmentSize:T,getIndentSize:m,getPreferredQuote:v,printString:o,printNumber:C,makeString:h,addLeadingComment:k,addDanglingComment:M,addTrailingComment:R,isFrontMatterNode:J,isNonEmptyArray:n,createGroupIdMapper:L}}}),Wa={};Kt(Wa,{basename:()=>za,default:()=>Ka,delimiter:()=>Mn,dirname:()=>Ja,extname:()=>Xa,isAbsolute:()=>Qn,join:()=>Ga,normalize:()=>Yn,relative:()=>Ua,resolve:()=>wr,sep:()=>qn});function Ha(e,r){for(var t=0,s=e.length-1;s>=0;s--){var a=e[s];a==="."?e.splice(s,1):a===".."?(e.splice(s,1),t++):t&&(e.splice(s,1),t--)}if(r)for(;t--;t)e.unshift("..");return e}function wr(){for(var e="",r=!1,t=arguments.length-1;t>=-1&&!r;t--){var s=t>=0?arguments[t]:"/";if(typeof s!="string")throw new TypeError("Arguments to path.resolve must be strings");if(!s)continue;e=s+"/"+e,r=s.charAt(0)==="/"}return e=Ha(Zn(e.split("/"),function(a){return!!a}),!r).join("/"),(r?"/":"")+e||"."}function Yn(e){var r=Qn(e),t=Ya(e,-1)==="/";return e=Ha(Zn(e.split("/"),function(s){return!!s}),!r).join("/"),!e&&!r&&(e="."),e&&t&&(e+="/"),(r?"/":"")+e}function Qn(e){return e.charAt(0)==="/"}function Ga(){var e=Array.prototype.slice.call(arguments,0);return Yn(Zn(e,function(r,t){if(typeof r!="string")throw new TypeError("Arguments to path.join must be strings");return r}).join("/"))}function Ua(e,r){e=wr(e).substr(1),r=wr(r).substr(1);function t(p){for(var d=0;d<p.length&&p[d]==="";d++);for(var y=p.length-1;y>=0&&p[y]==="";y--);return d>y?[]:p.slice(d,y-d+1)}for(var s=t(e.split("/")),a=t(r.split("/")),n=Math.min(s.length,a.length),u=n,i=0;i<n;i++)if(s[i]!==a[i]){u=i;break}for(var l=[],i=u;i<s.length;i++)l.push("..");return l=l.concat(a.slice(u)),l.join("/")}function Ja(e){var r=Ir(e),t=r[0],s=r[1];return!t&&!s?".":(s&&(s=s.substr(0,s.length-1)),t+s)}function za(e,r){var t=Ir(e)[2];return r&&t.substr(-1*r.length)===r&&(t=t.substr(0,t.length-r.length)),t}function Xa(e){return Ir(e)[3]}function Zn(e,r){if(e.filter)return e.filter(r);for(var t=[],s=0;s<e.length;s++)r(e[s],s,e)&&t.push(e[s]);return t}var Na,Ir,qn,Mn,Ka,Ya,QD=ht({"node-modules-polyfills:path"(){ne(),Na=/^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/,Ir=function(e){return Na.exec(e).slice(1)},qn="/",Mn=":",Ka={extname:Xa,basename:za,dirname:Ja,sep:qn,delimiter:Mn,relative:Ua,join:Ga,isAbsolute:Qn,normalize:Yn,resolve:wr},Ya= true?function(e,r,t){return e.substr(r,t)}:0}}),ZD=te({"node-modules-polyfills-commonjs:path"(e,r){ne();var t=(QD(),ft(Wa));if(t&&t.default){r.exports=t.default;for(let s in t)r.exports[s]=t[s]}else t&&(r.exports=t)}}),Qt=te({"src/common/errors.js"(e,r){"use strict";ne();var t=class extends Error{},s=class extends Error{},a=class extends Error{},n=class extends Error{};r.exports={ConfigError:t,DebugError:s,UndefinedParserError:a,ArgExpansionBailout:n}}}),vt={};Kt(vt,{__assign:()=>Nr,__asyncDelegator:()=>fm,__asyncGenerator:()=>pm,__asyncValues:()=>Dm,__await:()=>Xt,__awaiter:()=>sm,__classPrivateFieldGet:()=>ym,__classPrivateFieldSet:()=>hm,__createBinding:()=>am,__decorate:()=>rm,__exportStar:()=>om,__extends:()=>em,__generator:()=>im,__importDefault:()=>gm,__importStar:()=>dm,__makeTemplateObject:()=>mm,__metadata:()=>um,__param:()=>nm,__read:()=>Qa,__rest:()=>tm,__spread:()=>lm,__spreadArrays:()=>cm,__values:()=>Rn});function em(e,r){Br(e,r);function t(){this.constructor=e}e.prototype=r===null?Object.create(r):(t.prototype=r.prototype,new t)}function tm(e,r){var t={};for(var s in e)Object.prototype.hasOwnProperty.call(e,s)&&r.indexOf(s)<0&&(t[s]=e[s]);if(e!=null&&typeof Object.getOwnPropertySymbols=="function")for(var a=0,s=Object.getOwnPropertySymbols(e);a<s.length;a++)r.indexOf(s[a])<0&&Object.prototype.propertyIsEnumerable.call(e,s[a])&&(t[s[a]]=e[s[a]]);return t}function rm(e,r,t,s){var a=arguments.length,n=a<3?r:s===null?s=Object.getOwnPropertyDescriptor(r,t):s,u;if(typeof Reflect=="object"&&typeof Reflect.decorate=="function")n=Reflect.decorate(e,r,t,s);else for(var i=e.length-1;i>=0;i--)(u=e[i])&&(n=(a<3?u(n):a>3?u(r,t,n):u(r,t))||n);return a>3&&n&&Object.defineProperty(r,t,n),n}function nm(e,r){return function(t,s){r(t,s,e)}}function um(e,r){if(typeof Reflect=="object"&&typeof Reflect.metadata=="function")return Reflect.metadata(e,r)}function sm(e,r,t,s){function a(n){return n instanceof t?n:new t(function(u){u(n)})}return new(t||(t=Promise))(function(n,u){function i(d){try{p(s.next(d))}catch(y){u(y)}}function l(d){try{p(s.throw(d))}catch(y){u(y)}}function p(d){d.done?n(d.value):a(d.value).then(i,l)}p((s=s.apply(e,r||[])).next())})}function im(e,r){var t={label:0,sent:function(){if(n[0]&1)throw n[1];return n[1]},trys:[],ops:[]},s,a,n,u;return u={next:i(0),throw:i(1),return:i(2)},typeof Symbol=="function"&&(u[Symbol.iterator]=function(){return this}),u;function i(p){return function(d){return l([p,d])}}function l(p){if(s)throw new TypeError("Generator is already executing.");for(;t;)try{if(s=1,a&&(n=p[0]&2?a.return:p[0]?a.throw||((n=a.return)&&n.call(a),0):a.next)&&!(n=n.call(a,p[1])).done)return n;switch(a=0,n&&(p=[p[0]&2,n.value]),p[0]){case 0:case 1:n=p;break;case 4:return t.label++,{value:p[1],done:!1};case 5:t.label++,a=p[1],p=[0];continue;case 7:p=t.ops.pop(),t.trys.pop();continue;default:if(n=t.trys,!(n=n.length>0&&n[n.length-1])&&(p[0]===6||p[0]===2)){t=0;continue}if(p[0]===3&&(!n||p[1]>n[0]&&p[1]<n[3])){t.label=p[1];break}if(p[0]===6&&t.label<n[1]){t.label=n[1],n=p;break}if(n&&t.label<n[2]){t.label=n[2],t.ops.push(p);break}n[2]&&t.ops.pop(),t.trys.pop();continue}p=r.call(e,t)}catch(d){p=[6,d],a=0}finally{s=n=0}if(p[0]&5)throw p[1];return{value:p[0]?p[1]:void 0,done:!0}}}function am(e,r,t,s){s===void 0&&(s=t),e[s]=r[t]}function om(e,r){for(var t in e)t!=="default"&&!r.hasOwnProperty(t)&&(r[t]=e[t])}function Rn(e){var r=typeof Symbol=="function"&&Symbol.iterator,t=r&&e[r],s=0;if(t)return t.call(e);if(e&&typeof e.length=="number")return{next:function(){return e&&s>=e.length&&(e=void 0),{value:e&&e[s++],done:!e}}};throw new TypeError(r?"Object is not iterable.":"Symbol.iterator is not defined.")}function Qa(e,r){var t=typeof Symbol=="function"&&e[Symbol.iterator];if(!t)return e;var s=t.call(e),a,n=[],u;try{for(;(r===void 0||r-- >0)&&!(a=s.next()).done;)n.push(a.value)}catch(i){u={error:i}}finally{try{a&&!a.done&&(t=s.return)&&t.call(s)}finally{if(u)throw u.error}}return n}function lm(){for(var e=[],r=0;r<arguments.length;r++)e=e.concat(Qa(arguments[r]));return e}function cm(){for(var e=0,r=0,t=arguments.length;r<t;r++)e+=arguments[r].length;for(var s=Array(e),a=0,r=0;r<t;r++)for(var n=arguments[r],u=0,i=n.length;u<i;u++,a++)s[a]=n[u];return s}function Xt(e){return this instanceof Xt?(this.v=e,this):new Xt(e)}function pm(e,r,t){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var s=t.apply(e,r||[]),a,n=[];return a={},u("next"),u("throw"),u("return"),a[Symbol.asyncIterator]=function(){return this},a;function u(g){s[g]&&(a[g]=function(c){return new Promise(function(D,E){n.push([g,c,D,E])>1||i(g,c)})})}function i(g,c){try{l(s[g](c))}catch(D){y(n[0][3],D)}}function l(g){g.value instanceof Xt?Promise.resolve(g.value.v).then(p,d):y(n[0][2],g)}function p(g){i("next",g)}function d(g){i("throw",g)}function y(g,c){g(c),n.shift(),n.length&&i(n[0][0],n[0][1])}}function fm(e){var r,t;return r={},s("next"),s("throw",function(a){throw a}),s("return"),r[Symbol.iterator]=function(){return this},r;function s(a,n){r[a]=e[a]?function(u){return(t=!t)?{value:Xt(e[a](u)),done:a==="return"}:n?n(u):u}:n}}function Dm(e){if(!Symbol.asyncIterator)throw new TypeError("Symbol.asyncIterator is not defined.");var r=e[Symbol.asyncIterator],t;return r?r.call(e):(e=typeof Rn=="function"?Rn(e):e[Symbol.iterator](),t={},s("next"),s("throw"),s("return"),t[Symbol.asyncIterator]=function(){return this},t);function s(n){t[n]=e[n]&&function(u){return new Promise(function(i,l){u=e[n](u),a(i,l,u.done,u.value)})}}function a(n,u,i,l){Promise.resolve(l).then(function(p){n({value:p,done:i})},u)}}function mm(e,r){return Object.defineProperty?Object.defineProperty(e,"raw",{value:r}):e.raw=r,e}function dm(e){if(e&&e.__esModule)return e;var r={};if(e!=null)for(var t in e)Object.hasOwnProperty.call(e,t)&&(r[t]=e[t]);return r.default=e,r}function gm(e){return e&&e.__esModule?e:{default:e}}function ym(e,r){if(!r.has(e))throw new TypeError("attempted to get private field on non-instance");return r.get(e)}function hm(e,r,t){if(!r.has(e))throw new TypeError("attempted to set private field on non-instance");return r.set(e,t),t}var Br,Nr,Et=ht({"node_modules/tslib/tslib.es6.js"(){ne(),Br=function(e,r){return Br=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(t,s){t.__proto__=s}||function(t,s){for(var a in s)s.hasOwnProperty(a)&&(t[a]=s[a])},Br(e,r)},Nr=function(){return Nr=Object.assign||function(r){for(var t,s=1,a=arguments.length;s<a;s++){t=arguments[s];for(var n in t)Object.prototype.hasOwnProperty.call(t,n)&&(r[n]=t[n])}return r},Nr.apply(this,arguments)}}}),Za=te({"node_modules/vnopts/lib/descriptors/api.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0}),e.apiDescriptor={key:r=>/^[$_a-zA-Z][$_a-zA-Z0-9]*$/.test(r)?r:JSON.stringify(r),value(r){if(r===null||typeof r!="object")return JSON.stringify(r);if(Array.isArray(r))return`[${r.map(s=>e.apiDescriptor.value(s)).join(", ")}]`;let t=Object.keys(r);return t.length===0?"{}":`{ ${t.map(s=>`${e.apiDescriptor.key(s)}: ${e.apiDescriptor.value(r[s])}`).join(", ")} }`},pair:r=>{let{key:t,value:s}=r;return e.apiDescriptor.value({[t]:s})}}}}),vm=te({"node_modules/vnopts/lib/descriptors/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt));r.__exportStar(Za(),e)}}),kr=te({"scripts/build/shims/chalk.cjs"(e,r){"use strict";ne();var t=s=>s;t.grey=t,t.red=t,t.bold=t,t.yellow=t,t.blue=t,t.default=t,r.exports=t}}),eo=te({"node_modules/vnopts/lib/handlers/deprecated/common.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=kr();e.commonDeprecatedHandler=(t,s,a)=>{let{descriptor:n}=a,u=[`${r.default.yellow(typeof t=="string"?n.key(t):n.pair(t))} is deprecated`];return s&&u.push(`we now treat it as ${r.default.blue(typeof s=="string"?n.key(s):n.pair(s))}`),u.join("; ")+"."}}}),Cm=te({"node_modules/vnopts/lib/handlers/deprecated/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt));r.__exportStar(eo(),e)}}),Em=te({"node_modules/vnopts/lib/handlers/invalid/common.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=kr();e.commonInvalidHandler=(t,s,a)=>[`Invalid ${r.default.red(a.descriptor.key(t))} value.`,`Expected ${r.default.blue(a.schemas[t].expected(a))},`,`but received ${r.default.red(a.descriptor.value(s))}.`].join(" ")}}),to=te({"node_modules/vnopts/lib/handlers/invalid/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt));r.__exportStar(Em(),e)}}),Fm=te({"node_modules/vnopts/node_modules/leven/index.js"(e,r){"use strict";ne();var t=[],s=[];r.exports=function(a,n){if(a===n)return 0;var u=a;a.length>n.length&&(a=n,n=u);var i=a.length,l=n.length;if(i===0)return l;if(l===0)return i;for(;i>0&&a.charCodeAt(~-i)===n.charCodeAt(~-l);)i--,l--;if(i===0)return l;for(var p=0;p<i&&a.charCodeAt(p)===n.charCodeAt(p);)p++;if(i-=p,l-=p,i===0)return l;for(var d,y,g,c,D=0,E=0;D<i;)s[p+D]=a.charCodeAt(p+D),t[D]=++D;for(;E<l;)for(d=n.charCodeAt(p+E),g=E++,y=E,D=0;D<i;D++)c=d===s[p+D]?g:g+1,g=t[D],y=t[D]=g>y?c>y?y+1:c:c>g?g+1:c;return y}}}),ro=te({"node_modules/vnopts/lib/handlers/unknown/leven.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=kr(),t=Fm();e.levenUnknownHandler=(s,a,n)=>{let{descriptor:u,logger:i,schemas:l}=n,p=[`Ignored unknown option ${r.default.yellow(u.pair({key:s,value:a}))}.`],d=Object.keys(l).sort().find(y=>t(s,y)<3);d&&p.push(`Did you mean ${r.default.blue(u.key(d))}?`),i.warn(p.join(" "))}}}),Am=te({"node_modules/vnopts/lib/handlers/unknown/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt));r.__exportStar(ro(),e)}}),Sm=te({"node_modules/vnopts/lib/handlers/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt));r.__exportStar(Cm(),e),r.__exportStar(to(),e),r.__exportStar(Am(),e)}}),Ft=te({"node_modules/vnopts/lib/schema.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=["default","expected","validate","deprecated","forward","redirect","overlap","preprocess","postprocess"];function t(n,u){let i=new n(u),l=Object.create(i);for(let p of r)p in u&&(l[p]=a(u[p],i,s.prototype[p].length));return l}e.createSchema=t;var s=class{constructor(n){this.name=n.name}static create(n){return t(this,n)}default(n){}expected(n){return"nothing"}validate(n,u){return!1}deprecated(n,u){return!1}forward(n,u){}redirect(n,u){}overlap(n,u,i){return n}preprocess(n,u){return n}postprocess(n,u){return n}};e.Schema=s;function a(n,u,i){return typeof n=="function"?function(){for(var l=arguments.length,p=new Array(l),d=0;d<l;d++)p[d]=arguments[d];return n(...p.slice(0,i-1),u,...p.slice(i-1))}:()=>n}}}),xm=te({"node_modules/vnopts/lib/schemas/alias.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Ft(),t=class extends r.Schema{constructor(s){super(s),this._sourceName=s.sourceName}expected(s){return s.schemas[this._sourceName].expected(s)}validate(s,a){return a.schemas[this._sourceName].validate(s,a)}redirect(s,a){return this._sourceName}};e.AliasSchema=t}}),bm=te({"node_modules/vnopts/lib/schemas/any.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Ft(),t=class extends r.Schema{expected(){return"anything"}validate(){return!0}};e.AnySchema=t}}),Tm=te({"node_modules/vnopts/lib/schemas/array.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt)),t=Ft(),s=class extends t.Schema{constructor(n){var{valueSchema:u,name:i=u.name}=n,l=r.__rest(n,["valueSchema","name"]);super(Object.assign({},l,{name:i})),this._valueSchema=u}expected(n){return`an array of ${this._valueSchema.expected(n)}`}validate(n,u){if(!Array.isArray(n))return!1;let i=[];for(let l of n){let p=u.normalizeValidateResult(this._valueSchema.validate(l,u),l);p!==!0&&i.push(p.value)}return i.length===0?!0:{value:i}}deprecated(n,u){let i=[];for(let l of n){let p=u.normalizeDeprecatedResult(this._valueSchema.deprecated(l,u),l);p!==!1&&i.push(...p.map(d=>{let{value:y}=d;return{value:[y]}}))}return i}forward(n,u){let i=[];for(let l of n){let p=u.normalizeForwardResult(this._valueSchema.forward(l,u),l);i.push(...p.map(a))}return i}redirect(n,u){let i=[],l=[];for(let p of n){let d=u.normalizeRedirectResult(this._valueSchema.redirect(p,u),p);"remain"in d&&i.push(d.remain),l.push(...d.redirect.map(a))}return i.length===0?{redirect:l}:{redirect:l,remain:i}}overlap(n,u){return n.concat(u)}};e.ArraySchema=s;function a(n){let{from:u,to:i}=n;return{from:[u],to:i}}}}),Bm=te({"node_modules/vnopts/lib/schemas/boolean.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Ft(),t=class extends r.Schema{expected(){return"true or false"}validate(s){return typeof s=="boolean"}};e.BooleanSchema=t}}),eu=te({"node_modules/vnopts/lib/utils.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});function r(c,D){let E=Object.create(null);for(let _ of c){let w=_[D];if(E[w])throw new Error(`Duplicate ${D} ${JSON.stringify(w)}`);E[w]=_}return E}e.recordFromArray=r;function t(c,D){let E=new Map;for(let _ of c){let w=_[D];if(E.has(w))throw new Error(`Duplicate ${D} ${JSON.stringify(w)}`);E.set(w,_)}return E}e.mapFromArray=t;function s(){let c=Object.create(null);return D=>{let E=JSON.stringify(D);return c[E]?!0:(c[E]=!0,!1)}}e.createAutoChecklist=s;function a(c,D){let E=[],_=[];for(let w of c)D(w)?E.push(w):_.push(w);return[E,_]}e.partition=a;function n(c){return c===Math.floor(c)}e.isInt=n;function u(c,D){if(c===D)return 0;let E=typeof c,_=typeof D,w=["undefined","object","boolean","number","string"];return E!==_?w.indexOf(E)-w.indexOf(_):E!=="string"?Number(c)-Number(D):c.localeCompare(D)}e.comparePrimitive=u;function i(c){return c===void 0?{}:c}e.normalizeDefaultResult=i;function l(c,D){return c===!0?!0:c===!1?{value:D}:c}e.normalizeValidateResult=l;function p(c,D){let E=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!1;return c===!1?!1:c===!0?E?!0:[{value:D}]:"value"in c?[c]:c.length===0?!1:c}e.normalizeDeprecatedResult=p;function d(c,D){return typeof c=="string"||"key"in c?{from:D,to:c}:"from"in c?{from:c.from,to:c.to}:{from:D,to:c.to}}e.normalizeTransferResult=d;function y(c,D){return c===void 0?[]:Array.isArray(c)?c.map(E=>d(E,D)):[d(c,D)]}e.normalizeForwardResult=y;function g(c,D){let E=y(typeof c=="object"&&"redirect"in c?c.redirect:c,D);return E.length===0?{remain:D,redirect:E}:typeof c=="object"&&"remain"in c?{remain:c.remain,redirect:E}:{redirect:E}}e.normalizeRedirectResult=g}}),Nm=te({"node_modules/vnopts/lib/schemas/choice.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Ft(),t=eu(),s=class extends r.Schema{constructor(a){super(a),this._choices=t.mapFromArray(a.choices.map(n=>n&&typeof n=="object"?n:{value:n}),"value")}expected(a){let{descriptor:n}=a,u=Array.from(this._choices.keys()).map(p=>this._choices.get(p)).filter(p=>!p.deprecated).map(p=>p.value).sort(t.comparePrimitive).map(n.value),i=u.slice(0,-2),l=u.slice(-2);return i.concat(l.join(" or ")).join(", ")}validate(a){return this._choices.has(a)}deprecated(a){let n=this._choices.get(a);return n&&n.deprecated?{value:a}:!1}forward(a){let n=this._choices.get(a);return n?n.forward:void 0}redirect(a){let n=this._choices.get(a);return n?n.redirect:void 0}};e.ChoiceSchema=s}}),no=te({"node_modules/vnopts/lib/schemas/number.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Ft(),t=class extends r.Schema{expected(){return"a number"}validate(s,a){return typeof s=="number"}};e.NumberSchema=t}}),wm=te({"node_modules/vnopts/lib/schemas/integer.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=eu(),t=no(),s=class extends t.NumberSchema{expected(){return"an integer"}validate(a,n){return n.normalizeValidateResult(super.validate(a,n),a)===!0&&r.isInt(a)}};e.IntegerSchema=s}}),_m=te({"node_modules/vnopts/lib/schemas/string.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Ft(),t=class extends r.Schema{expected(){return"a string"}validate(s){return typeof s=="string"}};e.StringSchema=t}}),Pm=te({"node_modules/vnopts/lib/schemas/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt));r.__exportStar(xm(),e),r.__exportStar(bm(),e),r.__exportStar(Tm(),e),r.__exportStar(Bm(),e),r.__exportStar(Nm(),e),r.__exportStar(wm(),e),r.__exportStar(no(),e),r.__exportStar(_m(),e)}}),Im=te({"node_modules/vnopts/lib/defaults.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Za(),t=eo(),s=to(),a=ro();e.defaultDescriptor=r.apiDescriptor,e.defaultUnknownHandler=a.levenUnknownHandler,e.defaultInvalidHandler=s.commonInvalidHandler,e.defaultDeprecatedHandler=t.commonDeprecatedHandler}}),km=te({"node_modules/vnopts/lib/normalize.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=Im(),t=eu();e.normalize=(a,n,u)=>new s(n,u).normalize(a);var s=class{constructor(a,n){let{logger:u=console,descriptor:i=r.defaultDescriptor,unknown:l=r.defaultUnknownHandler,invalid:p=r.defaultInvalidHandler,deprecated:d=r.defaultDeprecatedHandler}=n||{};this._utils={descriptor:i,logger:u||{warn:()=>{}},schemas:t.recordFromArray(a,"name"),normalizeDefaultResult:t.normalizeDefaultResult,normalizeDeprecatedResult:t.normalizeDeprecatedResult,normalizeForwardResult:t.normalizeForwardResult,normalizeRedirectResult:t.normalizeRedirectResult,normalizeValidateResult:t.normalizeValidateResult},this._unknownHandler=l,this._invalidHandler=p,this._deprecatedHandler=d,this.cleanHistory()}cleanHistory(){this._hasDeprecationWarned=t.createAutoChecklist()}normalize(a){let n={},u=[a],i=()=>{for(;u.length!==0;){let l=u.shift(),p=this._applyNormalization(l,n);u.push(...p)}};i();for(let l of Object.keys(this._utils.schemas)){let p=this._utils.schemas[l];if(!(l in n)){let d=t.normalizeDefaultResult(p.default(this._utils));"value"in d&&u.push({[l]:d.value})}}i();for(let l of Object.keys(this._utils.schemas)){let p=this._utils.schemas[l];l in n&&(n[l]=p.postprocess(n[l],this._utils))}return n}_applyNormalization(a,n){let u=[],[i,l]=t.partition(Object.keys(a),p=>p in this._utils.schemas);for(let p of i){let d=this._utils.schemas[p],y=d.preprocess(a[p],this._utils),g=t.normalizeValidateResult(d.validate(y,this._utils),y);if(g!==!0){let{value:w}=g,F=this._invalidHandler(p,w,this._utils);throw typeof F=="string"?new Error(F):F}let c=w=>{let{from:F,to:S}=w;u.push(typeof S=="string"?{[S]:F}:{[S.key]:S.value})},D=w=>{let{value:F,redirectTo:S}=w,N=t.normalizeDeprecatedResult(d.deprecated(F,this._utils),y,!0);if(N!==!1)if(N===!0)this._hasDeprecationWarned(p)||this._utils.logger.warn(this._deprecatedHandler(p,S,this._utils));else for(let{value:I}of N){let P={key:p,value:I};if(!this._hasDeprecationWarned(P)){let $=typeof S=="string"?{key:S,value:I}:S;this._utils.logger.warn(this._deprecatedHandler(P,$,this._utils))}}};t.normalizeForwardResult(d.forward(y,this._utils),y).forEach(c);let _=t.normalizeRedirectResult(d.redirect(y,this._utils),y);if(_.redirect.forEach(c),"remain"in _){let w=_.remain;n[p]=p in n?d.overlap(n[p],w,this._utils):w,D({value:w})}for(let{from:w,to:F}of _.redirect)D({value:w,redirectTo:F})}for(let p of l){let d=a[p],y=this._unknownHandler(p,d,this._utils);if(y)for(let g of Object.keys(y)){let c={[g]:y[g]};g in this._utils.schemas?u.push(c):Object.assign(n,c)}}return u}};e.Normalizer=s}}),Lm=te({"node_modules/vnopts/lib/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=(Et(),ft(vt));r.__exportStar(vm(),e),r.__exportStar(Sm(),e),r.__exportStar(Pm(),e),r.__exportStar(km(),e),r.__exportStar(Ft(),e)}}),Om=te({"src/main/options-normalizer.js"(e,r){"use strict";ne();var t=Lm(),s=lt(),a={key:g=>g.length===1?`-${g}`:`--${g}`,value:g=>t.apiDescriptor.value(g),pair:g=>{let{key:c,value:D}=g;return D===!1?`--no-${c}`:D===!0?a.key(c):D===""?`${a.key(c)} without an argument`:`${a.key(c)}=${D}`}},n=g=>{let{colorsModule:c,levenshteinDistance:D}=g;return class extends t.ChoiceSchema{constructor(_){let{name:w,flags:F}=_;super({name:w,choices:F}),this._flags=[...F].sort()}preprocess(_,w){if(typeof _=="string"&&_.length>0&&!this._flags.includes(_)){let F=this._flags.find(S=>D(S,_)<3);if(F)return w.logger.warn([`Unknown flag ${c.yellow(w.descriptor.value(_))},`,`did you mean ${c.blue(w.descriptor.value(F))}?`].join(" ")),F}return _}expected(){return"a flag"}}},u;function i(g,c){let{logger:D=!1,isCLI:E=!1,passThrough:_=!1,colorsModule:w=null,levenshteinDistance:F=null}=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},S=_?Array.isArray(_)?(T,m)=>_.includes(T)?{[T]:m}:void 0:(T,m)=>({[T]:m}):(T,m,v)=>{let o=v.schemas,{_:h}=o,C=Hn(o,vD);return t.levenUnknownHandler(T,m,Object.assign(Object.assign({},v),{},{schemas:C}))},N=E?a:t.apiDescriptor,I=l(c,{isCLI:E,colorsModule:w,levenshteinDistance:F}),P=new t.Normalizer(I,{logger:D,unknown:S,descriptor:N}),$=D!==!1;$&&u&&(P._hasDeprecationWarned=u);let f=P.normalize(g);return $&&(u=P._hasDeprecationWarned),E&&f["plugin-search"]===!1&&(f["plugin-search-dir"]=!1),f}function l(g,c){let{isCLI:D,colorsModule:E,levenshteinDistance:_}=c,w=[];D&&w.push(t.AnySchema.create({name:"_"}));for(let F of g)w.push(p(F,{isCLI:D,optionInfos:g,colorsModule:E,levenshteinDistance:_})),F.alias&&D&&w.push(t.AliasSchema.create({name:F.alias,sourceName:F.name}));return w}function p(g,c){let{isCLI:D,optionInfos:E,colorsModule:_,levenshteinDistance:w}=c,{name:F}=g;if(F==="plugin-search-dir"||F==="pluginSearchDirs")return t.AnySchema.create({name:F,preprocess(P){return P===!1||(P=Array.isArray(P)?P:[P]),P},validate(P){return P===!1?!0:P.every($=>typeof $=="string")},expected(){return"false or paths to plugin search dir"}});let S={name:F},N,I={};switch(g.type){case"int":N=t.IntegerSchema,D&&(S.preprocess=Number);break;case"string":N=t.StringSchema;break;case"choice":N=t.ChoiceSchema,S.choices=g.choices.map(P=>typeof P=="object"&&P.redirect?Object.assign(Object.assign({},P),{},{redirect:{to:{key:g.name,value:P.redirect}}}):P);break;case"boolean":N=t.BooleanSchema;break;case"flag":N=n({colorsModule:_,levenshteinDistance:w}),S.flags=E.flatMap(P=>[P.alias,P.description&&P.name,P.oppositeDescription&&`no-${P.name}`].filter(Boolean));break;case"path":N=t.StringSchema;break;default:throw new Error(`Unexpected type ${g.type}`)}if(g.exception?S.validate=(P,$,f)=>g.exception(P)||$.validate(P,f):S.validate=(P,$,f)=>P===void 0||$.validate(P,f),g.redirect&&(I.redirect=P=>P?{to:{key:g.redirect.option,value:g.redirect.value}}:void 0),g.deprecated&&(I.deprecated=!0),D&&!g.array){let P=S.preprocess||($=>$);S.preprocess=($,f,T)=>f.preprocess(P(Array.isArray($)?s($):$),T)}return g.array?t.ArraySchema.create(Object.assign(Object.assign(Object.assign({},D?{preprocess:P=>Array.isArray(P)?P:[P]}:{}),I),{},{valueSchema:N.create(S)})):N.create(Object.assign(Object.assign({},S),I))}function d(g,c,D){return i(g,c,D)}function y(g,c,D){return i(g,c,Object.assign({isCLI:!0},D))}r.exports={normalizeApiOptions:d,normalizeCliOptions:y}}}),ut=te({"src/language-js/loc.js"(e,r){"use strict";ne();var t=Kn();function s(l){var p,d;let y=l.range?l.range[0]:l.start,g=(p=(d=l.declaration)===null||d===void 0?void 0:d.decorators)!==null&&p!==void 0?p:l.decorators;return t(g)?Math.min(s(g[0]),y):y}function a(l){return l.range?l.range[1]:l.end}function n(l,p){let d=s(l);return Number.isInteger(d)&&d===s(p)}function u(l,p){let d=a(l);return Number.isInteger(d)&&d===a(p)}function i(l,p){return n(l,p)&&u(l,p)}r.exports={locStart:s,locEnd:a,hasSameLocStart:n,hasSameLoc:i}}}),jm=te({"src/main/load-parser.js"(e,r){ne(),r.exports=()=>{}}}),qm=te({"scripts/build/shims/babel-highlight.cjs"(e,r){"use strict";ne();var t=kr(),s={shouldHighlight:()=>!1,getChalk:()=>t};r.exports=s}}),Mm=te({"node_modules/@babel/code-frame/lib/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0}),e.codeFrameColumns=u,e.default=i;var r=qm(),t=!1;function s(l){return{gutter:l.grey,marker:l.red.bold,message:l.red.bold}}var a=/\r\n|[\n\r\u2028\u2029]/;function n(l,p,d){let y=Object.assign({column:0,line:-1},l.start),g=Object.assign({},y,l.end),{linesAbove:c=2,linesBelow:D=3}=d||{},E=y.line,_=y.column,w=g.line,F=g.column,S=Math.max(E-(c+1),0),N=Math.min(p.length,w+D);E===-1&&(S=0),w===-1&&(N=p.length);let I=w-E,P={};if(I)for(let $=0;$<=I;$++){let f=$+E;if(!_)P[f]=!0;else if($===0){let T=p[f-1].length;P[f]=[_,T-_+1]}else if($===I)P[f]=[0,F];else{let T=p[f-$].length;P[f]=[0,T]}}else _===F?_?P[E]=[_,0]:P[E]=!0:P[E]=[_,F-_];return{start:S,end:N,markerLines:P}}function u(l,p){let d=arguments.length>2&&arguments[2]!==void 0?arguments[2]:{},y=(d.highlightCode||d.forceColor)&&(0,r.shouldHighlight)(d),g=(0,r.getChalk)(d),c=s(g),D=($,f)=>y?$(f):f,E=l.split(a),{start:_,end:w,markerLines:F}=n(p,E,d),S=p.start&&typeof p.start.column=="number",N=String(w).length,P=(y?(0,r.default)(l,d):l).split(a,w).slice(_,w).map(($,f)=>{let T=_+1+f,v=` ${` ${T}`.slice(-N)} |`,o=F[T],h=!F[T+1];if(o){let C="";if(Array.isArray(o)){let x=$.slice(0,Math.max(o[0]-1,0)).replace(/[^\t]/g," "),b=o[1]||1;C=[`
 `,D(c.gutter,v.replace(/\d/g," "))," ",x,D(c.marker,"^").repeat(b)].join(""),h&&d.message&&(C+=" "+D(c.message,d.message))}return[D(c.marker,">"),D(c.gutter,v),$.length>0?` ${$}`:"",C].join("")}else return` ${D(c.gutter,v)}${$.length>0?` ${$}`:""}`}).join(`
`);return d.message&&!S&&(P=`${" ".repeat(N+1)}${d.message}
${P}`),y?g.reset(P):P}function i(l,p,d){let y=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{};if(!t){t=!0;let c="Passing lineNumber and colNumber is deprecated to @babel/code-frame. Please use `codeFrameColumns`.";if(wt.emitWarning)wt.emitWarning(c,"DeprecationWarning");else{let D=new Error(c);D.name="DeprecationWarning",console.warn(new Error(c))}}return d=Math.max(d,0),u(l,{start:{column:d,line:p}},y)}}}),tu=te({"src/main/parser.js"(e,r){"use strict";ne();var{ConfigError:t}=Qt(),s=ut(),a=jm(),{locStart:n,locEnd:u}=s,i=Object.getOwnPropertyNames,l=Object.getOwnPropertyDescriptor;function p(g){let c={};for(let D of g.plugins)if(D.parsers)for(let E of i(D.parsers))Object.defineProperty(c,E,l(D.parsers,E));return c}function d(g){let c=arguments.length>1&&arguments[1]!==void 0?arguments[1]:p(g);if(typeof g.parser=="function")return{parse:g.parser,astFormat:"estree",locStart:n,locEnd:u};if(typeof g.parser=="string"){if(Object.prototype.hasOwnProperty.call(c,g.parser))return c[g.parser];throw new t(`Couldn't resolve parser "${g.parser}". Parsers must be explicitly added to the standalone bundle.`)}}function y(g,c){let D=p(c),E=Object.defineProperties({},Object.fromEntries(Object.keys(D).map(w=>[w,{enumerable:!0,get(){return D[w].parse}}]))),_=d(c,D);try{return _.preprocess&&(g=_.preprocess(g,c)),{text:g,ast:_.parse(g,E,c)}}catch(w){let{loc:F}=w;if(F){let{codeFrameColumns:S}=Mm();throw w.codeFrame=S(g,F,{highlightCode:!0}),w.message+=`
`+w.codeFrame,w}throw w}}r.exports={parse:y,resolveParser:d}}}),uo=te({"src/main/options.js"(e,r){"use strict";ne();var t=ZD(),{UndefinedParserError:s}=Qt(),{getSupportInfo:a}=Xn(),n=Om(),{resolveParser:u}=tu(),i={astFormat:"estree",printer:{},originalText:void 0,locStart:null,locEnd:null};function l(y){let g=arguments.length>1&&arguments[1]!==void 0?arguments[1]:{},c=Object.assign({},y),D=a({plugins:y.plugins,showUnreleased:!0,showDeprecated:!0}).options,E=Object.assign(Object.assign({},i),Object.fromEntries(D.filter(N=>N.default!==void 0).map(N=>[N.name,N.default])));if(!c.parser){if(!c.filepath)(g.logger||console).warn("No parser and no filepath given, using 'babel' the parser now but this will throw an error in the future. Please specify a parser or a filepath so one can be inferred."),c.parser="babel";else if(c.parser=d(c.filepath,c.plugins),!c.parser)throw new s(`No parser could be inferred for file: ${c.filepath}`)}let _=u(n.normalizeApiOptions(c,[D.find(N=>N.name==="parser")],{passThrough:!0,logger:!1}));c.astFormat=_.astFormat,c.locEnd=_.locEnd,c.locStart=_.locStart;let w=p(c);c.printer=w.printers[c.astFormat];let F=Object.fromEntries(D.filter(N=>N.pluginDefaults&&N.pluginDefaults[w.name]!==void 0).map(N=>[N.name,N.pluginDefaults[w.name]])),S=Object.assign(Object.assign({},E),F);for(let[N,I]of Object.entries(S))(c[N]===null||c[N]===void 0)&&(c[N]=I);return c.parser==="json"&&(c.trailingComma="none"),n.normalizeApiOptions(c,D,Object.assign({passThrough:Object.keys(i)},g))}function p(y){let{astFormat:g}=y;if(!g)throw new Error("getPlugin() requires astFormat to be set");let c=y.plugins.find(D=>D.printers&&D.printers[g]);if(!c)throw new Error(`Couldn't find plugin for AST format "${g}"`);return c}function d(y,g){let c=t.basename(y).toLowerCase(),E=a({plugins:g}).languages.filter(_=>_.since!==null).find(_=>_.extensions&&_.extensions.some(w=>c.endsWith(w))||_.filenames&&_.filenames.some(w=>w.toLowerCase()===c));return E&&E.parsers[0]}r.exports={normalize:l,hiddenDefaults:i,inferParser:d}}}),Rm=te({"src/main/massage-ast.js"(e,r){"use strict";ne();function t(s,a,n){if(Array.isArray(s))return s.map(p=>t(p,a,n)).filter(Boolean);if(!s||typeof s!="object")return s;let u=a.printer.massageAstNode,i;u&&u.ignoredProperties?i=u.ignoredProperties:i=new Set;let l={};for(let[p,d]of Object.entries(s))!i.has(p)&&typeof d!="function"&&(l[p]=t(d,a,s));if(u){let p=u(s,l,n);if(p===null)return;if(p)return p}return l}r.exports=t}}),Zt=te({"scripts/build/shims/assert.cjs"(e,r){"use strict";ne();var t=()=>{};t.ok=t,t.strictEqual=t,r.exports=t}}),et=te({"src/main/comments.js"(e,r){"use strict";ne();var t=Zt(),{builders:{line:s,hardline:a,breakParent:n,indent:u,lineSuffix:i,join:l,cursor:p}}=qe(),{hasNewline:d,skipNewline:y,skipSpaces:g,isPreviousLineEmpty:c,addLeadingComment:D,addDanglingComment:E,addTrailingComment:_}=Ue(),w=new WeakMap;function F(k,M,R){if(!k)return;let{printer:q,locStart:J,locEnd:L}=M;if(R){if(q.canAttachComment&&q.canAttachComment(k)){let V;for(V=R.length-1;V>=0&&!(J(R[V])<=J(k)&&L(R[V])<=L(k));--V);R.splice(V+1,0,k);return}}else if(w.has(k))return w.get(k);let Q=q.getCommentChildNodes&&q.getCommentChildNodes(k,M)||typeof k=="object"&&Object.entries(k).filter(V=>{let[j]=V;return j!=="enclosingNode"&&j!=="precedingNode"&&j!=="followingNode"&&j!=="tokens"&&j!=="comments"&&j!=="parent"}).map(V=>{let[,j]=V;return j});if(Q){R||(R=[],w.set(k,R));for(let V of Q)F(V,M,R);return R}}function S(k,M,R,q){let{locStart:J,locEnd:L}=R,Q=J(M),V=L(M),j=F(k,R),Y,ie,ee=0,le=j.length;for(;ee<le;){let W=ee+le>>1,K=j[W],de=J(K),ue=L(K);if(de<=Q&&V<=ue)return S(K,M,R,K);if(ue<=Q){Y=K,ee=W+1;continue}if(V<=de){ie=K,le=W;continue}throw new Error("Comment location overlaps with node location")}if(q&&q.type==="TemplateLiteral"){let{quasis:W}=q,K=v(W,M,R);Y&&v(W,Y,R)!==K&&(Y=null),ie&&v(W,ie,R)!==K&&(ie=null)}return{enclosingNode:q,precedingNode:Y,followingNode:ie}}var N=()=>!1;function I(k,M,R,q){if(!Array.isArray(k))return;let J=[],{locStart:L,locEnd:Q,printer:{handleComments:V={}}}=q,{avoidAstMutation:j,ownLine:Y=N,endOfLine:ie=N,remaining:ee=N}=V,le=k.map((W,K)=>Object.assign(Object.assign({},S(M,W,q)),{},{comment:W,text:R,options:q,ast:M,isLastComment:k.length-1===K}));for(let[W,K]of le.entries()){let{comment:de,precedingNode:ue,enclosingNode:Fe,followingNode:z,text:U,options:Z,ast:se,isLastComment:De}=K;if(Z.parser==="json"||Z.parser==="json5"||Z.parser==="__js_expression"||Z.parser==="__vue_expression"||Z.parser==="__vue_ts_expression"){if(L(de)-L(se)<=0){D(se,de);continue}if(Q(de)-Q(se)>=0){_(se,de);continue}}let ge;if(j?ge=[K]:(de.enclosingNode=Fe,de.precedingNode=ue,de.followingNode=z,ge=[de,U,Z,se,De]),$(U,Z,le,W))de.placement="ownLine",Y(...ge)||(z?D(z,de):ue?_(ue,de):E(Fe||se,de));else if(f(U,Z,le,W))de.placement="endOfLine",ie(...ge)||(ue?_(ue,de):z?D(z,de):E(Fe||se,de));else if(de.placement="remaining",!ee(...ge))if(ue&&z){let he=J.length;he>0&&J[he-1].followingNode!==z&&T(J,U,Z),J.push(K)}else ue?_(ue,de):z?D(z,de):E(Fe||se,de)}if(T(J,R,q),!j)for(let W of k)delete W.precedingNode,delete W.enclosingNode,delete W.followingNode}var P=k=>!/[\S\n\u2028\u2029]/.test(k);function $(k,M,R,q){let{comment:J,precedingNode:L}=R[q],{locStart:Q,locEnd:V}=M,j=Q(J);if(L)for(let Y=q-1;Y>=0;Y--){let{comment:ie,precedingNode:ee}=R[Y];if(ee!==L||!P(k.slice(V(ie),j)))break;j=Q(ie)}return d(k,j,{backwards:!0})}function f(k,M,R,q){let{comment:J,followingNode:L}=R[q],{locStart:Q,locEnd:V}=M,j=V(J);if(L)for(let Y=q+1;Y<R.length;Y++){let{comment:ie,followingNode:ee}=R[Y];if(ee!==L||!P(k.slice(j,Q(ie))))break;j=V(ie)}return d(k,j)}function T(k,M,R){let q=k.length;if(q===0)return;let{precedingNode:J,followingNode:L,enclosingNode:Q}=k[0],V=R.printer.getGapRegex&&R.printer.getGapRegex(Q)||/^[\s(]*$/,j=R.locStart(L),Y;for(Y=q;Y>0;--Y){let{comment:ie,precedingNode:ee,followingNode:le}=k[Y-1];t.strictEqual(ee,J),t.strictEqual(le,L);let W=M.slice(R.locEnd(ie),j);if(V.test(W))j=R.locStart(ie);else break}for(let[ie,{comment:ee}]of k.entries())ie<Y?_(J,ee):D(L,ee);for(let ie of[J,L])ie.comments&&ie.comments.length>1&&ie.comments.sort((ee,le)=>R.locStart(ee)-R.locStart(le));k.length=0}function m(k,M){let R=k.getValue();return R.printed=!0,M.printer.printComment(k,M)}function v(k,M,R){let q=R.locStart(M)-1;for(let J=1;J<k.length;++J)if(q<R.locStart(k[J]))return J-1;return 0}function o(k,M){let R=k.getValue(),q=[m(k,M)],{printer:J,originalText:L,locStart:Q,locEnd:V}=M;if(J.isBlockComment&&J.isBlockComment(R)){let ie=d(L,V(R))?d(L,Q(R),{backwards:!0})?a:s:" ";q.push(ie)}else q.push(a);let Y=y(L,g(L,V(R)));return Y!==!1&&d(L,Y)&&q.push(a),q}function h(k,M){let R=k.getValue(),q=m(k,M),{printer:J,originalText:L,locStart:Q}=M,V=J.isBlockComment&&J.isBlockComment(R);if(d(L,Q(R),{backwards:!0})){let Y=c(L,R,Q);return i([a,Y?a:"",q])}let j=[" ",q];return V||(j=[i(j),n]),j}function C(k,M,R,q){let J=[],L=k.getValue();return!L||!L.comments||(k.each(()=>{let Q=k.getValue();!Q.leading&&!Q.trailing&&(!q||q(Q))&&J.push(m(k,M))},"comments"),J.length===0)?"":R?l(a,J):u([a,l(a,J)])}function x(k,M,R){let q=k.getValue();if(!q)return{};let J=q.comments||[];R&&(J=J.filter(j=>!R.has(j)));let L=q===M.cursorNode;if(J.length===0){let j=L?p:"";return{leading:j,trailing:j}}let Q=[],V=[];return k.each(()=>{let j=k.getValue();if(R&&R.has(j))return;let{leading:Y,trailing:ie}=j;Y?Q.push(o(k,M)):ie&&V.push(h(k,M))},"comments"),L&&(Q.unshift(p),V.push(p)),{leading:Q,trailing:V}}function b(k,M,R,q){let{leading:J,trailing:L}=x(k,R,q);return!J&&!L?M:[J,M,L]}function B(k){if(k)for(let M of k){if(!M.printed)throw new Error('Comment "'+M.value.trim()+'" was not printed. Please report this error!');delete M.printed}}r.exports={attach:I,printComments:b,printCommentsSeparately:x,printDanglingComments:C,getSortedChildNodes:F,ensureAllCommentsPrinted:B}}}),$m=te({"src/common/ast-path.js"(e,r){"use strict";ne();var t=lt();function s(u,i){let l=a(u.stack,i);return l===-1?null:u.stack[l]}function a(u,i){for(let l=u.length-1;l>=0;l-=2){let p=u[l];if(p&&!Array.isArray(p)&&--i<0)return l}return-1}var n=class{constructor(u){this.stack=[u]}getName(){let{stack:u}=this,{length:i}=u;return i>1?u[i-2]:null}getValue(){return t(this.stack)}getNode(){let u=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return s(this,u)}getParentNode(){let u=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return s(this,u+1)}call(u){let{stack:i}=this,{length:l}=i,p=t(i);for(var d=arguments.length,y=new Array(d>1?d-1:0),g=1;g<d;g++)y[g-1]=arguments[g];for(let D of y)p=p[D],i.push(D,p);let c=u(this);return i.length=l,c}callParent(u){let i=arguments.length>1&&arguments[1]!==void 0?arguments[1]:0,l=a(this.stack,i+1),p=this.stack.splice(l+1),d=u(this);return this.stack.push(...p),d}each(u){let{stack:i}=this,{length:l}=i,p=t(i);for(var d=arguments.length,y=new Array(d>1?d-1:0),g=1;g<d;g++)y[g-1]=arguments[g];for(let c of y)p=p[c],i.push(c,p);for(let c=0;c<p.length;++c)i.push(c,p[c]),u(this,c,p),i.length-=2;i.length=l}map(u){let i=[];for(var l=arguments.length,p=new Array(l>1?l-1:0),d=1;d<l;d++)p[d-1]=arguments[d];return this.each((y,g,c)=>{i[g]=u(y,g,c)},...p),i}try(u){let{stack:i}=this,l=[...i];try{return u()}finally{i.length=0,i.push(...l)}}match(){let u=this.stack.length-1,i=null,l=this.stack[u--];for(var p=arguments.length,d=new Array(p),y=0;y<p;y++)d[y]=arguments[y];for(let g of d){if(l===void 0)return!1;let c=null;if(typeof i=="number"&&(c=i,i=this.stack[u--],l=this.stack[u--]),g&&!g(l,i,c))return!1;i=this.stack[u--],l=this.stack[u--]}return!0}findAncestor(u){let i=this.stack.length-1,l=null,p=this.stack[i--];for(;p;){let d=null;if(typeof l=="number"&&(d=l,l=this.stack[i--],p=this.stack[i--]),l!==null&&u(p,l,d))return p;l=this.stack[i--],p=this.stack[i--]}}};r.exports=n}}),Vm=te({"src/main/multiparser.js"(e,r){"use strict";ne();var{utils:{stripTrailingHardline:t}}=qe(),{normalize:s}=uo(),a=et();function n(i,l,p,d){if(p.printer.embed&&p.embeddedLanguageFormatting==="auto")return p.printer.embed(i,l,(y,g,c)=>u(y,g,p,d,c),p)}function u(i,l,p,d){let{stripTrailingHardline:y=!1}=arguments.length>4&&arguments[4]!==void 0?arguments[4]:{},g=s(Object.assign(Object.assign(Object.assign({},p),l),{},{parentParser:p.parser,originalText:i}),{passThrough:!0}),c=tu().parse(i,g),{ast:D}=c;i=c.text;let E=D.comments;delete D.comments,a.attach(E,D,i,g),g[Symbol.for("comments")]=E||[],g[Symbol.for("tokens")]=D.tokens||[];let _=d(D,g);return a.ensureAllCommentsPrinted(E),y?typeof _=="string"?_.replace(/(?:\r?\n)*$/,""):t(_):_}r.exports={printSubtree:n}}}),Wm=te({"src/main/ast-to-doc.js"(e,r){"use strict";ne();var t=$m(),{builders:{hardline:s,addAlignmentToDoc:a},utils:{propagateBreaks:n}}=qe(),{printComments:u}=et(),i=Vm();function l(y,g){let c=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0,{printer:D}=g;D.preprocess&&(y=D.preprocess(y,g));let E=new Map,_=new t(y),w=F();return c>0&&(w=a([s,w],c,g.tabWidth)),n(w),w;function F(N,I){return N===void 0||N===_?S(I):Array.isArray(N)?_.call(()=>S(I),...N):_.call(()=>S(I),N)}function S(N){let I=_.getValue(),P=I&&typeof I=="object"&&N===void 0;if(P&&E.has(I))return E.get(I);let $=d(_,g,F,N);return P&&E.set(I,$),$}}function p(y,g){let{originalText:c,[Symbol.for("comments")]:D,locStart:E,locEnd:_}=g,w=E(y),F=_(y),S=new Set;for(let N of D)E(N)>=w&&_(N)<=F&&(N.printed=!0,S.add(N));return{doc:c.slice(w,F),printedComments:S}}function d(y,g,c,D){let E=y.getValue(),{printer:_}=g,w,F;if(_.hasPrettierIgnore&&_.hasPrettierIgnore(y))({doc:w,printedComments:F}=p(E,g));else{if(E)try{w=i.printSubtree(y,c,g,l)}catch(S){if(globalThis.PRETTIER_DEBUG)throw S}w||(w=_.print(y,g,c,D))}return(!_.willPrintOwnComments||!_.willPrintOwnComments(y,g))&&(w=u(y,w,g,F)),w}r.exports=l}}),Hm=te({"src/main/range-util.js"(e,r){"use strict";ne();var t=Zt(),s=et(),a=D=>{let{parser:E}=D;return E==="json"||E==="json5"||E==="json-stringify"};function n(D,E){let _=[D.node,...D.parentNodes],w=new Set([E.node,...E.parentNodes]);return _.find(F=>d.has(F.type)&&w.has(F))}function u(D){let E=D.length-1;for(;;){let _=D[E];if(_&&(_.type==="Program"||_.type==="File"))E--;else break}return D.slice(0,E+1)}function i(D,E,_){let{locStart:w,locEnd:F}=_,S=D.node,N=E.node;if(S===N)return{startNode:S,endNode:N};let I=w(D.node);for(let $ of u(E.parentNodes))if(w($)>=I)N=$;else break;let P=F(E.node);for(let $ of u(D.parentNodes)){if(F($)<=P)S=$;else break;if(S===N)break}return{startNode:S,endNode:N}}function l(D,E,_,w){let F=arguments.length>4&&arguments[4]!==void 0?arguments[4]:[],S=arguments.length>5?arguments[5]:void 0,{locStart:N,locEnd:I}=_,P=N(D),$=I(D);if(!(E>$||E<P||S==="rangeEnd"&&E===P||S==="rangeStart"&&E===$)){for(let f of s.getSortedChildNodes(D,_)){let T=l(f,E,_,w,[D,...F],S);if(T)return T}if(!w||w(D,F[0]))return{node:D,parentNodes:F}}}function p(D,E){return E!=="DeclareExportDeclaration"&&D!=="TypeParameterDeclaration"&&(D==="Directive"||D==="TypeAlias"||D==="TSExportAssignment"||D.startsWith("Declare")||D.startsWith("TSDeclare")||D.endsWith("Statement")||D.endsWith("Declaration"))}var d=new Set(["ObjectExpression","ArrayExpression","StringLiteral","NumericLiteral","BooleanLiteral","NullLiteral","UnaryExpression","TemplateLiteral"]),y=new Set(["OperationDefinition","FragmentDefinition","VariableDefinition","TypeExtensionDefinition","ObjectTypeDefinition","FieldDefinition","DirectiveDefinition","EnumTypeDefinition","EnumValueDefinition","InputValueDefinition","InputObjectTypeDefinition","SchemaDefinition","OperationTypeDefinition","InterfaceTypeDefinition","UnionTypeDefinition","ScalarTypeDefinition"]);function g(D,E,_){if(!E)return!1;switch(D.parser){case"flow":case"babel":case"babel-flow":case"babel-ts":case"typescript":case"acorn":case"espree":case"meriyah":case"__babel_estree":return p(E.type,_&&_.type);case"json":case"json5":case"json-stringify":return d.has(E.type);case"graphql":return y.has(E.kind);case"vue":return E.tag!=="root"}return!1}function c(D,E,_){let{rangeStart:w,rangeEnd:F,locStart:S,locEnd:N}=E;t.ok(F>w);let I=D.slice(w,F).search(/\S/),P=I===-1;if(!P)for(w+=I;F>w&&!/\S/.test(D[F-1]);--F);let $=l(_,w,E,(v,o)=>g(E,v,o),[],"rangeStart"),f=P?$:l(_,F,E,v=>g(E,v),[],"rangeEnd");if(!$||!f)return{rangeStart:0,rangeEnd:0};let T,m;if(a(E)){let v=n($,f);T=v,m=v}else({startNode:T,endNode:m}=i($,f,E));return{rangeStart:Math.min(S(T),S(m)),rangeEnd:Math.max(N(T),N(m))}}r.exports={calculateRange:c,findNodeAtOffset:l}}}),Gm=te({"src/main/core.js"(e,r){"use strict";ne();var{diffArrays:t}=BD(),{printer:{printDocToString:s},debug:{printDocToDebug:a}}=qe(),{getAlignmentSize:n}=Ue(),{guessEndOfLine:u,convertEndOfLineToChars:i,countEndOfLineChars:l,normalizeEndOfLine:p}=Jn(),d=uo().normalize,y=Rm(),g=et(),c=tu(),D=Wm(),E=Hm(),_="\uFEFF",w=Symbol("cursor");function F(m,v,o){let h=v.comments;return h&&(delete v.comments,g.attach(h,v,m,o)),o[Symbol.for("comments")]=h||[],o[Symbol.for("tokens")]=v.tokens||[],o.originalText=m,h}function S(m,v){let o=arguments.length>2&&arguments[2]!==void 0?arguments[2]:0;if(!m||m.trim().length===0)return{formatted:"",cursorOffset:-1,comments:[]};let{ast:h,text:C}=c.parse(m,v);if(v.cursorOffset>=0){let k=E.findNodeAtOffset(h,v.cursorOffset,v);k&&k.node&&(v.cursorNode=k.node)}let x=F(C,h,v),b=D(h,v,o),B=s(b,v);if(g.ensureAllCommentsPrinted(x),o>0){let k=B.formatted.trim();B.cursorNodeStart!==void 0&&(B.cursorNodeStart-=B.formatted.indexOf(k)),B.formatted=k+i(v.endOfLine)}if(v.cursorOffset>=0){let k,M,R,q,J;if(v.cursorNode&&B.cursorNodeText?(k=v.locStart(v.cursorNode),M=C.slice(k,v.locEnd(v.cursorNode)),R=v.cursorOffset-k,q=B.cursorNodeStart,J=B.cursorNodeText):(k=0,M=C,R=v.cursorOffset,q=0,J=B.formatted),M===J)return{formatted:B.formatted,cursorOffset:q+R,comments:x};let L=[...M];L.splice(R,0,w);let Q=[...J],V=t(L,Q),j=q;for(let Y of V)if(Y.removed){if(Y.value.includes(w))break}else j+=Y.count;return{formatted:B.formatted,cursorOffset:j,comments:x}}return{formatted:B.formatted,cursorOffset:-1,comments:x}}function N(m,v){let{ast:o,text:h}=c.parse(m,v),{rangeStart:C,rangeEnd:x}=E.calculateRange(h,v,o),b=h.slice(C,x),B=Math.min(C,h.lastIndexOf(`
`,C)+1),k=h.slice(B,C).match(/^\s*/)[0],M=n(k,v.tabWidth),R=S(b,Object.assign(Object.assign({},v),{},{rangeStart:0,rangeEnd:Number.POSITIVE_INFINITY,cursorOffset:v.cursorOffset>C&&v.cursorOffset<=x?v.cursorOffset-C:-1,endOfLine:"lf"}),M),q=R.formatted.trimEnd(),{cursorOffset:J}=v;J>x?J+=q.length-b.length:R.cursorOffset>=0&&(J=R.cursorOffset+C);let L=h.slice(0,C)+q+h.slice(x);if(v.endOfLine!=="lf"){let Q=i(v.endOfLine);J>=0&&Q===`\r
`&&(J+=l(L.slice(0,J),`
`)),L=L.replace(/\n/g,Q)}return{formatted:L,cursorOffset:J,comments:R.comments}}function I(m,v,o){return typeof v!="number"||Number.isNaN(v)||v<0||v>m.length?o:v}function P(m,v){let{cursorOffset:o,rangeStart:h,rangeEnd:C}=v;return o=I(m,o,-1),h=I(m,h,0),C=I(m,C,m.length),Object.assign(Object.assign({},v),{},{cursorOffset:o,rangeStart:h,rangeEnd:C})}function $(m,v){let{cursorOffset:o,rangeStart:h,rangeEnd:C,endOfLine:x}=P(m,v),b=m.charAt(0)===_;if(b&&(m=m.slice(1),o--,h--,C--),x==="auto"&&(x=u(m)),m.includes("\r")){let B=k=>l(m.slice(0,Math.max(k,0)),`\r
`);o-=B(o),h-=B(h),C-=B(C),m=p(m)}return{hasBOM:b,text:m,options:P(m,Object.assign(Object.assign({},v),{},{cursorOffset:o,rangeStart:h,rangeEnd:C,endOfLine:x}))}}function f(m,v){let o=c.resolveParser(v);return!o.hasPragma||o.hasPragma(m)}function T(m,v){let{hasBOM:o,text:h,options:C}=$(m,d(v));if(C.rangeStart>=C.rangeEnd&&h!==""||C.requirePragma&&!f(h,C))return{formatted:m,cursorOffset:v.cursorOffset,comments:[]};let x;return C.rangeStart>0||C.rangeEnd<h.length?x=N(h,C):(!C.requirePragma&&C.insertPragma&&C.printer.insertPragma&&!f(h,C)&&(h=C.printer.insertPragma(h)),x=S(h,C)),o&&(x.formatted=_+x.formatted,x.cursorOffset>=0&&x.cursorOffset++),x}r.exports={formatWithCursor:T,parse(m,v,o){let{text:h,options:C}=$(m,d(v)),x=c.parse(h,C);return o&&(x.ast=y(x.ast,C)),x},formatAST(m,v){v=d(v);let o=D(m,v);return s(o,v)},formatDoc(m,v){return T(a(m),Object.assign(Object.assign({},v),{},{parser:"__js_expression"})).formatted},printToDoc(m,v){v=d(v);let{ast:o,text:h}=c.parse(m,v);return F(h,o,v),D(o,v)},printDocToString(m,v){return s(m,d(v))}}}}),Um=te({"src/common/util-shared.js"(e,r){"use strict";ne();var{getMaxContinuousCount:t,getStringWidth:s,getAlignmentSize:a,getIndentSize:n,skip:u,skipWhitespace:i,skipSpaces:l,skipNewline:p,skipToLineEnd:d,skipEverythingButNewLine:y,skipInlineComment:g,skipTrailingComment:c,hasNewline:D,hasNewlineInRange:E,hasSpaces:_,isNextLineEmpty:w,isNextLineEmptyAfterIndex:F,isPreviousLineEmpty:S,getNextNonSpaceNonCommentCharacterIndex:N,makeString:I,addLeadingComment:P,addDanglingComment:$,addTrailingComment:f}=Ue();r.exports={getMaxContinuousCount:t,getStringWidth:s,getAlignmentSize:a,getIndentSize:n,skip:u,skipWhitespace:i,skipSpaces:l,skipNewline:p,skipToLineEnd:d,skipEverythingButNewLine:y,skipInlineComment:g,skipTrailingComment:c,hasNewline:D,hasNewlineInRange:E,hasSpaces:_,isNextLineEmpty:w,isNextLineEmptyAfterIndex:F,isPreviousLineEmpty:S,getNextNonSpaceNonCommentCharacterIndex:N,makeString:I,addLeadingComment:P,addDanglingComment:$,addTrailingComment:f}}}),_t=te({"src/utils/create-language.js"(e,r){"use strict";ne(),r.exports=function(t,s){let{languageId:a}=t,n=Hn(t,CD);return Object.assign(Object.assign({linguistLanguageId:a},n),s(t))}}}),Jm=te({"node_modules/esutils/lib/ast.js"(e,r){ne(),function(){"use strict";function t(l){if(l==null)return!1;switch(l.type){case"ArrayExpression":case"AssignmentExpression":case"BinaryExpression":case"CallExpression":case"ConditionalExpression":case"FunctionExpression":case"Identifier":case"Literal":case"LogicalExpression":case"MemberExpression":case"NewExpression":case"ObjectExpression":case"SequenceExpression":case"ThisExpression":case"UnaryExpression":case"UpdateExpression":return!0}return!1}function s(l){if(l==null)return!1;switch(l.type){case"DoWhileStatement":case"ForInStatement":case"ForStatement":case"WhileStatement":return!0}return!1}function a(l){if(l==null)return!1;switch(l.type){case"BlockStatement":case"BreakStatement":case"ContinueStatement":case"DebuggerStatement":case"DoWhileStatement":case"EmptyStatement":case"ExpressionStatement":case"ForInStatement":case"ForStatement":case"IfStatement":case"LabeledStatement":case"ReturnStatement":case"SwitchStatement":case"ThrowStatement":case"TryStatement":case"VariableDeclaration":case"WhileStatement":case"WithStatement":return!0}return!1}function n(l){return a(l)||l!=null&&l.type==="FunctionDeclaration"}function u(l){switch(l.type){case"IfStatement":return l.alternate!=null?l.alternate:l.consequent;case"LabeledStatement":case"ForStatement":case"ForInStatement":case"WhileStatement":case"WithStatement":return l.body}return null}function i(l){var p;if(l.type!=="IfStatement"||l.alternate==null)return!1;p=l.consequent;do{if(p.type==="IfStatement"&&p.alternate==null)return!0;p=u(p)}while(p);return!1}r.exports={isExpression:t,isStatement:a,isIterationStatement:s,isSourceElement:n,isProblematicIfStatement:i,trailingStatement:u}}()}}),so=te({"node_modules/esutils/lib/code.js"(e,r){ne(),function(){"use strict";var t,s,a,n,u,i;s={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u1884\u1887-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2E2F\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/,NonAsciiIdentifierPart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19D9\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2119-\u211D\u2124\u2126\u2128\u212A-\u212D\u212F-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u2E2F\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099\u309A\u309D-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]/},t={NonAsciiIdentifierStart:/[\xAA\xB5\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0370-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386\u0388-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u05D0-\u05EA\u05F0-\u05F2\u0620-\u064A\u066E\u066F\u0671-\u06D3\u06D5\u06E5\u06E6\u06EE\u06EF\u06FA-\u06FC\u06FF\u0710\u0712-\u072F\u074D-\u07A5\u07B1\u07CA-\u07EA\u07F4\u07F5\u07FA\u0800-\u0815\u081A\u0824\u0828\u0840-\u0858\u08A0-\u08B4\u08B6-\u08BD\u0904-\u0939\u093D\u0950\u0958-\u0961\u0971-\u0980\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BD\u09CE\u09DC\u09DD\u09DF-\u09E1\u09F0\u09F1\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A59-\u0A5C\u0A5E\u0A72-\u0A74\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABD\u0AD0\u0AE0\u0AE1\u0AF9\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3D\u0B5C\u0B5D\u0B5F-\u0B61\u0B71\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BD0\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D\u0C58-\u0C5A\u0C60\u0C61\u0C80\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBD\u0CDE\u0CE0\u0CE1\u0CF1\u0CF2\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D\u0D4E\u0D54-\u0D56\u0D5F-\u0D61\u0D7A-\u0D7F\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0E01-\u0E30\u0E32\u0E33\u0E40-\u0E46\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB0\u0EB2\u0EB3\u0EBD\u0EC0-\u0EC4\u0EC6\u0EDC-\u0EDF\u0F00\u0F40-\u0F47\u0F49-\u0F6C\u0F88-\u0F8C\u1000-\u102A\u103F\u1050-\u1055\u105A-\u105D\u1061\u1065\u1066\u106E-\u1070\u1075-\u1081\u108E\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176C\u176E-\u1770\u1780-\u17B3\u17D7\u17DC\u1820-\u1877\u1880-\u18A8\u18AA\u18B0-\u18F5\u1900-\u191E\u1950-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u1A00-\u1A16\u1A20-\u1A54\u1AA7\u1B05-\u1B33\u1B45-\u1B4B\u1B83-\u1BA0\u1BAE\u1BAF\u1BBA-\u1BE5\u1C00-\u1C23\u1C4D-\u1C4F\u1C5A-\u1C7D\u1C80-\u1C88\u1CE9-\u1CEC\u1CEE-\u1CF1\u1CF5\u1CF6\u1D00-\u1DBF\u1E00-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u2071\u207F\u2090-\u209C\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CEE\u2CF2\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D80-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303C\u3041-\u3096\u309B-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA61F\uA62A\uA62B\uA640-\uA66E\uA67F-\uA69D\uA6A0-\uA6EF\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA801\uA803-\uA805\uA807-\uA80A\uA80C-\uA822\uA840-\uA873\uA882-\uA8B3\uA8F2-\uA8F7\uA8FB\uA8FD\uA90A-\uA925\uA930-\uA946\uA960-\uA97C\uA984-\uA9B2\uA9CF\uA9E0-\uA9E4\uA9E6-\uA9EF\uA9FA-\uA9FE\uAA00-\uAA28\uAA40-\uAA42\uAA44-\uAA4B\uAA60-\uAA76\uAA7A\uAA7E-\uAAAF\uAAB1\uAAB5\uAAB6\uAAB9-\uAABD\uAAC0\uAAC2\uAADB-\uAADD\uAAE0-\uAAEA\uAAF2-\uAAF4\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABE2\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D\uFB1F-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE70-\uFE74\uFE76-\uFEFC\uFF21-\uFF3A\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDE80-\uDE9C\uDEA0-\uDED0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF75\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00\uDE10-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE4\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC03-\uDC37\uDC83-\uDCAF\uDCD0-\uDCE8\uDD03-\uDD26\uDD50-\uDD72\uDD76\uDD83-\uDDB2\uDDC1-\uDDC4\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE2B\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEDE\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3D\uDF50\uDF5D-\uDF61]|\uD805[\uDC00-\uDC34\uDC47-\uDC4A\uDC80-\uDCAF\uDCC4\uDCC5\uDCC7\uDD80-\uDDAE\uDDD8-\uDDDB\uDE00-\uDE2F\uDE44\uDE80-\uDEAA\uDF00-\uDF19]|\uD806[\uDCA0-\uDCDF\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC2E\uDC40\uDC72-\uDC8F]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDED0-\uDEED\uDF00-\uDF2F\uDF40-\uDF43\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50\uDF93-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB]|\uD83A[\uDC00-\uDCC4\uDD00-\uDD43]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]/,NonAsciiIdentifierPart:/[\xAA\xB5\xB7\xBA\xC0-\xD6\xD8-\xF6\xF8-\u02C1\u02C6-\u02D1\u02E0-\u02E4\u02EC\u02EE\u0300-\u0374\u0376\u0377\u037A-\u037D\u037F\u0386-\u038A\u038C\u038E-\u03A1\u03A3-\u03F5\u03F7-\u0481\u0483-\u0487\u048A-\u052F\u0531-\u0556\u0559\u0561-\u0587\u0591-\u05BD\u05BF\u05C1\u05C2\u05C4\u05C5\u05C7\u05D0-\u05EA\u05F0-\u05F2\u0610-\u061A\u0620-\u0669\u066E-\u06D3\u06D5-\u06DC\u06DF-\u06E8\u06EA-\u06FC\u06FF\u0710-\u074A\u074D-\u07B1\u07C0-\u07F5\u07FA\u0800-\u082D\u0840-\u085B\u08A0-\u08B4\u08B6-\u08BD\u08D4-\u08E1\u08E3-\u0963\u0966-\u096F\u0971-\u0983\u0985-\u098C\u098F\u0990\u0993-\u09A8\u09AA-\u09B0\u09B2\u09B6-\u09B9\u09BC-\u09C4\u09C7\u09C8\u09CB-\u09CE\u09D7\u09DC\u09DD\u09DF-\u09E3\u09E6-\u09F1\u0A01-\u0A03\u0A05-\u0A0A\u0A0F\u0A10\u0A13-\u0A28\u0A2A-\u0A30\u0A32\u0A33\u0A35\u0A36\u0A38\u0A39\u0A3C\u0A3E-\u0A42\u0A47\u0A48\u0A4B-\u0A4D\u0A51\u0A59-\u0A5C\u0A5E\u0A66-\u0A75\u0A81-\u0A83\u0A85-\u0A8D\u0A8F-\u0A91\u0A93-\u0AA8\u0AAA-\u0AB0\u0AB2\u0AB3\u0AB5-\u0AB9\u0ABC-\u0AC5\u0AC7-\u0AC9\u0ACB-\u0ACD\u0AD0\u0AE0-\u0AE3\u0AE6-\u0AEF\u0AF9\u0B01-\u0B03\u0B05-\u0B0C\u0B0F\u0B10\u0B13-\u0B28\u0B2A-\u0B30\u0B32\u0B33\u0B35-\u0B39\u0B3C-\u0B44\u0B47\u0B48\u0B4B-\u0B4D\u0B56\u0B57\u0B5C\u0B5D\u0B5F-\u0B63\u0B66-\u0B6F\u0B71\u0B82\u0B83\u0B85-\u0B8A\u0B8E-\u0B90\u0B92-\u0B95\u0B99\u0B9A\u0B9C\u0B9E\u0B9F\u0BA3\u0BA4\u0BA8-\u0BAA\u0BAE-\u0BB9\u0BBE-\u0BC2\u0BC6-\u0BC8\u0BCA-\u0BCD\u0BD0\u0BD7\u0BE6-\u0BEF\u0C00-\u0C03\u0C05-\u0C0C\u0C0E-\u0C10\u0C12-\u0C28\u0C2A-\u0C39\u0C3D-\u0C44\u0C46-\u0C48\u0C4A-\u0C4D\u0C55\u0C56\u0C58-\u0C5A\u0C60-\u0C63\u0C66-\u0C6F\u0C80-\u0C83\u0C85-\u0C8C\u0C8E-\u0C90\u0C92-\u0CA8\u0CAA-\u0CB3\u0CB5-\u0CB9\u0CBC-\u0CC4\u0CC6-\u0CC8\u0CCA-\u0CCD\u0CD5\u0CD6\u0CDE\u0CE0-\u0CE3\u0CE6-\u0CEF\u0CF1\u0CF2\u0D01-\u0D03\u0D05-\u0D0C\u0D0E-\u0D10\u0D12-\u0D3A\u0D3D-\u0D44\u0D46-\u0D48\u0D4A-\u0D4E\u0D54-\u0D57\u0D5F-\u0D63\u0D66-\u0D6F\u0D7A-\u0D7F\u0D82\u0D83\u0D85-\u0D96\u0D9A-\u0DB1\u0DB3-\u0DBB\u0DBD\u0DC0-\u0DC6\u0DCA\u0DCF-\u0DD4\u0DD6\u0DD8-\u0DDF\u0DE6-\u0DEF\u0DF2\u0DF3\u0E01-\u0E3A\u0E40-\u0E4E\u0E50-\u0E59\u0E81\u0E82\u0E84\u0E87\u0E88\u0E8A\u0E8D\u0E94-\u0E97\u0E99-\u0E9F\u0EA1-\u0EA3\u0EA5\u0EA7\u0EAA\u0EAB\u0EAD-\u0EB9\u0EBB-\u0EBD\u0EC0-\u0EC4\u0EC6\u0EC8-\u0ECD\u0ED0-\u0ED9\u0EDC-\u0EDF\u0F00\u0F18\u0F19\u0F20-\u0F29\u0F35\u0F37\u0F39\u0F3E-\u0F47\u0F49-\u0F6C\u0F71-\u0F84\u0F86-\u0F97\u0F99-\u0FBC\u0FC6\u1000-\u1049\u1050-\u109D\u10A0-\u10C5\u10C7\u10CD\u10D0-\u10FA\u10FC-\u1248\u124A-\u124D\u1250-\u1256\u1258\u125A-\u125D\u1260-\u1288\u128A-\u128D\u1290-\u12B0\u12B2-\u12B5\u12B8-\u12BE\u12C0\u12C2-\u12C5\u12C8-\u12D6\u12D8-\u1310\u1312-\u1315\u1318-\u135A\u135D-\u135F\u1369-\u1371\u1380-\u138F\u13A0-\u13F5\u13F8-\u13FD\u1401-\u166C\u166F-\u167F\u1681-\u169A\u16A0-\u16EA\u16EE-\u16F8\u1700-\u170C\u170E-\u1714\u1720-\u1734\u1740-\u1753\u1760-\u176C\u176E-\u1770\u1772\u1773\u1780-\u17D3\u17D7\u17DC\u17DD\u17E0-\u17E9\u180B-\u180D\u1810-\u1819\u1820-\u1877\u1880-\u18AA\u18B0-\u18F5\u1900-\u191E\u1920-\u192B\u1930-\u193B\u1946-\u196D\u1970-\u1974\u1980-\u19AB\u19B0-\u19C9\u19D0-\u19DA\u1A00-\u1A1B\u1A20-\u1A5E\u1A60-\u1A7C\u1A7F-\u1A89\u1A90-\u1A99\u1AA7\u1AB0-\u1ABD\u1B00-\u1B4B\u1B50-\u1B59\u1B6B-\u1B73\u1B80-\u1BF3\u1C00-\u1C37\u1C40-\u1C49\u1C4D-\u1C7D\u1C80-\u1C88\u1CD0-\u1CD2\u1CD4-\u1CF6\u1CF8\u1CF9\u1D00-\u1DF5\u1DFB-\u1F15\u1F18-\u1F1D\u1F20-\u1F45\u1F48-\u1F4D\u1F50-\u1F57\u1F59\u1F5B\u1F5D\u1F5F-\u1F7D\u1F80-\u1FB4\u1FB6-\u1FBC\u1FBE\u1FC2-\u1FC4\u1FC6-\u1FCC\u1FD0-\u1FD3\u1FD6-\u1FDB\u1FE0-\u1FEC\u1FF2-\u1FF4\u1FF6-\u1FFC\u200C\u200D\u203F\u2040\u2054\u2071\u207F\u2090-\u209C\u20D0-\u20DC\u20E1\u20E5-\u20F0\u2102\u2107\u210A-\u2113\u2115\u2118-\u211D\u2124\u2126\u2128\u212A-\u2139\u213C-\u213F\u2145-\u2149\u214E\u2160-\u2188\u2C00-\u2C2E\u2C30-\u2C5E\u2C60-\u2CE4\u2CEB-\u2CF3\u2D00-\u2D25\u2D27\u2D2D\u2D30-\u2D67\u2D6F\u2D7F-\u2D96\u2DA0-\u2DA6\u2DA8-\u2DAE\u2DB0-\u2DB6\u2DB8-\u2DBE\u2DC0-\u2DC6\u2DC8-\u2DCE\u2DD0-\u2DD6\u2DD8-\u2DDE\u2DE0-\u2DFF\u3005-\u3007\u3021-\u302F\u3031-\u3035\u3038-\u303C\u3041-\u3096\u3099-\u309F\u30A1-\u30FA\u30FC-\u30FF\u3105-\u312D\u3131-\u318E\u31A0-\u31BA\u31F0-\u31FF\u3400-\u4DB5\u4E00-\u9FD5\uA000-\uA48C\uA4D0-\uA4FD\uA500-\uA60C\uA610-\uA62B\uA640-\uA66F\uA674-\uA67D\uA67F-\uA6F1\uA717-\uA71F\uA722-\uA788\uA78B-\uA7AE\uA7B0-\uA7B7\uA7F7-\uA827\uA840-\uA873\uA880-\uA8C5\uA8D0-\uA8D9\uA8E0-\uA8F7\uA8FB\uA8FD\uA900-\uA92D\uA930-\uA953\uA960-\uA97C\uA980-\uA9C0\uA9CF-\uA9D9\uA9E0-\uA9FE\uAA00-\uAA36\uAA40-\uAA4D\uAA50-\uAA59\uAA60-\uAA76\uAA7A-\uAAC2\uAADB-\uAADD\uAAE0-\uAAEF\uAAF2-\uAAF6\uAB01-\uAB06\uAB09-\uAB0E\uAB11-\uAB16\uAB20-\uAB26\uAB28-\uAB2E\uAB30-\uAB5A\uAB5C-\uAB65\uAB70-\uABEA\uABEC\uABED\uABF0-\uABF9\uAC00-\uD7A3\uD7B0-\uD7C6\uD7CB-\uD7FB\uF900-\uFA6D\uFA70-\uFAD9\uFB00-\uFB06\uFB13-\uFB17\uFB1D-\uFB28\uFB2A-\uFB36\uFB38-\uFB3C\uFB3E\uFB40\uFB41\uFB43\uFB44\uFB46-\uFBB1\uFBD3-\uFD3D\uFD50-\uFD8F\uFD92-\uFDC7\uFDF0-\uFDFB\uFE00-\uFE0F\uFE20-\uFE2F\uFE33\uFE34\uFE4D-\uFE4F\uFE70-\uFE74\uFE76-\uFEFC\uFF10-\uFF19\uFF21-\uFF3A\uFF3F\uFF41-\uFF5A\uFF66-\uFFBE\uFFC2-\uFFC7\uFFCA-\uFFCF\uFFD2-\uFFD7\uFFDA-\uFFDC]|\uD800[\uDC00-\uDC0B\uDC0D-\uDC26\uDC28-\uDC3A\uDC3C\uDC3D\uDC3F-\uDC4D\uDC50-\uDC5D\uDC80-\uDCFA\uDD40-\uDD74\uDDFD\uDE80-\uDE9C\uDEA0-\uDED0\uDEE0\uDF00-\uDF1F\uDF30-\uDF4A\uDF50-\uDF7A\uDF80-\uDF9D\uDFA0-\uDFC3\uDFC8-\uDFCF\uDFD1-\uDFD5]|\uD801[\uDC00-\uDC9D\uDCA0-\uDCA9\uDCB0-\uDCD3\uDCD8-\uDCFB\uDD00-\uDD27\uDD30-\uDD63\uDE00-\uDF36\uDF40-\uDF55\uDF60-\uDF67]|\uD802[\uDC00-\uDC05\uDC08\uDC0A-\uDC35\uDC37\uDC38\uDC3C\uDC3F-\uDC55\uDC60-\uDC76\uDC80-\uDC9E\uDCE0-\uDCF2\uDCF4\uDCF5\uDD00-\uDD15\uDD20-\uDD39\uDD80-\uDDB7\uDDBE\uDDBF\uDE00-\uDE03\uDE05\uDE06\uDE0C-\uDE13\uDE15-\uDE17\uDE19-\uDE33\uDE38-\uDE3A\uDE3F\uDE60-\uDE7C\uDE80-\uDE9C\uDEC0-\uDEC7\uDEC9-\uDEE6\uDF00-\uDF35\uDF40-\uDF55\uDF60-\uDF72\uDF80-\uDF91]|\uD803[\uDC00-\uDC48\uDC80-\uDCB2\uDCC0-\uDCF2]|\uD804[\uDC00-\uDC46\uDC66-\uDC6F\uDC7F-\uDCBA\uDCD0-\uDCE8\uDCF0-\uDCF9\uDD00-\uDD34\uDD36-\uDD3F\uDD50-\uDD73\uDD76\uDD80-\uDDC4\uDDCA-\uDDCC\uDDD0-\uDDDA\uDDDC\uDE00-\uDE11\uDE13-\uDE37\uDE3E\uDE80-\uDE86\uDE88\uDE8A-\uDE8D\uDE8F-\uDE9D\uDE9F-\uDEA8\uDEB0-\uDEEA\uDEF0-\uDEF9\uDF00-\uDF03\uDF05-\uDF0C\uDF0F\uDF10\uDF13-\uDF28\uDF2A-\uDF30\uDF32\uDF33\uDF35-\uDF39\uDF3C-\uDF44\uDF47\uDF48\uDF4B-\uDF4D\uDF50\uDF57\uDF5D-\uDF63\uDF66-\uDF6C\uDF70-\uDF74]|\uD805[\uDC00-\uDC4A\uDC50-\uDC59\uDC80-\uDCC5\uDCC7\uDCD0-\uDCD9\uDD80-\uDDB5\uDDB8-\uDDC0\uDDD8-\uDDDD\uDE00-\uDE40\uDE44\uDE50-\uDE59\uDE80-\uDEB7\uDEC0-\uDEC9\uDF00-\uDF19\uDF1D-\uDF2B\uDF30-\uDF39]|\uD806[\uDCA0-\uDCE9\uDCFF\uDEC0-\uDEF8]|\uD807[\uDC00-\uDC08\uDC0A-\uDC36\uDC38-\uDC40\uDC50-\uDC59\uDC72-\uDC8F\uDC92-\uDCA7\uDCA9-\uDCB6]|\uD808[\uDC00-\uDF99]|\uD809[\uDC00-\uDC6E\uDC80-\uDD43]|[\uD80C\uD81C-\uD820\uD840-\uD868\uD86A-\uD86C\uD86F-\uD872][\uDC00-\uDFFF]|\uD80D[\uDC00-\uDC2E]|\uD811[\uDC00-\uDE46]|\uD81A[\uDC00-\uDE38\uDE40-\uDE5E\uDE60-\uDE69\uDED0-\uDEED\uDEF0-\uDEF4\uDF00-\uDF36\uDF40-\uDF43\uDF50-\uDF59\uDF63-\uDF77\uDF7D-\uDF8F]|\uD81B[\uDF00-\uDF44\uDF50-\uDF7E\uDF8F-\uDF9F\uDFE0]|\uD821[\uDC00-\uDFEC]|\uD822[\uDC00-\uDEF2]|\uD82C[\uDC00\uDC01]|\uD82F[\uDC00-\uDC6A\uDC70-\uDC7C\uDC80-\uDC88\uDC90-\uDC99\uDC9D\uDC9E]|\uD834[\uDD65-\uDD69\uDD6D-\uDD72\uDD7B-\uDD82\uDD85-\uDD8B\uDDAA-\uDDAD\uDE42-\uDE44]|\uD835[\uDC00-\uDC54\uDC56-\uDC9C\uDC9E\uDC9F\uDCA2\uDCA5\uDCA6\uDCA9-\uDCAC\uDCAE-\uDCB9\uDCBB\uDCBD-\uDCC3\uDCC5-\uDD05\uDD07-\uDD0A\uDD0D-\uDD14\uDD16-\uDD1C\uDD1E-\uDD39\uDD3B-\uDD3E\uDD40-\uDD44\uDD46\uDD4A-\uDD50\uDD52-\uDEA5\uDEA8-\uDEC0\uDEC2-\uDEDA\uDEDC-\uDEFA\uDEFC-\uDF14\uDF16-\uDF34\uDF36-\uDF4E\uDF50-\uDF6E\uDF70-\uDF88\uDF8A-\uDFA8\uDFAA-\uDFC2\uDFC4-\uDFCB\uDFCE-\uDFFF]|\uD836[\uDE00-\uDE36\uDE3B-\uDE6C\uDE75\uDE84\uDE9B-\uDE9F\uDEA1-\uDEAF]|\uD838[\uDC00-\uDC06\uDC08-\uDC18\uDC1B-\uDC21\uDC23\uDC24\uDC26-\uDC2A]|\uD83A[\uDC00-\uDCC4\uDCD0-\uDCD6\uDD00-\uDD4A\uDD50-\uDD59]|\uD83B[\uDE00-\uDE03\uDE05-\uDE1F\uDE21\uDE22\uDE24\uDE27\uDE29-\uDE32\uDE34-\uDE37\uDE39\uDE3B\uDE42\uDE47\uDE49\uDE4B\uDE4D-\uDE4F\uDE51\uDE52\uDE54\uDE57\uDE59\uDE5B\uDE5D\uDE5F\uDE61\uDE62\uDE64\uDE67-\uDE6A\uDE6C-\uDE72\uDE74-\uDE77\uDE79-\uDE7C\uDE7E\uDE80-\uDE89\uDE8B-\uDE9B\uDEA1-\uDEA3\uDEA5-\uDEA9\uDEAB-\uDEBB]|\uD869[\uDC00-\uDED6\uDF00-\uDFFF]|\uD86D[\uDC00-\uDF34\uDF40-\uDFFF]|\uD86E[\uDC00-\uDC1D\uDC20-\uDFFF]|\uD873[\uDC00-\uDEA1]|\uD87E[\uDC00-\uDE1D]|\uDB40[\uDD00-\uDDEF]/};function l(F){return 48<=F&&F<=57}function p(F){return 48<=F&&F<=57||97<=F&&F<=102||65<=F&&F<=70}function d(F){return F>=48&&F<=55}a=[5760,8192,8193,8194,8195,8196,8197,8198,8199,8200,8201,8202,8239,8287,12288,65279];function y(F){return F===32||F===9||F===11||F===12||F===160||F>=5760&&a.indexOf(F)>=0}function g(F){return F===10||F===13||F===8232||F===8233}function c(F){if(F<=65535)return String.fromCharCode(F);var S=String.fromCharCode(Math.floor((F-65536)/1024)+55296),N=String.fromCharCode((F-65536)%1024+56320);return S+N}for(n=new Array(128),i=0;i<128;++i)n[i]=i>=97&&i<=122||i>=65&&i<=90||i===36||i===95;for(u=new Array(128),i=0;i<128;++i)u[i]=i>=97&&i<=122||i>=65&&i<=90||i>=48&&i<=57||i===36||i===95;function D(F){return F<128?n[F]:s.NonAsciiIdentifierStart.test(c(F))}function E(F){return F<128?u[F]:s.NonAsciiIdentifierPart.test(c(F))}function _(F){return F<128?n[F]:t.NonAsciiIdentifierStart.test(c(F))}function w(F){return F<128?u[F]:t.NonAsciiIdentifierPart.test(c(F))}r.exports={isDecimalDigit:l,isHexDigit:p,isOctalDigit:d,isWhiteSpace:y,isLineTerminator:g,isIdentifierStartES5:D,isIdentifierPartES5:E,isIdentifierStartES6:_,isIdentifierPartES6:w}}()}}),zm=te({"node_modules/esutils/lib/keyword.js"(e,r){ne(),function(){"use strict";var t=so();function s(D){switch(D){case"implements":case"interface":case"package":case"private":case"protected":case"public":case"static":case"let":return!0;default:return!1}}function a(D,E){return!E&&D==="yield"?!1:n(D,E)}function n(D,E){if(E&&s(D))return!0;switch(D.length){case 2:return D==="if"||D==="in"||D==="do";case 3:return D==="var"||D==="for"||D==="new"||D==="try";case 4:return D==="this"||D==="else"||D==="case"||D==="void"||D==="with"||D==="enum";case 5:return D==="while"||D==="break"||D==="catch"||D==="throw"||D==="const"||D==="yield"||D==="class"||D==="super";case 6:return D==="return"||D==="typeof"||D==="delete"||D==="switch"||D==="export"||D==="import";case 7:return D==="default"||D==="finally"||D==="extends";case 8:return D==="function"||D==="continue"||D==="debugger";case 10:return D==="instanceof";default:return!1}}function u(D,E){return D==="null"||D==="true"||D==="false"||a(D,E)}function i(D,E){return D==="null"||D==="true"||D==="false"||n(D,E)}function l(D){return D==="eval"||D==="arguments"}function p(D){var E,_,w;if(D.length===0||(w=D.charCodeAt(0),!t.isIdentifierStartES5(w)))return!1;for(E=1,_=D.length;E<_;++E)if(w=D.charCodeAt(E),!t.isIdentifierPartES5(w))return!1;return!0}function d(D,E){return(D-55296)*1024+(E-56320)+65536}function y(D){var E,_,w,F,S;if(D.length===0)return!1;for(S=t.isIdentifierStartES6,E=0,_=D.length;E<_;++E){if(w=D.charCodeAt(E),55296<=w&&w<=56319){if(++E,E>=_||(F=D.charCodeAt(E),!(56320<=F&&F<=57343)))return!1;w=d(w,F)}if(!S(w))return!1;S=t.isIdentifierPartES6}return!0}function g(D,E){return p(D)&&!u(D,E)}function c(D,E){return y(D)&&!i(D,E)}r.exports={isKeywordES5:a,isKeywordES6:n,isReservedWordES5:u,isReservedWordES6:i,isRestrictedWord:l,isIdentifierNameES5:p,isIdentifierNameES6:y,isIdentifierES5:g,isIdentifierES6:c}}()}}),Xm=te({"node_modules/esutils/lib/utils.js"(e){ne(),function(){"use strict";e.ast=Jm(),e.code=so(),e.keyword=zm()}()}}),Ot=te({"src/language-js/utils/is-block-comment.js"(e,r){"use strict";ne();var t=new Set(["Block","CommentBlock","MultiLine"]),s=a=>t.has(a==null?void 0:a.type);r.exports=s}}),Km=te({"src/language-js/utils/is-node-matches.js"(e,r){"use strict";ne();function t(a,n){let u=n.split(".");for(let i=u.length-1;i>=0;i--){let l=u[i];if(i===0)return a.type==="Identifier"&&a.name===l;if(a.type!=="MemberExpression"||a.optional||a.computed||a.property.type!=="Identifier"||a.property.name!==l)return!1;a=a.object}}function s(a,n){return n.some(u=>t(a,u))}r.exports=s}}),Ke=te({"src/language-js/utils/index.js"(e,r){"use strict";ne();var t=Xm().keyword.isIdentifierNameES5,{getLast:s,hasNewline:a,skipWhitespace:n,isNonEmptyArray:u,isNextLineEmptyAfterIndex:i,getStringWidth:l}=Ue(),{locStart:p,locEnd:d,hasSameLocStart:y}=ut(),g=Ot(),c=Km(),D="(?:(?=.)\\s)",E=new RegExp(`^${D}*:`),_=new RegExp(`^${D}*::`);function w(O){var me,_e;return((me=O.extra)===null||me===void 0?void 0:me.parenthesized)&&g((_e=O.trailingComments)===null||_e===void 0?void 0:_e[0])&&E.test(O.trailingComments[0].value)}function F(O){let me=O==null?void 0:O[0];return g(me)&&_.test(me.value)}function S(O,me){if(!O||typeof O!="object")return!1;if(Array.isArray(O))return O.some(He=>S(He,me));let _e=me(O);return typeof _e=="boolean"?_e:Object.values(O).some(He=>S(He,me))}function N(O){return O.type==="AssignmentExpression"||O.type==="BinaryExpression"||O.type==="LogicalExpression"||O.type==="NGPipeExpression"||O.type==="ConditionalExpression"||de(O)||ue(O)||O.type==="SequenceExpression"||O.type==="TaggedTemplateExpression"||O.type==="BindExpression"||O.type==="UpdateExpression"&&!O.prefix||st(O)||O.type==="TSNonNullExpression"}function I(O){var me,_e,He,Ge,it,Qe;return O.expressions?O.expressions[0]:(me=(_e=(He=(Ge=(it=(Qe=O.left)!==null&&Qe!==void 0?Qe:O.test)!==null&&it!==void 0?it:O.callee)!==null&&Ge!==void 0?Ge:O.object)!==null&&He!==void 0?He:O.tag)!==null&&_e!==void 0?_e:O.argument)!==null&&me!==void 0?me:O.expression}function P(O,me){if(me.expressions)return["expressions",0];if(me.left)return["left"];if(me.test)return["test"];if(me.object)return["object"];if(me.callee)return["callee"];if(me.tag)return["tag"];if(me.argument)return["argument"];if(me.expression)return["expression"];throw new Error("Unexpected node has no left side.")}function $(O){return O=new Set(O),me=>O.has(me==null?void 0:me.type)}var f=$(["Line","CommentLine","SingleLine","HashbangComment","HTMLOpen","HTMLClose"]),T=$(["ExportDefaultDeclaration","ExportDefaultSpecifier","DeclareExportDeclaration","ExportNamedDeclaration","ExportAllDeclaration"]);function m(O){let me=O.getParentNode();return O.getName()==="declaration"&&T(me)?me:null}var v=$(["BooleanLiteral","DirectiveLiteral","Literal","NullLiteral","NumericLiteral","BigIntLiteral","DecimalLiteral","RegExpLiteral","StringLiteral","TemplateLiteral","TSTypeLiteral","JSXText"]);function o(O){return O.type==="NumericLiteral"||O.type==="Literal"&&typeof O.value=="number"}function h(O){return O.type==="UnaryExpression"&&(O.operator==="+"||O.operator==="-")&&o(O.argument)}function C(O){return O.type==="StringLiteral"||O.type==="Literal"&&typeof O.value=="string"}var x=$(["ObjectTypeAnnotation","TSTypeLiteral","TSMappedType"]),b=$(["FunctionExpression","ArrowFunctionExpression"]);function B(O){return O.type==="FunctionExpression"||O.type==="ArrowFunctionExpression"&&O.body.type==="BlockStatement"}function k(O){return de(O)&&O.callee.type==="Identifier"&&["async","inject","fakeAsync","waitForAsync"].includes(O.callee.name)}var M=$(["JSXElement","JSXFragment"]);function R(O,me){if(O.parentParser!=="markdown"&&O.parentParser!=="mdx")return!1;let _e=me.getNode();if(!_e.expression||!M(_e.expression))return!1;let He=me.getParentNode();return He.type==="Program"&&He.body.length===1}function q(O){return O.kind==="get"||O.kind==="set"}function J(O){return q(O)||y(O,O.value)}function L(O){return(O.type==="ObjectTypeProperty"||O.type==="ObjectTypeInternalSlot")&&O.value.type==="FunctionTypeAnnotation"&&!O.static&&!J(O)}function Q(O){return(O.type==="TypeAnnotation"||O.type==="TSTypeAnnotation")&&O.typeAnnotation.type==="FunctionTypeAnnotation"&&!O.static&&!y(O,O.typeAnnotation)}var V=$(["BinaryExpression","LogicalExpression","NGPipeExpression"]);function j(O){return ue(O)||O.type==="BindExpression"&&Boolean(O.object)}var Y=new Set(["AnyTypeAnnotation","TSAnyKeyword","NullLiteralTypeAnnotation","TSNullKeyword","ThisTypeAnnotation","TSThisType","NumberTypeAnnotation","TSNumberKeyword","VoidTypeAnnotation","TSVoidKeyword","BooleanTypeAnnotation","TSBooleanKeyword","BigIntTypeAnnotation","TSBigIntKeyword","SymbolTypeAnnotation","TSSymbolKeyword","StringTypeAnnotation","TSStringKeyword","BooleanLiteralTypeAnnotation","StringLiteralTypeAnnotation","BigIntLiteralTypeAnnotation","NumberLiteralTypeAnnotation","TSLiteralType","TSTemplateLiteralType","EmptyTypeAnnotation","MixedTypeAnnotation","TSNeverKeyword","TSObjectKeyword","TSUndefinedKeyword","TSUnknownKeyword"]);function ie(O){return O?!!((O.type==="GenericTypeAnnotation"||O.type==="TSTypeReference")&&!O.typeParameters||Y.has(O.type)):!1}function ee(O){let me=/^(?:before|after)(?:Each|All)$/;return O.callee.type==="Identifier"&&me.test(O.callee.name)&&O.arguments.length===1}var le=["it","it.only","it.skip","describe","describe.only","describe.skip","test","test.only","test.skip","test.step","test.describe","test.describe.only","test.describe.parallel","test.describe.parallel.only","test.describe.serial","test.describe.serial.only","skip","xit","xdescribe","xtest","fit","fdescribe","ftest"];function W(O){return c(O,le)}function K(O,me){if(O.type!=="CallExpression")return!1;if(O.arguments.length===1){if(k(O)&&me&&K(me))return b(O.arguments[0]);if(ee(O))return k(O.arguments[0])}else if((O.arguments.length===2||O.arguments.length===3)&&(O.arguments[0].type==="TemplateLiteral"||C(O.arguments[0]))&&W(O.callee))return O.arguments[2]&&!o(O.arguments[2])?!1:(O.arguments.length===2?b(O.arguments[1]):B(O.arguments[1])&&ve(O.arguments[1]).length<=1)||k(O.arguments[1]);return!1}var de=$(["CallExpression","OptionalCallExpression"]),ue=$(["MemberExpression","OptionalMemberExpression"]);function Fe(O){let me="expressions";O.type==="TSTemplateLiteralType"&&(me="types");let _e=O[me];return _e.length===0?!1:_e.every(He=>{if(Me(He))return!1;if(He.type==="Identifier"||He.type==="ThisExpression")return!0;if(ue(He)){let Ge=He;for(;ue(Ge);)if(Ge.property.type!=="Identifier"&&Ge.property.type!=="Literal"&&Ge.property.type!=="StringLiteral"&&Ge.property.type!=="NumericLiteral"||(Ge=Ge.object,Me(Ge)))return!1;return Ge.type==="Identifier"||Ge.type==="ThisExpression"}return!1})}function z(O,me){return O==="+"||O==="-"?O+me:me}function U(O,me){let _e=p(me),He=n(O,d(me));return He!==!1&&O.slice(_e,_e+2)==="/*"&&O.slice(He,He+2)==="*/"}function Z(O,me){return M(me)?Oe(me):Me(me,Te.Leading,_e=>a(O,d(_e)))}function se(O,me){return me.parser!=="json"&&C(O.key)&&oe(O.key).slice(1,-1)===O.key.value&&(t(O.key.value)&&!(me.parser==="babel-ts"&&O.type==="ClassProperty"||me.parser==="typescript"&&O.type==="PropertyDefinition")||De(O.key.value)&&String(Number(O.key.value))===O.key.value&&(me.parser==="babel"||me.parser==="acorn"||me.parser==="espree"||me.parser==="meriyah"||me.parser==="__babel_estree"))}function De(O){return/^(?:\d+|\d+\.\d+)$/.test(O)}function ge(O,me){let _e=/^[fx]?(?:describe|it|test)$/;return me.type==="TaggedTemplateExpression"&&me.quasi===O&&me.tag.type==="MemberExpression"&&me.tag.property.type==="Identifier"&&me.tag.property.name==="each"&&(me.tag.object.type==="Identifier"&&_e.test(me.tag.object.name)||me.tag.object.type==="MemberExpression"&&me.tag.object.property.type==="Identifier"&&(me.tag.object.property.name==="only"||me.tag.object.property.name==="skip")&&me.tag.object.object.type==="Identifier"&&_e.test(me.tag.object.object.name))}function he(O){return O.quasis.some(me=>me.value.raw.includes(`
`))}function we(O,me){return(O.type==="TemplateLiteral"&&he(O)||O.type==="TaggedTemplateExpression"&&he(O.quasi))&&!a(me,p(O),{backwards:!0})}function ke(O){if(!Me(O))return!1;let me=s(ae(O,Te.Dangling));return me&&!g(me)}function Re(O){if(O.length<=1)return!1;let me=0;for(let _e of O)if(b(_e)){if(me+=1,me>1)return!0}else if(de(_e)){for(let He of _e.arguments)if(b(He))return!0}return!1}function Ne(O){let me=O.getValue(),_e=O.getParentNode();return de(me)&&de(_e)&&_e.callee===me&&me.arguments.length>_e.arguments.length&&_e.arguments.length>0}function Pe(O,me){if(me>=2)return!1;let _e=Qe=>Pe(Qe,me+1),He=O.type==="Literal"&&"regex"in O&&O.regex.pattern||O.type==="RegExpLiteral"&&O.pattern;if(He&&l(He)>5)return!1;if(O.type==="Literal"||O.type==="BigIntLiteral"||O.type==="DecimalLiteral"||O.type==="BooleanLiteral"||O.type==="NullLiteral"||O.type==="NumericLiteral"||O.type==="RegExpLiteral"||O.type==="StringLiteral"||O.type==="Identifier"||O.type==="ThisExpression"||O.type==="Super"||O.type==="PrivateName"||O.type==="PrivateIdentifier"||O.type==="ArgumentPlaceholder"||O.type==="Import")return!0;if(O.type==="TemplateLiteral")return O.quasis.every(Qe=>!Qe.value.raw.includes(`
`))&&O.expressions.every(_e);if(O.type==="ObjectExpression")return O.properties.every(Qe=>!Qe.computed&&(Qe.shorthand||Qe.value&&_e(Qe.value)));if(O.type==="ArrayExpression")return O.elements.every(Qe=>Qe===null||_e(Qe));if(tt(O))return(O.type==="ImportExpression"||Pe(O.callee,me))&&Ye(O).every(_e);if(ue(O))return Pe(O.object,me)&&Pe(O.property,me);let Ge={"!":!0,"-":!0,"+":!0,"~":!0};if(O.type==="UnaryExpression"&&Ge[O.operator])return Pe(O.argument,me);let it={"++":!0,"--":!0};return O.type==="UpdateExpression"&&it[O.operator]?Pe(O.argument,me):O.type==="TSNonNullExpression"?Pe(O.expression,me):!1}function oe(O){var me,_e;return(me=(_e=O.extra)===null||_e===void 0?void 0:_e.raw)!==null&&me!==void 0?me:O.raw}function H(O){return O}function ce(O){return O.filepath&&/\.tsx$/i.test(O.filepath)}function X(O){let me=arguments.length>1&&arguments[1]!==void 0?arguments[1]:"es5";return O.trailingComma==="es5"&&me==="es5"||O.trailingComma==="all"&&(me==="all"||me==="es5")}function pe(O,me){switch(O.type){case"BinaryExpression":case"LogicalExpression":case"AssignmentExpression":case"NGPipeExpression":return pe(O.left,me);case"MemberExpression":case"OptionalMemberExpression":return pe(O.object,me);case"TaggedTemplateExpression":return O.tag.type==="FunctionExpression"?!1:pe(O.tag,me);case"CallExpression":case"OptionalCallExpression":return O.callee.type==="FunctionExpression"?!1:pe(O.callee,me);case"ConditionalExpression":return pe(O.test,me);case"UpdateExpression":return!O.prefix&&pe(O.argument,me);case"BindExpression":return O.object&&pe(O.object,me);case"SequenceExpression":return pe(O.expressions[0],me);case"TSSatisfiesExpression":case"TSAsExpression":case"TSNonNullExpression":return pe(O.expression,me);default:return me(O)}}var Ae={"==":!0,"!=":!0,"===":!0,"!==":!0},Ce={"*":!0,"/":!0,"%":!0},fe={">>":!0,">>>":!0,"<<":!0};function A(O,me){return!(re(me)!==re(O)||O==="**"||Ae[O]&&Ae[me]||me==="%"&&Ce[O]||O==="%"&&Ce[me]||me!==O&&Ce[me]&&Ce[O]||fe[O]&&fe[me])}var G=new Map([["|>"],["??"],["||"],["&&"],["|"],["^"],["&"],["==","===","!=","!=="],["<",">","<=",">=","in","instanceof"],[">>","<<",">>>"],["+","-"],["*","/","%"],["**"]].flatMap((O,me)=>O.map(_e=>[_e,me])));function re(O){return G.get(O)}function ye(O){return Boolean(fe[O])||O==="|"||O==="^"||O==="&"}function Ee(O){var me;if(O.rest)return!0;let _e=ve(O);return((me=s(_e))===null||me===void 0?void 0:me.type)==="RestElement"}var Be=new WeakMap;function ve(O){if(Be.has(O))return Be.get(O);let me=[];return O.this&&me.push(O.this),Array.isArray(O.parameters)?me.push(...O.parameters):Array.isArray(O.params)&&me.push(...O.params),O.rest&&me.push(O.rest),Be.set(O,me),me}function ze(O,me){let _e=O.getValue(),He=0,Ge=it=>me(it,He++);_e.this&&O.call(Ge,"this"),Array.isArray(_e.parameters)?O.each(Ge,"parameters"):Array.isArray(_e.params)&&O.each(Ge,"params"),_e.rest&&O.call(Ge,"rest")}var be=new WeakMap;function Ye(O){if(be.has(O))return be.get(O);let me=O.arguments;return O.type==="ImportExpression"&&(me=[O.source],O.attributes&&me.push(O.attributes)),be.set(O,me),me}function Se(O,me){let _e=O.getValue();_e.type==="ImportExpression"?(O.call(He=>me(He,0),"source"),_e.attributes&&O.call(He=>me(He,1),"attributes")):O.each(me,"arguments")}function Ie(O){return O.value.trim()==="prettier-ignore"&&!O.unignore}function Oe(O){return O&&(O.prettierIgnore||Me(O,Te.PrettierIgnore))}function Je(O){let me=O.getValue();return Oe(me)}var Te={Leading:1<<1,Trailing:1<<2,Dangling:1<<3,Block:1<<4,Line:1<<5,PrettierIgnore:1<<6,First:1<<7,Last:1<<8},je=(O,me)=>{if(typeof O=="function"&&(me=O,O=0),O||me)return(_e,He,Ge)=>!(O&Te.Leading&&!_e.leading||O&Te.Trailing&&!_e.trailing||O&Te.Dangling&&(_e.leading||_e.trailing)||O&Te.Block&&!g(_e)||O&Te.Line&&!f(_e)||O&Te.First&&He!==0||O&Te.Last&&He!==Ge.length-1||O&Te.PrettierIgnore&&!Ie(_e)||me&&!me(_e))};function Me(O,me,_e){if(!u(O==null?void 0:O.comments))return!1;let He=je(me,_e);return He?O.comments.some(He):!0}function ae(O,me,_e){if(!Array.isArray(O==null?void 0:O.comments))return[];let He=je(me,_e);return He?O.comments.filter(He):O.comments}var nt=(O,me)=>{let{originalText:_e}=me;return i(_e,d(O))};function tt(O){return de(O)||O.type==="NewExpression"||O.type==="ImportExpression"}function Ve(O){return O&&(O.type==="ObjectProperty"||O.type==="Property"&&!O.method&&O.kind==="init")}function We(O){return Boolean(O.__isUsingHackPipeline)}var Xe=Symbol("ifWithoutBlockAndSameLineComment");function st(O){return O.type==="TSAsExpression"||O.type==="TSSatisfiesExpression"}r.exports={getFunctionParameters:ve,iterateFunctionParametersPath:ze,getCallArguments:Ye,iterateCallArgumentsPath:Se,hasRestParameter:Ee,getLeftSide:I,getLeftSidePathName:P,getParentExportDeclaration:m,getTypeScriptMappedTypeModifier:z,hasFlowAnnotationComment:F,hasFlowShorthandAnnotationComment:w,hasLeadingOwnLineComment:Z,hasNakedLeftSide:N,hasNode:S,hasIgnoreComment:Je,hasNodeIgnoreComment:Oe,identity:H,isBinaryish:V,isCallLikeExpression:tt,isEnabledHackPipeline:We,isLineComment:f,isPrettierIgnoreComment:Ie,isCallExpression:de,isMemberExpression:ue,isExportDeclaration:T,isFlowAnnotationComment:U,isFunctionCompositionArgs:Re,isFunctionNotation:J,isFunctionOrArrowExpression:b,isGetterOrSetter:q,isJestEachTemplateLiteral:ge,isJsxNode:M,isLiteral:v,isLongCurriedCallExpression:Ne,isSimpleCallArgument:Pe,isMemberish:j,isNumericLiteral:o,isSignedNumericLiteral:h,isObjectProperty:Ve,isObjectType:x,isObjectTypePropertyAFunction:L,isSimpleType:ie,isSimpleNumber:De,isSimpleTemplateLiteral:Fe,isStringLiteral:C,isStringPropSafeToUnquote:se,isTemplateOnItsOwnLine:we,isTestCall:K,isTheOnlyJsxElementInMarkdown:R,isTSXFile:ce,isTypeAnnotationAFunction:Q,isNextLineEmpty:nt,needsHardlineAfterDanglingComment:ke,rawText:oe,shouldPrintComma:X,isBitwiseOperator:ye,shouldFlatten:A,startsWithNoLookaheadToken:pe,getPrecedence:re,hasComment:Me,getComments:ae,CommentCheckFlags:Te,markerForIfWithoutBlockAndSameLineComment:Xe,isTSTypeExpression:st}}}),jt=te({"src/language-js/print/template-literal.js"(e,r){"use strict";ne();var t=lt(),{getStringWidth:s,getIndentSize:a}=Ue(),{builders:{join:n,hardline:u,softline:i,group:l,indent:p,align:d,lineSuffixBoundary:y,addAlignmentToDoc:g},printer:{printDocToString:c},utils:{mapDoc:D}}=qe(),{isBinaryish:E,isJestEachTemplateLiteral:_,isSimpleTemplateLiteral:w,hasComment:F,isMemberExpression:S,isTSTypeExpression:N}=Ke();function I(v,o,h){let C=v.getValue();if(C.type==="TemplateLiteral"&&_(C,v.getParentNode())){let R=P(v,h,o);if(R)return R}let b="expressions";C.type==="TSTemplateLiteralType"&&(b="types");let B=[],k=v.map(o,b),M=w(C);return M&&(k=k.map(R=>c(R,Object.assign(Object.assign({},h),{},{printWidth:Number.POSITIVE_INFINITY})).formatted)),B.push(y,"`"),v.each(R=>{let q=R.getName();if(B.push(o()),q<k.length){let{tabWidth:J}=h,L=R.getValue(),Q=a(L.value.raw,J),V=k[q];if(!M){let Y=C[b][q];(F(Y)||S(Y)||Y.type==="ConditionalExpression"||Y.type==="SequenceExpression"||N(Y)||E(Y))&&(V=[p([i,V]),i])}let j=Q===0&&L.value.raw.endsWith(`
`)?d(Number.NEGATIVE_INFINITY,V):g(V,Q,J);B.push(l(["${",j,y,"}"]))}},"quasis"),B.push("`"),B}function P(v,o,h){let C=v.getNode(),x=C.quasis[0].value.raw.trim().split(/\s*\|\s*/);if(x.length>1||x.some(b=>b.length>0)){o.__inJestEach=!0;let b=v.map(h,"expressions");o.__inJestEach=!1;let B=[],k=b.map(L=>"${"+c(L,Object.assign(Object.assign({},o),{},{printWidth:Number.POSITIVE_INFINITY,endOfLine:"lf"})).formatted+"}"),M=[{hasLineBreak:!1,cells:[]}];for(let L=1;L<C.quasis.length;L++){let Q=t(M),V=k[L-1];Q.cells.push(V),V.includes(`
`)&&(Q.hasLineBreak=!0),C.quasis[L].value.raw.includes(`
`)&&M.push({hasLineBreak:!1,cells:[]})}let R=Math.max(x.length,...M.map(L=>L.cells.length)),q=Array.from({length:R}).fill(0),J=[{cells:x},...M.filter(L=>L.cells.length>0)];for(let{cells:L}of J.filter(Q=>!Q.hasLineBreak))for(let[Q,V]of L.entries())q[Q]=Math.max(q[Q],s(V));return B.push(y,"`",p([u,n(u,J.map(L=>n(" | ",L.cells.map((Q,V)=>L.hasLineBreak?Q:Q+" ".repeat(q[V]-s(Q))))))]),u,"`"),B}}function $(v,o){let h=v.getValue(),C=o();return F(h)&&(C=l([p([i,C]),i])),["${",C,y,"}"]}function f(v,o){return v.map(h=>$(h,o),"expressions")}function T(v,o){return D(v,h=>typeof h=="string"?o?h.replace(/(\\*)`/g,"$1$1\\`"):m(h):h)}function m(v){return v.replace(/([\\`]|\${)/g,"\\$1")}r.exports={printTemplateLiteral:I,printTemplateExpressions:f,escapeTemplateCharacters:T,uncookTemplateElementValue:m}}}),Ym=te({"src/language-js/embed/markdown.js"(e,r){"use strict";ne();var{builders:{indent:t,softline:s,literalline:a,dedentToRoot:n}}=qe(),{escapeTemplateCharacters:u}=jt();function i(p,d,y){let c=p.getValue().quasis[0].value.raw.replace(/((?:\\\\)*)\\`/g,(w,F)=>"\\".repeat(F.length/2)+"`"),D=l(c),E=D!=="";E&&(c=c.replace(new RegExp(`^${D}`,"gm"),""));let _=u(y(c,{parser:"markdown",__inJsTemplate:!0},{stripTrailingHardline:!0}),!0);return["`",E?t([s,_]):[a,n(_)],s,"`"]}function l(p){let d=p.match(/^([^\S\n]*)\S/m);return d===null?"":d[1]}r.exports=i}}),Qm=te({"src/language-js/embed/css.js"(e,r){"use strict";ne();var{isNonEmptyArray:t}=Ue(),{builders:{indent:s,hardline:a,softline:n},utils:{mapDoc:u,replaceEndOfLine:i,cleanDoc:l}}=qe(),{printTemplateExpressions:p}=jt();function d(c,D,E){let _=c.getValue(),w=_.quasis.map(P=>P.value.raw),F=0,S=w.reduce((P,$,f)=>f===0?$:P+"@prettier-placeholder-"+F+++"-id"+$,""),N=E(S,{parser:"scss"},{stripTrailingHardline:!0}),I=p(c,D);return y(N,_,I)}function y(c,D,E){if(D.quasis.length===1&&!D.quasis[0].value.raw.trim())return"``";let w=g(c,E);if(!w)throw new Error("Couldn't insert all the expressions");return["`",s([a,w]),n,"`"]}function g(c,D){if(!t(D))return c;let E=0,_=u(l(c),w=>typeof w!="string"||!w.includes("@prettier-placeholder")?w:w.split(/@prettier-placeholder-(\d+)-id/).map((F,S)=>S%2===0?i(F):(E++,D[F])));return D.length===E?_:null}r.exports=d}}),Zm=te({"src/language-js/embed/graphql.js"(e,r){"use strict";ne();var{builders:{indent:t,join:s,hardline:a}}=qe(),{escapeTemplateCharacters:n,printTemplateExpressions:u}=jt();function i(p,d,y){let g=p.getValue(),c=g.quasis.length;if(c===1&&g.quasis[0].value.raw.trim()==="")return"``";let D=u(p,d),E=[];for(let _=0;_<c;_++){let w=g.quasis[_],F=_===0,S=_===c-1,N=w.value.cooked,I=N.split(`
`),P=I.length,$=D[_],f=P>2&&I[0].trim()===""&&I[1].trim()==="",T=P>2&&I[P-1].trim()===""&&I[P-2].trim()==="",m=I.every(o=>/^\s*(?:#[^\n\r]*)?$/.test(o));if(!S&&/#[^\n\r]*$/.test(I[P-1]))return null;let v=null;m?v=l(I):v=y(N,{parser:"graphql"},{stripTrailingHardline:!0}),v?(v=n(v,!1),!F&&f&&E.push(""),E.push(v),!S&&T&&E.push("")):!F&&!S&&f&&E.push(""),$&&E.push($)}return["`",t([a,s(a,E)]),a,"`"]}function l(p){let d=[],y=!1,g=p.map(c=>c.trim());for(let[c,D]of g.entries())D!==""&&(g[c-1]===""&&y?d.push([a,D]):d.push(D),y=!0);return d.length===0?null:s(a,d)}r.exports=i}}),ed=te({"src/language-js/embed/html.js"(e,r){"use strict";ne();var{builders:{indent:t,line:s,hardline:a,group:n},utils:{mapDoc:u}}=qe(),{printTemplateExpressions:i,uncookTemplateElementValue:l}=jt(),p=0;function d(y,g,c,D,E){let{parser:_}=E,w=y.getValue(),F=p;p=p+1>>>0;let S=h=>`PRETTIER_HTML_PLACEHOLDER_${h}_${F}_IN_JS`,N=w.quasis.map((h,C,x)=>C===x.length-1?h.value.cooked:h.value.cooked+S(C)).join(""),I=i(y,g);if(I.length===0&&N.trim().length===0)return"``";let P=new RegExp(S("(\\d+)"),"g"),$=0,f=c(N,{parser:_,__onHtmlRoot(h){$=h.children.length}},{stripTrailingHardline:!0}),T=u(f,h=>{if(typeof h!="string")return h;let C=[],x=h.split(P);for(let b=0;b<x.length;b++){let B=x[b];if(b%2===0){B&&(B=l(B),D.__embeddedInHtml&&(B=B.replace(/<\/(script)\b/gi,"<\\/$1")),C.push(B));continue}let k=Number(B);C.push(I[k])}return C}),m=/^\s/.test(N)?" ":"",v=/\s$/.test(N)?" ":"",o=D.htmlWhitespaceSensitivity==="ignore"?a:m&&v?s:null;return n(o?["`",t([o,n(T)]),o,"`"]:["`",m,$>1?t(n(T)):n(T),v,"`"])}r.exports=d}}),td=te({"src/language-js/embed.js"(e,r){"use strict";ne();var{hasComment:t,CommentCheckFlags:s,isObjectProperty:a}=Ke(),n=Ym(),u=Qm(),i=Zm(),l=ed();function p(f){if(g(f)||_(f)||w(f)||c(f))return"css";if(N(f))return"graphql";if(P(f))return"html";if(D(f))return"angular";if(y(f))return"markdown"}function d(f,T,m,v){let o=f.getValue();if(o.type!=="TemplateLiteral"||$(o))return;let h=p(f);if(h){if(h==="markdown")return n(f,T,m);if(h==="css")return u(f,T,m);if(h==="graphql")return i(f,T,m);if(h==="html"||h==="angular")return l(f,T,m,v,{parser:h})}}function y(f){let T=f.getValue(),m=f.getParentNode();return m&&m.type==="TaggedTemplateExpression"&&T.quasis.length===1&&m.tag.type==="Identifier"&&(m.tag.name==="md"||m.tag.name==="markdown")}function g(f){let T=f.getValue(),m=f.getParentNode(),v=f.getParentNode(1);return v&&T.quasis&&m.type==="JSXExpressionContainer"&&v.type==="JSXElement"&&v.openingElement.name.name==="style"&&v.openingElement.attributes.some(o=>o.name.name==="jsx")||m&&m.type==="TaggedTemplateExpression"&&m.tag.type==="Identifier"&&m.tag.name==="css"||m&&m.type==="TaggedTemplateExpression"&&m.tag.type==="MemberExpression"&&m.tag.object.name==="css"&&(m.tag.property.name==="global"||m.tag.property.name==="resolve")}function c(f){return f.match(T=>T.type==="TemplateLiteral",(T,m)=>T.type==="ArrayExpression"&&m==="elements",(T,m)=>a(T)&&T.key.type==="Identifier"&&T.key.name==="styles"&&m==="value",...E)}function D(f){return f.match(T=>T.type==="TemplateLiteral",(T,m)=>a(T)&&T.key.type==="Identifier"&&T.key.name==="template"&&m==="value",...E)}var E=[(f,T)=>f.type==="ObjectExpression"&&T==="properties",(f,T)=>f.type==="CallExpression"&&f.callee.type==="Identifier"&&f.callee.name==="Component"&&T==="arguments",(f,T)=>f.type==="Decorator"&&T==="expression"];function _(f){let T=f.getParentNode();if(!T||T.type!=="TaggedTemplateExpression")return!1;let m=T.tag.type==="ParenthesizedExpression"?T.tag.expression:T.tag;switch(m.type){case"MemberExpression":return F(m.object)||S(m);case"CallExpression":return F(m.callee)||m.callee.type==="MemberExpression"&&(m.callee.object.type==="MemberExpression"&&(F(m.callee.object.object)||S(m.callee.object))||m.callee.object.type==="CallExpression"&&F(m.callee.object.callee));case"Identifier":return m.name==="css";default:return!1}}function w(f){let T=f.getParentNode(),m=f.getParentNode(1);return m&&T.type==="JSXExpressionContainer"&&m.type==="JSXAttribute"&&m.name.type==="JSXIdentifier"&&m.name.name==="css"}function F(f){return f.type==="Identifier"&&f.name==="styled"}function S(f){return/^[A-Z]/.test(f.object.name)&&f.property.name==="extend"}function N(f){let T=f.getValue(),m=f.getParentNode();return I(T,"GraphQL")||m&&(m.type==="TaggedTemplateExpression"&&(m.tag.type==="MemberExpression"&&m.tag.object.name==="graphql"&&m.tag.property.name==="experimental"||m.tag.type==="Identifier"&&(m.tag.name==="gql"||m.tag.name==="graphql"))||m.type==="CallExpression"&&m.callee.type==="Identifier"&&m.callee.name==="graphql")}function I(f,T){return t(f,s.Block|s.Leading,m=>{let{value:v}=m;return v===` ${T} `})}function P(f){return I(f.getValue(),"HTML")||f.match(T=>T.type==="TemplateLiteral",(T,m)=>T.type==="TaggedTemplateExpression"&&T.tag.type==="Identifier"&&T.tag.name==="html"&&m==="quasi")}function $(f){let{quasis:T}=f;return T.some(m=>{let{value:{cooked:v}}=m;return v===null})}r.exports=d}}),rd=te({"src/language-js/clean.js"(e,r){"use strict";ne();var t=Ot(),s=new Set(["range","raw","comments","leadingComments","trailingComments","innerComments","extra","start","end","loc","flags","errors","tokens"]),a=u=>{for(let i of u.quasis)delete i.value};function n(u,i,l){if(u.type==="Program"&&delete i.sourceType,(u.type==="BigIntLiteral"||u.type==="BigIntLiteralTypeAnnotation")&&i.value&&(i.value=i.value.toLowerCase()),(u.type==="BigIntLiteral"||u.type==="Literal")&&i.bigint&&(i.bigint=i.bigint.toLowerCase()),u.type==="DecimalLiteral"&&(i.value=Number(i.value)),u.type==="Literal"&&i.decimal&&(i.decimal=Number(i.decimal)),u.type==="EmptyStatement"||u.type==="JSXText"||u.type==="JSXExpressionContainer"&&(u.expression.type==="Literal"||u.expression.type==="StringLiteral")&&u.expression.value===" ")return null;if((u.type==="Property"||u.type==="ObjectProperty"||u.type==="MethodDefinition"||u.type==="ClassProperty"||u.type==="ClassMethod"||u.type==="PropertyDefinition"||u.type==="TSDeclareMethod"||u.type==="TSPropertySignature"||u.type==="ObjectTypeProperty")&&typeof u.key=="object"&&u.key&&(u.key.type==="Literal"||u.key.type==="NumericLiteral"||u.key.type==="StringLiteral"||u.key.type==="Identifier")&&delete i.key,u.type==="JSXElement"&&u.openingElement.name.name==="style"&&u.openingElement.attributes.some(y=>y.name.name==="jsx"))for(let{type:y,expression:g}of i.children)y==="JSXExpressionContainer"&&g.type==="TemplateLiteral"&&a(g);u.type==="JSXAttribute"&&u.name.name==="css"&&u.value.type==="JSXExpressionContainer"&&u.value.expression.type==="TemplateLiteral"&&a(i.value.expression),u.type==="JSXAttribute"&&u.value&&u.value.type==="Literal"&&/["']|&quot;|&apos;/.test(u.value.value)&&(i.value.value=i.value.value.replace(/["']|&quot;|&apos;/g,'"'));let p=u.expression||u.callee;if(u.type==="Decorator"&&p.type==="CallExpression"&&p.callee.name==="Component"&&p.arguments.length===1){let y=u.expression.arguments[0].properties;for(let[g,c]of i.expression.arguments[0].properties.entries())switch(y[g].key.name){case"styles":c.value.type==="ArrayExpression"&&a(c.value.elements[0]);break;case"template":c.value.type==="TemplateLiteral"&&a(c.value);break}}if(u.type==="TaggedTemplateExpression"&&(u.tag.type==="MemberExpression"||u.tag.type==="Identifier"&&(u.tag.name==="gql"||u.tag.name==="graphql"||u.tag.name==="css"||u.tag.name==="md"||u.tag.name==="markdown"||u.tag.name==="html")||u.tag.type==="CallExpression")&&a(i.quasi),u.type==="TemplateLiteral"){var d;(((d=u.leadingComments)===null||d===void 0?void 0:d.some(g=>t(g)&&["GraphQL","HTML"].some(c=>g.value===` ${c} `)))||l.type==="CallExpression"&&l.callee.name==="graphql"||!u.leadingComments)&&a(i)}if(u.type==="InterpreterDirective"&&(i.value=i.value.trimEnd()),(u.type==="TSIntersectionType"||u.type==="TSUnionType")&&u.types.length===1)return i.types[0]}n.ignoredProperties=s,r.exports=n}}),io={};Kt(io,{EOL:()=>Wn,arch:()=>nd,cpus:()=>Do,default:()=>vo,endianness:()=>ao,freemem:()=>po,getNetworkInterfaces:()=>ho,hostname:()=>oo,loadavg:()=>lo,networkInterfaces:()=>yo,platform:()=>ud,release:()=>go,tmpDir:()=>$n,tmpdir:()=>Vn,totalmem:()=>fo,type:()=>mo,uptime:()=>co});function ao(){if(typeof Tr>"u"){var e=new ArrayBuffer(2),r=new Uint8Array(e),t=new Uint16Array(e);if(r[0]=1,r[1]=2,t[0]===258)Tr="BE";else if(t[0]===513)Tr="LE";else throw new Error("unable to figure out endianess")}return Tr}function oo(){return typeof globalThis.location<"u"?globalThis.location.hostname:""}function lo(){return[]}function co(){return 0}function po(){return Number.MAX_VALUE}function fo(){return Number.MAX_VALUE}function Do(){return[]}function mo(){return"Browser"}function go(){return typeof globalThis.navigator<"u"?globalThis.navigator.appVersion:""}function yo(){}function ho(){}function nd(){return"javascript"}function ud(){return"browser"}function $n(){return"/tmp"}var Tr,Vn,Wn,vo,sd=ht({"node-modules-polyfills:os"(){ne(),Vn=$n,Wn=`
`,vo={EOL:Wn,tmpdir:Vn,tmpDir:$n,networkInterfaces:yo,getNetworkInterfaces:ho,release:go,type:mo,cpus:Do,totalmem:fo,freemem:po,uptime:co,loadavg:lo,hostname:oo,endianness:ao}}}),id=te({"node-modules-polyfills-commonjs:os"(e,r){ne();var t=(sd(),ft(io));if(t&&t.default){r.exports=t.default;for(let s in t)r.exports[s]=t[s]}else t&&(r.exports=t)}}),ad=te({"node_modules/detect-newline/index.js"(e,r){"use strict";ne();var t=s=>{if(typeof s!="string")throw new TypeError("Expected a string");let a=s.match(/(?:\r?\n)/g)||[];if(a.length===0)return;let n=a.filter(i=>i===`\r
`).length,u=a.length-n;return n>u?`\r
`:`
`};r.exports=t,r.exports.graceful=s=>typeof s=="string"&&t(s)||`
`}}),od=te({"node_modules/jest-docblock/build/index.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0}),e.extract=c,e.parse=E,e.parseWithComments=_,e.print=w,e.strip=D;function r(){let S=id();return r=function(){return S},S}function t(){let S=s(ad());return t=function(){return S},S}function s(S){return S&&S.__esModule?S:{default:S}}var a=/\*\/$/,n=/^\/\*\*?/,u=/^\s*(\/\*\*?(.|\r?\n)*?\*\/)/,i=/(^|\s+)\/\/([^\r\n]*)/g,l=/^(\r?\n)+/,p=/(?:^|\r?\n) *(@[^\r\n]*?) *\r?\n *(?![^@\r\n]*\/\/[^]*)([^@\r\n\s][^@\r\n]+?) *\r?\n/g,d=/(?:^|\r?\n) *@(\S+) *([^\r\n]*)/g,y=/(\r?\n|^) *\* ?/g,g=[];function c(S){let N=S.match(u);return N?N[0].trimLeft():""}function D(S){let N=S.match(u);return N&&N[0]?S.substring(N[0].length):S}function E(S){return _(S).pragmas}function _(S){let N=(0,t().default)(S)||r().EOL;S=S.replace(n,"").replace(a,"").replace(y,"$1");let I="";for(;I!==S;)I=S,S=S.replace(p,`${N}$1 $2${N}`);S=S.replace(l,"").trimRight();let P=Object.create(null),$=S.replace(d,"").replace(l,"").trimRight(),f;for(;f=d.exec(S);){let T=f[2].replace(i,"");typeof P[f[1]]=="string"||Array.isArray(P[f[1]])?P[f[1]]=g.concat(P[f[1]],T):P[f[1]]=T}return{comments:$,pragmas:P}}function w(S){let{comments:N="",pragmas:I={}}=S,P=(0,t().default)(N)||r().EOL,$="/**",f=" *",T=" */",m=Object.keys(I),v=m.map(h=>F(h,I[h])).reduce((h,C)=>h.concat(C),[]).map(h=>`${f} ${h}${P}`).join("");if(!N){if(m.length===0)return"";if(m.length===1&&!Array.isArray(I[m[0]])){let h=I[m[0]];return`${$} ${F(m[0],h)[0]}${T}`}}let o=N.split(P).map(h=>`${f} ${h}`).join(P)+P;return $+P+(N?o:"")+(N&&m.length?f+P:"")+v+T}function F(S,N){return g.concat(N).map(I=>`@${S} ${I}`.trim())}}}),ld=te({"src/language-js/utils/get-shebang.js"(e,r){"use strict";ne();function t(s){if(!s.startsWith("#!"))return"";let a=s.indexOf(`
`);return a===-1?s:s.slice(0,a)}r.exports=t}}),Co=te({"src/language-js/pragma.js"(e,r){"use strict";ne();var{parseWithComments:t,strip:s,extract:a,print:n}=od(),{normalizeEndOfLine:u}=Jn(),i=ld();function l(y){let g=i(y);g&&(y=y.slice(g.length+1));let c=a(y),{pragmas:D,comments:E}=t(c);return{shebang:g,text:y,pragmas:D,comments:E}}function p(y){let g=Object.keys(l(y).pragmas);return g.includes("prettier")||g.includes("format")}function d(y){let{shebang:g,text:c,pragmas:D,comments:E}=l(y),_=s(c),w=n({pragmas:Object.assign({format:""},D),comments:E.trimStart()});return(g?`${g}
`:"")+u(w)+(_.startsWith(`
`)?`
`:`

`)+_}r.exports={hasPragma:p,insertPragma:d}}}),Eo=te({"src/language-js/comments.js"(e,r){"use strict";ne();var{getLast:t,hasNewline:s,getNextNonSpaceNonCommentCharacterIndexWithStartIndex:a,getNextNonSpaceNonCommentCharacter:n,hasNewlineInRange:u,addLeadingComment:i,addTrailingComment:l,addDanglingComment:p,getNextNonSpaceNonCommentCharacterIndex:d,isNonEmptyArray:y}=Ue(),{getFunctionParameters:g,isPrettierIgnoreComment:c,isJsxNode:D,hasFlowShorthandAnnotationComment:E,hasFlowAnnotationComment:_,hasIgnoreComment:w,isCallLikeExpression:F,getCallArguments:S,isCallExpression:N,isMemberExpression:I,isObjectProperty:P,isLineComment:$,getComments:f,CommentCheckFlags:T,markerForIfWithoutBlockAndSameLineComment:m}=Ke(),{locStart:v,locEnd:o}=ut(),h=Ot();function C(fe){return[oe,ue,L,R,q,J,Y,ge,Z,De,he,we,ee,Fe,z].some(A=>A(fe))}function x(fe){return[M,ue,Q,he,R,q,J,Y,Fe,U,se,De,Ne,z,ce].some(A=>A(fe))}function b(fe){return[oe,R,q,V,de,ee,De,K,W,H,z,Pe].some(A=>A(fe))}function B(fe,A){let G=(fe.body||fe.properties).find(re=>{let{type:ye}=re;return ye!=="EmptyStatement"});G?i(G,A):p(fe,A)}function k(fe,A){fe.type==="BlockStatement"?B(fe,A):i(fe,A)}function M(fe){let{comment:A,followingNode:G}=fe;return G&&Ae(A)?(i(G,A),!0):!1}function R(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye,text:Ee}=fe;if((re==null?void 0:re.type)!=="IfStatement"||!ye)return!1;if(n(Ee,A,o)===")")return l(G,A),!0;if(G===re.consequent&&ye===re.alternate){if(G.type==="BlockStatement")l(G,A);else{let ve=A.type==="SingleLine"||A.loc.start.line===A.loc.end.line,ze=A.loc.start.line===G.loc.start.line;ve&&ze?p(G,A,m):p(re,A)}return!0}return ye.type==="BlockStatement"?(B(ye,A),!0):ye.type==="IfStatement"?(k(ye.consequent,A),!0):re.consequent===ye?(i(ye,A),!0):!1}function q(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye,text:Ee}=fe;return(re==null?void 0:re.type)!=="WhileStatement"||!ye?!1:n(Ee,A,o)===")"?(l(G,A),!0):ye.type==="BlockStatement"?(B(ye,A),!0):re.body===ye?(i(ye,A),!0):!1}function J(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye}=fe;return(re==null?void 0:re.type)!=="TryStatement"&&(re==null?void 0:re.type)!=="CatchClause"||!ye?!1:re.type==="CatchClause"&&G?(l(G,A),!0):ye.type==="BlockStatement"?(B(ye,A),!0):ye.type==="TryStatement"?(k(ye.finalizer,A),!0):ye.type==="CatchClause"?(k(ye.body,A),!0):!1}function L(fe){let{comment:A,enclosingNode:G,followingNode:re}=fe;return I(G)&&(re==null?void 0:re.type)==="Identifier"?(i(G,A),!0):!1}function Q(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye,text:Ee}=fe,Be=G&&!u(Ee,o(G),v(A));return(!G||!Be)&&((re==null?void 0:re.type)==="ConditionalExpression"||(re==null?void 0:re.type)==="TSConditionalType")&&ye?(i(ye,A),!0):!1}function V(fe){let{comment:A,precedingNode:G,enclosingNode:re}=fe;return P(re)&&re.shorthand&&re.key===G&&re.value.type==="AssignmentPattern"?(l(re.value.left,A),!0):!1}var j=new Set(["ClassDeclaration","ClassExpression","DeclareClass","DeclareInterface","InterfaceDeclaration","TSInterfaceDeclaration"]);function Y(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye}=fe;if(j.has(re==null?void 0:re.type)){if(y(re.decorators)&&!(ye&&ye.type==="Decorator"))return l(t(re.decorators),A),!0;if(re.body&&ye===re.body)return B(re.body,A),!0;if(ye){if(re.superClass&&ye===re.superClass&&G&&(G===re.id||G===re.typeParameters))return l(G,A),!0;for(let Ee of["implements","extends","mixins"])if(re[Ee]&&ye===re[Ee][0])return G&&(G===re.id||G===re.typeParameters||G===re.superClass)?l(G,A):p(re,A,Ee),!0}}return!1}var ie=new Set(["ClassMethod","ClassProperty","PropertyDefinition","TSAbstractPropertyDefinition","TSAbstractMethodDefinition","TSDeclareMethod","MethodDefinition","ClassAccessorProperty","AccessorProperty","TSAbstractAccessorProperty"]);function ee(fe){let{comment:A,precedingNode:G,enclosingNode:re,text:ye}=fe;return re&&G&&n(ye,A,o)==="("&&(re.type==="Property"||re.type==="TSDeclareMethod"||re.type==="TSAbstractMethodDefinition")&&G.type==="Identifier"&&re.key===G&&n(ye,G,o)!==":"||(G==null?void 0:G.type)==="Decorator"&&ie.has(re==null?void 0:re.type)?(l(G,A),!0):!1}var le=new Set(["FunctionDeclaration","FunctionExpression","ClassMethod","MethodDefinition","ObjectMethod"]);function W(fe){let{comment:A,precedingNode:G,enclosingNode:re,text:ye}=fe;return n(ye,A,o)!=="("?!1:G&&le.has(re==null?void 0:re.type)?(l(G,A),!0):!1}function K(fe){let{comment:A,enclosingNode:G,text:re}=fe;if((G==null?void 0:G.type)!=="ArrowFunctionExpression")return!1;let ye=d(re,A,o);return ye!==!1&&re.slice(ye,ye+2)==="=>"?(p(G,A),!0):!1}function de(fe){let{comment:A,enclosingNode:G,text:re}=fe;return n(re,A,o)!==")"?!1:G&&(X(G)&&g(G).length===0||F(G)&&S(G).length===0)?(p(G,A),!0):((G==null?void 0:G.type)==="MethodDefinition"||(G==null?void 0:G.type)==="TSAbstractMethodDefinition")&&g(G.value).length===0?(p(G.value,A),!0):!1}function ue(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye,text:Ee}=fe;if((G==null?void 0:G.type)==="FunctionTypeParam"&&(re==null?void 0:re.type)==="FunctionTypeAnnotation"&&(ye==null?void 0:ye.type)!=="FunctionTypeParam"||((G==null?void 0:G.type)==="Identifier"||(G==null?void 0:G.type)==="AssignmentPattern")&&re&&X(re)&&n(Ee,A,o)===")")return l(G,A),!0;if((re==null?void 0:re.type)==="FunctionDeclaration"&&(ye==null?void 0:ye.type)==="BlockStatement"){let Be=(()=>{let ve=g(re);if(ve.length>0)return a(Ee,o(t(ve)));let ze=a(Ee,o(re.id));return ze!==!1&&a(Ee,ze+1)})();if(v(A)>Be)return B(ye,A),!0}return!1}function Fe(fe){let{comment:A,enclosingNode:G}=fe;return(G==null?void 0:G.type)==="LabeledStatement"?(i(G,A),!0):!1}function z(fe){let{comment:A,enclosingNode:G}=fe;return((G==null?void 0:G.type)==="ContinueStatement"||(G==null?void 0:G.type)==="BreakStatement")&&!G.label?(l(G,A),!0):!1}function U(fe){let{comment:A,precedingNode:G,enclosingNode:re}=fe;return N(re)&&G&&re.callee===G&&re.arguments.length>0?(i(re.arguments[0],A),!0):!1}function Z(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye}=fe;return(re==null?void 0:re.type)==="UnionTypeAnnotation"||(re==null?void 0:re.type)==="TSUnionType"?(c(A)&&(ye.prettierIgnore=!0,A.unignore=!0),G?(l(G,A),!0):!1):(((ye==null?void 0:ye.type)==="UnionTypeAnnotation"||(ye==null?void 0:ye.type)==="TSUnionType")&&c(A)&&(ye.types[0].prettierIgnore=!0,A.unignore=!0),!1)}function se(fe){let{comment:A,enclosingNode:G}=fe;return P(G)?(i(G,A),!0):!1}function De(fe){let{comment:A,enclosingNode:G,followingNode:re,ast:ye,isLastComment:Ee}=fe;return ye&&ye.body&&ye.body.length===0?(Ee?p(ye,A):i(ye,A),!0):(G==null?void 0:G.type)==="Program"&&(G==null?void 0:G.body.length)===0&&!y(G.directives)?(Ee?p(G,A):i(G,A),!0):(re==null?void 0:re.type)==="Program"&&(re==null?void 0:re.body.length)===0&&(G==null?void 0:G.type)==="ModuleExpression"?(p(re,A),!0):!1}function ge(fe){let{comment:A,enclosingNode:G}=fe;return(G==null?void 0:G.type)==="ForInStatement"||(G==null?void 0:G.type)==="ForOfStatement"?(i(G,A),!0):!1}function he(fe){let{comment:A,precedingNode:G,enclosingNode:re,text:ye}=fe;if((re==null?void 0:re.type)==="ImportSpecifier"||(re==null?void 0:re.type)==="ExportSpecifier")return i(re,A),!0;let Ee=(G==null?void 0:G.type)==="ImportSpecifier"&&(re==null?void 0:re.type)==="ImportDeclaration",Be=(G==null?void 0:G.type)==="ExportSpecifier"&&(re==null?void 0:re.type)==="ExportNamedDeclaration";return(Ee||Be)&&s(ye,o(A))?(l(G,A),!0):!1}function we(fe){let{comment:A,enclosingNode:G}=fe;return(G==null?void 0:G.type)==="AssignmentPattern"?(i(G,A),!0):!1}var ke=new Set(["VariableDeclarator","AssignmentExpression","TypeAlias","TSTypeAliasDeclaration"]),Re=new Set(["ObjectExpression","ArrayExpression","TemplateLiteral","TaggedTemplateExpression","ObjectTypeAnnotation","TSTypeLiteral"]);function Ne(fe){let{comment:A,enclosingNode:G,followingNode:re}=fe;return ke.has(G==null?void 0:G.type)&&re&&(Re.has(re.type)||h(A))?(i(re,A),!0):!1}function Pe(fe){let{comment:A,enclosingNode:G,followingNode:re,text:ye}=fe;return!re&&((G==null?void 0:G.type)==="TSMethodSignature"||(G==null?void 0:G.type)==="TSDeclareFunction"||(G==null?void 0:G.type)==="TSAbstractMethodDefinition")&&n(ye,A,o)===";"?(l(G,A),!0):!1}function oe(fe){let{comment:A,enclosingNode:G,followingNode:re}=fe;if(c(A)&&(G==null?void 0:G.type)==="TSMappedType"&&(re==null?void 0:re.type)==="TSTypeParameter"&&re.constraint)return G.prettierIgnore=!0,A.unignore=!0,!0}function H(fe){let{comment:A,precedingNode:G,enclosingNode:re,followingNode:ye}=fe;return(re==null?void 0:re.type)!=="TSMappedType"?!1:(ye==null?void 0:ye.type)==="TSTypeParameter"&&ye.name?(i(ye.name,A),!0):(G==null?void 0:G.type)==="TSTypeParameter"&&G.constraint?(l(G.constraint,A),!0):!1}function ce(fe){let{comment:A,enclosingNode:G,followingNode:re}=fe;return!G||G.type!=="SwitchCase"||G.test||!re||re!==G.consequent[0]?!1:(re.type==="BlockStatement"&&$(A)?B(re,A):p(G,A),!0)}function X(fe){return fe.type==="ArrowFunctionExpression"||fe.type==="FunctionExpression"||fe.type==="FunctionDeclaration"||fe.type==="ObjectMethod"||fe.type==="ClassMethod"||fe.type==="TSDeclareFunction"||fe.type==="TSCallSignatureDeclaration"||fe.type==="TSConstructSignatureDeclaration"||fe.type==="TSMethodSignature"||fe.type==="TSConstructorType"||fe.type==="TSFunctionType"||fe.type==="TSDeclareMethod"}function pe(fe,A){if((A.parser==="typescript"||A.parser==="flow"||A.parser==="acorn"||A.parser==="espree"||A.parser==="meriyah"||A.parser==="__babel_estree")&&fe.type==="MethodDefinition"&&fe.value&&fe.value.type==="FunctionExpression"&&g(fe.value).length===0&&!fe.value.returnType&&!y(fe.value.typeParameters)&&fe.value.body)return[...fe.decorators||[],fe.key,fe.value.body]}function Ae(fe){return h(fe)&&fe.value[0]==="*"&&/@type\b/.test(fe.value)}function Ce(fe){let A=fe.getValue(),G=fe.getParentNode(),re=ye=>_(f(ye,T.Leading))||_(f(ye,T.Trailing));return(A&&(D(A)||E(A)||N(G)&&re(A))||G&&(G.type==="JSXSpreadAttribute"||G.type==="JSXSpreadChild"||G.type==="UnionTypeAnnotation"||G.type==="TSUnionType"||(G.type==="ClassDeclaration"||G.type==="ClassExpression")&&G.superClass===A))&&(!w(fe)||G.type==="UnionTypeAnnotation"||G.type==="TSUnionType")}r.exports={handleOwnLineComment:C,handleEndOfLineComment:x,handleRemainingComment:b,isTypeCastComment:Ae,getCommentChildNodes:pe,willPrintOwnComments:Ce}}}),qt=te({"src/language-js/needs-parens.js"(e,r){"use strict";ne();var t=lt(),s=Kn(),{getFunctionParameters:a,getLeftSidePathName:n,hasFlowShorthandAnnotationComment:u,hasNakedLeftSide:i,hasNode:l,isBitwiseOperator:p,startsWithNoLookaheadToken:d,shouldFlatten:y,getPrecedence:g,isCallExpression:c,isMemberExpression:D,isObjectProperty:E,isTSTypeExpression:_}=Ke();function w(f,T){let m=f.getParentNode();if(!m)return!1;let v=f.getName(),o=f.getNode();if(T.__isInHtmlInterpolation&&!T.bracketSpacing&&I(o)&&P(f))return!0;if(F(o))return!1;if(T.parser!=="flow"&&u(f.getValue()))return!0;if(o.type==="Identifier"){if(o.extra&&o.extra.parenthesized&&/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(o.name)||v==="left"&&(o.name==="async"&&!m.await||o.name==="let")&&m.type==="ForOfStatement")return!0;if(o.name==="let"){var h;let x=(h=f.findAncestor(b=>b.type==="ForOfStatement"))===null||h===void 0?void 0:h.left;if(x&&d(x,b=>b===o))return!0}if(v==="object"&&o.name==="let"&&m.type==="MemberExpression"&&m.computed&&!m.optional){let x=f.findAncestor(B=>B.type==="ExpressionStatement"||B.type==="ForStatement"||B.type==="ForInStatement"),b=x?x.type==="ExpressionStatement"?x.expression:x.type==="ForStatement"?x.init:x.left:void 0;if(b&&d(b,B=>B===o))return!0}return!1}if(o.type==="ObjectExpression"||o.type==="FunctionExpression"||o.type==="ClassExpression"||o.type==="DoExpression"){var C;let x=(C=f.findAncestor(b=>b.type==="ExpressionStatement"))===null||C===void 0?void 0:C.expression;if(x&&d(x,b=>b===o))return!0}switch(m.type){case"ParenthesizedExpression":return!1;case"ClassDeclaration":case"ClassExpression":{if(v==="superClass"&&(o.type==="ArrowFunctionExpression"||o.type==="AssignmentExpression"||o.type==="AwaitExpression"||o.type==="BinaryExpression"||o.type==="ConditionalExpression"||o.type==="LogicalExpression"||o.type==="NewExpression"||o.type==="ObjectExpression"||o.type==="SequenceExpression"||o.type==="TaggedTemplateExpression"||o.type==="UnaryExpression"||o.type==="UpdateExpression"||o.type==="YieldExpression"||o.type==="TSNonNullExpression"))return!0;break}case"ExportDefaultDeclaration":return $(f,T)||o.type==="SequenceExpression";case"Decorator":{if(v==="expression"){let x=!1,b=!1,B=o;for(;B;)switch(B.type){case"MemberExpression":b=!0,B=B.object;break;case"CallExpression":if(b||x)return T.parser!=="typescript";x=!0,B=B.callee;break;case"Identifier":return!1;case"TaggedTemplateExpression":return T.parser!=="typescript";default:return!0}return!0}break}case"ArrowFunctionExpression":{if(v==="body"&&o.type!=="SequenceExpression"&&d(o,x=>x.type==="ObjectExpression"))return!0;break}}switch(o.type){case"UpdateExpression":if(m.type==="UnaryExpression")return o.prefix&&(o.operator==="++"&&m.operator==="+"||o.operator==="--"&&m.operator==="-");case"UnaryExpression":switch(m.type){case"UnaryExpression":return o.operator===m.operator&&(o.operator==="+"||o.operator==="-");case"BindExpression":return!0;case"MemberExpression":case"OptionalMemberExpression":return v==="object";case"TaggedTemplateExpression":return!0;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return v==="callee";case"BinaryExpression":return v==="left"&&m.operator==="**";case"TSNonNullExpression":return!0;default:return!1}case"BinaryExpression":{if(m.type==="UpdateExpression"||o.operator==="in"&&S(f))return!0;if(o.operator==="|>"&&o.extra&&o.extra.parenthesized){let x=f.getParentNode(1);if(x.type==="BinaryExpression"&&x.operator==="|>")return!0}}case"TSTypeAssertion":case"TSAsExpression":case"TSSatisfiesExpression":case"LogicalExpression":switch(m.type){case"TSSatisfiesExpression":case"TSAsExpression":return!_(o);case"ConditionalExpression":return _(o);case"CallExpression":case"NewExpression":case"OptionalCallExpression":return v==="callee";case"ClassExpression":case"ClassDeclaration":return v==="superClass";case"TSTypeAssertion":case"TaggedTemplateExpression":case"UnaryExpression":case"JSXSpreadAttribute":case"SpreadElement":case"SpreadProperty":case"BindExpression":case"AwaitExpression":case"TSNonNullExpression":case"UpdateExpression":return!0;case"MemberExpression":case"OptionalMemberExpression":return v==="object";case"AssignmentExpression":case"AssignmentPattern":return v==="left"&&(o.type==="TSTypeAssertion"||_(o));case"LogicalExpression":if(o.type==="LogicalExpression")return m.operator!==o.operator;case"BinaryExpression":{let{operator:x,type:b}=o;if(!x&&b!=="TSTypeAssertion")return!0;let B=g(x),k=m.operator,M=g(k);return M>B||v==="right"&&M===B||M===B&&!y(k,x)?!0:M<B&&x==="%"?k==="+"||k==="-":!!p(k)}default:return!1}case"SequenceExpression":switch(m.type){case"ReturnStatement":return!1;case"ForStatement":return!1;case"ExpressionStatement":return v!=="expression";case"ArrowFunctionExpression":return v!=="body";default:return!0}case"YieldExpression":if(m.type==="UnaryExpression"||m.type==="AwaitExpression"||_(m)||m.type==="TSNonNullExpression")return!0;case"AwaitExpression":switch(m.type){case"TaggedTemplateExpression":case"UnaryExpression":case"LogicalExpression":case"SpreadElement":case"SpreadProperty":case"TSAsExpression":case"TSSatisfiesExpression":case"TSNonNullExpression":case"BindExpression":return!0;case"MemberExpression":case"OptionalMemberExpression":return v==="object";case"NewExpression":case"CallExpression":case"OptionalCallExpression":return v==="callee";case"ConditionalExpression":return v==="test";case"BinaryExpression":return!(!o.argument&&m.operator==="|>");default:return!1}case"TSConditionalType":if(v==="extendsType"&&m.type==="TSConditionalType")return!0;case"TSFunctionType":case"TSConstructorType":if(v==="extendsType"&&m.type==="TSConditionalType"){let x=(o.returnType||o.typeAnnotation).typeAnnotation;if(x.type==="TSInferType"&&x.typeParameter.constraint)return!0}if(v==="checkType"&&m.type==="TSConditionalType")return!0;case"TSUnionType":case"TSIntersectionType":if((m.type==="TSUnionType"||m.type==="TSIntersectionType")&&m.types.length>1&&(!o.types||o.types.length>1))return!0;case"TSInferType":if(o.type==="TSInferType"&&m.type==="TSRestType")return!1;case"TSTypeOperator":return m.type==="TSArrayType"||m.type==="TSOptionalType"||m.type==="TSRestType"||v==="objectType"&&m.type==="TSIndexedAccessType"||m.type==="TSTypeOperator"||m.type==="TSTypeAnnotation"&&f.getParentNode(1).type.startsWith("TSJSDoc");case"TSTypeQuery":return v==="objectType"&&m.type==="TSIndexedAccessType"||v==="elementType"&&m.type==="TSArrayType";case"ArrayTypeAnnotation":return m.type==="NullableTypeAnnotation";case"IntersectionTypeAnnotation":case"UnionTypeAnnotation":return m.type==="ArrayTypeAnnotation"||m.type==="NullableTypeAnnotation"||m.type==="IntersectionTypeAnnotation"||m.type==="UnionTypeAnnotation"||v==="objectType"&&(m.type==="IndexedAccessType"||m.type==="OptionalIndexedAccessType");case"NullableTypeAnnotation":return m.type==="ArrayTypeAnnotation"||v==="objectType"&&(m.type==="IndexedAccessType"||m.type==="OptionalIndexedAccessType");case"FunctionTypeAnnotation":{let x=m.type==="NullableTypeAnnotation"?f.getParentNode(1):m;return x.type==="UnionTypeAnnotation"||x.type==="IntersectionTypeAnnotation"||x.type==="ArrayTypeAnnotation"||v==="objectType"&&(x.type==="IndexedAccessType"||x.type==="OptionalIndexedAccessType")||x.type==="NullableTypeAnnotation"||m.type==="FunctionTypeParam"&&m.name===null&&a(o).some(b=>b.typeAnnotation&&b.typeAnnotation.type==="NullableTypeAnnotation")}case"OptionalIndexedAccessType":return v==="objectType"&&m.type==="IndexedAccessType";case"TypeofTypeAnnotation":return v==="objectType"&&(m.type==="IndexedAccessType"||m.type==="OptionalIndexedAccessType");case"StringLiteral":case"NumericLiteral":case"Literal":if(typeof o.value=="string"&&m.type==="ExpressionStatement"&&!m.directive){let x=f.getParentNode(1);return x.type==="Program"||x.type==="BlockStatement"}return v==="object"&&m.type==="MemberExpression"&&typeof o.value=="number";case"AssignmentExpression":{let x=f.getParentNode(1);return v==="body"&&m.type==="ArrowFunctionExpression"?!0:v==="key"&&(m.type==="ClassProperty"||m.type==="PropertyDefinition")&&m.computed||(v==="init"||v==="update")&&m.type==="ForStatement"?!1:m.type==="ExpressionStatement"?o.left.type==="ObjectPattern":!(v==="key"&&m.type==="TSPropertySignature"||m.type==="AssignmentExpression"||m.type==="SequenceExpression"&&x&&x.type==="ForStatement"&&(x.init===m||x.update===m)||v==="value"&&m.type==="Property"&&x&&x.type==="ObjectPattern"&&x.properties.includes(m)||m.type==="NGChainedExpression")}case"ConditionalExpression":switch(m.type){case"TaggedTemplateExpression":case"UnaryExpression":case"SpreadElement":case"SpreadProperty":case"BinaryExpression":case"LogicalExpression":case"NGPipeExpression":case"ExportDefaultDeclaration":case"AwaitExpression":case"JSXSpreadAttribute":case"TSTypeAssertion":case"TypeCastExpression":case"TSAsExpression":case"TSSatisfiesExpression":case"TSNonNullExpression":return!0;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return v==="callee";case"ConditionalExpression":return v==="test";case"MemberExpression":case"OptionalMemberExpression":return v==="object";default:return!1}case"FunctionExpression":switch(m.type){case"NewExpression":case"CallExpression":case"OptionalCallExpression":return v==="callee";case"TaggedTemplateExpression":return!0;default:return!1}case"ArrowFunctionExpression":switch(m.type){case"BinaryExpression":return m.operator!=="|>"||o.extra&&o.extra.parenthesized;case"NewExpression":case"CallExpression":case"OptionalCallExpression":return v==="callee";case"MemberExpression":case"OptionalMemberExpression":return v==="object";case"TSAsExpression":case"TSSatisfiesExpression":case"TSNonNullExpression":case"BindExpression":case"TaggedTemplateExpression":case"UnaryExpression":case"LogicalExpression":case"AwaitExpression":case"TSTypeAssertion":return!0;case"ConditionalExpression":return v==="test";default:return!1}case"ClassExpression":if(s(o.decorators))return!0;switch(m.type){case"NewExpression":return v==="callee";default:return!1}case"OptionalMemberExpression":case"OptionalCallExpression":{let x=f.getParentNode(1);if(v==="object"&&m.type==="MemberExpression"||v==="callee"&&(m.type==="CallExpression"||m.type==="NewExpression")||m.type==="TSNonNullExpression"&&x.type==="MemberExpression"&&x.object===m)return!0}case"CallExpression":case"MemberExpression":case"TaggedTemplateExpression":case"TSNonNullExpression":if(v==="callee"&&(m.type==="BindExpression"||m.type==="NewExpression")){let x=o;for(;x;)switch(x.type){case"CallExpression":case"OptionalCallExpression":return!0;case"MemberExpression":case"OptionalMemberExpression":case"BindExpression":x=x.object;break;case"TaggedTemplateExpression":x=x.tag;break;case"TSNonNullExpression":x=x.expression;break;default:return!1}}return!1;case"BindExpression":return v==="callee"&&(m.type==="BindExpression"||m.type==="NewExpression")||v==="object"&&D(m);case"NGPipeExpression":return!(m.type==="NGRoot"||m.type==="NGMicrosyntaxExpression"||m.type==="ObjectProperty"&&!(o.extra&&o.extra.parenthesized)||m.type==="ArrayExpression"||c(m)&&m.arguments[v]===o||v==="right"&&m.type==="NGPipeExpression"||v==="property"&&m.type==="MemberExpression"||m.type==="AssignmentExpression");case"JSXFragment":case"JSXElement":return v==="callee"||v==="left"&&m.type==="BinaryExpression"&&m.operator==="<"||m.type!=="ArrayExpression"&&m.type!=="ArrowFunctionExpression"&&m.type!=="AssignmentExpression"&&m.type!=="AssignmentPattern"&&m.type!=="BinaryExpression"&&m.type!=="NewExpression"&&m.type!=="ConditionalExpression"&&m.type!=="ExpressionStatement"&&m.type!=="JsExpressionRoot"&&m.type!=="JSXAttribute"&&m.type!=="JSXElement"&&m.type!=="JSXExpressionContainer"&&m.type!=="JSXFragment"&&m.type!=="LogicalExpression"&&!c(m)&&!E(m)&&m.type!=="ReturnStatement"&&m.type!=="ThrowStatement"&&m.type!=="TypeCastExpression"&&m.type!=="VariableDeclarator"&&m.type!=="YieldExpression";case"TypeAnnotation":return v==="returnType"&&m.type==="ArrowFunctionExpression"&&N(o)}return!1}function F(f){return f.type==="BlockStatement"||f.type==="BreakStatement"||f.type==="ClassBody"||f.type==="ClassDeclaration"||f.type==="ClassMethod"||f.type==="ClassProperty"||f.type==="PropertyDefinition"||f.type==="ClassPrivateProperty"||f.type==="ContinueStatement"||f.type==="DebuggerStatement"||f.type==="DeclareClass"||f.type==="DeclareExportAllDeclaration"||f.type==="DeclareExportDeclaration"||f.type==="DeclareFunction"||f.type==="DeclareInterface"||f.type==="DeclareModule"||f.type==="DeclareModuleExports"||f.type==="DeclareVariable"||f.type==="DoWhileStatement"||f.type==="EnumDeclaration"||f.type==="ExportAllDeclaration"||f.type==="ExportDefaultDeclaration"||f.type==="ExportNamedDeclaration"||f.type==="ExpressionStatement"||f.type==="ForInStatement"||f.type==="ForOfStatement"||f.type==="ForStatement"||f.type==="FunctionDeclaration"||f.type==="IfStatement"||f.type==="ImportDeclaration"||f.type==="InterfaceDeclaration"||f.type==="LabeledStatement"||f.type==="MethodDefinition"||f.type==="ReturnStatement"||f.type==="SwitchStatement"||f.type==="ThrowStatement"||f.type==="TryStatement"||f.type==="TSDeclareFunction"||f.type==="TSEnumDeclaration"||f.type==="TSImportEqualsDeclaration"||f.type==="TSInterfaceDeclaration"||f.type==="TSModuleDeclaration"||f.type==="TSNamespaceExportDeclaration"||f.type==="TypeAlias"||f.type==="VariableDeclaration"||f.type==="WhileStatement"||f.type==="WithStatement"}function S(f){let T=0,m=f.getValue();for(;m;){let v=f.getParentNode(T++);if(v&&v.type==="ForStatement"&&v.init===m)return!0;m=v}return!1}function N(f){return l(f,T=>T.type==="ObjectTypeAnnotation"&&l(T,m=>m.type==="FunctionTypeAnnotation"||void 0)||void 0)}function I(f){switch(f.type){case"ObjectExpression":return!0;default:return!1}}function P(f){let T=f.getValue(),m=f.getParentNode(),v=f.getName();switch(m.type){case"NGPipeExpression":if(typeof v=="number"&&m.arguments[v]===T&&m.arguments.length-1===v)return f.callParent(P);break;case"ObjectProperty":if(v==="value"){let o=f.getParentNode(1);return t(o.properties)===m}break;case"BinaryExpression":case"LogicalExpression":if(v==="right")return f.callParent(P);break;case"ConditionalExpression":if(v==="alternate")return f.callParent(P);break;case"UnaryExpression":if(m.prefix)return f.callParent(P);break}return!1}function $(f,T){let m=f.getValue(),v=f.getParentNode();return m.type==="FunctionExpression"||m.type==="ClassExpression"?v.type==="ExportDefaultDeclaration"||!w(f,T):!i(m)||v.type!=="ExportDefaultDeclaration"&&w(f,T)?!1:f.call(o=>$(o,T),...n(f,m))}r.exports=w}}),Fo=te({"src/language-js/print-preprocess.js"(e,r){"use strict";ne();function t(s,a){switch(a.parser){case"json":case"json5":case"json-stringify":case"__js_expression":case"__vue_expression":case"__vue_ts_expression":return Object.assign(Object.assign({},s),{},{type:a.parser.startsWith("__")?"JsExpressionRoot":"JsonRoot",node:s,comments:[],rootMarker:a.rootMarker});default:return s}}r.exports=t}}),cd=te({"src/language-js/print/html-binding.js"(e,r){"use strict";ne();var{builders:{join:t,line:s,group:a,softline:n,indent:u}}=qe();function i(p,d,y){let g=p.getValue();if(d.__onHtmlBindingRoot&&p.getName()===null&&d.__onHtmlBindingRoot(g,d),g.type==="File"){if(d.__isVueForBindingLeft)return p.call(c=>{let D=t([",",s],c.map(y,"params")),{params:E}=c.getValue();return E.length===1?D:["(",u([n,a(D)]),n,")"]},"program","body",0);if(d.__isVueBindings)return p.call(c=>t([",",s],c.map(y,"params")),"program","body",0)}}function l(p){switch(p.type){case"MemberExpression":switch(p.property.type){case"Identifier":case"NumericLiteral":case"StringLiteral":return l(p.object)}return!1;case"Identifier":return!0;default:return!1}}r.exports={isVueEventBindingExpression:l,printHtmlBinding:i}}}),ru=te({"src/language-js/print/binaryish.js"(e,r){"use strict";ne();var{printComments:t}=et(),{getLast:s}=Ue(),{builders:{join:a,line:n,softline:u,group:i,indent:l,align:p,indentIfBreak:d},utils:{cleanDoc:y,getDocParts:g,isConcat:c}}=qe(),{hasLeadingOwnLineComment:D,isBinaryish:E,isJsxNode:_,shouldFlatten:w,hasComment:F,CommentCheckFlags:S,isCallExpression:N,isMemberExpression:I,isObjectProperty:P,isEnabledHackPipeline:$}=Ke(),f=0;function T(o,h,C){let x=o.getValue(),b=o.getParentNode(),B=o.getParentNode(1),k=x!==b.body&&(b.type==="IfStatement"||b.type==="WhileStatement"||b.type==="SwitchStatement"||b.type==="DoWhileStatement"),M=$(h)&&x.operator==="|>",R=m(o,C,h,!1,k);if(k)return R;if(M)return i(R);if(N(b)&&b.callee===x||b.type==="UnaryExpression"||I(b)&&!b.computed)return i([l([u,...R]),u]);let q=b.type==="ReturnStatement"||b.type==="ThrowStatement"||b.type==="JSXExpressionContainer"&&B.type==="JSXAttribute"||x.operator!=="|"&&b.type==="JsExpressionRoot"||x.type!=="NGPipeExpression"&&(b.type==="NGRoot"&&h.parser==="__ng_binding"||b.type==="NGMicrosyntaxExpression"&&B.type==="NGMicrosyntax"&&B.body.length===1)||x===b.body&&b.type==="ArrowFunctionExpression"||x!==b.body&&b.type==="ForStatement"||b.type==="ConditionalExpression"&&B.type!=="ReturnStatement"&&B.type!=="ThrowStatement"&&!N(B)||b.type==="TemplateLiteral",J=b.type==="AssignmentExpression"||b.type==="VariableDeclarator"||b.type==="ClassProperty"||b.type==="PropertyDefinition"||b.type==="TSAbstractPropertyDefinition"||b.type==="ClassPrivateProperty"||P(b),L=E(x.left)&&w(x.operator,x.left.operator);if(q||v(x)&&!L||!v(x)&&J)return i(R);if(R.length===0)return"";let Q=_(x.right),V=R.findIndex(W=>typeof W!="string"&&!Array.isArray(W)&&W.type==="group"),j=R.slice(0,V===-1?1:V+1),Y=R.slice(j.length,Q?-1:void 0),ie=Symbol("logicalChain-"+ ++f),ee=i([...j,l(Y)],{id:ie});if(!Q)return ee;let le=s(R);return i([ee,d(le,{groupId:ie})])}function m(o,h,C,x,b){let B=o.getValue();if(!E(B))return[i(h())];let k=[];w(B.operator,B.left.operator)?k=o.call(Y=>m(Y,h,C,!0,b),"left"):k.push(i(h("left")));let M=v(B),R=(B.operator==="|>"||B.type==="NGPipeExpression"||B.operator==="|"&&C.parser==="__vue_expression")&&!D(C.originalText,B.right),q=B.type==="NGPipeExpression"?"|":B.operator,J=B.type==="NGPipeExpression"&&B.arguments.length>0?i(l([n,": ",a([n,": "],o.map(h,"arguments").map(Y=>p(2,i(Y))))])):"",L;if(M)L=[q," ",h("right"),J];else{let ie=$(C)&&q==="|>"?o.call(ee=>m(ee,h,C,!0,b),"right"):h("right");L=[R?n:"",q,R?" ":n,ie,J]}let Q=o.getParentNode(),V=F(B.left,S.Trailing|S.Line),j=V||!(b&&B.type==="LogicalExpression")&&Q.type!==B.type&&B.left.type!==B.type&&B.right.type!==B.type;if(k.push(R?"":" ",j?i(L,{shouldBreak:V}):L),x&&F(B)){let Y=y(t(o,k,C));return c(Y)||Y.type==="fill"?g(Y):[Y]}return k}function v(o){return o.type!=="LogicalExpression"?!1:!!(o.right.type==="ObjectExpression"&&o.right.properties.length>0||o.right.type==="ArrayExpression"&&o.right.elements.length>0||_(o.right))}r.exports={printBinaryishExpression:T,shouldInlineLogicalExpression:v}}}),pd=te({"src/language-js/print/angular.js"(e,r){"use strict";ne();var{builders:{join:t,line:s,group:a}}=qe(),{hasNode:n,hasComment:u,getComments:i}=Ke(),{printBinaryishExpression:l}=ru();function p(g,c,D){let E=g.getValue();if(E.type.startsWith("NG"))switch(E.type){case"NGRoot":return[D("node"),u(E.node)?" //"+i(E.node)[0].value.trimEnd():""];case"NGPipeExpression":return l(g,c,D);case"NGChainedExpression":return a(t([";",s],g.map(_=>y(_)?D():["(",D(),")"],"expressions")));case"NGEmptyExpression":return"";case"NGQuotedExpression":return[E.prefix,": ",E.value.trim()];case"NGMicrosyntax":return g.map((_,w)=>[w===0?"":d(_.getValue(),w,E)?" ":[";",s],D()],"body");case"NGMicrosyntaxKey":return/^[$_a-z][\w$]*(?:-[$_a-z][\w$])*$/i.test(E.name)?E.name:JSON.stringify(E.name);case"NGMicrosyntaxExpression":return[D("expression"),E.alias===null?"":[" as ",D("alias")]];case"NGMicrosyntaxKeyedExpression":{let _=g.getName(),w=g.getParentNode(),F=d(E,_,w)||(_===1&&(E.key.name==="then"||E.key.name==="else")||_===2&&E.key.name==="else"&&w.body[_-1].type==="NGMicrosyntaxKeyedExpression"&&w.body[_-1].key.name==="then")&&w.body[0].type==="NGMicrosyntaxExpression";return[D("key"),F?" ":": ",D("expression")]}case"NGMicrosyntaxLet":return["let ",D("key"),E.value===null?"":[" = ",D("value")]];case"NGMicrosyntaxAs":return[D("key")," as ",D("alias")];default:throw new Error(`Unknown Angular node type: ${JSON.stringify(E.type)}.`)}}function d(g,c,D){return g.type==="NGMicrosyntaxKeyedExpression"&&g.key.name==="of"&&c===1&&D.body[0].type==="NGMicrosyntaxLet"&&D.body[0].value===null}function y(g){return n(g.getValue(),c=>{switch(c.type){case void 0:return!1;case"CallExpression":case"OptionalCallExpression":case"AssignmentExpression":return!0}})}r.exports={printAngular:p}}}),fd=te({"src/language-js/print/jsx.js"(e,r){"use strict";ne();var{printComments:t,printDanglingComments:s,printCommentsSeparately:a}=et(),{builders:{line:n,hardline:u,softline:i,group:l,indent:p,conditionalGroup:d,fill:y,ifBreak:g,lineSuffixBoundary:c,join:D},utils:{willBreak:E}}=qe(),{getLast:_,getPreferredQuote:w}=Ue(),{isJsxNode:F,rawText:S,isCallExpression:N,isStringLiteral:I,isBinaryish:P,hasComment:$,CommentCheckFlags:f,hasNodeIgnoreComment:T}=Ke(),m=qt(),{willPrintOwnComments:v}=Eo(),o=U=>U===""||U===n||U===u||U===i;function h(U,Z,se){let De=U.getValue();if(De.type==="JSXElement"&&de(De))return[se("openingElement"),se("closingElement")];let ge=De.type==="JSXElement"?se("openingElement"):se("openingFragment"),he=De.type==="JSXElement"?se("closingElement"):se("closingFragment");if(De.children.length===1&&De.children[0].type==="JSXExpressionContainer"&&(De.children[0].expression.type==="TemplateLiteral"||De.children[0].expression.type==="TaggedTemplateExpression"))return[ge,...U.map(se,"children"),he];De.children=De.children.map(A=>Fe(A)?{type:"JSXText",value:" ",raw:" "}:A);let we=De.children.some(F),ke=De.children.filter(A=>A.type==="JSXExpressionContainer").length>1,Re=De.type==="JSXElement"&&De.openingElement.attributes.length>1,Ne=E(ge)||we||Re||ke,Pe=U.getParentNode().rootMarker==="mdx",oe=Z.singleQuote?"{' '}":'{" "}',H=Pe?" ":g([oe,i]," "),ce=De.openingElement&&De.openingElement.name&&De.openingElement.name.name==="fbt",X=C(U,Z,se,H,ce),pe=De.children.some(A=>ue(A));for(let A=X.length-2;A>=0;A--){let G=X[A]===""&&X[A+1]==="",re=X[A]===u&&X[A+1]===""&&X[A+2]===u,ye=(X[A]===i||X[A]===u)&&X[A+1]===""&&X[A+2]===H,Ee=X[A]===H&&X[A+1]===""&&(X[A+2]===i||X[A+2]===u),Be=X[A]===H&&X[A+1]===""&&X[A+2]===H,ve=X[A]===i&&X[A+1]===""&&X[A+2]===u||X[A]===u&&X[A+1]===""&&X[A+2]===i;re&&pe||G||ye||Be||ve?X.splice(A,2):Ee&&X.splice(A+1,2)}for(;X.length>0&&o(_(X));)X.pop();for(;X.length>1&&o(X[0])&&o(X[1]);)X.shift(),X.shift();let Ae=[];for(let[A,G]of X.entries()){if(G===H){if(A===1&&X[A-1]===""){if(X.length===2){Ae.push(oe);continue}Ae.push([oe,u]);continue}else if(A===X.length-1){Ae.push(oe);continue}else if(X[A-1]===""&&X[A-2]===u){Ae.push(oe);continue}}Ae.push(G),E(G)&&(Ne=!0)}let Ce=pe?y(Ae):l(Ae,{shouldBreak:!0});if(Pe)return Ce;let fe=l([ge,p([u,Ce]),u,he]);return Ne?fe:d([l([ge,...X,he]),fe])}function C(U,Z,se,De,ge){let he=[];return U.each((we,ke,Re)=>{let Ne=we.getValue();if(Ne.type==="JSXText"){let Pe=S(Ne);if(ue(Ne)){let oe=Pe.split(le);if(oe[0]===""){if(he.push(""),oe.shift(),/\n/.test(oe[0])){let ce=Re[ke+1];he.push(b(ge,oe[1],Ne,ce))}else he.push(De);oe.shift()}let H;if(_(oe)===""&&(oe.pop(),H=oe.pop()),oe.length===0)return;for(let[ce,X]of oe.entries())ce%2===1?he.push(n):he.push(X);if(H!==void 0)if(/\n/.test(H)){let ce=Re[ke+1];he.push(b(ge,_(he),Ne,ce))}else he.push(De);else{let ce=Re[ke+1];he.push(x(ge,_(he),Ne,ce))}}else/\n/.test(Pe)?Pe.match(/\n/g).length>1&&he.push("",u):he.push("",De)}else{let Pe=se();he.push(Pe);let oe=Re[ke+1];if(oe&&ue(oe)){let ce=K(S(oe)).split(le)[0];he.push(x(ge,ce,Ne,oe))}else he.push(u)}},"children"),he}function x(U,Z,se,De){return U?"":se.type==="JSXElement"&&!se.closingElement||De&&De.type==="JSXElement"&&!De.closingElement?Z.length===1?i:u:i}function b(U,Z,se,De){return U?u:Z.length===1?se.type==="JSXElement"&&!se.closingElement||De&&De.type==="JSXElement"&&!De.closingElement?u:i:u}function B(U,Z,se){let De=U.getParentNode();if(!De||{ArrayExpression:!0,JSXAttribute:!0,JSXElement:!0,JSXExpressionContainer:!0,JSXFragment:!0,ExpressionStatement:!0,CallExpression:!0,OptionalCallExpression:!0,ConditionalExpression:!0,JsExpressionRoot:!0}[De.type])return Z;let he=U.match(void 0,ke=>ke.type==="ArrowFunctionExpression",N,ke=>ke.type==="JSXExpressionContainer"),we=m(U,se);return l([we?"":g("("),p([i,Z]),i,we?"":g(")")],{shouldBreak:he})}function k(U,Z,se){let De=U.getValue(),ge=[];if(ge.push(se("name")),De.value){let he;if(I(De.value)){let ke=S(De.value).slice(1,-1).replace(/&apos;/g,"'").replace(/&quot;/g,'"'),{escaped:Re,quote:Ne,regex:Pe}=w(ke,Z.jsxSingleQuote?"'":'"');ke=ke.replace(Pe,Re);let{leading:oe,trailing:H}=U.call(()=>a(U,Z),"value");he=[oe,Ne,ke,Ne,H]}else he=se("value");ge.push("=",he)}return ge}function M(U,Z,se){let De=U.getValue(),ge=(he,we)=>he.type==="JSXEmptyExpression"||!$(he)&&(he.type==="ArrayExpression"||he.type==="ObjectExpression"||he.type==="ArrowFunctionExpression"||he.type==="AwaitExpression"&&(ge(he.argument,he)||he.argument.type==="JSXElement")||N(he)||he.type==="FunctionExpression"||he.type==="TemplateLiteral"||he.type==="TaggedTemplateExpression"||he.type==="DoExpression"||F(we)&&(he.type==="ConditionalExpression"||P(he)));return ge(De.expression,U.getParentNode(0))?l(["{",se("expression"),c,"}"]):l(["{",p([i,se("expression")]),i,c,"}"])}function R(U,Z,se){let De=U.getValue(),ge=De.name&&$(De.name)||De.typeParameters&&$(De.typeParameters);if(De.selfClosing&&De.attributes.length===0&&!ge)return["<",se("name"),se("typeParameters")," />"];if(De.attributes&&De.attributes.length===1&&De.attributes[0].value&&I(De.attributes[0].value)&&!De.attributes[0].value.value.includes(`
`)&&!ge&&!$(De.attributes[0]))return l(["<",se("name"),se("typeParameters")," ",...U.map(se,"attributes"),De.selfClosing?" />":">"]);let he=De.attributes&&De.attributes.some(ke=>ke.value&&I(ke.value)&&ke.value.value.includes(`
`)),we=Z.singleAttributePerLine&&De.attributes.length>1?u:n;return l(["<",se("name"),se("typeParameters"),p(U.map(()=>[we,se()],"attributes")),...q(De,Z,ge)],{shouldBreak:he})}function q(U,Z,se){return U.selfClosing?[n,"/>"]:J(U,Z,se)?[">"]:[i,">"]}function J(U,Z,se){let De=U.attributes.length>0&&$(_(U.attributes),f.Trailing);return U.attributes.length===0&&!se||(Z.bracketSameLine||Z.jsxBracketSameLine)&&(!se||U.attributes.length>0)&&!De}function L(U,Z,se){let De=U.getValue(),ge=[];ge.push("</");let he=se("name");return $(De.name,f.Leading|f.Line)?ge.push(p([u,he]),u):$(De.name,f.Leading|f.Block)?ge.push(" ",he):ge.push(he),ge.push(">"),ge}function Q(U,Z){let se=U.getValue(),De=$(se),ge=$(se,f.Line),he=se.type==="JSXOpeningFragment";return[he?"<":"</",p([ge?u:De&&!he?" ":"",s(U,Z,!0)]),ge?u:"",">"]}function V(U,Z,se){let De=t(U,h(U,Z,se),Z);return B(U,De,Z)}function j(U,Z){let se=U.getValue(),De=$(se,f.Line);return[s(U,Z,!De),De?u:""]}function Y(U,Z,se){let De=U.getValue();return["{",U.call(ge=>{let he=["...",se()],we=ge.getValue();return!$(we)||!v(ge)?he:[p([i,t(ge,he,Z)]),i]},De.type==="JSXSpreadAttribute"?"argument":"expression"),"}"]}function ie(U,Z,se){let De=U.getValue();if(De.type.startsWith("JSX"))switch(De.type){case"JSXAttribute":return k(U,Z,se);case"JSXIdentifier":return String(De.name);case"JSXNamespacedName":return D(":",[se("namespace"),se("name")]);case"JSXMemberExpression":return D(".",[se("object"),se("property")]);case"JSXSpreadAttribute":return Y(U,Z,se);case"JSXSpreadChild":return Y(U,Z,se);case"JSXExpressionContainer":return M(U,Z,se);case"JSXFragment":case"JSXElement":return V(U,Z,se);case"JSXOpeningElement":return R(U,Z,se);case"JSXClosingElement":return L(U,Z,se);case"JSXOpeningFragment":case"JSXClosingFragment":return Q(U,Z);case"JSXEmptyExpression":return j(U,Z);case"JSXText":throw new Error("JSXText should be handled by JSXElement");default:throw new Error(`Unknown JSX node type: ${JSON.stringify(De.type)}.`)}}var ee=` 
\r	`,le=new RegExp("(["+ee+"]+)"),W=new RegExp("[^"+ee+"]"),K=U=>U.replace(new RegExp("(?:^"+le.source+"|"+le.source+"$)"),"");function de(U){if(U.children.length===0)return!0;if(U.children.length>1)return!1;let Z=U.children[0];return Z.type==="JSXText"&&!ue(Z)}function ue(U){return U.type==="JSXText"&&(W.test(S(U))||!/\n/.test(S(U)))}function Fe(U){return U.type==="JSXExpressionContainer"&&I(U.expression)&&U.expression.value===" "&&!$(U.expression)}function z(U){let Z=U.getValue(),se=U.getParentNode();if(!se||!Z||!F(Z)||!F(se))return!1;let De=se.children.indexOf(Z),ge=null;for(let he=De;he>0;he--){let we=se.children[he-1];if(!(we.type==="JSXText"&&!ue(we))){ge=we;break}}return ge&&ge.type==="JSXExpressionContainer"&&ge.expression.type==="JSXEmptyExpression"&&T(ge.expression)}r.exports={hasJsxIgnoreComment:z,printJsx:ie}}}),ct=te({"src/language-js/print/misc.js"(e,r){"use strict";ne();var{isNonEmptyArray:t}=Ue(),{builders:{indent:s,join:a,line:n}}=qe(),{isFlowAnnotationComment:u}=Ke();function i(_){let w=_.getValue();return!w.optional||w.type==="Identifier"&&w===_.getParentNode().key?"":w.type==="OptionalCallExpression"||w.type==="OptionalMemberExpression"&&w.computed?"?.":"?"}function l(_){return _.getValue().definite||_.match(void 0,(w,F)=>F==="id"&&w.type==="VariableDeclarator"&&w.definite)?"!":""}function p(_,w,F){let S=_.getValue();return S.typeArguments?F("typeArguments"):S.typeParameters?F("typeParameters"):""}function d(_,w,F){let S=_.getValue();if(!S.typeAnnotation)return"";let N=_.getParentNode(),I=N.type==="DeclareFunction"&&N.id===S;return u(w.originalText,S.typeAnnotation)?[" /*: ",F("typeAnnotation")," */"]:[I?"":": ",F("typeAnnotation")]}function y(_,w,F){return["::",F("callee")]}function g(_,w,F){let S=_.getValue();return t(S.modifiers)?[a(" ",_.map(F,"modifiers"))," "]:""}function c(_,w,F){return _.type==="EmptyStatement"?";":_.type==="BlockStatement"||F?[" ",w]:s([n,w])}function D(_,w,F){return["...",F("argument"),d(_,w,F)]}function E(_,w){let F=_.slice(1,-1);if(F.includes('"')||F.includes("'"))return _;let S=w.singleQuote?"'":'"';return S+F+S}r.exports={printOptionalToken:i,printDefiniteToken:l,printFunctionTypeParameters:p,printBindExpressionCallee:y,printTypeScriptModifiers:g,printTypeAnnotation:d,printRestSpread:D,adjustClause:c,printDirective:E}}}),er=te({"src/language-js/print/array.js"(e,r){"use strict";ne();var{printDanglingComments:t}=et(),{builders:{line:s,softline:a,hardline:n,group:u,indent:i,ifBreak:l,fill:p}}=qe(),{getLast:d,hasNewline:y}=Ue(),{shouldPrintComma:g,hasComment:c,CommentCheckFlags:D,isNextLineEmpty:E,isNumericLiteral:_,isSignedNumericLiteral:w}=Ke(),{locStart:F}=ut(),{printOptionalToken:S,printTypeAnnotation:N}=ct();function I(T,m,v){let o=T.getValue(),h=[],C=o.type==="TupleExpression"?"#[":"[",x="]";if(o.elements.length===0)c(o,D.Dangling)?h.push(u([C,t(T,m),a,x])):h.push(C,x);else{let b=d(o.elements),B=!(b&&b.type==="RestElement"),k=b===null,M=Symbol("array"),R=!m.__inJestEach&&o.elements.length>1&&o.elements.every((L,Q,V)=>{let j=L&&L.type;if(j!=="ArrayExpression"&&j!=="ObjectExpression")return!1;let Y=V[Q+1];if(Y&&j!==Y.type)return!1;let ie=j==="ArrayExpression"?"elements":"properties";return L[ie]&&L[ie].length>1}),q=P(o,m),J=B?k?",":g(m)?q?l(",","",{groupId:M}):l(","):"":"";h.push(u([C,i([a,q?f(T,m,v,J):[$(T,m,"elements",v),J],t(T,m,!0)]),a,x],{shouldBreak:R,id:M}))}return h.push(S(T),N(T,m,v)),h}function P(T,m){return T.elements.length>1&&T.elements.every(v=>v&&(_(v)||w(v)&&!c(v.argument))&&!c(v,D.Trailing|D.Line,o=>!y(m.originalText,F(o),{backwards:!0})))}function $(T,m,v,o){let h=[],C=[];return T.each(x=>{h.push(C,u(o())),C=[",",s],x.getValue()&&E(x.getValue(),m)&&C.push(a)},v),h}function f(T,m,v,o){let h=[];return T.each((C,x,b)=>{let B=x===b.length-1;h.push([v(),B?o:","]),B||h.push(E(C.getValue(),m)?[n,n]:c(b[x+1],D.Leading|D.Line)?n:s)},"elements"),p(h)}r.exports={printArray:I,printArrayItems:$,isConciselyPrintedArray:P}}}),Ao=te({"src/language-js/print/call-arguments.js"(e,r){"use strict";ne();var{printDanglingComments:t}=et(),{getLast:s,getPenultimate:a}=Ue(),{getFunctionParameters:n,hasComment:u,CommentCheckFlags:i,isFunctionCompositionArgs:l,isJsxNode:p,isLongCurriedCallExpression:d,shouldPrintComma:y,getCallArguments:g,iterateCallArgumentsPath:c,isNextLineEmpty:D,isCallExpression:E,isStringLiteral:_,isObjectProperty:w,isTSTypeExpression:F}=Ke(),{builders:{line:S,hardline:N,softline:I,group:P,indent:$,conditionalGroup:f,ifBreak:T,breakParent:m},utils:{willBreak:v}}=qe(),{ArgExpansionBailout:o}=Qt(),{isConciselyPrintedArray:h}=er();function C(q,J,L){let Q=q.getValue(),V=Q.type==="ImportExpression",j=g(Q);if(j.length===0)return["(",t(q,J,!0),")"];if(k(j))return["(",L(["arguments",0]),", ",L(["arguments",1]),")"];let Y=!1,ie=!1,ee=j.length-1,le=[];c(q,(z,U)=>{let Z=z.getNode(),se=[L()];U===ee||(D(Z,J)?(U===0&&(ie=!0),Y=!0,se.push(",",N,N)):se.push(",",S)),le.push(se)});let W=!(V||Q.callee&&Q.callee.type==="Import")&&y(J,"all")?",":"";function K(){return P(["(",$([S,...le]),W,S,")"],{shouldBreak:!0})}if(Y||q.getParentNode().type!=="Decorator"&&l(j))return K();let de=B(j),ue=b(j,J);if(de||ue){if(de?le.slice(1).some(v):le.slice(0,-1).some(v))return K();let z=[];try{q.try(()=>{c(q,(U,Z)=>{de&&Z===0&&(z=[[L([],{expandFirstArg:!0}),le.length>1?",":"",ie?N:S,ie?N:""],...le.slice(1)]),ue&&Z===ee&&(z=[...le.slice(0,-1),L([],{expandLastArg:!0})])})})}catch(U){if(U instanceof o)return K();throw U}return[le.some(v)?m:"",f([["(",...z,")"],de?["(",P(z[0],{shouldBreak:!0}),...z.slice(1),")"]:["(",...le.slice(0,-1),P(s(z),{shouldBreak:!0}),")"],K()])]}let Fe=["(",$([I,...le]),T(W),I,")"];return d(q)?Fe:P(Fe,{shouldBreak:le.some(v)||Y})}function x(q){let J=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!1;return q.type==="ObjectExpression"&&(q.properties.length>0||u(q))||q.type==="ArrayExpression"&&(q.elements.length>0||u(q))||q.type==="TSTypeAssertion"&&x(q.expression)||F(q)&&x(q.expression)||q.type==="FunctionExpression"||q.type==="ArrowFunctionExpression"&&(!q.returnType||!q.returnType.typeAnnotation||q.returnType.typeAnnotation.type!=="TSTypeReference"||M(q.body))&&(q.body.type==="BlockStatement"||q.body.type==="ArrowFunctionExpression"&&x(q.body,!0)||q.body.type==="ObjectExpression"||q.body.type==="ArrayExpression"||!J&&(E(q.body)||q.body.type==="ConditionalExpression")||p(q.body))||q.type==="DoExpression"||q.type==="ModuleExpression"}function b(q,J){let L=s(q),Q=a(q);return!u(L,i.Leading)&&!u(L,i.Trailing)&&x(L)&&(!Q||Q.type!==L.type)&&(q.length!==2||Q.type!=="ArrowFunctionExpression"||L.type!=="ArrayExpression")&&!(q.length>1&&L.type==="ArrayExpression"&&h(L,J))}function B(q){if(q.length!==2)return!1;let[J,L]=q;return J.type==="ModuleExpression"&&R(L)?!0:!u(J)&&(J.type==="FunctionExpression"||J.type==="ArrowFunctionExpression"&&J.body.type==="BlockStatement")&&L.type!=="FunctionExpression"&&L.type!=="ArrowFunctionExpression"&&L.type!=="ConditionalExpression"&&!x(L)}function k(q){return q.length===2&&q[0].type==="ArrowFunctionExpression"&&n(q[0]).length===0&&q[0].body.type==="BlockStatement"&&q[1].type==="ArrayExpression"&&!q.some(J=>u(J))}function M(q){return q.type==="BlockStatement"&&(q.body.some(J=>J.type!=="EmptyStatement")||u(q,i.Dangling))}function R(q){return q.type==="ObjectExpression"&&q.properties.length===1&&w(q.properties[0])&&q.properties[0].key.type==="Identifier"&&q.properties[0].key.name==="type"&&_(q.properties[0].value)&&q.properties[0].value.value==="module"}r.exports=C}}),So=te({"src/language-js/print/member.js"(e,r){"use strict";ne();var{builders:{softline:t,group:s,indent:a,label:n}}=qe(),{isNumericLiteral:u,isMemberExpression:i,isCallExpression:l}=Ke(),{printOptionalToken:p}=ct();function d(g,c,D){let E=g.getValue(),_=g.getParentNode(),w,F=0;do w=g.getParentNode(F),F++;while(w&&(i(w)||w.type==="TSNonNullExpression"));let S=D("object"),N=y(g,c,D),I=w&&(w.type==="NewExpression"||w.type==="BindExpression"||w.type==="AssignmentExpression"&&w.left.type!=="Identifier")||E.computed||E.object.type==="Identifier"&&E.property.type==="Identifier"&&!i(_)||(_.type==="AssignmentExpression"||_.type==="VariableDeclarator")&&(l(E.object)&&E.object.arguments.length>0||E.object.type==="TSNonNullExpression"&&l(E.object.expression)&&E.object.expression.arguments.length>0||S.label==="member-chain");return n(S.label==="member-chain"?"member-chain":"member",[S,I?N:s(a([t,N]))])}function y(g,c,D){let E=D("property"),_=g.getValue(),w=p(g);return _.computed?!_.property||u(_.property)?[w,"[",E,"]"]:s([w,"[",a([t,E]),t,"]"]):[w,".",E]}r.exports={printMemberExpression:d,printMemberLookup:y}}}),Dd=te({"src/language-js/print/member-chain.js"(e,r){"use strict";ne();var{printComments:t}=et(),{getLast:s,isNextLineEmptyAfterIndex:a,getNextNonSpaceNonCommentCharacterIndex:n}=Ue(),u=qt(),{isCallExpression:i,isMemberExpression:l,isFunctionOrArrowExpression:p,isLongCurriedCallExpression:d,isMemberish:y,isNumericLiteral:g,isSimpleCallArgument:c,hasComment:D,CommentCheckFlags:E,isNextLineEmpty:_}=Ke(),{locEnd:w}=ut(),{builders:{join:F,hardline:S,group:N,indent:I,conditionalGroup:P,breakParent:$,label:f},utils:{willBreak:T}}=qe(),m=Ao(),{printMemberLookup:v}=So(),{printOptionalToken:o,printFunctionTypeParameters:h,printBindExpressionCallee:C}=ct();function x(b,B,k){let M=b.getParentNode(),R=!M||M.type==="ExpressionStatement",q=[];function J(Ne){let{originalText:Pe}=B,oe=n(Pe,Ne,w);return Pe.charAt(oe)===")"?oe!==!1&&a(Pe,oe+1):_(Ne,B)}function L(Ne){let Pe=Ne.getValue();i(Pe)&&(y(Pe.callee)||i(Pe.callee))?(q.unshift({node:Pe,printed:[t(Ne,[o(Ne),h(Ne,B,k),m(Ne,B,k)],B),J(Pe)?S:""]}),Ne.call(oe=>L(oe),"callee")):y(Pe)?(q.unshift({node:Pe,needsParens:u(Ne,B),printed:t(Ne,l(Pe)?v(Ne,B,k):C(Ne,B,k),B)}),Ne.call(oe=>L(oe),"object")):Pe.type==="TSNonNullExpression"?(q.unshift({node:Pe,printed:t(Ne,"!",B)}),Ne.call(oe=>L(oe),"expression")):q.unshift({node:Pe,printed:k()})}let Q=b.getValue();q.unshift({node:Q,printed:[o(b),h(b,B,k),m(b,B,k)]}),Q.callee&&b.call(Ne=>L(Ne),"callee");let V=[],j=[q[0]],Y=1;for(;Y<q.length&&(q[Y].node.type==="TSNonNullExpression"||i(q[Y].node)||l(q[Y].node)&&q[Y].node.computed&&g(q[Y].node.property));++Y)j.push(q[Y]);if(!i(q[0].node))for(;Y+1<q.length&&(y(q[Y].node)&&y(q[Y+1].node));++Y)j.push(q[Y]);V.push(j),j=[];let ie=!1;for(;Y<q.length;++Y){if(ie&&y(q[Y].node)){if(q[Y].node.computed&&g(q[Y].node.property)){j.push(q[Y]);continue}V.push(j),j=[],ie=!1}(i(q[Y].node)||q[Y].node.type==="ImportExpression")&&(ie=!0),j.push(q[Y]),D(q[Y].node,E.Trailing)&&(V.push(j),j=[],ie=!1)}j.length>0&&V.push(j);function ee(Ne){return/^[A-Z]|^[$_]+$/.test(Ne)}function le(Ne){return Ne.length<=B.tabWidth}function W(Ne){let Pe=Ne[1].length>0&&Ne[1][0].node.computed;if(Ne[0].length===1){let H=Ne[0][0].node;return H.type==="ThisExpression"||H.type==="Identifier"&&(ee(H.name)||R&&le(H.name)||Pe)}let oe=s(Ne[0]).node;return l(oe)&&oe.property.type==="Identifier"&&(ee(oe.property.name)||Pe)}let K=V.length>=2&&!D(V[1][0].node)&&W(V);function de(Ne){let Pe=Ne.map(oe=>oe.printed);return Ne.length>0&&s(Ne).needsParens?["(",...Pe,")"]:Pe}function ue(Ne){return Ne.length===0?"":I(N([S,F(S,Ne.map(de))]))}let Fe=V.map(de),z=Fe,U=K?3:2,Z=V.flat(),se=Z.slice(1,-1).some(Ne=>D(Ne.node,E.Leading))||Z.slice(0,-1).some(Ne=>D(Ne.node,E.Trailing))||V[U]&&D(V[U][0].node,E.Leading);if(V.length<=U&&!se)return d(b)?z:N(z);let De=s(V[K?1:0]).node,ge=!i(De)&&J(De),he=[de(V[0]),K?V.slice(1,2).map(de):"",ge?S:"",ue(V.slice(K?2:1))],we=q.map(Ne=>{let{node:Pe}=Ne;return Pe}).filter(i);function ke(){let Ne=s(s(V)).node,Pe=s(Fe);return i(Ne)&&T(Pe)&&we.slice(0,-1).some(oe=>oe.arguments.some(p))}let Re;return se||we.length>2&&we.some(Ne=>!Ne.arguments.every(Pe=>c(Pe,0)))||Fe.slice(0,-1).some(T)||ke()?Re=N(he):Re=[T(z)||ge?$:"",P([z,he])],f("member-chain",Re)}r.exports=x}}),xo=te({"src/language-js/print/call-expression.js"(e,r){"use strict";ne();var{builders:{join:t,group:s}}=qe(),a=qt(),{getCallArguments:n,hasFlowAnnotationComment:u,isCallExpression:i,isMemberish:l,isStringLiteral:p,isTemplateOnItsOwnLine:d,isTestCall:y,iterateCallArgumentsPath:g}=Ke(),c=Dd(),D=Ao(),{printOptionalToken:E,printFunctionTypeParameters:_}=ct();function w(S,N,I){let P=S.getValue(),$=S.getParentNode(),f=P.type==="NewExpression",T=P.type==="ImportExpression",m=E(S),v=n(P);if(v.length>0&&(!T&&!f&&F(P,$)||v.length===1&&d(v[0],N.originalText)||!f&&y(P,$))){let C=[];return g(S,()=>{C.push(I())}),[f?"new ":"",I("callee"),m,_(S,N,I),"(",t(", ",C),")"]}let o=(N.parser==="babel"||N.parser==="babel-flow")&&P.callee&&P.callee.type==="Identifier"&&u(P.callee.trailingComments);if(o&&(P.callee.trailingComments[0].printed=!0),!T&&!f&&l(P.callee)&&!S.call(C=>a(C,N),"callee"))return c(S,N,I);let h=[f?"new ":"",T?"import":I("callee"),m,o?`/*:: ${P.callee.trailingComments[0].value.slice(2).trim()} */`:"",_(S,N,I),D(S,N,I)];return T||i(P.callee)?s(h):h}function F(S,N){if(S.callee.type!=="Identifier")return!1;if(S.callee.name==="require")return!0;if(S.callee.name==="define"){let I=n(S);return N.type==="ExpressionStatement"&&(I.length===1||I.length===2&&I[0].type==="ArrayExpression"||I.length===3&&p(I[0])&&I[1].type==="ArrayExpression")}return!1}r.exports={printCallExpression:w}}}),tr=te({"src/language-js/print/assignment.js"(e,r){"use strict";ne();var{isNonEmptyArray:t,getStringWidth:s}=Ue(),{builders:{line:a,group:n,indent:u,indentIfBreak:i,lineSuffixBoundary:l},utils:{cleanDoc:p,willBreak:d,canBreak:y}}=qe(),{hasLeadingOwnLineComment:g,isBinaryish:c,isStringLiteral:D,isLiteral:E,isNumericLiteral:_,isCallExpression:w,isMemberExpression:F,getCallArguments:S,rawText:N,hasComment:I,isSignedNumericLiteral:P,isObjectProperty:$}=Ke(),{shouldInlineLogicalExpression:f}=ru(),{printCallExpression:T}=xo();function m(W,K,de,ue,Fe,z){let U=h(W,K,de,ue,z),Z=de(z,{assignmentLayout:U});switch(U){case"break-after-operator":return n([n(ue),Fe,n(u([a,Z]))]);case"never-break-after-operator":return n([n(ue),Fe," ",Z]);case"fluid":{let se=Symbol("assignment");return n([n(ue),Fe,n(u(a),{id:se}),l,i(Z,{groupId:se})])}case"break-lhs":return n([ue,Fe," ",n(Z)]);case"chain":return[n(ue),Fe,a,Z];case"chain-tail":return[n(ue),Fe,u([a,Z])];case"chain-tail-arrow-chain":return[n(ue),Fe,Z];case"only-left":return ue}}function v(W,K,de){let ue=W.getValue();return m(W,K,de,de("left"),[" ",ue.operator],"right")}function o(W,K,de){return m(W,K,de,de("id")," =","init")}function h(W,K,de,ue,Fe){let z=W.getValue(),U=z[Fe];if(!U)return"only-left";let Z=!b(U);if(W.match(b,B,he=>!Z||he.type!=="ExpressionStatement"&&he.type!=="VariableDeclaration"))return Z?U.type==="ArrowFunctionExpression"&&U.body.type==="ArrowFunctionExpression"?"chain-tail-arrow-chain":"chain-tail":"chain";if(!Z&&b(U.right)||g(K.originalText,U))return"break-after-operator";if(U.type==="CallExpression"&&U.callee.name==="require"||K.parser==="json5"||K.parser==="json")return"never-break-after-operator";if(x(z)||k(z)||q(z)||J(z)&&y(ue))return"break-lhs";let ge=ie(z,ue,K);return W.call(()=>C(W,K,de,ge),Fe)?"break-after-operator":ge||U.type==="TemplateLiteral"||U.type==="TaggedTemplateExpression"||U.type==="BooleanLiteral"||_(U)||U.type==="ClassExpression"?"never-break-after-operator":"fluid"}function C(W,K,de,ue){let Fe=W.getValue();if(c(Fe)&&!f(Fe))return!0;switch(Fe.type){case"StringLiteralTypeAnnotation":case"SequenceExpression":return!0;case"ConditionalExpression":{let{test:Z}=Fe;return c(Z)&&!f(Z)}case"ClassExpression":return t(Fe.decorators)}if(ue)return!1;let z=Fe,U=[];for(;;)if(z.type==="UnaryExpression")z=z.argument,U.push("argument");else if(z.type==="TSNonNullExpression")z=z.expression,U.push("expression");else break;return!!(D(z)||W.call(()=>V(W,K,de),...U))}function x(W){if(B(W)){let K=W.left||W.id;return K.type==="ObjectPattern"&&K.properties.length>2&&K.properties.some(de=>$(de)&&(!de.shorthand||de.value&&de.value.type==="AssignmentPattern"))}return!1}function b(W){return W.type==="AssignmentExpression"}function B(W){return b(W)||W.type==="VariableDeclarator"}function k(W){let K=M(W);if(t(K)){let de=W.type==="TSTypeAliasDeclaration"?"constraint":"bound";if(K.length>1&&K.some(ue=>ue[de]||ue.default))return!0}return!1}function M(W){return R(W)&&W.typeParameters&&W.typeParameters.params?W.typeParameters.params:null}function R(W){return W.type==="TSTypeAliasDeclaration"||W.type==="TypeAlias"}function q(W){if(W.type!=="VariableDeclarator")return!1;let{typeAnnotation:K}=W.id;if(!K||!K.typeAnnotation)return!1;let de=L(K.typeAnnotation);return t(de)&&de.length>1&&de.some(ue=>t(L(ue))||ue.type==="TSConditionalType")}function J(W){return W.type==="VariableDeclarator"&&W.init&&W.init.type==="ArrowFunctionExpression"}function L(W){return Q(W)&&W.typeParameters&&W.typeParameters.params?W.typeParameters.params:null}function Q(W){return W.type==="TSTypeReference"||W.type==="GenericTypeAnnotation"}function V(W,K,de){let ue=arguments.length>3&&arguments[3]!==void 0?arguments[3]:!1,Fe=W.getValue(),z=()=>V(W,K,de,!0);if(Fe.type==="TSNonNullExpression")return W.call(z,"expression");if(w(Fe)){if(T(W,K,de).label==="member-chain")return!1;let Z=S(Fe);return!(Z.length===0||Z.length===1&&Y(Z[0],K))||ee(Fe,de)?!1:W.call(z,"callee")}return F(Fe)?W.call(z,"object"):ue&&(Fe.type==="Identifier"||Fe.type==="ThisExpression")}var j=.25;function Y(W,K){let{printWidth:de}=K;if(I(W))return!1;let ue=de*j;if(W.type==="ThisExpression"||W.type==="Identifier"&&W.name.length<=ue||P(W)&&!I(W.argument))return!0;let Fe=W.type==="Literal"&&"regex"in W&&W.regex.pattern||W.type==="RegExpLiteral"&&W.pattern;return Fe?Fe.length<=ue:D(W)?N(W).length<=ue:W.type==="TemplateLiteral"?W.expressions.length===0&&W.quasis[0].value.raw.length<=ue&&!W.quasis[0].value.raw.includes(`
`):E(W)}function ie(W,K,de){if(!$(W))return!1;K=p(K);let ue=3;return typeof K=="string"&&s(K)<de.tabWidth+ue}function ee(W,K){let de=le(W);if(t(de)){if(de.length>1)return!0;if(de.length===1){let Fe=de[0];if(Fe.type==="TSUnionType"||Fe.type==="UnionTypeAnnotation"||Fe.type==="TSIntersectionType"||Fe.type==="IntersectionTypeAnnotation"||Fe.type==="TSTypeLiteral"||Fe.type==="ObjectTypeAnnotation")return!0}let ue=W.typeParameters?"typeParameters":"typeArguments";if(d(K(ue)))return!0}return!1}function le(W){return W.typeParameters&&W.typeParameters.params||W.typeArguments&&W.typeArguments.params}r.exports={printVariableDeclarator:o,printAssignmentExpression:v,printAssignment:m,isArrowFunctionVariableDeclarator:J}}}),Lr=te({"src/language-js/print/function-parameters.js"(e,r){"use strict";ne();var{getNextNonSpaceNonCommentCharacter:t}=Ue(),{printDanglingComments:s}=et(),{builders:{line:a,hardline:n,softline:u,group:i,indent:l,ifBreak:p},utils:{removeLines:d,willBreak:y}}=qe(),{getFunctionParameters:g,iterateFunctionParametersPath:c,isSimpleType:D,isTestCall:E,isTypeAnnotationAFunction:_,isObjectType:w,isObjectTypePropertyAFunction:F,hasRestParameter:S,shouldPrintComma:N,hasComment:I,isNextLineEmpty:P}=Ke(),{locEnd:$}=ut(),{ArgExpansionBailout:f}=Qt(),{printFunctionTypeParameters:T}=ct();function m(C,x,b,B,k){let M=C.getValue(),R=g(M),q=k?T(C,b,x):"";if(R.length===0)return[q,"(",s(C,b,!0,ie=>t(b.originalText,ie,$)===")"),")"];let J=C.getParentNode(),L=E(J),Q=v(M),V=[];if(c(C,(ie,ee)=>{let le=ee===R.length-1;le&&M.rest&&V.push("..."),V.push(x()),!le&&(V.push(","),L||Q?V.push(" "):P(R[ee],b)?V.push(n,n):V.push(a))}),B){if(y(q)||y(V))throw new f;return i([d(q),"(",d(V),")"])}let j=R.every(ie=>!ie.decorators);return Q&&j?[q,"(",...V,")"]:L?[q,"(",...V,")"]:(F(J)||_(J)||J.type==="TypeAlias"||J.type==="UnionTypeAnnotation"||J.type==="TSUnionType"||J.type==="IntersectionTypeAnnotation"||J.type==="FunctionTypeAnnotation"&&J.returnType===M)&&R.length===1&&R[0].name===null&&M.this!==R[0]&&R[0].typeAnnotation&&M.typeParameters===null&&D(R[0].typeAnnotation)&&!M.rest?b.arrowParens==="always"?["(",...V,")"]:V:[q,"(",l([u,...V]),p(!S(M)&&N(b,"all")?",":""),u,")"]}function v(C){if(!C)return!1;let x=g(C);if(x.length!==1)return!1;let[b]=x;return!I(b)&&(b.type==="ObjectPattern"||b.type==="ArrayPattern"||b.type==="Identifier"&&b.typeAnnotation&&(b.typeAnnotation.type==="TypeAnnotation"||b.typeAnnotation.type==="TSTypeAnnotation")&&w(b.typeAnnotation.typeAnnotation)||b.type==="FunctionTypeParam"&&w(b.typeAnnotation)||b.type==="AssignmentPattern"&&(b.left.type==="ObjectPattern"||b.left.type==="ArrayPattern")&&(b.right.type==="Identifier"||b.right.type==="ObjectExpression"&&b.right.properties.length===0||b.right.type==="ArrayExpression"&&b.right.elements.length===0))}function o(C){let x;return C.returnType?(x=C.returnType,x.typeAnnotation&&(x=x.typeAnnotation)):C.typeAnnotation&&(x=C.typeAnnotation),x}function h(C,x){let b=o(C);if(!b)return!1;let B=C.typeParameters&&C.typeParameters.params;if(B){if(B.length>1)return!1;if(B.length===1){let k=B[0];if(k.constraint||k.default)return!1}}return g(C).length===1&&(w(b)||y(x))}r.exports={printFunctionParameters:m,shouldHugFunctionParameters:v,shouldGroupFunctionParameters:h}}}),Or=te({"src/language-js/print/type-annotation.js"(e,r){"use strict";ne();var{printComments:t,printDanglingComments:s}=et(),{isNonEmptyArray:a}=Ue(),{builders:{group:n,join:u,line:i,softline:l,indent:p,align:d,ifBreak:y}}=qe(),g=qt(),{locStart:c}=ut(),{isSimpleType:D,isObjectType:E,hasLeadingOwnLineComment:_,isObjectTypePropertyAFunction:w,shouldPrintComma:F}=Ke(),{printAssignment:S}=tr(),{printFunctionParameters:N,shouldGroupFunctionParameters:I}=Lr(),{printArrayItems:P}=er();function $(b){if(D(b)||E(b))return!0;if(b.type==="UnionTypeAnnotation"||b.type==="TSUnionType"){let B=b.types.filter(M=>M.type==="VoidTypeAnnotation"||M.type==="TSVoidKeyword"||M.type==="NullLiteralTypeAnnotation"||M.type==="TSNullKeyword").length,k=b.types.some(M=>M.type==="ObjectTypeAnnotation"||M.type==="TSTypeLiteral"||M.type==="GenericTypeAnnotation"||M.type==="TSTypeReference");if(b.types.length-1===B&&k)return!0}return!1}function f(b,B,k){let M=B.semi?";":"",R=b.getValue(),q=[];return q.push("opaque type ",k("id"),k("typeParameters")),R.supertype&&q.push(": ",k("supertype")),R.impltype&&q.push(" = ",k("impltype")),q.push(M),q}function T(b,B,k){let M=B.semi?";":"",R=b.getValue(),q=[];R.declare&&q.push("declare "),q.push("type ",k("id"),k("typeParameters"));let J=R.type==="TSTypeAliasDeclaration"?"typeAnnotation":"right";return[S(b,B,k,q," =",J),M]}function m(b,B,k){let M=b.getValue(),R=b.map(k,"types"),q=[],J=!1;for(let L=0;L<R.length;++L)L===0?q.push(R[L]):E(M.types[L-1])&&E(M.types[L])?q.push([" & ",J?p(R[L]):R[L]]):!E(M.types[L-1])&&!E(M.types[L])?q.push(p([" &",i,R[L]])):(L>1&&(J=!0),q.push(" & ",L>1?p(R[L]):R[L]));return n(q)}function v(b,B,k){let M=b.getValue(),R=b.getParentNode(),q=R.type!=="TypeParameterInstantiation"&&R.type!=="TSTypeParameterInstantiation"&&R.type!=="GenericTypeAnnotation"&&R.type!=="TSTypeReference"&&R.type!=="TSTypeAssertion"&&R.type!=="TupleTypeAnnotation"&&R.type!=="TSTupleType"&&!(R.type==="FunctionTypeParam"&&!R.name&&b.getParentNode(1).this!==R)&&!((R.type==="TypeAlias"||R.type==="VariableDeclarator"||R.type==="TSTypeAliasDeclaration")&&_(B.originalText,M)),J=$(M),L=b.map(j=>{let Y=k();return J||(Y=d(2,Y)),t(j,Y,B)},"types");if(J)return u(" | ",L);let Q=q&&!_(B.originalText,M),V=[y([Q?i:"","| "]),u([i,"| "],L)];return g(b,B)?n([p(V),l]):R.type==="TupleTypeAnnotation"&&R.types.length>1||R.type==="TSTupleType"&&R.elementTypes.length>1?n([p([y(["(",l]),V]),l,y(")")]):n(q?p(V):V)}function o(b,B,k){let M=b.getValue(),R=[],q=b.getParentNode(0),J=b.getParentNode(1),L=b.getParentNode(2),Q=M.type==="TSFunctionType"||!((q.type==="ObjectTypeProperty"||q.type==="ObjectTypeInternalSlot")&&!q.variance&&!q.optional&&c(q)===c(M)||q.type==="ObjectTypeCallProperty"||L&&L.type==="DeclareFunction"),V=Q&&(q.type==="TypeAnnotation"||q.type==="TSTypeAnnotation"),j=V&&Q&&(q.type==="TypeAnnotation"||q.type==="TSTypeAnnotation")&&J.type==="ArrowFunctionExpression";w(q)&&(Q=!0,V=!0),j&&R.push("(");let Y=N(b,k,B,!1,!0),ie=M.returnType||M.predicate||M.typeAnnotation?[Q?" => ":": ",k("returnType"),k("predicate"),k("typeAnnotation")]:"",ee=I(M,ie);return R.push(ee?n(Y):Y),ie&&R.push(ie),j&&R.push(")"),n(R)}function h(b,B,k){let M=b.getValue(),R=M.type==="TSTupleType"?"elementTypes":"types",q=M[R],J=a(q),L=J?l:"";return n(["[",p([L,P(b,B,R,k)]),y(J&&F(B,"all")?",":""),s(b,B,!0),L,"]"])}function C(b,B,k){let M=b.getValue(),R=M.type==="OptionalIndexedAccessType"&&M.optional?"?.[":"[";return[k("objectType"),R,k("indexType"),"]"]}function x(b,B,k){let M=b.getValue();return[M.postfix?"":k,B("typeAnnotation"),M.postfix?k:""]}r.exports={printOpaqueType:f,printTypeAlias:T,printIntersectionType:m,printUnionType:v,printFunctionType:o,printTupleType:h,printIndexedAccessType:C,shouldHugType:$,printJSDocType:x}}}),jr=te({"src/language-js/print/type-parameters.js"(e,r){"use strict";ne();var{printDanglingComments:t}=et(),{builders:{join:s,line:a,hardline:n,softline:u,group:i,indent:l,ifBreak:p}}=qe(),{isTestCall:d,hasComment:y,CommentCheckFlags:g,isTSXFile:c,shouldPrintComma:D,getFunctionParameters:E,isObjectType:_}=Ke(),{createGroupIdMapper:w}=Ue(),{shouldHugType:F}=Or(),{isArrowFunctionVariableDeclarator:S}=tr(),N=w("typeParameters");function I(f,T,m,v){let o=f.getValue();if(!o[v])return"";if(!Array.isArray(o[v]))return m(v);let h=f.getNode(2),C=h&&d(h),x=f.match(k=>!(k[v].length===1&&_(k[v][0])),void 0,(k,M)=>M==="typeAnnotation",k=>k.type==="Identifier",S);if(o[v].length===0||!x&&(C||o[v].length===1&&(o[v][0].type==="NullableTypeAnnotation"||F(o[v][0]))))return["<",s(", ",f.map(m,v)),P(f,T),">"];let B=o.type==="TSTypeParameterInstantiation"?"":E(o).length===1&&c(T)&&!o[v][0].constraint&&f.getParentNode().type==="ArrowFunctionExpression"?",":D(T,"all")?p(","):"";return i(["<",l([u,s([",",a],f.map(m,v))]),B,u,">"],{id:N(o)})}function P(f,T){let m=f.getValue();if(!y(m,g.Dangling))return"";let v=!y(m,g.Line),o=t(f,T,v);return v?o:[o,n]}function $(f,T,m){let v=f.getValue(),o=[],h=f.getParentNode();return h.type==="TSMappedType"?(o.push("[",m("name")),v.constraint&&o.push(" in ",m("constraint")),h.nameType&&o.push(" as ",f.callParent(()=>m("nameType"))),o.push("]"),o):(v.variance&&o.push(m("variance")),v.in&&o.push("in "),v.out&&o.push("out "),o.push(m("name")),v.bound&&o.push(": ",m("bound")),v.constraint&&o.push(" extends ",m("constraint")),v.default&&o.push(" = ",m("default")),o)}r.exports={printTypeParameter:$,printTypeParameters:I,getTypeParametersGroupId:N}}}),rr=te({"src/language-js/print/property.js"(e,r){"use strict";ne();var{printComments:t}=et(),{printString:s,printNumber:a}=Ue(),{isNumericLiteral:n,isSimpleNumber:u,isStringLiteral:i,isStringPropSafeToUnquote:l,rawText:p}=Ke(),{printAssignment:d}=tr(),y=new WeakMap;function g(D,E,_){let w=D.getNode();if(w.computed)return["[",_("key"),"]"];let F=D.getParentNode(),{key:S}=w;if(E.quoteProps==="consistent"&&!y.has(F)){let N=(F.properties||F.body||F.members).some(I=>!I.computed&&I.key&&i(I.key)&&!l(I,E));y.set(F,N)}if((S.type==="Identifier"||n(S)&&u(a(p(S)))&&String(S.value)===a(p(S))&&!(E.parser==="typescript"||E.parser==="babel-ts"))&&(E.parser==="json"||E.quoteProps==="consistent"&&y.get(F))){let N=s(JSON.stringify(S.type==="Identifier"?S.name:S.value.toString()),E);return D.call(I=>t(I,N,E),"key")}return l(w,E)&&(E.quoteProps==="as-needed"||E.quoteProps==="consistent"&&!y.get(F))?D.call(N=>t(N,/^\d/.test(S.value)?a(S.value):S.value,E),"key"):_("key")}function c(D,E,_){return D.getValue().shorthand?_("value"):d(D,E,_,g(D,E,_),":","value")}r.exports={printProperty:c,printPropertyKey:g}}}),qr=te({"src/language-js/print/function.js"(e,r){"use strict";ne();var t=Zt(),{printDanglingComments:s,printCommentsSeparately:a}=et(),n=lt(),{getNextNonSpaceNonCommentCharacterIndex:u}=Ue(),{builders:{line:i,softline:l,group:p,indent:d,ifBreak:y,hardline:g,join:c,indentIfBreak:D},utils:{removeLines:E,willBreak:_}}=qe(),{ArgExpansionBailout:w}=Qt(),{getFunctionParameters:F,hasLeadingOwnLineComment:S,isFlowAnnotationComment:N,isJsxNode:I,isTemplateOnItsOwnLine:P,shouldPrintComma:$,startsWithNoLookaheadToken:f,isBinaryish:T,isLineComment:m,hasComment:v,getComments:o,CommentCheckFlags:h,isCallLikeExpression:C,isCallExpression:x,getCallArguments:b,hasNakedLeftSide:B,getLeftSide:k}=Ke(),{locEnd:M}=ut(),{printFunctionParameters:R,shouldGroupFunctionParameters:q}=Lr(),{printPropertyKey:J}=rr(),{printFunctionTypeParameters:L}=ct();function Q(U,Z,se,De){let ge=U.getValue(),he=!1;if((ge.type==="FunctionDeclaration"||ge.type==="FunctionExpression")&&De&&De.expandLastArg){let Pe=U.getParentNode();x(Pe)&&b(Pe).length>1&&(he=!0)}let we=[];ge.type==="TSDeclareFunction"&&ge.declare&&we.push("declare "),ge.async&&we.push("async "),ge.generator?we.push("function* "):we.push("function "),ge.id&&we.push(Z("id"));let ke=R(U,Z,se,he),Re=K(U,Z,se),Ne=q(ge,Re);return we.push(L(U,se,Z),p([Ne?p(ke):ke,Re]),ge.body?" ":"",Z("body")),se.semi&&(ge.declare||!ge.body)&&we.push(";"),we}function V(U,Z,se){let De=U.getNode(),{kind:ge}=De,he=De.value||De,we=[];return!ge||ge==="init"||ge==="method"||ge==="constructor"?he.async&&we.push("async "):(t.ok(ge==="get"||ge==="set"),we.push(ge," ")),he.generator&&we.push("*"),we.push(J(U,Z,se),De.optional||De.key.optional?"?":""),De===he?we.push(j(U,Z,se)):he.type==="FunctionExpression"?we.push(U.call(ke=>j(ke,Z,se),"value")):we.push(se("value")),we}function j(U,Z,se){let De=U.getNode(),ge=R(U,se,Z),he=K(U,se,Z),we=q(De,he),ke=[L(U,Z,se),p([we?p(ge):ge,he])];return De.body?ke.push(" ",se("body")):ke.push(Z.semi?";":""),ke}function Y(U,Z,se,De){let ge=U.getValue(),he=[];if(ge.async&&he.push("async "),W(U,Z))he.push(se(["params",0]));else{let ke=De&&(De.expandLastArg||De.expandFirstArg),Re=K(U,se,Z);if(ke){if(_(Re))throw new w;Re=p(E(Re))}he.push(p([R(U,se,Z,ke,!0),Re]))}let we=s(U,Z,!0,ke=>{let Re=u(Z.originalText,ke,M);return Re!==!1&&Z.originalText.slice(Re,Re+2)==="=>"});return we&&he.push(" ",we),he}function ie(U,Z,se,De,ge,he){let we=U.getName(),ke=U.getParentNode(),Re=C(ke)&&we==="callee",Ne=Boolean(Z&&Z.assignmentLayout),Pe=he.body.type!=="BlockStatement"&&he.body.type!=="ObjectExpression"&&he.body.type!=="SequenceExpression",oe=Re&&Pe||Z&&Z.assignmentLayout==="chain-tail-arrow-chain",H=Symbol("arrow-chain");return he.body.type==="SequenceExpression"&&(ge=p(["(",d([l,ge]),l,")"])),p([p(d([Re||Ne?l:"",p(c([" =>",i],se),{shouldBreak:De})]),{id:H,shouldBreak:oe})," =>",D(Pe?d([i,ge]):[" ",ge],{groupId:H}),Re?y(l,"",{groupId:H}):""])}function ee(U,Z,se,De){let ge=U.getValue(),he=[],we=[],ke=!1;if(function H(){let ce=Y(U,Z,se,De);if(he.length===0)he.push(ce);else{let{leading:X,trailing:pe}=a(U,Z);he.push([X,ce]),we.unshift(pe)}ke=ke||ge.returnType&&F(ge).length>0||ge.typeParameters||F(ge).some(X=>X.type!=="Identifier"),ge.body.type!=="ArrowFunctionExpression"||De&&De.expandLastArg?we.unshift(se("body",De)):(ge=ge.body,U.call(H,"body"))}(),he.length>1)return ie(U,De,he,ke,we,ge);let Re=he;if(Re.push(" =>"),!S(Z.originalText,ge.body)&&(ge.body.type==="ArrayExpression"||ge.body.type==="ObjectExpression"||ge.body.type==="BlockStatement"||I(ge.body)||P(ge.body,Z.originalText)||ge.body.type==="ArrowFunctionExpression"||ge.body.type==="DoExpression"))return p([...Re," ",we]);if(ge.body.type==="SequenceExpression")return p([...Re,p([" (",d([l,we]),l,")"])]);let Ne=(De&&De.expandLastArg||U.getParentNode().type==="JSXExpressionContainer")&&!v(ge),Pe=De&&De.expandLastArg&&$(Z,"all"),oe=ge.body.type==="ConditionalExpression"&&!f(ge.body,H=>H.type==="ObjectExpression");return p([...Re,p([d([i,oe?y("","("):"",we,oe?y("",")"):""]),Ne?[y(Pe?",":""),l]:""])])}function le(U){let Z=F(U);return Z.length===1&&!U.typeParameters&&!v(U,h.Dangling)&&Z[0].type==="Identifier"&&!Z[0].typeAnnotation&&!v(Z[0])&&!Z[0].optional&&!U.predicate&&!U.returnType}function W(U,Z){if(Z.arrowParens==="always")return!1;if(Z.arrowParens==="avoid"){let se=U.getValue();return le(se)}return!1}function K(U,Z,se){let De=U.getValue(),ge=Z("returnType");if(De.returnType&&N(se.originalText,De.returnType))return[" /*: ",ge," */"];let he=[ge];return De.returnType&&De.returnType.typeAnnotation&&he.unshift(": "),De.predicate&&he.push(De.returnType?" ":": ",Z("predicate")),he}function de(U,Z,se){let De=U.getValue(),ge=Z.semi?";":"",he=[];De.argument&&(z(Z,De.argument)?he.push([" (",d([g,se("argument")]),g,")"]):T(De.argument)||De.argument.type==="SequenceExpression"?he.push(p([y(" ("," "),d([l,se("argument")]),l,y(")")])):he.push(" ",se("argument")));let we=o(De),ke=n(we),Re=ke&&m(ke);return Re&&he.push(ge),v(De,h.Dangling)&&he.push(" ",s(U,Z,!0)),Re||he.push(ge),he}function ue(U,Z,se){return["return",de(U,Z,se)]}function Fe(U,Z,se){return["throw",de(U,Z,se)]}function z(U,Z){if(S(U.originalText,Z))return!0;if(B(Z)){let se=Z,De;for(;De=k(se);)if(se=De,S(U.originalText,se))return!0}return!1}r.exports={printFunction:Q,printArrowFunction:ee,printMethod:V,printReturnStatement:ue,printThrowStatement:Fe,printMethodInternal:j,shouldPrintParamsWithoutParens:W}}}),nu=te({"src/language-js/print/decorators.js"(e,r){"use strict";ne();var{isNonEmptyArray:t,hasNewline:s}=Ue(),{builders:{line:a,hardline:n,join:u,breakParent:i,group:l}}=qe(),{locStart:p,locEnd:d}=ut(),{getParentExportDeclaration:y}=Ke();function g(w,F,S){let N=w.getValue();return l([u(a,w.map(S,"decorators")),E(N,F)?n:a])}function c(w,F,S){return[u(n,w.map(S,"declaration","decorators")),n]}function D(w,F,S){let N=w.getValue(),{decorators:I}=N;if(!t(I)||_(w.getParentNode()))return;let P=N.type==="ClassExpression"||N.type==="ClassDeclaration"||E(N,F);return[y(w)?n:P?i:"",u(a,w.map(S,"decorators")),a]}function E(w,F){return w.decorators.some(S=>s(F.originalText,d(S)))}function _(w){if(w.type!=="ExportDefaultDeclaration"&&w.type!=="ExportNamedDeclaration"&&w.type!=="DeclareExportDeclaration")return!1;let F=w.declaration&&w.declaration.decorators;return t(F)&&p(w)===p(F[0])}r.exports={printDecorators:D,printClassMemberDecorators:g,printDecoratorsBeforeExport:c,hasDecoratorsBeforeExport:_}}}),nr=te({"src/language-js/print/class.js"(e,r){"use strict";ne();var{isNonEmptyArray:t,createGroupIdMapper:s}=Ue(),{printComments:a,printDanglingComments:n}=et(),{builders:{join:u,line:i,hardline:l,softline:p,group:d,indent:y,ifBreak:g}}=qe(),{hasComment:c,CommentCheckFlags:D}=Ke(),{getTypeParametersGroupId:E}=jr(),{printMethod:_}=qr(),{printOptionalToken:w,printTypeAnnotation:F,printDefiniteToken:S}=ct(),{printPropertyKey:N}=rr(),{printAssignment:I}=tr(),{printClassMemberDecorators:P}=nu();function $(b,B,k){let M=b.getValue(),R=[];M.declare&&R.push("declare "),M.abstract&&R.push("abstract "),R.push("class");let q=M.id&&c(M.id,D.Trailing)||M.typeParameters&&c(M.typeParameters,D.Trailing)||M.superClass&&c(M.superClass)||t(M.extends)||t(M.mixins)||t(M.implements),J=[],L=[];if(M.id&&J.push(" ",k("id")),J.push(k("typeParameters")),M.superClass){let Q=[h(b,B,k),k("superTypeParameters")],V=b.call(j=>["extends ",a(j,Q,B)],"superClass");q?L.push(i,d(V)):L.push(" ",V)}else L.push(o(b,B,k,"extends"));if(L.push(o(b,B,k,"mixins"),o(b,B,k,"implements")),q){let Q;v(M)?Q=[...J,y(L)]:Q=y([...J,L]),R.push(d(Q,{id:f(M)}))}else R.push(...J,...L);return R.push(" ",k("body")),R}var f=s("heritageGroup");function T(b){return g(l,"",{groupId:f(b)})}function m(b){return["superClass","extends","mixins","implements"].filter(B=>Boolean(b[B])).length>1}function v(b){return b.typeParameters&&!c(b.typeParameters,D.Trailing|D.Line)&&!m(b)}function o(b,B,k,M){let R=b.getValue();if(!t(R[M]))return"";let q=n(b,B,!0,J=>{let{marker:L}=J;return L===M});return[v(R)?g(" ",i,{groupId:E(R.typeParameters)}):i,q,q&&l,M,d(y([i,u([",",i],b.map(k,M))]))]}function h(b,B,k){let M=k("superClass");return b.getParentNode().type==="AssignmentExpression"?d(g(["(",y([p,M]),p,")"],M)):M}function C(b,B,k){let M=b.getValue(),R=[];return t(M.decorators)&&R.push(P(b,B,k)),M.accessibility&&R.push(M.accessibility+" "),M.readonly&&R.push("readonly "),M.declare&&R.push("declare "),M.static&&R.push("static "),(M.type==="TSAbstractMethodDefinition"||M.abstract)&&R.push("abstract "),M.override&&R.push("override "),R.push(_(b,B,k)),R}function x(b,B,k){let M=b.getValue(),R=[],q=B.semi?";":"";return t(M.decorators)&&R.push(P(b,B,k)),M.accessibility&&R.push(M.accessibility+" "),M.declare&&R.push("declare "),M.static&&R.push("static "),(M.type==="TSAbstractPropertyDefinition"||M.type==="TSAbstractAccessorProperty"||M.abstract)&&R.push("abstract "),M.override&&R.push("override "),M.readonly&&R.push("readonly "),M.variance&&R.push(k("variance")),(M.type==="ClassAccessorProperty"||M.type==="AccessorProperty"||M.type==="TSAbstractAccessorProperty")&&R.push("accessor "),R.push(N(b,B,k),w(b),S(b),F(b,B,k)),[I(b,B,k,R," =","value"),q]}r.exports={printClass:$,printClassMethod:C,printClassProperty:x,printHardlineAfterHeritage:T}}}),bo=te({"src/language-js/print/interface.js"(e,r){"use strict";ne();var{isNonEmptyArray:t}=Ue(),{builders:{join:s,line:a,group:n,indent:u,ifBreak:i}}=qe(),{hasComment:l,identity:p,CommentCheckFlags:d}=Ke(),{getTypeParametersGroupId:y}=jr(),{printTypeScriptModifiers:g}=ct();function c(D,E,_){let w=D.getValue(),F=[];w.declare&&F.push("declare "),w.type==="TSInterfaceDeclaration"&&F.push(w.abstract?"abstract ":"",g(D,E,_)),F.push("interface");let S=[],N=[];w.type!=="InterfaceTypeAnnotation"&&S.push(" ",_("id"),_("typeParameters"));let I=w.typeParameters&&!l(w.typeParameters,d.Trailing|d.Line);return t(w.extends)&&N.push(I?i(" ",a,{groupId:y(w.typeParameters)}):a,"extends ",(w.extends.length===1?p:u)(s([",",a],D.map(_,"extends")))),w.id&&l(w.id,d.Trailing)||t(w.extends)?I?F.push(n([...S,u(N)])):F.push(n(u([...S,...N]))):F.push(...S,...N),F.push(" ",_("body")),n(F)}r.exports={printInterface:c}}}),To=te({"src/language-js/print/module.js"(e,r){"use strict";ne();var{isNonEmptyArray:t}=Ue(),{builders:{softline:s,group:a,indent:n,join:u,line:i,ifBreak:l,hardline:p}}=qe(),{printDanglingComments:d}=et(),{hasComment:y,CommentCheckFlags:g,shouldPrintComma:c,needsHardlineAfterDanglingComment:D,isStringLiteral:E,rawText:_}=Ke(),{locStart:w,hasSameLoc:F}=ut(),{hasDecoratorsBeforeExport:S,printDecoratorsBeforeExport:N}=nu();function I(x,b,B){let k=x.getValue(),M=b.semi?";":"",R=[],{importKind:q}=k;return R.push("import"),q&&q!=="value"&&R.push(" ",q),R.push(m(x,b,B),T(x,b,B),o(x,b,B),M),R}function P(x,b,B){let k=x.getValue(),M=[];S(k)&&M.push(N(x,b,B));let{type:R,exportKind:q,declaration:J}=k;return M.push("export"),(k.default||R==="ExportDefaultDeclaration")&&M.push(" default"),y(k,g.Dangling)&&(M.push(" ",d(x,b,!0)),D(k)&&M.push(p)),J?M.push(" ",B("declaration")):M.push(q==="type"?" type":"",m(x,b,B),T(x,b,B),o(x,b,B)),f(k,b)&&M.push(";"),M}function $(x,b,B){let k=x.getValue(),M=b.semi?";":"",R=[],{exportKind:q,exported:J}=k;return R.push("export"),q==="type"&&R.push(" type"),R.push(" *"),J&&R.push(" as ",B("exported")),R.push(T(x,b,B),o(x,b,B),M),R}function f(x,b){if(!b.semi)return!1;let{type:B,declaration:k}=x,M=x.default||B==="ExportDefaultDeclaration";if(!k)return!0;let{type:R}=k;return!!(M&&R!=="ClassDeclaration"&&R!=="FunctionDeclaration"&&R!=="TSInterfaceDeclaration"&&R!=="DeclareClass"&&R!=="DeclareFunction"&&R!=="TSDeclareFunction"&&R!=="EnumDeclaration")}function T(x,b,B){let k=x.getValue();if(!k.source)return"";let M=[];return v(k,b)||M.push(" from"),M.push(" ",B("source")),M}function m(x,b,B){let k=x.getValue();if(v(k,b))return"";let M=[" "];if(t(k.specifiers)){let R=[],q=[];x.each(()=>{let J=x.getValue().type;if(J==="ExportNamespaceSpecifier"||J==="ExportDefaultSpecifier"||J==="ImportNamespaceSpecifier"||J==="ImportDefaultSpecifier")R.push(B());else if(J==="ExportSpecifier"||J==="ImportSpecifier")q.push(B());else throw new Error(`Unknown specifier type ${JSON.stringify(J)}`)},"specifiers"),M.push(u(", ",R)),q.length>0&&(R.length>0&&M.push(", "),q.length>1||R.length>0||k.specifiers.some(L=>y(L))?M.push(a(["{",n([b.bracketSpacing?i:s,u([",",i],q)]),l(c(b)?",":""),b.bracketSpacing?i:s,"}"])):M.push(["{",b.bracketSpacing?" ":"",...q,b.bracketSpacing?" ":"","}"]))}else M.push("{}");return M}function v(x,b){let{type:B,importKind:k,source:M,specifiers:R}=x;return B!=="ImportDeclaration"||t(R)||k==="type"?!1:!/{\s*}/.test(b.originalText.slice(w(x),w(M)))}function o(x,b,B){let k=x.getNode();return t(k.assertions)?[" assert {",b.bracketSpacing?" ":"",u(", ",x.map(B,"assertions")),b.bracketSpacing?" ":"","}"]:""}function h(x,b,B){let k=x.getNode(),{type:M}=k,R=[],q=M==="ImportSpecifier"?k.importKind:k.exportKind;q&&q!=="value"&&R.push(q," ");let J=M.startsWith("Import"),L=J?"imported":"local",Q=J?"local":"exported",V=k[L],j=k[Q],Y="",ie="";return M==="ExportNamespaceSpecifier"||M==="ImportNamespaceSpecifier"?Y="*":V&&(Y=B(L)),j&&!C(k)&&(ie=B(Q)),R.push(Y,Y&&ie?" as ":"",ie),R}function C(x){if(x.type!=="ImportSpecifier"&&x.type!=="ExportSpecifier")return!1;let{local:b,[x.type==="ImportSpecifier"?"imported":"exported"]:B}=x;if(b.type!==B.type||!F(b,B))return!1;if(E(b))return b.value===B.value&&_(b)===_(B);switch(b.type){case"Identifier":return b.name===B.name;default:return!1}}r.exports={printImportDeclaration:I,printExportDeclaration:P,printExportAllDeclaration:$,printModuleSpecifier:h}}}),uu=te({"src/language-js/print/object.js"(e,r){"use strict";ne();var{printDanglingComments:t}=et(),{builders:{line:s,softline:a,group:n,indent:u,ifBreak:i,hardline:l}}=qe(),{getLast:p,hasNewlineInRange:d,hasNewline:y,isNonEmptyArray:g}=Ue(),{shouldPrintComma:c,hasComment:D,getComments:E,CommentCheckFlags:_,isNextLineEmpty:w}=Ke(),{locStart:F,locEnd:S}=ut(),{printOptionalToken:N,printTypeAnnotation:I}=ct(),{shouldHugFunctionParameters:P}=Lr(),{shouldHugType:$}=Or(),{printHardlineAfterHeritage:f}=nr();function T(m,v,o){let h=v.semi?";":"",C=m.getValue(),x;C.type==="TSTypeLiteral"?x="members":C.type==="TSInterfaceBody"?x="body":x="properties";let b=C.type==="ObjectTypeAnnotation",B=[x];b&&B.push("indexers","callProperties","internalSlots");let k=B.map(W=>C[W][0]).sort((W,K)=>F(W)-F(K))[0],M=m.getParentNode(0),R=b&&M&&(M.type==="InterfaceDeclaration"||M.type==="DeclareInterface"||M.type==="DeclareClass")&&m.getName()==="body",q=C.type==="TSInterfaceBody"||R||C.type==="ObjectPattern"&&M.type!=="FunctionDeclaration"&&M.type!=="FunctionExpression"&&M.type!=="ArrowFunctionExpression"&&M.type!=="ObjectMethod"&&M.type!=="ClassMethod"&&M.type!=="ClassPrivateMethod"&&M.type!=="AssignmentPattern"&&M.type!=="CatchClause"&&C.properties.some(W=>W.value&&(W.value.type==="ObjectPattern"||W.value.type==="ArrayPattern"))||C.type!=="ObjectPattern"&&k&&d(v.originalText,F(C),F(k)),J=R?";":C.type==="TSInterfaceBody"||C.type==="TSTypeLiteral"?i(h,";"):",",L=C.type==="RecordExpression"?"#{":C.exact?"{|":"{",Q=C.exact?"|}":"}",V=[];for(let W of B)m.each(K=>{let de=K.getValue();V.push({node:de,printed:o(),loc:F(de)})},W);B.length>1&&V.sort((W,K)=>W.loc-K.loc);let j=[],Y=V.map(W=>{let K=[...j,n(W.printed)];return j=[J,s],(W.node.type==="TSPropertySignature"||W.node.type==="TSMethodSignature"||W.node.type==="TSConstructSignatureDeclaration")&&D(W.node,_.PrettierIgnore)&&j.shift(),w(W.node,v)&&j.push(l),K});if(C.inexact){let W;if(D(C,_.Dangling)){let K=D(C,_.Line);W=[t(m,v,!0),K||y(v.originalText,S(p(E(C))))?l:s,"..."]}else W=["..."];Y.push([...j,...W])}let ie=p(C[x]),ee=!(C.inexact||ie&&ie.type==="RestElement"||ie&&(ie.type==="TSPropertySignature"||ie.type==="TSCallSignatureDeclaration"||ie.type==="TSMethodSignature"||ie.type==="TSConstructSignatureDeclaration")&&D(ie,_.PrettierIgnore)),le;if(Y.length===0){if(!D(C,_.Dangling))return[L,Q,I(m,v,o)];le=n([L,t(m,v),a,Q,N(m),I(m,v,o)])}else le=[R&&g(C.properties)?f(M):"",L,u([v.bracketSpacing?s:a,...Y]),i(ee&&(J!==","||c(v))?J:""),v.bracketSpacing?s:a,Q,N(m),I(m,v,o)];return m.match(W=>W.type==="ObjectPattern"&&!W.decorators,(W,K,de)=>P(W)&&(K==="params"||K==="parameters"||K==="this"||K==="rest")&&de===0)||m.match($,(W,K)=>K==="typeAnnotation",(W,K)=>K==="typeAnnotation",(W,K,de)=>P(W)&&(K==="params"||K==="parameters"||K==="this"||K==="rest")&&de===0)||!q&&m.match(W=>W.type==="ObjectPattern",W=>W.type==="AssignmentExpression"||W.type==="VariableDeclarator")?le:n(le,{shouldBreak:q})}r.exports={printObject:T}}}),md=te({"src/language-js/print/flow.js"(e,r){"use strict";ne();var t=Zt(),{printDanglingComments:s}=et(),{printString:a,printNumber:n}=Ue(),{builders:{hardline:u,softline:i,group:l,indent:p}}=qe(),{getParentExportDeclaration:d,isFunctionNotation:y,isGetterOrSetter:g,rawText:c,shouldPrintComma:D}=Ke(),{locStart:E,locEnd:_}=ut(),{replaceTextEndOfLine:w}=Yt(),{printClass:F}=nr(),{printOpaqueType:S,printTypeAlias:N,printIntersectionType:I,printUnionType:P,printFunctionType:$,printTupleType:f,printIndexedAccessType:T}=Or(),{printInterface:m}=bo(),{printTypeParameter:v,printTypeParameters:o}=jr(),{printExportDeclaration:h,printExportAllDeclaration:C}=To(),{printArrayItems:x}=er(),{printObject:b}=uu(),{printPropertyKey:B}=rr(),{printOptionalToken:k,printTypeAnnotation:M,printRestSpread:R}=ct();function q(L,Q,V){let j=L.getValue(),Y=Q.semi?";":"",ie=[];switch(j.type){case"DeclareClass":return J(L,F(L,Q,V));case"DeclareFunction":return J(L,["function ",V("id"),j.predicate?" ":"",V("predicate"),Y]);case"DeclareModule":return J(L,["module ",V("id")," ",V("body")]);case"DeclareModuleExports":return J(L,["module.exports",": ",V("typeAnnotation"),Y]);case"DeclareVariable":return J(L,["var ",V("id"),Y]);case"DeclareOpaqueType":return J(L,S(L,Q,V));case"DeclareInterface":return J(L,m(L,Q,V));case"DeclareTypeAlias":return J(L,N(L,Q,V));case"DeclareExportDeclaration":return J(L,h(L,Q,V));case"DeclareExportAllDeclaration":return J(L,C(L,Q,V));case"OpaqueType":return S(L,Q,V);case"TypeAlias":return N(L,Q,V);case"IntersectionTypeAnnotation":return I(L,Q,V);case"UnionTypeAnnotation":return P(L,Q,V);case"FunctionTypeAnnotation":return $(L,Q,V);case"TupleTypeAnnotation":return f(L,Q,V);case"GenericTypeAnnotation":return[V("id"),o(L,Q,V,"typeParameters")];case"IndexedAccessType":case"OptionalIndexedAccessType":return T(L,Q,V);case"TypeAnnotation":return V("typeAnnotation");case"TypeParameter":return v(L,Q,V);case"TypeofTypeAnnotation":return["typeof ",V("argument")];case"ExistsTypeAnnotation":return"*";case"EmptyTypeAnnotation":return"empty";case"MixedTypeAnnotation":return"mixed";case"ArrayTypeAnnotation":return[V("elementType"),"[]"];case"BooleanLiteralTypeAnnotation":return String(j.value);case"EnumDeclaration":return["enum ",V("id")," ",V("body")];case"EnumBooleanBody":case"EnumNumberBody":case"EnumStringBody":case"EnumSymbolBody":{if(j.type==="EnumSymbolBody"||j.explicitType){let ee=null;switch(j.type){case"EnumBooleanBody":ee="boolean";break;case"EnumNumberBody":ee="number";break;case"EnumStringBody":ee="string";break;case"EnumSymbolBody":ee="symbol";break}ie.push("of ",ee," ")}if(j.members.length===0&&!j.hasUnknownMembers)ie.push(l(["{",s(L,Q),i,"}"]));else{let ee=j.members.length>0?[u,x(L,Q,"members",V),j.hasUnknownMembers||D(Q)?",":""]:[];ie.push(l(["{",p([...ee,...j.hasUnknownMembers?[u,"..."]:[]]),s(L,Q,!0),u,"}"]))}return ie}case"EnumBooleanMember":case"EnumNumberMember":case"EnumStringMember":return[V("id")," = ",typeof j.init=="object"?V("init"):String(j.init)];case"EnumDefaultedMember":return V("id");case"FunctionTypeParam":{let ee=j.name?V("name"):L.getParentNode().this===j?"this":"";return[ee,k(L),ee?": ":"",V("typeAnnotation")]}case"InterfaceDeclaration":case"InterfaceTypeAnnotation":return m(L,Q,V);case"ClassImplements":case"InterfaceExtends":return[V("id"),V("typeParameters")];case"NullableTypeAnnotation":return["?",V("typeAnnotation")];case"Variance":{let{kind:ee}=j;return t.ok(ee==="plus"||ee==="minus"),ee==="plus"?"+":"-"}case"ObjectTypeCallProperty":return j.static&&ie.push("static "),ie.push(V("value")),ie;case"ObjectTypeIndexer":return[j.static?"static ":"",j.variance?V("variance"):"","[",V("id"),j.id?": ":"",V("key"),"]: ",V("value")];case"ObjectTypeProperty":{let ee="";return j.proto?ee="proto ":j.static&&(ee="static "),[ee,g(j)?j.kind+" ":"",j.variance?V("variance"):"",B(L,Q,V),k(L),y(j)?"":": ",V("value")]}case"ObjectTypeAnnotation":return b(L,Q,V);case"ObjectTypeInternalSlot":return[j.static?"static ":"","[[",V("id"),"]]",k(L),j.method?"":": ",V("value")];case"ObjectTypeSpreadProperty":return R(L,Q,V);case"QualifiedTypeofIdentifier":case"QualifiedTypeIdentifier":return[V("qualification"),".",V("id")];case"StringLiteralTypeAnnotation":return w(a(c(j),Q));case"NumberLiteralTypeAnnotation":t.strictEqual(typeof j.value,"number");case"BigIntLiteralTypeAnnotation":return j.extra?n(j.extra.raw):n(j.raw);case"TypeCastExpression":return["(",V("expression"),M(L,Q,V),")"];case"TypeParameterDeclaration":case"TypeParameterInstantiation":{let ee=o(L,Q,V,"params");if(Q.parser==="flow"){let le=E(j),W=_(j),K=Q.originalText.lastIndexOf("/*",le),de=Q.originalText.indexOf("*/",W);if(K!==-1&&de!==-1){let ue=Q.originalText.slice(K+2,de).trim();if(ue.startsWith("::")&&!ue.includes("/*")&&!ue.includes("*/"))return["/*:: ",ee," */"]}}return ee}case"InferredPredicate":return"%checks";case"DeclaredPredicate":return["%checks(",V("value"),")"];case"AnyTypeAnnotation":return"any";case"BooleanTypeAnnotation":return"boolean";case"BigIntTypeAnnotation":return"bigint";case"NullLiteralTypeAnnotation":return"null";case"NumberTypeAnnotation":return"number";case"SymbolTypeAnnotation":return"symbol";case"StringTypeAnnotation":return"string";case"VoidTypeAnnotation":return"void";case"ThisTypeAnnotation":return"this";case"Node":case"Printable":case"SourceLocation":case"Position":case"Statement":case"Function":case"Pattern":case"Expression":case"Declaration":case"Specifier":case"NamedSpecifier":case"Comment":case"MemberTypeAnnotation":case"Type":throw new Error("unprintable type: "+JSON.stringify(j.type))}}function J(L,Q){let V=d(L);return V?(t.strictEqual(V.type,"DeclareExportDeclaration"),Q):["declare ",Q]}r.exports={printFlow:q}}}),dd=te({"src/language-js/utils/is-ts-keyword-type.js"(e,r){"use strict";ne();function t(s){let{type:a}=s;return a.startsWith("TS")&&a.endsWith("Keyword")}r.exports=t}}),Bo=te({"src/language-js/print/ternary.js"(e,r){"use strict";ne();var{hasNewlineInRange:t}=Ue(),{isJsxNode:s,getComments:a,isCallExpression:n,isMemberExpression:u,isTSTypeExpression:i}=Ke(),{locStart:l,locEnd:p}=ut(),d=Ot(),{builders:{line:y,softline:g,group:c,indent:D,align:E,ifBreak:_,dedent:w,breakParent:F}}=qe();function S(f){let T=[f];for(let m=0;m<T.length;m++){let v=T[m];for(let o of["test","consequent","alternate"]){let h=v[o];if(s(h))return!0;h.type==="ConditionalExpression"&&T.push(h)}}return!1}function N(f,T,m){let v=f.getValue(),o=v.type==="ConditionalExpression",h=o?"alternate":"falseType",C=f.getParentNode(),x=o?m("test"):[m("checkType")," ","extends"," ",m("extendsType")];return C.type===v.type&&C[h]===v?E(2,x):x}var I=new Map([["AssignmentExpression","right"],["VariableDeclarator","init"],["ReturnStatement","argument"],["ThrowStatement","argument"],["UnaryExpression","argument"],["YieldExpression","argument"]]);function P(f){let T=f.getValue();if(T.type!=="ConditionalExpression")return!1;let m,v=T;for(let o=0;!m;o++){let h=f.getParentNode(o);if(n(h)&&h.callee===v||u(h)&&h.object===v||h.type==="TSNonNullExpression"&&h.expression===v){v=h;continue}h.type==="NewExpression"&&h.callee===v||i(h)&&h.expression===v?(m=f.getParentNode(o+1),v=h):m=h}return v===T?!1:m[I.get(m.type)]===v}function $(f,T,m){let v=f.getValue(),o=v.type==="ConditionalExpression",h=o?"consequent":"trueType",C=o?"alternate":"falseType",x=o?["test"]:["checkType","extendsType"],b=v[h],B=v[C],k=[],M=!1,R=f.getParentNode(),q=R.type===v.type&&x.some(ue=>R[ue]===v),J=R.type===v.type&&!q,L,Q,V=0;do Q=L||v,L=f.getParentNode(V),V++;while(L&&L.type===v.type&&x.every(ue=>L[ue]!==Q));let j=L||R,Y=Q;if(o&&(s(v[x[0]])||s(b)||s(B)||S(Y))){M=!0,J=!0;let ue=z=>[_("("),D([g,z]),g,_(")")],Fe=z=>z.type==="NullLiteral"||z.type==="Literal"&&z.value===null||z.type==="Identifier"&&z.name==="undefined";k.push(" ? ",Fe(b)?m(h):ue(m(h))," : ",B.type===v.type||Fe(B)?m(C):ue(m(C)))}else{let ue=[y,"? ",b.type===v.type?_("","("):"",E(2,m(h)),b.type===v.type?_("",")"):"",y,": ",B.type===v.type?m(C):E(2,m(C))];k.push(R.type!==v.type||R[C]===v||q?ue:T.useTabs?w(D(ue)):E(Math.max(0,T.tabWidth-2),ue))}let ee=[...x.map(ue=>a(v[ue])),a(b),a(B)].flat().some(ue=>d(ue)&&t(T.originalText,l(ue),p(ue))),le=ue=>R===j?c(ue,{shouldBreak:ee}):ee?[ue,F]:ue,W=!M&&(u(R)||R.type==="NGPipeExpression"&&R.left===v)&&!R.computed,K=P(f),de=le([N(f,T,m),J?k:D(k),o&&W&&!K?g:""]);return q||K?c([D([g,de]),g]):de}r.exports={printTernary:$}}}),No=te({"src/language-js/print/statement.js"(e,r){"use strict";ne();var{builders:{hardline:t}}=qe(),s=qt(),{getLeftSidePathName:a,hasNakedLeftSide:n,isJsxNode:u,isTheOnlyJsxElementInMarkdown:i,hasComment:l,CommentCheckFlags:p,isNextLineEmpty:d}=Ke(),{shouldPrintParamsWithoutParens:y}=qr();function g(N,I,P,$){let f=N.getValue(),T=[],m=f.type==="ClassBody",v=c(f[$]);return N.each((o,h,C)=>{let x=o.getValue();if(x.type==="EmptyStatement")return;let b=P();!I.semi&&!m&&!i(I,o)&&D(o,I)?l(x,p.Leading)?T.push(P([],{needsSemi:!0})):T.push(";",b):T.push(b),!I.semi&&m&&F(x)&&S(x,C[h+1])&&T.push(";"),x!==v&&(T.push(t),d(x,I)&&T.push(t))},$),T}function c(N){for(let I=N.length-1;I>=0;I--){let P=N[I];if(P.type!=="EmptyStatement")return P}}function D(N,I){return N.getNode().type!=="ExpressionStatement"?!1:N.call($=>E($,I),"expression")}function E(N,I){let P=N.getValue();switch(P.type){case"ParenthesizedExpression":case"TypeCastExpression":case"ArrayExpression":case"ArrayPattern":case"TemplateLiteral":case"TemplateElement":case"RegExpLiteral":return!0;case"ArrowFunctionExpression":{if(!y(N,I))return!0;break}case"UnaryExpression":{let{prefix:$,operator:f}=P;if($&&(f==="+"||f==="-"))return!0;break}case"BindExpression":{if(!P.object)return!0;break}case"Literal":{if(P.regex)return!0;break}default:if(u(P))return!0}return s(N,I)?!0:n(P)?N.call($=>E($,I),...a(N,P)):!1}function _(N,I,P){return g(N,I,P,"body")}function w(N,I,P){return g(N,I,P,"consequent")}var F=N=>{let{type:I}=N;return I==="ClassProperty"||I==="PropertyDefinition"||I==="ClassPrivateProperty"||I==="ClassAccessorProperty"||I==="AccessorProperty"||I==="TSAbstractPropertyDefinition"||I==="TSAbstractAccessorProperty"};function S(N,I){let{type:P,name:$}=N.key;if(!N.computed&&P==="Identifier"&&($==="static"||$==="get"||$==="set"||$==="accessor")&&!N.value&&!N.typeAnnotation)return!0;if(!I||I.static||I.accessibility)return!1;if(!I.computed){let f=I.key&&I.key.name;if(f==="in"||f==="instanceof")return!0}if(F(I)&&I.variance&&!I.static&&!I.declare)return!0;switch(I.type){case"ClassProperty":case"PropertyDefinition":case"TSAbstractPropertyDefinition":return I.computed;case"MethodDefinition":case"TSAbstractMethodDefinition":case"ClassMethod":case"ClassPrivateMethod":{if((I.value?I.value.async:I.async)||I.kind==="get"||I.kind==="set")return!1;let T=I.value?I.value.generator:I.generator;return!!(I.computed||T)}case"TSIndexSignature":return!0}return!1}r.exports={printBody:_,printSwitchCaseConsequent:w}}}),wo=te({"src/language-js/print/block.js"(e,r){"use strict";ne();var{printDanglingComments:t}=et(),{isNonEmptyArray:s}=Ue(),{builders:{hardline:a,indent:n}}=qe(),{hasComment:u,CommentCheckFlags:i,isNextLineEmpty:l}=Ke(),{printHardlineAfterHeritage:p}=nr(),{printBody:d}=No();function y(c,D,E){let _=c.getValue(),w=[];if(_.type==="StaticBlock"&&w.push("static "),_.type==="ClassBody"&&s(_.body)){let S=c.getParentNode();w.push(p(S))}w.push("{");let F=g(c,D,E);if(F)w.push(n([a,F]),a);else{let S=c.getParentNode(),N=c.getParentNode(1);S.type==="ArrowFunctionExpression"||S.type==="FunctionExpression"||S.type==="FunctionDeclaration"||S.type==="ObjectMethod"||S.type==="ClassMethod"||S.type==="ClassPrivateMethod"||S.type==="ForStatement"||S.type==="WhileStatement"||S.type==="DoWhileStatement"||S.type==="DoExpression"||S.type==="CatchClause"&&!N.finalizer||S.type==="TSModuleDeclaration"||S.type==="TSDeclareFunction"||_.type==="StaticBlock"||_.type==="ClassBody"||w.push(a)}return w.push("}"),w}function g(c,D,E){let _=c.getValue(),w=s(_.directives),F=_.body.some(I=>I.type!=="EmptyStatement"),S=u(_,i.Dangling);if(!w&&!F&&!S)return"";let N=[];if(w&&c.each((I,P,$)=>{N.push(E()),(P<$.length-1||F||S)&&(N.push(a),l(I.getValue(),D)&&N.push(a))},"directives"),F&&N.push(d(c,D,E)),S&&N.push(t(c,D,!0)),_.type==="Program"){let I=c.getParentNode();(!I||I.type!=="ModuleExpression")&&N.push(a)}return N}r.exports={printBlock:y,printBlockBody:g}}}),gd=te({"src/language-js/print/typescript.js"(e,r){"use strict";ne();var{printDanglingComments:t}=et(),{hasNewlineInRange:s}=Ue(),{builders:{join:a,line:n,hardline:u,softline:i,group:l,indent:p,conditionalGroup:d,ifBreak:y}}=qe(),{isStringLiteral:g,getTypeScriptMappedTypeModifier:c,shouldPrintComma:D,isCallExpression:E,isMemberExpression:_}=Ke(),w=dd(),{locStart:F,locEnd:S}=ut(),{printOptionalToken:N,printTypeScriptModifiers:I}=ct(),{printTernary:P}=Bo(),{printFunctionParameters:$,shouldGroupFunctionParameters:f}=Lr(),{printTemplateLiteral:T}=jt(),{printArrayItems:m}=er(),{printObject:v}=uu(),{printClassProperty:o,printClassMethod:h}=nr(),{printTypeParameter:C,printTypeParameters:x}=jr(),{printPropertyKey:b}=rr(),{printFunction:B,printMethodInternal:k}=qr(),{printInterface:M}=bo(),{printBlock:R}=wo(),{printTypeAlias:q,printIntersectionType:J,printUnionType:L,printFunctionType:Q,printTupleType:V,printIndexedAccessType:j,printJSDocType:Y}=Or();function ie(ee,le,W){let K=ee.getValue();if(!K.type.startsWith("TS"))return;if(w(K))return K.type.slice(2,-7).toLowerCase();let de=le.semi?";":"",ue=[];switch(K.type){case"TSThisType":return"this";case"TSTypeAssertion":{let Fe=!(K.expression.type==="ArrayExpression"||K.expression.type==="ObjectExpression"),z=l(["<",p([i,W("typeAnnotation")]),i,">"]),U=[y("("),p([i,W("expression")]),i,y(")")];return Fe?d([[z,W("expression")],[z,l(U,{shouldBreak:!0})],[z,W("expression")]]):l([z,W("expression")])}case"TSDeclareFunction":return B(ee,W,le);case"TSExportAssignment":return["export = ",W("expression"),de];case"TSModuleBlock":return R(ee,le,W);case"TSInterfaceBody":case"TSTypeLiteral":return v(ee,le,W);case"TSTypeAliasDeclaration":return q(ee,le,W);case"TSQualifiedName":return a(".",[W("left"),W("right")]);case"TSAbstractMethodDefinition":case"TSDeclareMethod":return h(ee,le,W);case"TSAbstractAccessorProperty":case"TSAbstractPropertyDefinition":return o(ee,le,W);case"TSInterfaceHeritage":case"TSExpressionWithTypeArguments":return ue.push(W("expression")),K.typeParameters&&ue.push(W("typeParameters")),ue;case"TSTemplateLiteralType":return T(ee,W,le);case"TSNamedTupleMember":return[W("label"),K.optional?"?":"",": ",W("elementType")];case"TSRestType":return["...",W("typeAnnotation")];case"TSOptionalType":return[W("typeAnnotation"),"?"];case"TSInterfaceDeclaration":return M(ee,le,W);case"TSClassImplements":return[W("expression"),W("typeParameters")];case"TSTypeParameterDeclaration":case"TSTypeParameterInstantiation":return x(ee,le,W,"params");case"TSTypeParameter":return C(ee,le,W);case"TSSatisfiesExpression":case"TSAsExpression":{let Fe=K.type==="TSAsExpression"?"as":"satisfies";ue.push(W("expression"),` ${Fe} `,W("typeAnnotation"));let z=ee.getParentNode();return E(z)&&z.callee===K||_(z)&&z.object===K?l([p([i,...ue]),i]):ue}case"TSArrayType":return[W("elementType"),"[]"];case"TSPropertySignature":return K.readonly&&ue.push("readonly "),ue.push(b(ee,le,W),N(ee)),K.typeAnnotation&&ue.push(": ",W("typeAnnotation")),K.initializer&&ue.push(" = ",W("initializer")),ue;case"TSParameterProperty":return K.accessibility&&ue.push(K.accessibility+" "),K.export&&ue.push("export "),K.static&&ue.push("static "),K.override&&ue.push("override "),K.readonly&&ue.push("readonly "),ue.push(W("parameter")),ue;case"TSTypeQuery":return["typeof ",W("exprName"),W("typeParameters")];case"TSIndexSignature":{let Fe=ee.getParentNode(),z=K.parameters.length>1?y(D(le)?",":""):"",U=l([p([i,a([", ",i],ee.map(W,"parameters"))]),z,i]);return[K.export?"export ":"",K.accessibility?[K.accessibility," "]:"",K.static?"static ":"",K.readonly?"readonly ":"",K.declare?"declare ":"","[",K.parameters?U:"",K.typeAnnotation?"]: ":"]",K.typeAnnotation?W("typeAnnotation"):"",Fe.type==="ClassBody"?de:""]}case"TSTypePredicate":return[K.asserts?"asserts ":"",W("parameterName"),K.typeAnnotation?[" is ",W("typeAnnotation")]:""];case"TSNonNullExpression":return[W("expression"),"!"];case"TSImportType":return[K.isTypeOf?"typeof ":"","import(",W(K.parameter?"parameter":"argument"),")",K.qualifier?[".",W("qualifier")]:"",x(ee,le,W,"typeParameters")];case"TSLiteralType":return W("literal");case"TSIndexedAccessType":return j(ee,le,W);case"TSConstructSignatureDeclaration":case"TSCallSignatureDeclaration":case"TSConstructorType":{if(K.type==="TSConstructorType"&&K.abstract&&ue.push("abstract "),K.type!=="TSCallSignatureDeclaration"&&ue.push("new "),ue.push(l($(ee,W,le,!1,!0))),K.returnType||K.typeAnnotation){let Fe=K.type==="TSConstructorType";ue.push(Fe?" => ":": ",W("returnType"),W("typeAnnotation"))}return ue}case"TSTypeOperator":return[K.operator," ",W("typeAnnotation")];case"TSMappedType":{let Fe=s(le.originalText,F(K),S(K));return l(["{",p([le.bracketSpacing?n:i,K.readonly?[c(K.readonly,"readonly")," "]:"",I(ee,le,W),W("typeParameter"),K.optional?c(K.optional,"?"):"",K.typeAnnotation?": ":"",W("typeAnnotation"),y(de)]),t(ee,le,!0),le.bracketSpacing?n:i,"}"],{shouldBreak:Fe})}case"TSMethodSignature":{let Fe=K.kind&&K.kind!=="method"?`${K.kind} `:"";ue.push(K.accessibility?[K.accessibility," "]:"",Fe,K.export?"export ":"",K.static?"static ":"",K.readonly?"readonly ":"",K.abstract?"abstract ":"",K.declare?"declare ":"",K.computed?"[":"",W("key"),K.computed?"]":"",N(ee));let z=$(ee,W,le,!1,!0),U=K.returnType?"returnType":"typeAnnotation",Z=K[U],se=Z?W(U):"",De=f(K,se);return ue.push(De?l(z):z),Z&&ue.push(": ",l(se)),l(ue)}case"TSNamespaceExportDeclaration":return ue.push("export as namespace ",W("id")),le.semi&&ue.push(";"),l(ue);case"TSEnumDeclaration":return K.declare&&ue.push("declare "),K.modifiers&&ue.push(I(ee,le,W)),K.const&&ue.push("const "),ue.push("enum ",W("id")," "),K.members.length===0?ue.push(l(["{",t(ee,le),i,"}"])):ue.push(l(["{",p([u,m(ee,le,"members",W),D(le,"es5")?",":""]),t(ee,le,!0),u,"}"])),ue;case"TSEnumMember":return K.computed?ue.push("[",W("id"),"]"):ue.push(W("id")),K.initializer&&ue.push(" = ",W("initializer")),ue;case"TSImportEqualsDeclaration":return K.isExport&&ue.push("export "),ue.push("import "),K.importKind&&K.importKind!=="value"&&ue.push(K.importKind," "),ue.push(W("id")," = ",W("moduleReference")),le.semi&&ue.push(";"),l(ue);case"TSExternalModuleReference":return["require(",W("expression"),")"];case"TSModuleDeclaration":{let Fe=ee.getParentNode(),z=g(K.id),U=Fe.type==="TSModuleDeclaration",Z=K.body&&K.body.type==="TSModuleDeclaration";if(U)ue.push(".");else{K.declare&&ue.push("declare "),ue.push(I(ee,le,W));let se=le.originalText.slice(F(K),F(K.id));K.id.type==="Identifier"&&K.id.name==="global"&&!/namespace|module/.test(se)||ue.push(z||/(?:^|\s)module(?:\s|$)/.test(se)?"module ":"namespace ")}return ue.push(W("id")),Z?ue.push(W("body")):K.body?ue.push(" ",l(W("body"))):ue.push(de),ue}case"TSConditionalType":return P(ee,le,W);case"TSInferType":return["infer"," ",W("typeParameter")];case"TSIntersectionType":return J(ee,le,W);case"TSUnionType":return L(ee,le,W);case"TSFunctionType":return Q(ee,le,W);case"TSTupleType":return V(ee,le,W);case"TSTypeReference":return[W("typeName"),x(ee,le,W,"typeParameters")];case"TSTypeAnnotation":return W("typeAnnotation");case"TSEmptyBodyFunctionExpression":return k(ee,le,W);case"TSJSDocAllType":return"*";case"TSJSDocUnknownType":return"?";case"TSJSDocNullableType":return Y(ee,W,"?");case"TSJSDocNonNullableType":return Y(ee,W,"!");case"TSInstantiationExpression":return[W("expression"),W("typeParameters")];default:throw new Error(`Unknown TypeScript node type: ${JSON.stringify(K.type)}.`)}}r.exports={printTypescript:ie}}}),yd=te({"src/language-js/print/comment.js"(e,r){"use strict";ne();var{hasNewline:t}=Ue(),{builders:{join:s,hardline:a},utils:{replaceTextEndOfLine:n}}=qe(),{isLineComment:u}=Ke(),{locStart:i,locEnd:l}=ut(),p=Ot();function d(c,D){let E=c.getValue();if(u(E))return D.originalText.slice(i(E),l(E)).trimEnd();if(p(E)){if(y(E)){let F=g(E);return E.trailing&&!t(D.originalText,i(E),{backwards:!0})?[a,F]:F}let _=l(E),w=D.originalText.slice(_-3,_)==="*-/";return["/*",n(E.value),w?"*-/":"*/"]}throw new Error("Not a comment: "+JSON.stringify(E))}function y(c){let D=`*${c.value}*`.split(`
`);return D.length>1&&D.every(E=>E.trim()[0]==="*")}function g(c){let D=c.value.split(`
`);return["/*",s(a,D.map((E,_)=>_===0?E.trimEnd():" "+(_<D.length-1?E.trim():E.trimStart()))),"*/"]}r.exports={printComment:d}}}),hd=te({"src/language-js/print/literal.js"(e,r){"use strict";ne();var{printString:t,printNumber:s}=Ue(),{replaceTextEndOfLine:a}=Yt(),{printDirective:n}=ct();function u(d,y){let g=d.getNode();switch(g.type){case"RegExpLiteral":return p(g);case"BigIntLiteral":return l(g.bigint||g.extra.raw);case"NumericLiteral":return s(g.extra.raw);case"StringLiteral":return a(t(g.extra.raw,y));case"NullLiteral":return"null";case"BooleanLiteral":return String(g.value);case"DecimalLiteral":return s(g.value)+"m";case"Literal":{if(g.regex)return p(g.regex);if(g.bigint)return l(g.raw);if(g.decimal)return s(g.decimal)+"m";let{value:c}=g;return typeof c=="number"?s(g.raw):typeof c=="string"?i(d)?n(g.raw,y):a(t(g.raw,y)):String(c)}}}function i(d){if(d.getName()!=="expression")return;let y=d.getParentNode();return y.type==="ExpressionStatement"&&y.directive}function l(d){return d.toLowerCase()}function p(d){let{pattern:y,flags:g}=d;return g=[...g].sort().join(""),`/${y}/${g}`}r.exports={printLiteral:u}}}),vd=te({"src/language-js/printer-estree.js"(e,r){"use strict";ne();var{printDanglingComments:t}=et(),{hasNewline:s}=Ue(),{builders:{join:a,line:n,hardline:u,softline:i,group:l,indent:p},utils:{replaceTextEndOfLine:d}}=qe(),y=td(),g=rd(),{insertPragma:c}=Co(),D=Eo(),E=qt(),_=Fo(),{hasFlowShorthandAnnotationComment:w,hasComment:F,CommentCheckFlags:S,isTheOnlyJsxElementInMarkdown:N,isLineComment:I,isNextLineEmpty:P,needsHardlineAfterDanglingComment:$,hasIgnoreComment:f,isCallExpression:T,isMemberExpression:m,markerForIfWithoutBlockAndSameLineComment:v}=Ke(),{locStart:o,locEnd:h}=ut(),C=Ot(),{printHtmlBinding:x,isVueEventBindingExpression:b}=cd(),{printAngular:B}=pd(),{printJsx:k,hasJsxIgnoreComment:M}=fd(),{printFlow:R}=md(),{printTypescript:q}=gd(),{printOptionalToken:J,printBindExpressionCallee:L,printTypeAnnotation:Q,adjustClause:V,printRestSpread:j,printDefiniteToken:Y,printDirective:ie}=ct(),{printImportDeclaration:ee,printExportDeclaration:le,printExportAllDeclaration:W,printModuleSpecifier:K}=To(),{printTernary:de}=Bo(),{printTemplateLiteral:ue}=jt(),{printArray:Fe}=er(),{printObject:z}=uu(),{printClass:U,printClassMethod:Z,printClassProperty:se}=nr(),{printProperty:De}=rr(),{printFunction:ge,printArrowFunction:he,printMethod:we,printReturnStatement:ke,printThrowStatement:Re}=qr(),{printCallExpression:Ne}=xo(),{printVariableDeclarator:Pe,printAssignmentExpression:oe}=tr(),{printBinaryishExpression:H}=ru(),{printSwitchCaseConsequent:ce}=No(),{printMemberExpression:X}=So(),{printBlock:pe,printBlockBody:Ae}=wo(),{printComment:Ce}=yd(),{printLiteral:fe}=hd(),{printDecorators:A}=nu();function G(Ee,Be,ve,ze){let be=re(Ee,Be,ve,ze);if(!be)return"";let Ye=Ee.getValue(),{type:Se}=Ye;if(Se==="ClassMethod"||Se==="ClassPrivateMethod"||Se==="ClassProperty"||Se==="ClassAccessorProperty"||Se==="AccessorProperty"||Se==="TSAbstractAccessorProperty"||Se==="PropertyDefinition"||Se==="TSAbstractPropertyDefinition"||Se==="ClassPrivateProperty"||Se==="MethodDefinition"||Se==="TSAbstractMethodDefinition"||Se==="TSDeclareMethod")return be;let Ie=[be],Oe=A(Ee,Be,ve),Je=Ye.type==="ClassExpression"&&Oe;if(Oe&&(Ie=[...Oe,be],!Je))return l(Ie);if(!E(Ee,Be))return ze&&ze.needsSemi&&Ie.unshift(";"),Ie.length===1&&Ie[0]===be?be:Ie;if(Je&&(Ie=[p([n,...Ie])]),Ie.unshift("("),ze&&ze.needsSemi&&Ie.unshift(";"),w(Ye)){let[je]=Ye.trailingComments;Ie.push(" /*",je.value.trimStart(),"*/"),je.printed=!0}return Je&&Ie.push(n),Ie.push(")"),Ie}function re(Ee,Be,ve,ze){let be=Ee.getValue(),Ye=Be.semi?";":"";if(!be)return"";if(typeof be=="string")return be;for(let Ie of[fe,x,B,k,R,q]){let Oe=Ie(Ee,Be,ve);if(typeof Oe<"u")return Oe}let Se=[];switch(be.type){case"JsExpressionRoot":return ve("node");case"JsonRoot":return[ve("node"),u];case"File":return be.program&&be.program.interpreter&&Se.push(ve(["program","interpreter"])),Se.push(ve("program")),Se;case"Program":return Ae(Ee,Be,ve);case"EmptyStatement":return"";case"ExpressionStatement":{if(Be.parser==="__vue_event_binding"||Be.parser==="__vue_ts_event_binding"){let Oe=Ee.getParentNode();if(Oe.type==="Program"&&Oe.body.length===1&&Oe.body[0]===be)return[ve("expression"),b(be.expression)?";":""]}let Ie=t(Ee,Be,!0,Oe=>{let{marker:Je}=Oe;return Je===v});return[ve("expression"),N(Be,Ee)?"":Ye,Ie?[" ",Ie]:""]}case"ParenthesizedExpression":return!F(be.expression)&&(be.expression.type==="ObjectExpression"||be.expression.type==="ArrayExpression")?["(",ve("expression"),")"]:l(["(",p([i,ve("expression")]),i,")"]);case"AssignmentExpression":return oe(Ee,Be,ve);case"VariableDeclarator":return Pe(Ee,Be,ve);case"BinaryExpression":case"LogicalExpression":return H(Ee,Be,ve);case"AssignmentPattern":return[ve("left")," = ",ve("right")];case"OptionalMemberExpression":case"MemberExpression":return X(Ee,Be,ve);case"MetaProperty":return[ve("meta"),".",ve("property")];case"BindExpression":return be.object&&Se.push(ve("object")),Se.push(l(p([i,L(Ee,Be,ve)]))),Se;case"Identifier":return[be.name,J(Ee),Y(Ee),Q(Ee,Be,ve)];case"V8IntrinsicIdentifier":return["%",be.name];case"SpreadElement":case"SpreadElementPattern":case"SpreadProperty":case"SpreadPropertyPattern":case"RestElement":return j(Ee,Be,ve);case"FunctionDeclaration":case"FunctionExpression":return ge(Ee,ve,Be,ze);case"ArrowFunctionExpression":return he(Ee,Be,ve,ze);case"YieldExpression":return Se.push("yield"),be.delegate&&Se.push("*"),be.argument&&Se.push(" ",ve("argument")),Se;case"AwaitExpression":{if(Se.push("await"),be.argument){Se.push(" ",ve("argument"));let Ie=Ee.getParentNode();if(T(Ie)&&Ie.callee===be||m(Ie)&&Ie.object===be){Se=[p([i,...Se]),i];let Oe=Ee.findAncestor(Je=>Je.type==="AwaitExpression"||Je.type==="BlockStatement");if(!Oe||Oe.type!=="AwaitExpression")return l(Se)}}return Se}case"ExportDefaultDeclaration":case"ExportNamedDeclaration":return le(Ee,Be,ve);case"ExportAllDeclaration":return W(Ee,Be,ve);case"ImportDeclaration":return ee(Ee,Be,ve);case"ImportSpecifier":case"ExportSpecifier":case"ImportNamespaceSpecifier":case"ExportNamespaceSpecifier":case"ImportDefaultSpecifier":case"ExportDefaultSpecifier":return K(Ee,Be,ve);case"ImportAttribute":return[ve("key"),": ",ve("value")];case"Import":return"import";case"BlockStatement":case"StaticBlock":case"ClassBody":return pe(Ee,Be,ve);case"ThrowStatement":return Re(Ee,Be,ve);case"ReturnStatement":return ke(Ee,Be,ve);case"NewExpression":case"ImportExpression":case"OptionalCallExpression":case"CallExpression":return Ne(Ee,Be,ve);case"ObjectExpression":case"ObjectPattern":case"RecordExpression":return z(Ee,Be,ve);case"ObjectProperty":case"Property":return be.method||be.kind==="get"||be.kind==="set"?we(Ee,Be,ve):De(Ee,Be,ve);case"ObjectMethod":return we(Ee,Be,ve);case"Decorator":return["@",ve("expression")];case"ArrayExpression":case"ArrayPattern":case"TupleExpression":return Fe(Ee,Be,ve);case"SequenceExpression":{let Ie=Ee.getParentNode(0);if(Ie.type==="ExpressionStatement"||Ie.type==="ForStatement"){let Oe=[];return Ee.each((Je,Te)=>{Te===0?Oe.push(ve()):Oe.push(",",p([n,ve()]))},"expressions"),l(Oe)}return l(a([",",n],Ee.map(ve,"expressions")))}case"ThisExpression":return"this";case"Super":return"super";case"Directive":return[ve("value"),Ye];case"DirectiveLiteral":return ie(be.extra.raw,Be);case"UnaryExpression":return Se.push(be.operator),/[a-z]$/.test(be.operator)&&Se.push(" "),F(be.argument)?Se.push(l(["(",p([i,ve("argument")]),i,")"])):Se.push(ve("argument")),Se;case"UpdateExpression":return Se.push(ve("argument"),be.operator),be.prefix&&Se.reverse(),Se;case"ConditionalExpression":return de(Ee,Be,ve);case"VariableDeclaration":{let Ie=Ee.map(ve,"declarations"),Oe=Ee.getParentNode(),Je=Oe.type==="ForStatement"||Oe.type==="ForInStatement"||Oe.type==="ForOfStatement",Te=be.declarations.some(Me=>Me.init),je;return Ie.length===1&&!F(be.declarations[0])?je=Ie[0]:Ie.length>0&&(je=p(Ie[0])),Se=[be.declare?"declare ":"",be.kind,je?[" ",je]:"",p(Ie.slice(1).map(Me=>[",",Te&&!Je?u:n,Me]))],Je&&Oe.body!==be||Se.push(Ye),l(Se)}case"WithStatement":return l(["with (",ve("object"),")",V(be.body,ve("body"))]);case"IfStatement":{let Ie=V(be.consequent,ve("consequent")),Oe=l(["if (",l([p([i,ve("test")]),i]),")",Ie]);if(Se.push(Oe),be.alternate){let Je=F(be.consequent,S.Trailing|S.Line)||$(be),Te=be.consequent.type==="BlockStatement"&&!Je;Se.push(Te?" ":u),F(be,S.Dangling)&&Se.push(t(Ee,Be,!0),Je?u:" "),Se.push("else",l(V(be.alternate,ve("alternate"),be.alternate.type==="IfStatement")))}return Se}case"ForStatement":{let Ie=V(be.body,ve("body")),Oe=t(Ee,Be,!0),Je=Oe?[Oe,i]:"";return!be.init&&!be.test&&!be.update?[Je,l(["for (;;)",Ie])]:[Je,l(["for (",l([p([i,ve("init"),";",n,ve("test"),";",n,ve("update")]),i]),")",Ie])]}case"WhileStatement":return l(["while (",l([p([i,ve("test")]),i]),")",V(be.body,ve("body"))]);case"ForInStatement":return l(["for (",ve("left")," in ",ve("right"),")",V(be.body,ve("body"))]);case"ForOfStatement":return l(["for",be.await?" await":""," (",ve("left")," of ",ve("right"),")",V(be.body,ve("body"))]);case"DoWhileStatement":{let Ie=V(be.body,ve("body"));return Se=[l(["do",Ie])],be.body.type==="BlockStatement"?Se.push(" "):Se.push(u),Se.push("while (",l([p([i,ve("test")]),i]),")",Ye),Se}case"DoExpression":return[be.async?"async ":"","do ",ve("body")];case"BreakStatement":return Se.push("break"),be.label&&Se.push(" ",ve("label")),Se.push(Ye),Se;case"ContinueStatement":return Se.push("continue"),be.label&&Se.push(" ",ve("label")),Se.push(Ye),Se;case"LabeledStatement":return be.body.type==="EmptyStatement"?[ve("label"),":;"]:[ve("label"),": ",ve("body")];case"TryStatement":return["try ",ve("block"),be.handler?[" ",ve("handler")]:"",be.finalizer?[" finally ",ve("finalizer")]:""];case"CatchClause":if(be.param){let Ie=F(be.param,Je=>!C(Je)||Je.leading&&s(Be.originalText,h(Je))||Je.trailing&&s(Be.originalText,o(Je),{backwards:!0})),Oe=ve("param");return["catch ",Ie?["(",p([i,Oe]),i,") "]:["(",Oe,") "],ve("body")]}return["catch ",ve("body")];case"SwitchStatement":return[l(["switch (",p([i,ve("discriminant")]),i,")"])," {",be.cases.length>0?p([u,a(u,Ee.map((Ie,Oe,Je)=>{let Te=Ie.getValue();return[ve(),Oe!==Je.length-1&&P(Te,Be)?u:""]},"cases"))]):"",u,"}"];case"SwitchCase":{be.test?Se.push("case ",ve("test"),":"):Se.push("default:"),F(be,S.Dangling)&&Se.push(" ",t(Ee,Be,!0));let Ie=be.consequent.filter(Oe=>Oe.type!=="EmptyStatement");if(Ie.length>0){let Oe=ce(Ee,Be,ve);Se.push(Ie.length===1&&Ie[0].type==="BlockStatement"?[" ",Oe]:p([u,Oe]))}return Se}case"DebuggerStatement":return["debugger",Ye];case"ClassDeclaration":case"ClassExpression":return U(Ee,Be,ve);case"ClassMethod":case"ClassPrivateMethod":case"MethodDefinition":return Z(Ee,Be,ve);case"ClassProperty":case"PropertyDefinition":case"ClassPrivateProperty":case"ClassAccessorProperty":case"AccessorProperty":return se(Ee,Be,ve);case"TemplateElement":return d(be.value.raw);case"TemplateLiteral":return ue(Ee,ve,Be);case"TaggedTemplateExpression":return[ve("tag"),ve("typeParameters"),ve("quasi")];case"PrivateIdentifier":return["#",ve("name")];case"PrivateName":return["#",ve("id")];case"InterpreterDirective":return Se.push("#!",be.value,u),P(be,Be)&&Se.push(u),Se;case"TopicReference":return"%";case"ArgumentPlaceholder":return"?";case"ModuleExpression":{Se.push("module {");let Ie=ve("body");return Ie&&Se.push(p([u,Ie]),u),Se.push("}"),Se}default:throw new Error("unknown type: "+JSON.stringify(be.type))}}function ye(Ee){return Ee.type&&!C(Ee)&&!I(Ee)&&Ee.type!=="EmptyStatement"&&Ee.type!=="TemplateElement"&&Ee.type!=="Import"&&Ee.type!=="TSEmptyBodyFunctionExpression"}r.exports={preprocess:_,print:G,embed:y,insertPragma:c,massageAstNode:g,hasPrettierIgnore(Ee){return f(Ee)||M(Ee)},willPrintOwnComments:D.willPrintOwnComments,canAttachComment:ye,printComment:Ce,isBlockComment:C,handleComments:{avoidAstMutation:!0,ownLine:D.handleOwnLineComment,endOfLine:D.handleEndOfLineComment,remaining:D.handleRemainingComment},getCommentChildNodes:D.getCommentChildNodes}}}),Cd=te({"src/language-js/printer-estree-json.js"(e,r){"use strict";ne();var{builders:{hardline:t,indent:s,join:a}}=qe(),n=Fo();function u(d,y,g){let c=d.getValue();switch(c.type){case"JsonRoot":return[g("node"),t];case"ArrayExpression":{if(c.elements.length===0)return"[]";let D=d.map(()=>d.getValue()===null?"null":g(),"elements");return["[",s([t,a([",",t],D)]),t,"]"]}case"ObjectExpression":return c.properties.length===0?"{}":["{",s([t,a([",",t],d.map(g,"properties"))]),t,"}"];case"ObjectProperty":return[g("key"),": ",g("value")];case"UnaryExpression":return[c.operator==="+"?"":c.operator,g("argument")];case"NullLiteral":return"null";case"BooleanLiteral":return c.value?"true":"false";case"StringLiteral":return JSON.stringify(c.value);case"NumericLiteral":return i(d)?JSON.stringify(String(c.value)):JSON.stringify(c.value);case"Identifier":return i(d)?JSON.stringify(c.name):c.name;case"TemplateLiteral":return g(["quasis",0]);case"TemplateElement":return JSON.stringify(c.value.cooked);default:throw new Error("unknown type: "+JSON.stringify(c.type))}}function i(d){return d.getName()==="key"&&d.getParentNode().type==="ObjectProperty"}var l=new Set(["start","end","extra","loc","comments","leadingComments","trailingComments","innerComments","errors","range","tokens"]);function p(d,y){let{type:g}=d;if(g==="ObjectProperty"){let{key:c}=d;c.type==="Identifier"?y.key={type:"StringLiteral",value:c.name}:c.type==="NumericLiteral"&&(y.key={type:"StringLiteral",value:String(c.value)});return}if(g==="UnaryExpression"&&d.operator==="+")return y.argument;if(g==="ArrayExpression"){for(let[c,D]of d.elements.entries())D===null&&y.elements.splice(c,0,{type:"NullLiteral"});return}if(g==="TemplateLiteral")return{type:"StringLiteral",value:d.quasis[0].value.cooked}}p.ignoredProperties=l,r.exports={preprocess:n,print:u,massageAstNode:p}}}),Mt=te({"src/common/common-options.js"(e,r){"use strict";ne();var t="Common";r.exports={bracketSpacing:{since:"0.0.0",category:t,type:"boolean",default:!0,description:"Print spaces between brackets.",oppositeDescription:"Do not print spaces between brackets."},singleQuote:{since:"0.0.0",category:t,type:"boolean",default:!1,description:"Use single quotes instead of double quotes."},proseWrap:{since:"1.8.2",category:t,type:"choice",default:[{since:"1.8.2",value:!0},{since:"1.9.0",value:"preserve"}],description:"How to wrap prose.",choices:[{since:"1.9.0",value:"always",description:"Wrap prose if it exceeds the print width."},{since:"1.9.0",value:"never",description:"Do not wrap prose."},{since:"1.9.0",value:"preserve",description:"Wrap prose as-is."}]},bracketSameLine:{since:"2.4.0",category:t,type:"boolean",default:!1,description:"Put > of opening tags on the last line instead of on a new line."},singleAttributePerLine:{since:"2.6.0",category:t,type:"boolean",default:!1,description:"Enforce single attribute per line in HTML, Vue and JSX."}}}}),Ed=te({"src/language-js/options.js"(e,r){"use strict";ne();var t=Mt(),s="JavaScript";r.exports={arrowParens:{since:"1.9.0",category:s,type:"choice",default:[{since:"1.9.0",value:"avoid"},{since:"2.0.0",value:"always"}],description:"Include parentheses around a sole arrow function parameter.",choices:[{value:"always",description:"Always include parens. Example: `(x) => x`"},{value:"avoid",description:"Omit parens when possible. Example: `x => x`"}]},bracketSameLine:t.bracketSameLine,bracketSpacing:t.bracketSpacing,jsxBracketSameLine:{since:"0.17.0",category:s,type:"boolean",description:"Put > on the last line instead of at a new line.",deprecated:"2.4.0"},semi:{since:"1.0.0",category:s,type:"boolean",default:!0,description:"Print semicolons.",oppositeDescription:"Do not print semicolons, except at the beginning of lines which may need them."},singleQuote:t.singleQuote,jsxSingleQuote:{since:"1.15.0",category:s,type:"boolean",default:!1,description:"Use single quotes in JSX."},quoteProps:{since:"1.17.0",category:s,type:"choice",default:"as-needed",description:"Change when properties in objects are quoted.",choices:[{value:"as-needed",description:"Only add quotes around object properties where required."},{value:"consistent",description:"If at least one property in an object requires quotes, quote all properties."},{value:"preserve",description:"Respect the input use of quotes in object properties."}]},trailingComma:{since:"0.0.0",category:s,type:"choice",default:[{since:"0.0.0",value:!1},{since:"0.19.0",value:"none"},{since:"2.0.0",value:"es5"}],description:"Print trailing commas wherever possible when multi-line.",choices:[{value:"es5",description:"Trailing commas where valid in ES5 (objects, arrays, etc.)"},{value:"none",description:"No trailing commas."},{value:"all",description:"Trailing commas wherever possible (including function arguments)."}]},singleAttributePerLine:t.singleAttributePerLine}}}),Fd=te({"src/language-js/parse/parsers.js"(){ne()}}),Ln=te({"node_modules/linguist-languages/data/JavaScript.json"(e,r){r.exports={name:"JavaScript",type:"programming",tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"text/javascript",color:"#f1e05a",aliases:["js","node"],extensions:[".js","._js",".bones",".cjs",".es",".es6",".frag",".gs",".jake",".javascript",".jsb",".jscad",".jsfl",".jslib",".jsm",".jspre",".jss",".jsx",".mjs",".njs",".pac",".sjs",".ssjs",".xsjs",".xsjslib"],filenames:["Jakefile"],interpreters:["chakra","d8","gjs","js","node","nodejs","qjs","rhino","v8","v8-shell"],languageId:183}}}),Ad=te({"node_modules/linguist-languages/data/TypeScript.json"(e,r){r.exports={name:"TypeScript",type:"programming",color:"#3178c6",aliases:["ts"],interpreters:["deno","ts-node"],extensions:[".ts",".cts",".mts"],tmScope:"source.ts",aceMode:"typescript",codemirrorMode:"javascript",codemirrorMimeType:"application/typescript",languageId:378}}}),Sd=te({"node_modules/linguist-languages/data/TSX.json"(e,r){r.exports={name:"TSX",type:"programming",color:"#3178c6",group:"TypeScript",extensions:[".tsx"],tmScope:"source.tsx",aceMode:"javascript",codemirrorMode:"jsx",codemirrorMimeType:"text/jsx",languageId:94901924}}}),wa=te({"node_modules/linguist-languages/data/JSON.json"(e,r){r.exports={name:"JSON",type:"data",color:"#292929",tmScope:"source.json",aceMode:"json",codemirrorMode:"javascript",codemirrorMimeType:"application/json",aliases:["geojson","jsonl","topojson"],extensions:[".json",".4DForm",".4DProject",".avsc",".geojson",".gltf",".har",".ice",".JSON-tmLanguage",".jsonl",".mcmeta",".tfstate",".tfstate.backup",".topojson",".webapp",".webmanifest",".yy",".yyp"],filenames:[".arcconfig",".auto-changelog",".c8rc",".htmlhintrc",".imgbotconfig",".nycrc",".tern-config",".tern-project",".watchmanconfig","Pipfile.lock","composer.lock","mcmod.info"],languageId:174}}}),xd=te({"node_modules/linguist-languages/data/JSON with Comments.json"(e,r){r.exports={name:"JSON with Comments",type:"data",color:"#292929",group:"JSON",tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"text/javascript",aliases:["jsonc"],extensions:[".jsonc",".code-snippets",".sublime-build",".sublime-commands",".sublime-completions",".sublime-keymap",".sublime-macro",".sublime-menu",".sublime-mousemap",".sublime-project",".sublime-settings",".sublime-theme",".sublime-workspace",".sublime_metrics",".sublime_session"],filenames:[".babelrc",".devcontainer.json",".eslintrc.json",".jscsrc",".jshintrc",".jslintrc","api-extractor.json","devcontainer.json","jsconfig.json","language-configuration.json","tsconfig.json","tslint.json"],languageId:423}}}),bd=te({"node_modules/linguist-languages/data/JSON5.json"(e,r){r.exports={name:"JSON5",type:"data",color:"#267CB9",extensions:[".json5"],tmScope:"source.js",aceMode:"javascript",codemirrorMode:"javascript",codemirrorMimeType:"application/json",languageId:175}}}),Td=te({"src/language-js/index.js"(e,r){"use strict";ne();var t=_t(),s=vd(),a=Cd(),n=Ed(),u=Fd(),i=[t(Ln(),p=>({since:"0.0.0",parsers:["babel","acorn","espree","meriyah","babel-flow","babel-ts","flow","typescript"],vscodeLanguageIds:["javascript","mongo"],interpreters:[...p.interpreters,"zx"],extensions:[...p.extensions.filter(d=>d!==".jsx"),".wxs"]})),t(Ln(),()=>({name:"Flow",since:"0.0.0",parsers:["flow","babel-flow"],vscodeLanguageIds:["javascript"],aliases:[],filenames:[],extensions:[".js.flow"]})),t(Ln(),()=>({name:"JSX",since:"0.0.0",parsers:["babel","babel-flow","babel-ts","flow","typescript","espree","meriyah"],vscodeLanguageIds:["javascriptreact"],aliases:void 0,filenames:void 0,extensions:[".jsx"],group:"JavaScript",interpreters:void 0,tmScope:"source.js.jsx",aceMode:"javascript",codemirrorMode:"jsx",codemirrorMimeType:"text/jsx",color:void 0})),t(Ad(),()=>({since:"1.4.0",parsers:["typescript","babel-ts"],vscodeLanguageIds:["typescript"]})),t(Sd(),()=>({since:"1.4.0",parsers:["typescript","babel-ts"],vscodeLanguageIds:["typescriptreact"]})),t(wa(),()=>({name:"JSON.stringify",since:"1.13.0",parsers:["json-stringify"],vscodeLanguageIds:["json"],extensions:[".importmap"],filenames:["package.json","package-lock.json","composer.json"]})),t(wa(),p=>({since:"1.5.0",parsers:["json"],vscodeLanguageIds:["json"],extensions:p.extensions.filter(d=>d!==".jsonl")})),t(xd(),p=>({since:"1.5.0",parsers:["json"],vscodeLanguageIds:["jsonc"],filenames:[...p.filenames,".eslintrc",".swcrc"]})),t(bd(),()=>({since:"1.13.0",parsers:["json5"],vscodeLanguageIds:["json5"]}))],l={estree:s,"estree-json":a};r.exports={languages:i,options:n,printers:l,parsers:u}}}),Bd=te({"src/language-css/clean.js"(e,r){"use strict";ne();var{isFrontMatterNode:t}=Ue(),s=lt(),a=new Set(["raw","raws","sourceIndex","source","before","after","trailingComma"]);function n(i,l,p){if(t(i)&&i.lang==="yaml"&&delete l.value,i.type==="css-comment"&&p.type==="css-root"&&p.nodes.length>0&&((p.nodes[0]===i||t(p.nodes[0])&&p.nodes[1]===i)&&(delete l.text,/^\*\s*@(?:format|prettier)\s*$/.test(i.text))||p.type==="css-root"&&s(p.nodes)===i))return null;if(i.type==="value-root"&&delete l.text,(i.type==="media-query"||i.type==="media-query-list"||i.type==="media-feature-expression")&&delete l.value,i.type==="css-rule"&&delete l.params,i.type==="selector-combinator"&&(l.value=l.value.replace(/\s+/g," ")),i.type==="media-feature"&&(l.value=l.value.replace(/ /g,"")),(i.type==="value-word"&&(i.isColor&&i.isHex||["initial","inherit","unset","revert"].includes(l.value.replace().toLowerCase()))||i.type==="media-feature"||i.type==="selector-root-invalid"||i.type==="selector-pseudo")&&(l.value=l.value.toLowerCase()),i.type==="css-decl"&&(l.prop=l.prop.toLowerCase()),(i.type==="css-atrule"||i.type==="css-import")&&(l.name=l.name.toLowerCase()),i.type==="value-number"&&(l.unit=l.unit.toLowerCase()),(i.type==="media-feature"||i.type==="media-keyword"||i.type==="media-type"||i.type==="media-unknown"||i.type==="media-url"||i.type==="media-value"||i.type==="selector-attribute"||i.type==="selector-string"||i.type==="selector-class"||i.type==="selector-combinator"||i.type==="value-string")&&l.value&&(l.value=u(l.value)),i.type==="selector-attribute"&&(l.attribute=l.attribute.trim(),l.namespace&&typeof l.namespace=="string"&&(l.namespace=l.namespace.trim(),l.namespace.length===0&&(l.namespace=!0)),l.value&&(l.value=l.value.trim().replace(/^["']|["']$/g,""),delete l.quoted)),(i.type==="media-value"||i.type==="media-type"||i.type==="value-number"||i.type==="selector-root-invalid"||i.type==="selector-class"||i.type==="selector-combinator"||i.type==="selector-tag")&&l.value&&(l.value=l.value.replace(/([\d+.Ee-]+)([A-Za-z]*)/g,(d,y,g)=>{let c=Number(y);return Number.isNaN(c)?d:c+g.toLowerCase()})),i.type==="selector-tag"){let d=i.value.toLowerCase();["from","to"].includes(d)&&(l.value=d)}if(i.type==="css-atrule"&&i.name.toLowerCase()==="supports"&&delete l.value,i.type==="selector-unknown"&&delete l.value,i.type==="value-comma_group"){let d=i.groups.findIndex(y=>y.type==="value-number"&&y.unit==="...");d!==-1&&(l.groups[d].unit="",l.groups.splice(d+1,0,{type:"value-word",value:"...",isColor:!1,isHex:!1}))}if(i.type==="value-comma_group"&&i.groups.some(d=>d.type==="value-atword"&&d.value.endsWith("[")||d.type==="value-word"&&d.value.startsWith("]")))return{type:"value-atword",value:i.groups.map(d=>d.value).join(""),group:{open:null,close:null,groups:[],type:"value-paren_group"}}}n.ignoredProperties=a;function u(i){return i.replace(/'/g,'"').replace(/\\([^\dA-Fa-f])/g,"$1")}r.exports=n}}),su=te({"src/utils/front-matter/print.js"(e,r){"use strict";ne();var{builders:{hardline:t,markAsRoot:s}}=qe();function a(n,u){if(n.lang==="yaml"){let i=n.value.trim(),l=i?u(i,{parser:"yaml"},{stripTrailingHardline:!0}):"";return s([n.startDelimiter,t,l,l?t:"",n.endDelimiter])}}r.exports=a}}),Nd=te({"src/language-css/embed.js"(e,r){"use strict";ne();var{builders:{hardline:t}}=qe(),s=su();function a(n,u,i){let l=n.getValue();if(l.type==="front-matter"){let p=s(l,i);return p?[p,t]:""}}r.exports=a}}),_o=te({"src/utils/front-matter/parse.js"(e,r){"use strict";ne();var t=new RegExp("^(?<startDelimiter>-{3}|\\+{3})(?<language>[^\\n]*)\\n(?:|(?<value>.*?)\\n)(?<endDelimiter>\\k<startDelimiter>|\\.{3})[^\\S\\n]*(?:\\n|$)","s");function s(a){let n=a.match(t);if(!n)return{content:a};let{startDelimiter:u,language:i,value:l="",endDelimiter:p}=n.groups,d=i.trim()||"yaml";if(u==="+++"&&(d="toml"),d!=="yaml"&&u!==p)return{content:a};let[y]=n;return{frontMatter:{type:"front-matter",lang:d,value:l,startDelimiter:u,endDelimiter:p,raw:y.replace(/\n$/,"")},content:y.replace(/[^\n]/g," ")+a.slice(y.length)}}r.exports=s}}),wd=te({"src/language-css/pragma.js"(e,r){"use strict";ne();var t=Co(),s=_o();function a(u){return t.hasPragma(s(u).content)}function n(u){let{frontMatter:i,content:l}=s(u);return(i?i.raw+`

`:"")+t.insertPragma(l)}r.exports={hasPragma:a,insertPragma:n}}}),_d=te({"src/language-css/utils/index.js"(e,r){"use strict";ne();var t=new Set(["red","green","blue","alpha","a","rgb","hue","h","saturation","s","lightness","l","whiteness","w","blackness","b","tint","shade","blend","blenda","contrast","hsl","hsla","hwb","hwba"]);function s(z,U){let Z=Array.isArray(U)?U:[U],se=-1,De;for(;De=z.getParentNode(++se);)if(Z.includes(De.type))return se;return-1}function a(z,U){let Z=s(z,U);return Z===-1?null:z.getParentNode(Z)}function n(z){var U;let Z=a(z,"css-decl");return Z==null||(U=Z.prop)===null||U===void 0?void 0:U.toLowerCase()}var u=new Set(["initial","inherit","unset","revert"]);function i(z){return u.has(z.toLowerCase())}function l(z,U){let Z=a(z,"css-atrule");return(Z==null?void 0:Z.name)&&Z.name.toLowerCase().endsWith("keyframes")&&["from","to"].includes(U.toLowerCase())}function p(z){return z.includes("$")||z.includes("@")||z.includes("#")||z.startsWith("%")||z.startsWith("--")||z.startsWith(":--")||z.includes("(")&&z.includes(")")?z:z.toLowerCase()}function d(z,U){var Z;let se=a(z,"value-func");return(se==null||(Z=se.value)===null||Z===void 0?void 0:Z.toLowerCase())===U}function y(z){var U;let Z=a(z,"css-rule"),se=Z==null||(U=Z.raws)===null||U===void 0?void 0:U.selector;return se&&(se.startsWith(":import")||se.startsWith(":export"))}function g(z,U){let Z=Array.isArray(U)?U:[U],se=a(z,"css-atrule");return se&&Z.includes(se.name.toLowerCase())}function c(z){let U=z.getValue(),Z=a(z,"css-atrule");return(Z==null?void 0:Z.name)==="import"&&U.groups[0].value==="url"&&U.groups.length===2}function D(z){return z.type==="value-func"&&z.value.toLowerCase()==="url"}function E(z,U){var Z;let se=(Z=z.getParentNode())===null||Z===void 0?void 0:Z.nodes;return se&&se.indexOf(U)===se.length-1}function _(z){let{selector:U}=z;return U?typeof U=="string"&&/^@.+:.*$/.test(U)||U.value&&/^@.+:.*$/.test(U.value):!1}function w(z){return z.type==="value-word"&&["from","through","end"].includes(z.value)}function F(z){return z.type==="value-word"&&["and","or","not"].includes(z.value)}function S(z){return z.type==="value-word"&&z.value==="in"}function N(z){return z.type==="value-operator"&&z.value==="*"}function I(z){return z.type==="value-operator"&&z.value==="/"}function P(z){return z.type==="value-operator"&&z.value==="+"}function $(z){return z.type==="value-operator"&&z.value==="-"}function f(z){return z.type==="value-operator"&&z.value==="%"}function T(z){return N(z)||I(z)||P(z)||$(z)||f(z)}function m(z){return z.type==="value-word"&&["==","!="].includes(z.value)}function v(z){return z.type==="value-word"&&["<",">","<=",">="].includes(z.value)}function o(z){return z.type==="css-atrule"&&["if","else","for","each","while"].includes(z.name)}function h(z){var U;return((U=z.raws)===null||U===void 0?void 0:U.params)&&/^\(\s*\)$/.test(z.raws.params)}function C(z){return z.name.startsWith("prettier-placeholder")}function x(z){return z.prop.startsWith("@prettier-placeholder")}function b(z,U){return z.value==="$$"&&z.type==="value-func"&&(U==null?void 0:U.type)==="value-word"&&!U.raws.before}function B(z){var U,Z;return((U=z.value)===null||U===void 0?void 0:U.type)==="value-root"&&((Z=z.value.group)===null||Z===void 0?void 0:Z.type)==="value-value"&&z.prop.toLowerCase()==="composes"}function k(z){var U,Z,se;return((U=z.value)===null||U===void 0||(Z=U.group)===null||Z===void 0||(se=Z.group)===null||se===void 0?void 0:se.type)==="value-paren_group"&&z.value.group.group.open!==null&&z.value.group.group.close!==null}function M(z){var U;return((U=z.raws)===null||U===void 0?void 0:U.before)===""}function R(z){var U,Z;return z.type==="value-comma_group"&&((U=z.groups)===null||U===void 0||(Z=U[1])===null||Z===void 0?void 0:Z.type)==="value-colon"}function q(z){var U;return z.type==="value-paren_group"&&((U=z.groups)===null||U===void 0?void 0:U[0])&&R(z.groups[0])}function J(z){var U;let Z=z.getValue();if(Z.groups.length===0)return!1;let se=z.getParentNode(1);if(!q(Z)&&!(se&&q(se)))return!1;let De=a(z,"css-decl");return!!(De!=null&&(U=De.prop)!==null&&U!==void 0&&U.startsWith("$")||q(se)||se.type==="value-func")}function L(z){return z.type==="value-comment"&&z.inline}function Q(z){return z.type==="value-word"&&z.value==="#"}function V(z){return z.type==="value-word"&&z.value==="{"}function j(z){return z.type==="value-word"&&z.value==="}"}function Y(z){return["value-word","value-atword"].includes(z.type)}function ie(z){return(z==null?void 0:z.type)==="value-colon"}function ee(z,U){if(!R(U))return!1;let{groups:Z}=U,se=Z.indexOf(z);return se===-1?!1:ie(Z[se+1])}function le(z){return z.value&&["not","and","or"].includes(z.value.toLowerCase())}function W(z){return z.type!=="value-func"?!1:t.has(z.value.toLowerCase())}function K(z){return/\/\//.test(z.split(/[\n\r]/).pop())}function de(z){return(z==null?void 0:z.type)==="value-atword"&&z.value.startsWith("prettier-placeholder-")}function ue(z,U){var Z,se;if(((Z=z.open)===null||Z===void 0?void 0:Z.value)!=="("||((se=z.close)===null||se===void 0?void 0:se.value)!==")"||z.groups.some(De=>De.type!=="value-comma_group"))return!1;if(U.type==="value-comma_group"){let De=U.groups.indexOf(z)-1,ge=U.groups[De];if((ge==null?void 0:ge.type)==="value-word"&&ge.value==="with")return!0}return!1}function Fe(z){var U,Z;return z.type==="value-paren_group"&&((U=z.open)===null||U===void 0?void 0:U.value)==="("&&((Z=z.close)===null||Z===void 0?void 0:Z.value)===")"}r.exports={getAncestorCounter:s,getAncestorNode:a,getPropOfDeclNode:n,maybeToLowerCase:p,insideValueFunctionNode:d,insideICSSRuleNode:y,insideAtRuleNode:g,insideURLFunctionInImportAtRuleNode:c,isKeyframeAtRuleKeywords:l,isWideKeywords:i,isLastNode:E,isSCSSControlDirectiveNode:o,isDetachedRulesetDeclarationNode:_,isRelationalOperatorNode:v,isEqualityOperatorNode:m,isMultiplicationNode:N,isDivisionNode:I,isAdditionNode:P,isSubtractionNode:$,isModuloNode:f,isMathOperatorNode:T,isEachKeywordNode:S,isForKeywordNode:w,isURLFunctionNode:D,isIfElseKeywordNode:F,hasComposesNode:B,hasParensAroundNode:k,hasEmptyRawBefore:M,isDetachedRulesetCallNode:h,isTemplatePlaceholderNode:C,isTemplatePropNode:x,isPostcssSimpleVarNode:b,isKeyValuePairNode:R,isKeyValuePairInParenGroupNode:q,isKeyInValuePairNode:ee,isSCSSMapItemNode:J,isInlineValueCommentNode:L,isHashNode:Q,isLeftCurlyBraceNode:V,isRightCurlyBraceNode:j,isWordNode:Y,isColonNode:ie,isMediaAndSupportsKeywords:le,isColorAdjusterFuncNode:W,lastLineHasInlineComment:K,isAtWordPlaceholderNode:de,isConfigurationNode:ue,isParenGroupNode:Fe}}}),Pd=te({"src/utils/line-column-to-index.js"(e,r){"use strict";ne(),r.exports=function(t,s){let a=0;for(let n=0;n<t.line-1;++n)a=s.indexOf(`
`,a)+1;return a+t.column}}}),Id=te({"src/language-css/loc.js"(e,r){"use strict";ne();var{skipEverythingButNewLine:t}=Pr(),s=lt(),a=Pd();function n(c,D){return typeof c.sourceIndex=="number"?c.sourceIndex:c.source?a(c.source.start,D)-1:null}function u(c,D){if(c.type==="css-comment"&&c.inline)return t(D,c.source.startOffset);let E=c.nodes&&s(c.nodes);return E&&c.source&&!c.source.end&&(c=E),c.source&&c.source.end?a(c.source.end,D):null}function i(c,D){c.source&&(c.source.startOffset=n(c,D),c.source.endOffset=u(c,D));for(let E in c){let _=c[E];E==="source"||!_||typeof _!="object"||(_.type==="value-root"||_.type==="value-unknown"?l(_,p(c),_.text||_.value):i(_,D))}}function l(c,D,E){c.source&&(c.source.startOffset=n(c,E)+D,c.source.endOffset=u(c,E)+D);for(let _ in c){let w=c[_];_==="source"||!w||typeof w!="object"||l(w,D,E)}}function p(c){let D=c.source.startOffset;return typeof c.prop=="string"&&(D+=c.prop.length),c.type==="css-atrule"&&typeof c.name=="string"&&(D+=1+c.name.length+c.raws.afterName.match(/^\s*:?\s*/)[0].length),c.type!=="css-atrule"&&c.raws&&typeof c.raws.between=="string"&&(D+=c.raws.between.length),D}function d(c){let D="initial",E="initial",_,w=!1,F=[];for(let S=0;S<c.length;S++){let N=c[S];switch(D){case"initial":if(N==="'"){D="single-quotes";continue}if(N==='"'){D="double-quotes";continue}if((N==="u"||N==="U")&&c.slice(S,S+4).toLowerCase()==="url("){D="url",S+=3;continue}if(N==="*"&&c[S-1]==="/"){D="comment-block";continue}if(N==="/"&&c[S-1]==="/"){D="comment-inline",_=S-1;continue}continue;case"single-quotes":if(N==="'"&&c[S-1]!=="\\"&&(D=E,E="initial"),N===`
`||N==="\r")return c;continue;case"double-quotes":if(N==='"'&&c[S-1]!=="\\"&&(D=E,E="initial"),N===`
`||N==="\r")return c;continue;case"url":if(N===")"&&(D="initial"),N===`
`||N==="\r")return c;if(N==="'"){D="single-quotes",E="url";continue}if(N==='"'){D="double-quotes",E="url";continue}continue;case"comment-block":N==="/"&&c[S-1]==="*"&&(D="initial");continue;case"comment-inline":(N==='"'||N==="'"||N==="*")&&(w=!0),(N===`
`||N==="\r")&&(w&&F.push([_,S]),D="initial",w=!1);continue}}for(let[S,N]of F)c=c.slice(0,S)+c.slice(S,N).replace(/["'*]/g," ")+c.slice(N);return c}function y(c){return c.source.startOffset}function g(c){return c.source.endOffset}r.exports={locStart:y,locEnd:g,calculateLoc:i,replaceQuotesInInlineComments:d}}}),kd=te({"src/language-css/utils/is-less-parser.js"(e,r){"use strict";ne();function t(s){return s.parser==="css"||s.parser==="less"}r.exports=t}}),Ld=te({"src/language-css/utils/is-scss.js"(e,r){"use strict";ne();function t(s,a){return s==="less"||s==="scss"?s==="scss":/(?:\w\s*:\s*[^:}]+|#){|@import[^\n]+(?:url|,)/.test(a)}r.exports=t}}),Od=te({"src/language-css/utils/css-units.evaluate.js"(e,r){r.exports={em:"em",rem:"rem",ex:"ex",rex:"rex",cap:"cap",rcap:"rcap",ch:"ch",rch:"rch",ic:"ic",ric:"ric",lh:"lh",rlh:"rlh",vw:"vw",svw:"svw",lvw:"lvw",dvw:"dvw",vh:"vh",svh:"svh",lvh:"lvh",dvh:"dvh",vi:"vi",svi:"svi",lvi:"lvi",dvi:"dvi",vb:"vb",svb:"svb",lvb:"lvb",dvb:"dvb",vmin:"vmin",svmin:"svmin",lvmin:"lvmin",dvmin:"dvmin",vmax:"vmax",svmax:"svmax",lvmax:"lvmax",dvmax:"dvmax",cm:"cm",mm:"mm",q:"Q",in:"in",pt:"pt",pc:"pc",px:"px",deg:"deg",grad:"grad",rad:"rad",turn:"turn",s:"s",ms:"ms",hz:"Hz",khz:"kHz",dpi:"dpi",dpcm:"dpcm",dppx:"dppx",x:"x"}}}),jd=te({"src/language-css/utils/print-unit.js"(e,r){"use strict";ne();var t=Od();function s(a){let n=a.toLowerCase();return Object.prototype.hasOwnProperty.call(t,n)?t[n]:a}r.exports=s}}),qd=te({"src/language-css/printer-postcss.js"(e,r){"use strict";ne();var t=lt(),{printNumber:s,printString:a,hasNewline:n,isFrontMatterNode:u,isNextLineEmpty:i,isNonEmptyArray:l}=Ue(),{builders:{join:p,line:d,hardline:y,softline:g,group:c,fill:D,indent:E,dedent:_,ifBreak:w,breakParent:F},utils:{removeLines:S,getDocParts:N}}=qe(),I=Bd(),P=Nd(),{insertPragma:$}=wd(),{getAncestorNode:f,getPropOfDeclNode:T,maybeToLowerCase:m,insideValueFunctionNode:v,insideICSSRuleNode:o,insideAtRuleNode:h,insideURLFunctionInImportAtRuleNode:C,isKeyframeAtRuleKeywords:x,isWideKeywords:b,isLastNode:B,isSCSSControlDirectiveNode:k,isDetachedRulesetDeclarationNode:M,isRelationalOperatorNode:R,isEqualityOperatorNode:q,isMultiplicationNode:J,isDivisionNode:L,isAdditionNode:Q,isSubtractionNode:V,isMathOperatorNode:j,isEachKeywordNode:Y,isForKeywordNode:ie,isURLFunctionNode:ee,isIfElseKeywordNode:le,hasComposesNode:W,hasParensAroundNode:K,hasEmptyRawBefore:de,isKeyValuePairNode:ue,isKeyInValuePairNode:Fe,isDetachedRulesetCallNode:z,isTemplatePlaceholderNode:U,isTemplatePropNode:Z,isPostcssSimpleVarNode:se,isSCSSMapItemNode:De,isInlineValueCommentNode:ge,isHashNode:he,isLeftCurlyBraceNode:we,isRightCurlyBraceNode:ke,isWordNode:Re,isColonNode:Ne,isMediaAndSupportsKeywords:Pe,isColorAdjusterFuncNode:oe,lastLineHasInlineComment:H,isAtWordPlaceholderNode:ce,isConfigurationNode:X,isParenGroupNode:pe}=_d(),{locStart:Ae,locEnd:Ce}=Id(),fe=kd(),A=Ld(),G=jd();function re(Te){return Te.trailingComma==="es5"||Te.trailingComma==="all"}function ye(Te,je,Me){let ae=Te.getValue();if(!ae)return"";if(typeof ae=="string")return ae;switch(ae.type){case"front-matter":return[ae.raw,y];case"css-root":{let Ve=Ee(Te,je,Me),We=ae.raws.after.trim();return We.startsWith(";")&&(We=We.slice(1).trim()),[Ve,We?` ${We}`:"",N(Ve).length>0?y:""]}case"css-comment":{let Ve=ae.inline||ae.raws.inline,We=je.originalText.slice(Ae(ae),Ce(ae));return Ve?We.trimEnd():We}case"css-rule":return[Me("selector"),ae.important?" !important":"",ae.nodes?[ae.selector&&ae.selector.type==="selector-unknown"&&H(ae.selector.value)?d:" ","{",ae.nodes.length>0?E([y,Ee(Te,je,Me)]):"",y,"}",M(ae)?";":""]:";"];case"css-decl":{let Ve=Te.getParentNode(),{between:We}=ae.raws,Xe=We.trim(),st=Xe===":",O=W(ae)?S(Me("value")):Me("value");return!st&&H(Xe)&&(O=E([y,_(O)])),[ae.raws.before.replace(/[\s;]/g,""),Ve.type==="css-atrule"&&Ve.variable||o(Te)?ae.prop:m(ae.prop),Xe.startsWith("//")?" ":"",Xe,ae.extend?"":" ",fe(je)&&ae.extend&&ae.selector?["extend(",Me("selector"),")"]:"",O,ae.raws.important?ae.raws.important.replace(/\s*!\s*important/i," !important"):ae.important?" !important":"",ae.raws.scssDefault?ae.raws.scssDefault.replace(/\s*!default/i," !default"):ae.scssDefault?" !default":"",ae.raws.scssGlobal?ae.raws.scssGlobal.replace(/\s*!global/i," !global"):ae.scssGlobal?" !global":"",ae.nodes?[" {",E([g,Ee(Te,je,Me)]),g,"}"]:Z(ae)&&!Ve.raws.semicolon&&je.originalText[Ce(ae)-1]!==";"?"":je.__isHTMLStyleAttribute&&B(Te,ae)?w(";"):";"]}case"css-atrule":{let Ve=Te.getParentNode(),We=U(ae)&&!Ve.raws.semicolon&&je.originalText[Ce(ae)-1]!==";";if(fe(je)){if(ae.mixin)return[Me("selector"),ae.important?" !important":"",We?"":";"];if(ae.function)return[ae.name,Me("params"),We?"":";"];if(ae.variable)return["@",ae.name,": ",ae.value?Me("value"):"",ae.raws.between.trim()?ae.raws.between.trim()+" ":"",ae.nodes?["{",E([ae.nodes.length>0?g:"",Ee(Te,je,Me)]),g,"}"]:"",We?"":";"]}return["@",z(ae)||ae.name.endsWith(":")?ae.name:m(ae.name),ae.params?[z(ae)?"":U(ae)?ae.raws.afterName===""?"":ae.name.endsWith(":")?" ":/^\s*\n\s*\n/.test(ae.raws.afterName)?[y,y]:/^\s*\n/.test(ae.raws.afterName)?y:" ":" ",Me("params")]:"",ae.selector?E([" ",Me("selector")]):"",ae.value?c([" ",Me("value"),k(ae)?K(ae)?" ":d:""]):ae.name==="else"?" ":"",ae.nodes?[k(ae)?"":ae.selector&&!ae.selector.nodes&&typeof ae.selector.value=="string"&&H(ae.selector.value)||!ae.selector&&typeof ae.params=="string"&&H(ae.params)?d:" ","{",E([ae.nodes.length>0?g:"",Ee(Te,je,Me)]),g,"}"]:We?"":";"]}case"media-query-list":{let Ve=[];return Te.each(We=>{let Xe=We.getValue();Xe.type==="media-query"&&Xe.value===""||Ve.push(Me())},"nodes"),c(E(p(d,Ve)))}case"media-query":return[p(" ",Te.map(Me,"nodes")),B(Te,ae)?"":","];case"media-type":return Oe(Se(ae.value,je));case"media-feature-expression":return ae.nodes?["(",...Te.map(Me,"nodes"),")"]:ae.value;case"media-feature":return m(Se(ae.value.replace(/ +/g," "),je));case"media-colon":return[ae.value," "];case"media-value":return Oe(Se(ae.value,je));case"media-keyword":return Se(ae.value,je);case"media-url":return Se(ae.value.replace(/^url\(\s+/gi,"url(").replace(/\s+\)$/g,")"),je);case"media-unknown":return ae.value;case"selector-root":return c([h(Te,"custom-selector")?[f(Te,"css-atrule").customSelector,d]:"",p([",",h(Te,["extend","custom-selector","nest"])?d:y],Te.map(Me,"nodes"))]);case"selector-selector":return c(E(Te.map(Me,"nodes")));case"selector-comment":return ae.value;case"selector-string":return Se(ae.value,je);case"selector-tag":{let Ve=Te.getParentNode(),We=Ve&&Ve.nodes.indexOf(ae),Xe=We&&Ve.nodes[We-1];return[ae.namespace?[ae.namespace===!0?"":ae.namespace.trim(),"|"]:"",Xe.type==="selector-nesting"?ae.value:Oe(x(Te,ae.value)?ae.value.toLowerCase():ae.value)]}case"selector-id":return["#",ae.value];case"selector-class":return[".",Oe(Se(ae.value,je))];case"selector-attribute":{var nt;return["[",ae.namespace?[ae.namespace===!0?"":ae.namespace.trim(),"|"]:"",ae.attribute.trim(),(nt=ae.operator)!==null&&nt!==void 0?nt:"",ae.value?Ie(Se(ae.value.trim(),je),je):"",ae.insensitive?" i":"","]"]}case"selector-combinator":{if(ae.value==="+"||ae.value===">"||ae.value==="~"||ae.value===">>>"){let Xe=Te.getParentNode();return[Xe.type==="selector-selector"&&Xe.nodes[0]===ae?"":d,ae.value,B(Te,ae)?"":" "]}let Ve=ae.value.trim().startsWith("(")?d:"",We=Oe(Se(ae.value.trim(),je))||d;return[Ve,We]}case"selector-universal":return[ae.namespace?[ae.namespace===!0?"":ae.namespace.trim(),"|"]:"",ae.value];case"selector-pseudo":return[m(ae.value),l(ae.nodes)?c(["(",E([g,p([",",d],Te.map(Me,"nodes"))]),g,")"]):""];case"selector-nesting":return ae.value;case"selector-unknown":{let Ve=f(Te,"css-rule");if(Ve&&Ve.isSCSSNesterProperty)return Oe(Se(m(ae.value),je));let We=Te.getParentNode();if(We.raws&&We.raws.selector){let st=Ae(We),O=st+We.raws.selector.length;return je.originalText.slice(st,O).trim()}let Xe=Te.getParentNode(1);if(We.type==="value-paren_group"&&Xe&&Xe.type==="value-func"&&Xe.value==="selector"){let st=Ce(We.open)+1,O=Ae(We.close),me=je.originalText.slice(st,O).trim();return H(me)?[F,me]:me}return ae.value}case"value-value":case"value-root":return Me("group");case"value-comment":return je.originalText.slice(Ae(ae),Ce(ae));case"value-comma_group":{let Ve=Te.getParentNode(),We=Te.getParentNode(1),Xe=T(Te),st=Xe&&Ve.type==="value-value"&&(Xe==="grid"||Xe.startsWith("grid-template")),O=f(Te,"css-atrule"),me=O&&k(O),_e=ae.groups.some(at=>ge(at)),He=Te.map(Me,"groups"),Ge=[],it=v(Te,"url"),Qe=!1,rt=!1;for(let at=0;at<ae.groups.length;++at){var tt;Ge.push(He[at]);let Ze=ae.groups[at-1],Le=ae.groups[at],$e=ae.groups[at+1],sr=ae.groups[at+2];if(it){($e&&Q($e)||Q(Le))&&Ge.push(" ");continue}if(h(Te,"forward")&&Le.type==="value-word"&&Le.value&&Ze!==void 0&&Ze.type==="value-word"&&Ze.value==="as"&&$e.type==="value-operator"&&$e.value==="*"||!$e||Le.type==="value-word"&&Le.value.endsWith("-")&&ce($e))continue;if(Le.type==="value-string"&&Le.quoted){let $r=Le.value.lastIndexOf("#{"),Vr=Le.value.lastIndexOf("}");$r!==-1&&Vr!==-1?Qe=$r>Vr:$r!==-1?Qe=!0:Vr!==-1&&(Qe=!1)}if(Qe||Ne(Le)||Ne($e)||Le.type==="value-atword"&&(Le.value===""||Le.value.endsWith("["))||$e.type==="value-word"&&$e.value.startsWith("]")||Le.value==="~"||Le.value&&Le.value.includes("\\")&&$e&&$e.type!=="value-comment"||Ze&&Ze.value&&Ze.value.indexOf("\\")===Ze.value.length-1&&Le.type==="value-operator"&&Le.value==="/"||Le.value==="\\"||se(Le,$e)||he(Le)||we(Le)||ke($e)||we($e)&&de($e)||ke(Le)&&de($e)||Le.value==="--"&&he($e))continue;let Rr=j(Le),ou=j($e);if((Rr&&he($e)||ou&&ke(Le))&&de($e)||!Ze&&L(Le)||v(Te,"calc")&&(Q(Le)||Q($e)||V(Le)||V($e))&&de($e))continue;let qo=(Q(Le)||V(Le))&&at===0&&($e.type==="value-number"||$e.isHex)&&We&&oe(We)&&!de($e),lu=sr&&sr.type==="value-func"||sr&&Re(sr)||Le.type==="value-func"||Re(Le),cu=$e.type==="value-func"||Re($e)||Ze&&Ze.type==="value-func"||Ze&&Re(Ze);if(!(!(J($e)||J(Le))&&!v(Te,"calc")&&!qo&&(L($e)&&!lu||L(Le)&&!cu||Q($e)&&!lu||Q(Le)&&!cu||V($e)||V(Le))&&(de($e)||Rr&&(!Ze||Ze&&j(Ze))))&&!((je.parser==="scss"||je.parser==="less")&&Rr&&Le.value==="-"&&pe($e)&&Ce(Le)===Ae($e.open)&&$e.open.value==="(")){if(ge(Le)){if(Ve.type==="value-paren_group"){Ge.push(_(y));continue}Ge.push(y);continue}if(me&&(q($e)||R($e)||le($e)||Y(Le)||ie(Le))){Ge.push(" ");continue}if(O&&O.name.toLowerCase()==="namespace"){Ge.push(" ");continue}if(st){Le.source&&$e.source&&Le.source.start.line!==$e.source.start.line?(Ge.push(y),rt=!0):Ge.push(" ");continue}if(ou){Ge.push(" ");continue}if(!($e&&$e.value==="...")&&!(ce(Le)&&ce($e)&&Ce(Le)===Ae($e))){if(ce(Le)&&pe($e)&&Ce(Le)===Ae($e.open)){Ge.push(g);continue}if(Le.value==="with"&&pe($e)){Ge.push(" ");continue}(tt=Le.value)!==null&&tt!==void 0&&tt.endsWith("#")&&$e.value==="{"&&pe($e.group)||Ge.push(d)}}}return _e&&Ge.push(F),rt&&Ge.unshift(y),me?c(E(Ge)):C(Te)?c(D(Ge)):c(E(D(Ge)))}case"value-paren_group":{let Ve=Te.getParentNode();if(Ve&&ee(Ve)&&(ae.groups.length===1||ae.groups.length>0&&ae.groups[0].type==="value-comma_group"&&ae.groups[0].groups.length>0&&ae.groups[0].groups[0].type==="value-word"&&ae.groups[0].groups[0].value.startsWith("data:")))return[ae.open?Me("open"):"",p(",",Te.map(Me,"groups")),ae.close?Me("close"):""];if(!ae.open){let it=Te.map(Me,"groups"),Qe=[];for(let rt=0;rt<it.length;rt++)rt!==0&&Qe.push([",",d]),Qe.push(it[rt]);return c(E(D(Qe)))}let We=De(Te),Xe=t(ae.groups),st=Xe&&Xe.type==="value-comment",O=Fe(ae,Ve),me=X(ae,Ve),_e=me||We&&!O,He=me||O,Ge=c([ae.open?Me("open"):"",E([g,p([d],Te.map((it,Qe)=>{let rt=it.getValue(),at=Qe===ae.groups.length-1,Ze=[Me(),at?"":","];if(ue(rt)&&rt.type==="value-comma_group"&&rt.groups&&rt.groups[0].type!=="value-paren_group"&&rt.groups[2]&&rt.groups[2].type==="value-paren_group"){let Le=N(Ze[0].contents.contents);Le[1]=c(Le[1]),Ze=[c(_(Ze))]}if(!at&&rt.type==="value-comma_group"&&l(rt.groups)){let Le=t(rt.groups);!Le.source&&Le.close&&(Le=Le.close),Le.source&&i(je.originalText,Le,Ce)&&Ze.push(y)}return Ze},"groups"))]),w(!st&&A(je.parser,je.originalText)&&We&&re(je)?",":""),g,ae.close?Me("close"):""],{shouldBreak:_e});return He?_(Ge):Ge}case"value-func":return[ae.value,h(Te,"supports")&&Pe(ae)?" ":"",Me("group")];case"value-paren":return ae.value;case"value-number":return[Je(ae.value),G(ae.unit)];case"value-operator":return ae.value;case"value-word":return ae.isColor&&ae.isHex||b(ae.value)?ae.value.toLowerCase():ae.value;case"value-colon":{let Ve=Te.getParentNode(),We=Ve&&Ve.groups.indexOf(ae),Xe=We&&Ve.groups[We-1];return[ae.value,Xe&&typeof Xe.value=="string"&&t(Xe.value)==="\\"||v(Te,"url")?"":d]}case"value-comma":return[ae.value," "];case"value-string":return a(ae.raws.quote+ae.value+ae.raws.quote,je);case"value-atword":return["@",ae.value];case"value-unicode-range":return ae.value;case"value-unknown":return ae.value;default:throw new Error(`Unknown postcss type ${JSON.stringify(ae.type)}`)}}function Ee(Te,je,Me){let ae=[];return Te.each((nt,tt,Ve)=>{let We=Ve[tt-1];if(We&&We.type==="css-comment"&&We.text.trim()==="prettier-ignore"){let Xe=nt.getValue();ae.push(je.originalText.slice(Ae(Xe),Ce(Xe)))}else ae.push(Me());tt!==Ve.length-1&&(Ve[tt+1].type==="css-comment"&&!n(je.originalText,Ae(Ve[tt+1]),{backwards:!0})&&!u(Ve[tt])||Ve[tt+1].type==="css-atrule"&&Ve[tt+1].name==="else"&&Ve[tt].type!=="css-comment"?ae.push(" "):(ae.push(je.__isHTMLStyleAttribute?d:y),i(je.originalText,nt.getValue(),Ce)&&!u(Ve[tt])&&ae.push(y)))},"nodes"),ae}var Be=/(["'])(?:(?!\1)[^\\]|\\.)*\1/gs,ve=/(?:\d*\.\d+|\d+\.?)(?:[Ee][+-]?\d+)?/g,ze=/[A-Za-z]+/g,be=/[$@]?[A-Z_a-z\u0080-\uFFFF][\w\u0080-\uFFFF-]*/g,Ye=new RegExp(Be.source+`|(${be.source})?(${ve.source})(${ze.source})?`,"g");function Se(Te,je){return Te.replace(Be,Me=>a(Me,je))}function Ie(Te,je){let Me=je.singleQuote?"'":'"';return Te.includes('"')||Te.includes("'")?Te:Me+Te+Me}function Oe(Te){return Te.replace(Ye,(je,Me,ae,nt,tt)=>!ae&&nt?Je(nt)+m(tt||""):je)}function Je(Te){return s(Te).replace(/\.0(?=$|e)/,"")}r.exports={print:ye,embed:P,insertPragma:$,massageAstNode:I}}}),Md=te({"src/language-css/options.js"(e,r){"use strict";ne();var t=Mt();r.exports={singleQuote:t.singleQuote}}}),Rd=te({"src/language-css/parsers.js"(){ne()}}),$d=te({"node_modules/linguist-languages/data/CSS.json"(e,r){r.exports={name:"CSS",type:"markup",tmScope:"source.css",aceMode:"css",codemirrorMode:"css",codemirrorMimeType:"text/css",color:"#563d7c",extensions:[".css"],languageId:50}}}),Vd=te({"node_modules/linguist-languages/data/PostCSS.json"(e,r){r.exports={name:"PostCSS",type:"markup",color:"#dc3a0c",tmScope:"source.postcss",group:"CSS",extensions:[".pcss",".postcss"],aceMode:"text",languageId:262764437}}}),Wd=te({"node_modules/linguist-languages/data/Less.json"(e,r){r.exports={name:"Less",type:"markup",color:"#1d365d",aliases:["less-css"],extensions:[".less"],tmScope:"source.css.less",aceMode:"less",codemirrorMode:"css",codemirrorMimeType:"text/css",languageId:198}}}),Hd=te({"node_modules/linguist-languages/data/SCSS.json"(e,r){r.exports={name:"SCSS",type:"markup",color:"#c6538c",tmScope:"source.css.scss",aceMode:"scss",codemirrorMode:"css",codemirrorMimeType:"text/x-scss",extensions:[".scss"],languageId:329}}}),Gd=te({"src/language-css/index.js"(e,r){"use strict";ne();var t=_t(),s=qd(),a=Md(),n=Rd(),u=[t($d(),l=>({since:"1.4.0",parsers:["css"],vscodeLanguageIds:["css"],extensions:[...l.extensions,".wxss"]})),t(Vd(),()=>({since:"1.4.0",parsers:["css"],vscodeLanguageIds:["postcss"]})),t(Wd(),()=>({since:"1.4.0",parsers:["less"],vscodeLanguageIds:["less"]})),t(Hd(),()=>({since:"1.4.0",parsers:["scss"],vscodeLanguageIds:["scss"]}))],i={postcss:s};r.exports={languages:u,options:a,printers:i,parsers:n}}}),Ud=te({"src/language-handlebars/loc.js"(e,r){"use strict";ne();function t(a){return a.loc.start.offset}function s(a){return a.loc.end.offset}r.exports={locStart:t,locEnd:s}}}),Jd=te({"src/language-handlebars/clean.js"(e,r){"use strict";ne();function t(s,a){if(s.type==="TextNode"){let n=s.chars.trim();if(!n)return null;a.chars=n.replace(/[\t\n\f\r ]+/g," ")}s.type==="AttrNode"&&s.name.toLowerCase()==="class"&&delete a.value}t.ignoredProperties=new Set(["loc","selfClosing"]),r.exports=t}}),zd=te({"vendors/html-void-elements.json"(e,r){r.exports={htmlVoidElements:["area","base","basefont","bgsound","br","col","command","embed","frame","hr","image","img","input","isindex","keygen","link","menuitem","meta","nextid","param","source","track","wbr"]}}}),Xd=te({"src/language-handlebars/utils.js"(e,r){"use strict";ne();var{htmlVoidElements:t}=zd(),s=lt();function a(S){let N=S.getValue(),I=S.getParentNode(0);return!!(y(S,["ElementNode"])&&s(I.children)===N||y(S,["Block"])&&s(I.body)===N)}function n(S){return S.toUpperCase()===S}function u(S){return d(S,["ElementNode"])&&typeof S.tag=="string"&&!S.tag.startsWith(":")&&(n(S.tag[0])||S.tag.includes("."))}var i=new Set(t);function l(S){return i.has(S.tag)||S.selfClosing===!0||u(S)&&S.children.every(N=>p(N))}function p(S){return d(S,["TextNode"])&&!/\S/.test(S.chars)}function d(S,N){return S&&N.includes(S.type)}function y(S,N){let I=S.getParentNode(0);return d(I,N)}function g(S,N){let I=E(S);return d(I,N)}function c(S,N){let I=_(S);return d(I,N)}function D(S,N){var I,P,$,f;let T=S.getValue(),m=(I=S.getParentNode(0))!==null&&I!==void 0?I:{},v=(P=($=(f=m.children)!==null&&f!==void 0?f:m.body)!==null&&$!==void 0?$:m.parts)!==null&&P!==void 0?P:[],o=v.indexOf(T);return o!==-1&&v[o+N]}function E(S){let N=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;return D(S,-N)}function _(S){return D(S,1)}function w(S){return d(S,["MustacheCommentStatement"])&&typeof S.value=="string"&&S.value.trim()==="prettier-ignore"}function F(S){let N=S.getValue(),I=E(S,2);return w(N)||w(I)}r.exports={getNextNode:_,getPreviousNode:E,hasPrettierIgnore:F,isLastNodeOfSiblings:a,isNextNodeOfSomeType:c,isNodeOfSomeType:d,isParentOfSomeType:y,isPreviousNodeOfSomeType:g,isVoid:l,isWhitespaceNode:p}}}),Kd=te({"src/language-handlebars/printer-glimmer.js"(e,r){"use strict";ne();var{builders:{dedent:t,fill:s,group:a,hardline:n,ifBreak:u,indent:i,join:l,line:p,softline:d},utils:{getDocParts:y,replaceTextEndOfLine:g}}=qe(),{getPreferredQuote:c,isNonEmptyArray:D}=Ue(),{locStart:E,locEnd:_}=Ud(),w=Jd(),{getNextNode:F,getPreviousNode:S,hasPrettierIgnore:N,isLastNodeOfSiblings:I,isNextNodeOfSomeType:P,isNodeOfSomeType:$,isParentOfSomeType:f,isPreviousNodeOfSomeType:T,isVoid:m,isWhitespaceNode:v}=Xd(),o=2;function h(H,ce,X){let pe=H.getValue();if(!pe)return"";if(N(H))return ce.originalText.slice(E(pe),_(pe));let Ae=ce.singleQuote?"'":'"';switch(pe.type){case"Block":case"Program":case"Template":return a(H.map(X,"body"));case"ElementNode":{let Ce=a(x(H,X)),fe=ce.htmlWhitespaceSensitivity==="ignore"&&P(H,["ElementNode"])?d:"";if(m(pe))return[Ce,fe];let A=["</",pe.tag,">"];return pe.children.length===0?[Ce,i(A),fe]:ce.htmlWhitespaceSensitivity==="ignore"?[Ce,i(b(H,ce,X)),n,i(A),fe]:[Ce,i(a(b(H,ce,X))),i(A),fe]}case"BlockStatement":{let Ce=H.getParentNode(1);return Ce&&Ce.inverse&&Ce.inverse.body.length===1&&Ce.inverse.body[0]===pe&&Ce.inverse.body[0].path.parts[0]===Ce.path.parts[0]?[ie(H,X,Ce.inverse.body[0].path.parts[0]),de(H,X,ce),ue(H,X,ce)]:[j(H,X),a([de(H,X,ce),ue(H,X,ce),ee(H,X,ce)])]}case"ElementModifierStatement":return a(["{{",Re(H,X),"}}"]);case"MustacheStatement":return a([k(pe),Re(H,X),M(pe)]);case"SubExpression":return a(["(",ke(H,X),d,")"]);case"AttrNode":{let Ce=pe.value.type==="TextNode";if(Ce&&pe.value.chars===""&&E(pe.value)===_(pe.value))return pe.name;let A=Ce?c(pe.value.chars,Ae).quote:pe.value.type==="ConcatStatement"?c(pe.value.parts.filter(re=>re.type==="TextNode").map(re=>re.chars).join(""),Ae).quote:"",G=X("value");return[pe.name,"=",A,pe.name==="class"&&A?a(i(G)):G,A]}case"ConcatStatement":return H.map(X,"parts");case"Hash":return l(p,H.map(X,"pairs"));case"HashPair":return[pe.key,"=",X("value")];case"TextNode":{let Ce=pe.chars.replace(/{{/g,"\\{{"),fe=U(H);if(fe){if(fe==="class"){let Ye=Ce.trim().split(/\s+/).join(" "),Se=!1,Ie=!1;return f(H,["ConcatStatement"])&&(T(H,["MustacheStatement"])&&/^\s/.test(Ce)&&(Se=!0),P(H,["MustacheStatement"])&&/\s$/.test(Ce)&&Ye!==""&&(Ie=!0)),[Se?p:"",Ye,Ie?p:""]}return g(Ce)}let G=/^[\t\n\f\r ]*$/.test(Ce),re=!S(H),ye=!F(H);if(ce.htmlWhitespaceSensitivity!=="ignore"){let Ye=/^[\t\n\f\r ]*/,Se=/[\t\n\f\r ]*$/,Ie=ye&&f(H,["Template"]),Oe=re&&f(H,["Template"]);if(G){if(Oe||Ie)return"";let ae=[p],nt=Z(Ce);return nt&&(ae=ge(nt)),I(H)&&(ae=ae.map(tt=>t(tt))),ae}let[Je]=Ce.match(Ye),[Te]=Ce.match(Se),je=[];if(Je){je=[p];let ae=Z(Je);ae&&(je=ge(ae)),Ce=Ce.replace(Ye,"")}let Me=[];if(Te){if(!Ie){Me=[p];let ae=Z(Te);ae&&(Me=ge(ae)),I(H)&&(Me=Me.map(nt=>t(nt)))}Ce=Ce.replace(Se,"")}return[...je,s(Fe(Ce)),...Me]}let Ee=Z(Ce),Be=se(Ce),ve=De(Ce);if((re||ye)&&G&&f(H,["Block","ElementNode","Template"]))return"";G&&Ee?(Be=Math.min(Ee,o),ve=0):(P(H,["BlockStatement","ElementNode"])&&(ve=Math.max(ve,1)),T(H,["BlockStatement","ElementNode"])&&(Be=Math.max(Be,1)));let ze="",be="";return ve===0&&P(H,["MustacheStatement"])&&(be=" "),Be===0&&T(H,["MustacheStatement"])&&(ze=" "),re&&(Be=0,ze=""),ye&&(ve=0,be=""),Ce=Ce.replace(/^[\t\n\f\r ]+/g,ze).replace(/[\t\n\f\r ]+$/,be),[...ge(Be),s(Fe(Ce)),...ge(ve)]}case"MustacheCommentStatement":{let Ce=E(pe),fe=_(pe),A=ce.originalText.charAt(Ce+2)==="~",G=ce.originalText.charAt(fe-3)==="~",re=pe.value.includes("}}")?"--":"";return["{{",A?"~":"","!",re,pe.value,re,G?"~":"","}}"]}case"PathExpression":return pe.original;case"BooleanLiteral":return String(pe.value);case"CommentStatement":return["<!--",pe.value,"-->"];case"StringLiteral":{if(we(H)){let Ce=ce.singleQuote?'"':"'";return he(pe.value,Ce)}return he(pe.value,Ae)}case"NumberLiteral":return String(pe.value);case"UndefinedLiteral":return"undefined";case"NullLiteral":return"null";default:throw new Error("unknown glimmer type: "+JSON.stringify(pe.type))}}function C(H,ce){return E(H)-E(ce)}function x(H,ce){let X=H.getValue(),pe=["attributes","modifiers","comments"].filter(Ce=>D(X[Ce])),Ae=pe.flatMap(Ce=>X[Ce]).sort(C);for(let Ce of pe)H.each(fe=>{let A=Ae.indexOf(fe.getValue());Ae.splice(A,1,[p,ce()])},Ce);return D(X.blockParams)&&Ae.push(p,oe(X)),["<",X.tag,i(Ae),B(X)]}function b(H,ce,X){let Ae=H.getValue().children.every(Ce=>v(Ce));return ce.htmlWhitespaceSensitivity==="ignore"&&Ae?"":H.map((Ce,fe)=>{let A=X();return fe===0&&ce.htmlWhitespaceSensitivity==="ignore"?[d,A]:A},"children")}function B(H){return m(H)?u([d,"/>"],[" />",d]):u([d,">"],">")}function k(H){let ce=H.escaped===!1?"{{{":"{{",X=H.strip&&H.strip.open?"~":"";return[ce,X]}function M(H){let ce=H.escaped===!1?"}}}":"}}";return[H.strip&&H.strip.close?"~":"",ce]}function R(H){let ce=k(H),X=H.openStrip.open?"~":"";return[ce,X,"#"]}function q(H){let ce=M(H);return[H.openStrip.close?"~":"",ce]}function J(H){let ce=k(H),X=H.closeStrip.open?"~":"";return[ce,X,"/"]}function L(H){let ce=M(H);return[H.closeStrip.close?"~":"",ce]}function Q(H){let ce=k(H),X=H.inverseStrip.open?"~":"";return[ce,X]}function V(H){let ce=M(H);return[H.inverseStrip.close?"~":"",ce]}function j(H,ce){let X=H.getValue(),pe=R(X),Ae=q(X),Ce=[Ne(H,ce)],fe=Pe(H,ce);if(fe&&Ce.push(p,fe),D(X.program.blockParams)){let A=oe(X.program);Ce.push(p,A)}return a([pe,i(Ce),d,Ae])}function Y(H,ce){return[ce.htmlWhitespaceSensitivity==="ignore"?n:"",Q(H),"else",V(H)]}function ie(H,ce,X){let pe=H.getValue(),Ae=[];D(pe.program.blockParams)&&(Ae=[p,oe(pe.program)]);let Ce=H.getParentNode(1);return a([Q(Ce),i(a([a(["else",p,X]),p,Pe(H,ce)])),i(Ae),d,V(Ce)])}function ee(H,ce,X){let pe=H.getValue();return X.htmlWhitespaceSensitivity==="ignore"?[le(pe)?d:n,J(pe),ce("path"),L(pe)]:[J(pe),ce("path"),L(pe)]}function le(H){return $(H,["BlockStatement"])&&H.program.body.every(ce=>v(ce))}function W(H){return K(H)&&H.inverse.body.length===1&&$(H.inverse.body[0],["BlockStatement"])&&H.inverse.body[0].path.parts[0]===H.path.parts[0]}function K(H){return $(H,["BlockStatement"])&&H.inverse}function de(H,ce,X){let pe=H.getValue();if(le(pe))return"";let Ae=ce("program");return X.htmlWhitespaceSensitivity==="ignore"?i([n,Ae]):i(Ae)}function ue(H,ce,X){let pe=H.getValue(),Ae=ce("inverse"),Ce=X.htmlWhitespaceSensitivity==="ignore"?[n,Ae]:Ae;return W(pe)?Ce:K(pe)?[Y(pe,X),i(Ce)]:""}function Fe(H){return y(l(p,z(H)))}function z(H){return H.split(/[\t\n\f\r ]+/)}function U(H){for(let ce=0;ce<2;ce++){let X=H.getParentNode(ce);if(X&&X.type==="AttrNode")return X.name.toLowerCase()}}function Z(H){return H=typeof H=="string"?H:"",H.split(`
`).length-1}function se(H){H=typeof H=="string"?H:"";let ce=(H.match(/^([^\S\n\r]*[\n\r])+/g)||[])[0]||"";return Z(ce)}function De(H){H=typeof H=="string"?H:"";let ce=(H.match(/([\n\r][^\S\n\r]*)+$/g)||[])[0]||"";return Z(ce)}function ge(){let H=arguments.length>0&&arguments[0]!==void 0?arguments[0]:0;return Array.from({length:Math.min(H,o)}).fill(n)}function he(H,ce){let{quote:X,regex:pe}=c(H,ce);return[X,H.replace(pe,`\\${X}`),X]}function we(H){let ce=0,X=H.getParentNode(ce);for(;X&&$(X,["SubExpression"]);)ce++,X=H.getParentNode(ce);return!!(X&&$(H.getParentNode(ce+1),["ConcatStatement"])&&$(H.getParentNode(ce+2),["AttrNode"]))}function ke(H,ce){let X=Ne(H,ce),pe=Pe(H,ce);return pe?i([X,p,a(pe)]):X}function Re(H,ce){let X=Ne(H,ce),pe=Pe(H,ce);return pe?[i([X,p,pe]),d]:X}function Ne(H,ce){return ce("path")}function Pe(H,ce){let X=H.getValue(),pe=[];if(X.params.length>0){let Ae=H.map(ce,"params");pe.push(...Ae)}if(X.hash&&X.hash.pairs.length>0){let Ae=ce("hash");pe.push(Ae)}return pe.length===0?"":l(p,pe)}function oe(H){return["as |",H.blockParams.join(" "),"|"]}r.exports={print:h,massageAstNode:w}}}),Yd=te({"src/language-handlebars/parsers.js"(){ne()}}),Qd=te({"node_modules/linguist-languages/data/Handlebars.json"(e,r){r.exports={name:"Handlebars",type:"markup",color:"#f7931e",aliases:["hbs","htmlbars"],extensions:[".handlebars",".hbs"],tmScope:"text.html.handlebars",aceMode:"handlebars",languageId:155}}}),Zd=te({"src/language-handlebars/index.js"(e,r){"use strict";ne();var t=_t(),s=Kd(),a=Yd(),n=[t(Qd(),()=>({since:"2.3.0",parsers:["glimmer"],vscodeLanguageIds:["handlebars"]}))],u={glimmer:s};r.exports={languages:n,printers:u,parsers:a}}}),eg=te({"src/language-graphql/pragma.js"(e,r){"use strict";ne();function t(a){return/^\s*#[^\S\n]*@(?:format|prettier)\s*(?:\n|$)/.test(a)}function s(a){return`# @format

`+a}r.exports={hasPragma:t,insertPragma:s}}}),tg=te({"src/language-graphql/loc.js"(e,r){"use strict";ne();function t(a){return typeof a.start=="number"?a.start:a.loc&&a.loc.start}function s(a){return typeof a.end=="number"?a.end:a.loc&&a.loc.end}r.exports={locStart:t,locEnd:s}}}),rg=te({"src/language-graphql/printer-graphql.js"(e,r){"use strict";ne();var{builders:{join:t,hardline:s,line:a,softline:n,group:u,indent:i,ifBreak:l}}=qe(),{isNextLineEmpty:p,isNonEmptyArray:d}=Ue(),{insertPragma:y}=eg(),{locStart:g,locEnd:c}=tg();function D(P,$,f){let T=P.getValue();if(!T)return"";if(typeof T=="string")return T;switch(T.kind){case"Document":{let m=[];return P.each((v,o,h)=>{m.push(f()),o!==h.length-1&&(m.push(s),p($.originalText,v.getValue(),c)&&m.push(s))},"definitions"),[...m,s]}case"OperationDefinition":{let m=$.originalText[g(T)]!=="{",v=Boolean(T.name);return[m?T.operation:"",m&&v?[" ",f("name")]:"",m&&!v&&d(T.variableDefinitions)?" ":"",d(T.variableDefinitions)?u(["(",i([n,t([l("",", "),n],P.map(f,"variableDefinitions"))]),n,")"]):"",E(P,f,T),T.selectionSet?!m&&!v?"":" ":"",f("selectionSet")]}case"FragmentDefinition":return["fragment ",f("name"),d(T.variableDefinitions)?u(["(",i([n,t([l("",", "),n],P.map(f,"variableDefinitions"))]),n,")"]):""," on ",f("typeCondition"),E(P,f,T)," ",f("selectionSet")];case"SelectionSet":return["{",i([s,t(s,_(P,$,f,"selections"))]),s,"}"];case"Field":return u([T.alias?[f("alias"),": "]:"",f("name"),T.arguments.length>0?u(["(",i([n,t([l("",", "),n],_(P,$,f,"arguments"))]),n,")"]):"",E(P,f,T),T.selectionSet?" ":"",f("selectionSet")]);case"Name":return T.value;case"StringValue":{if(T.block){let m=T.value.replace(/"""/g,"\\$&").split(`
`);return m.length===1&&(m[0]=m[0].trim()),m.every(v=>v==="")&&(m.length=0),t(s,['"""',...m,'"""'])}return['"',T.value.replace(/["\\]/g,"\\$&").replace(/\n/g,"\\n"),'"']}case"IntValue":case"FloatValue":case"EnumValue":return T.value;case"BooleanValue":return T.value?"true":"false";case"NullValue":return"null";case"Variable":return["$",f("name")];case"ListValue":return u(["[",i([n,t([l("",", "),n],P.map(f,"values"))]),n,"]"]);case"ObjectValue":return u(["{",$.bracketSpacing&&T.fields.length>0?" ":"",i([n,t([l("",", "),n],P.map(f,"fields"))]),n,l("",$.bracketSpacing&&T.fields.length>0?" ":""),"}"]);case"ObjectField":case"Argument":return[f("name"),": ",f("value")];case"Directive":return["@",f("name"),T.arguments.length>0?u(["(",i([n,t([l("",", "),n],_(P,$,f,"arguments"))]),n,")"]):""];case"NamedType":return f("name");case"VariableDefinition":return[f("variable"),": ",f("type"),T.defaultValue?[" = ",f("defaultValue")]:"",E(P,f,T)];case"ObjectTypeExtension":case"ObjectTypeDefinition":return[f("description"),T.description?s:"",T.kind==="ObjectTypeExtension"?"extend ":"","type ",f("name"),T.interfaces.length>0?[" implements ",...S(P,$,f)]:"",E(P,f,T),T.fields.length>0?[" {",i([s,t(s,_(P,$,f,"fields"))]),s,"}"]:""];case"FieldDefinition":return[f("description"),T.description?s:"",f("name"),T.arguments.length>0?u(["(",i([n,t([l("",", "),n],_(P,$,f,"arguments"))]),n,")"]):"",": ",f("type"),E(P,f,T)];case"DirectiveDefinition":return[f("description"),T.description?s:"","directive ","@",f("name"),T.arguments.length>0?u(["(",i([n,t([l("",", "),n],_(P,$,f,"arguments"))]),n,")"]):"",T.repeatable?" repeatable":""," on ",t(" | ",P.map(f,"locations"))];case"EnumTypeExtension":case"EnumTypeDefinition":return[f("description"),T.description?s:"",T.kind==="EnumTypeExtension"?"extend ":"","enum ",f("name"),E(P,f,T),T.values.length>0?[" {",i([s,t(s,_(P,$,f,"values"))]),s,"}"]:""];case"EnumValueDefinition":return[f("description"),T.description?s:"",f("name"),E(P,f,T)];case"InputValueDefinition":return[f("description"),T.description?T.description.block?s:a:"",f("name"),": ",f("type"),T.defaultValue?[" = ",f("defaultValue")]:"",E(P,f,T)];case"InputObjectTypeExtension":case"InputObjectTypeDefinition":return[f("description"),T.description?s:"",T.kind==="InputObjectTypeExtension"?"extend ":"","input ",f("name"),E(P,f,T),T.fields.length>0?[" {",i([s,t(s,_(P,$,f,"fields"))]),s,"}"]:""];case"SchemaExtension":return["extend schema",E(P,f,T),...T.operationTypes.length>0?[" {",i([s,t(s,_(P,$,f,"operationTypes"))]),s,"}"]:[]];case"SchemaDefinition":return[f("description"),T.description?s:"","schema",E(P,f,T)," {",T.operationTypes.length>0?i([s,t(s,_(P,$,f,"operationTypes"))]):"",s,"}"];case"OperationTypeDefinition":return[f("operation"),": ",f("type")];case"InterfaceTypeExtension":case"InterfaceTypeDefinition":return[f("description"),T.description?s:"",T.kind==="InterfaceTypeExtension"?"extend ":"","interface ",f("name"),T.interfaces.length>0?[" implements ",...S(P,$,f)]:"",E(P,f,T),T.fields.length>0?[" {",i([s,t(s,_(P,$,f,"fields"))]),s,"}"]:""];case"FragmentSpread":return["...",f("name"),E(P,f,T)];case"InlineFragment":return["...",T.typeCondition?[" on ",f("typeCondition")]:"",E(P,f,T)," ",f("selectionSet")];case"UnionTypeExtension":case"UnionTypeDefinition":return u([f("description"),T.description?s:"",u([T.kind==="UnionTypeExtension"?"extend ":"","union ",f("name"),E(P,f,T),T.types.length>0?[" =",l(""," "),i([l([a,"  "]),t([a,"| "],P.map(f,"types"))])]:""])]);case"ScalarTypeExtension":case"ScalarTypeDefinition":return[f("description"),T.description?s:"",T.kind==="ScalarTypeExtension"?"extend ":"","scalar ",f("name"),E(P,f,T)];case"NonNullType":return[f("type"),"!"];case"ListType":return["[",f("type"),"]"];default:throw new Error("unknown graphql type: "+JSON.stringify(T.kind))}}function E(P,$,f){if(f.directives.length===0)return"";let T=t(a,P.map($,"directives"));return f.kind==="FragmentDefinition"||f.kind==="OperationDefinition"?u([a,T]):[" ",u(i([n,T]))]}function _(P,$,f,T){return P.map((m,v,o)=>{let h=f();return v<o.length-1&&p($.originalText,m.getValue(),c)?[h,s]:h},T)}function w(P){return P.kind&&P.kind!=="Comment"}function F(P){let $=P.getValue();if($.kind==="Comment")return"#"+$.value.trimEnd();throw new Error("Not a comment: "+JSON.stringify($))}function S(P,$,f){let T=P.getNode(),m=[],{interfaces:v}=T,o=P.map(h=>f(h),"interfaces");for(let h=0;h<v.length;h++){let C=v[h];m.push(o[h]);let x=v[h+1];if(x){let b=$.originalText.slice(C.loc.end,x.loc.start),B=b.includes("#"),k=b.replace(/#.*/g,"").trim();m.push(k===","?",":" &",B?a:" ")}}return m}function N(P,$){P.kind==="StringValue"&&P.block&&!P.value.includes(`
`)&&($.value=$.value.trim())}N.ignoredProperties=new Set(["loc","comments"]);function I(P){var $;let f=P.getValue();return f==null||($=f.comments)===null||$===void 0?void 0:$.some(T=>T.value.trim()==="prettier-ignore")}r.exports={print:D,massageAstNode:N,hasPrettierIgnore:I,insertPragma:y,printComment:F,canAttachComment:w}}}),ng=te({"src/language-graphql/options.js"(e,r){"use strict";ne();var t=Mt();r.exports={bracketSpacing:t.bracketSpacing}}}),ug=te({"src/language-graphql/parsers.js"(){ne()}}),sg=te({"node_modules/linguist-languages/data/GraphQL.json"(e,r){r.exports={name:"GraphQL",type:"data",color:"#e10098",extensions:[".graphql",".gql",".graphqls"],tmScope:"source.graphql",aceMode:"text",languageId:139}}}),ig=te({"src/language-graphql/index.js"(e,r){"use strict";ne();var t=_t(),s=rg(),a=ng(),n=ug(),u=[t(sg(),()=>({since:"1.5.0",parsers:["graphql"],vscodeLanguageIds:["graphql"]}))],i={graphql:s};r.exports={languages:u,options:a,printers:i,parsers:n}}}),Po=te({"node_modules/collapse-white-space/index.js"(e,r){"use strict";ne(),r.exports=t;function t(s){return String(s).replace(/\s+/g," ")}}}),Io=te({"src/language-markdown/loc.js"(e,r){"use strict";ne();function t(a){return a.position.start.offset}function s(a){return a.position.end.offset}r.exports={locStart:t,locEnd:s}}}),ag=te({"src/language-markdown/constants.evaluate.js"(e,r){r.exports={cjkPattern:"(?:[\\u02ea-\\u02eb\\u1100-\\u11ff\\u2e80-\\u2e99\\u2e9b-\\u2ef3\\u2f00-\\u2fd5\\u2ff0-\\u303f\\u3041-\\u3096\\u3099-\\u309f\\u30a1-\\u30fa\\u30fc-\\u30ff\\u3105-\\u312f\\u3131-\\u318e\\u3190-\\u3191\\u3196-\\u31ba\\u31c0-\\u31e3\\u31f0-\\u321e\\u322a-\\u3247\\u3260-\\u327e\\u328a-\\u32b0\\u32c0-\\u32cb\\u32d0-\\u3370\\u337b-\\u337f\\u33e0-\\u33fe\\u3400-\\u4db5\\u4e00-\\u9fef\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\uf900-\\ufa6d\\ufa70-\\ufad9\\ufe10-\\ufe1f\\ufe30-\\ufe6f\\uff00-\\uffef]|[\\ud840-\\ud868\\ud86a-\\ud86c\\ud86f-\\ud872\\ud874-\\ud879][\\udc00-\\udfff]|\\ud82c[\\udc00-\\udd1e\\udd50-\\udd52\\udd64-\\udd67]|\\ud83c[\\ude00\\ude50-\\ude51]|\\ud869[\\udc00-\\uded6\\udf00-\\udfff]|\\ud86d[\\udc00-\\udf34\\udf40-\\udfff]|\\ud86e[\\udc00-\\udc1d\\udc20-\\udfff]|\\ud873[\\udc00-\\udea1\\udeb0-\\udfff]|\\ud87a[\\udc00-\\udfe0]|\\ud87e[\\udc00-\\ude1d])(?:[\\ufe00-\\ufe0f]|\\udb40[\\udd00-\\uddef])?",kPattern:"[\\u1100-\\u11ff\\u3001-\\u3003\\u3008-\\u3011\\u3013-\\u301f\\u302e-\\u3030\\u3037\\u30fb\\u3131-\\u318e\\u3200-\\u321e\\u3260-\\u327e\\ua960-\\ua97c\\uac00-\\ud7a3\\ud7b0-\\ud7c6\\ud7cb-\\ud7fb\\ufe45-\\ufe46\\uff61-\\uff65\\uffa0-\\uffbe\\uffc2-\\uffc7\\uffca-\\uffcf\\uffd2-\\uffd7\\uffda-\\uffdc]",punctuationPattern:"[\\u0021-\\u002f\\u003a-\\u0040\\u005b-\\u0060\\u007b-\\u007e\\u00a1\\u00a7\\u00ab\\u00b6-\\u00b7\\u00bb\\u00bf\\u037e\\u0387\\u055a-\\u055f\\u0589-\\u058a\\u05be\\u05c0\\u05c3\\u05c6\\u05f3-\\u05f4\\u0609-\\u060a\\u060c-\\u060d\\u061b\\u061e-\\u061f\\u066a-\\u066d\\u06d4\\u0700-\\u070d\\u07f7-\\u07f9\\u0830-\\u083e\\u085e\\u0964-\\u0965\\u0970\\u09fd\\u0a76\\u0af0\\u0c77\\u0c84\\u0df4\\u0e4f\\u0e5a-\\u0e5b\\u0f04-\\u0f12\\u0f14\\u0f3a-\\u0f3d\\u0f85\\u0fd0-\\u0fd4\\u0fd9-\\u0fda\\u104a-\\u104f\\u10fb\\u1360-\\u1368\\u1400\\u166e\\u169b-\\u169c\\u16eb-\\u16ed\\u1735-\\u1736\\u17d4-\\u17d6\\u17d8-\\u17da\\u1800-\\u180a\\u1944-\\u1945\\u1a1e-\\u1a1f\\u1aa0-\\u1aa6\\u1aa8-\\u1aad\\u1b5a-\\u1b60\\u1bfc-\\u1bff\\u1c3b-\\u1c3f\\u1c7e-\\u1c7f\\u1cc0-\\u1cc7\\u1cd3\\u2010-\\u2027\\u2030-\\u2043\\u2045-\\u2051\\u2053-\\u205e\\u207d-\\u207e\\u208d-\\u208e\\u2308-\\u230b\\u2329-\\u232a\\u2768-\\u2775\\u27c5-\\u27c6\\u27e6-\\u27ef\\u2983-\\u2998\\u29d8-\\u29db\\u29fc-\\u29fd\\u2cf9-\\u2cfc\\u2cfe-\\u2cff\\u2d70\\u2e00-\\u2e2e\\u2e30-\\u2e4f\\u3001-\\u3003\\u3008-\\u3011\\u3014-\\u301f\\u3030\\u303d\\u30a0\\u30fb\\ua4fe-\\ua4ff\\ua60d-\\ua60f\\ua673\\ua67e\\ua6f2-\\ua6f7\\ua874-\\ua877\\ua8ce-\\ua8cf\\ua8f8-\\ua8fa\\ua8fc\\ua92e-\\ua92f\\ua95f\\ua9c1-\\ua9cd\\ua9de-\\ua9df\\uaa5c-\\uaa5f\\uaade-\\uaadf\\uaaf0-\\uaaf1\\uabeb\\ufd3e-\\ufd3f\\ufe10-\\ufe19\\ufe30-\\ufe52\\ufe54-\\ufe61\\ufe63\\ufe68\\ufe6a-\\ufe6b\\uff01-\\uff03\\uff05-\\uff0a\\uff0c-\\uff0f\\uff1a-\\uff1b\\uff1f-\\uff20\\uff3b-\\uff3d\\uff3f\\uff5b\\uff5d\\uff5f-\\uff65]|\\ud800[\\udd00-\\udd02\\udf9f\\udfd0]|\\ud801[\\udd6f]|\\ud802[\\udc57\\udd1f\\udd3f\\ude50-\\ude58\\ude7f\\udef0-\\udef6\\udf39-\\udf3f\\udf99-\\udf9c]|\\ud803[\\udf55-\\udf59]|\\ud804[\\udc47-\\udc4d\\udcbb-\\udcbc\\udcbe-\\udcc1\\udd40-\\udd43\\udd74-\\udd75\\uddc5-\\uddc8\\uddcd\\udddb\\udddd-\\udddf\\ude38-\\ude3d\\udea9]|\\ud805[\\udc4b-\\udc4f\\udc5b\\udc5d\\udcc6\\uddc1-\\uddd7\\ude41-\\ude43\\ude60-\\ude6c\\udf3c-\\udf3e]|\\ud806[\\udc3b\\udde2\\ude3f-\\ude46\\ude9a-\\ude9c\\ude9e-\\udea2]|\\ud807[\\udc41-\\udc45\\udc70-\\udc71\\udef7-\\udef8\\udfff]|\\ud809[\\udc70-\\udc74]|\\ud81a[\\ude6e-\\ude6f\\udef5\\udf37-\\udf3b\\udf44]|\\ud81b[\\ude97-\\ude9a\\udfe2]|\\ud82f[\\udc9f]|\\ud836[\\ude87-\\ude8b]|\\ud83a[\\udd5e-\\udd5f]"}}}),iu=te({"src/language-markdown/utils.js"(e,r){"use strict";ne();var{getLast:t}=Ue(),{locStart:s,locEnd:a}=Io(),{cjkPattern:n,kPattern:u,punctuationPattern:i}=ag(),l=["liquidNode","inlineCode","emphasis","esComment","strong","delete","wikiLink","link","linkReference","image","imageReference","footnote","footnoteReference","sentence","whitespace","word","break","inlineMath"],p=[...l,"tableCell","paragraph","heading"],d=new RegExp(u),y=new RegExp(i);function g(F,S){let N="non-cjk",I="cj-letter",P="k-letter",$="cjk-punctuation",f=[],T=(S.proseWrap==="preserve"?F:F.replace(new RegExp(`(${n})
(${n})`,"g"),"$1$2")).split(/([\t\n ]+)/);for(let[v,o]of T.entries()){if(v%2===1){f.push({type:"whitespace",value:/\n/.test(o)?`
`:" "});continue}if((v===0||v===T.length-1)&&o==="")continue;let h=o.split(new RegExp(`(${n})`));for(let[C,x]of h.entries())if(!((C===0||C===h.length-1)&&x==="")){if(C%2===0){x!==""&&m({type:"word",value:x,kind:N,hasLeadingPunctuation:y.test(x[0]),hasTrailingPunctuation:y.test(t(x))});continue}m(y.test(x)?{type:"word",value:x,kind:$,hasLeadingPunctuation:!0,hasTrailingPunctuation:!0}:{type:"word",value:x,kind:d.test(x)?P:I,hasLeadingPunctuation:!1,hasTrailingPunctuation:!1})}}return f;function m(v){let o=t(f);o&&o.type==="word"&&(o.kind===N&&v.kind===I&&!o.hasTrailingPunctuation||o.kind===I&&v.kind===N&&!v.hasLeadingPunctuation?f.push({type:"whitespace",value:" "}):!h(N,$)&&![o.value,v.value].some(C=>/\u3000/.test(C))&&f.push({type:"whitespace",value:""})),f.push(v);function h(C,x){return o.kind===C&&v.kind===x||o.kind===x&&v.kind===C}}}function c(F,S){let[,N,I,P]=S.slice(F.position.start.offset,F.position.end.offset).match(/^\s*(\d+)(\.|\))(\s*)/);return{numberText:N,marker:I,leadingSpaces:P}}function D(F,S){if(!F.ordered||F.children.length<2)return!1;let N=Number(c(F.children[0],S.originalText).numberText),I=Number(c(F.children[1],S.originalText).numberText);if(N===0&&F.children.length>2){let P=Number(c(F.children[2],S.originalText).numberText);return I===1&&P===1}return I===1}function E(F,S){let{value:N}=F;return F.position.end.offset===S.length&&N.endsWith(`
`)&&S.endsWith(`
`)?N.slice(0,-1):N}function _(F,S){return function N(I,P,$){let f=Object.assign({},S(I,P,$));return f.children&&(f.children=f.children.map((T,m)=>N(T,m,[f,...$]))),f}(F,null,[])}function w(F){if((F==null?void 0:F.type)!=="link"||F.children.length!==1)return!1;let[S]=F.children;return s(F)===s(S)&&a(F)===a(S)}r.exports={mapAst:_,splitText:g,punctuationPattern:i,getFencedCodeBlockValue:E,getOrderedListItemInfo:c,hasGitDiffFriendlyOrderedList:D,INLINE_NODE_TYPES:l,INLINE_NODE_WRAPPER_TYPES:p,isAutolink:w}}}),og=te({"src/language-markdown/embed.js"(e,r){"use strict";ne();var{inferParserByLanguage:t,getMaxContinuousCount:s}=Ue(),{builders:{hardline:a,markAsRoot:n},utils:{replaceEndOfLine:u}}=qe(),i=su(),{getFencedCodeBlockValue:l}=iu();function p(d,y,g,c){let D=d.getValue();if(D.type==="code"&&D.lang!==null){let E=t(D.lang,c);if(E){let _=c.__inJsTemplate?"~":"`",w=_.repeat(Math.max(3,s(D.value,_)+1)),F={parser:E};D.lang==="tsx"&&(F.filepath="dummy.tsx");let S=g(l(D,c.originalText),F,{stripTrailingHardline:!0});return n([w,D.lang,D.meta?" "+D.meta:"",a,u(S),a,w])}}switch(D.type){case"front-matter":return i(D,g);case"importExport":return[g(D.value,{parser:"babel"},{stripTrailingHardline:!0}),a];case"jsx":return g(`<$>${D.value}</$>`,{parser:"__js_expression",rootMarker:"mdx"},{stripTrailingHardline:!0})}return null}r.exports=p}}),ko=te({"src/language-markdown/pragma.js"(e,r){"use strict";ne();var t=_o(),s=["format","prettier"];function a(n){let u=`@(${s.join("|")})`,i=new RegExp([`<!--\\s*${u}\\s*-->`,`{\\s*\\/\\*\\s*${u}\\s*\\*\\/\\s*}`,`<!--.*\r?
[\\s\\S]*(^|
)[^\\S
]*${u}[^\\S
]*($|
)[\\s\\S]*
.*-->`].join("|"),"m"),l=n.match(i);return(l==null?void 0:l.index)===0}r.exports={startWithPragma:a,hasPragma:n=>a(t(n).content.trimStart()),insertPragma:n=>{let u=t(n),i=`<!-- @${s[0]} -->`;return u.frontMatter?`${u.frontMatter.raw}

${i}

${u.content}`:`${i}

${u.content}`}}}}),lg=te({"src/language-markdown/print-preprocess.js"(e,r){"use strict";ne();var t=lt(),{getOrderedListItemInfo:s,mapAst:a,splitText:n}=iu(),u=/^.$/su;function i(w,F){return w=d(w,F),w=c(w),w=p(w,F),w=E(w,F),w=_(w,F),w=D(w,F),w=l(w),w=y(w),w}function l(w){return a(w,F=>F.type!=="import"&&F.type!=="export"?F:Object.assign(Object.assign({},F),{},{type:"importExport"}))}function p(w,F){return a(w,S=>S.type!=="inlineCode"||F.proseWrap==="preserve"?S:Object.assign(Object.assign({},S),{},{value:S.value.replace(/\s+/g," ")}))}function d(w,F){return a(w,S=>S.type!=="text"||S.value==="*"||S.value==="_"||!u.test(S.value)||S.position.end.offset-S.position.start.offset===S.value.length?S:Object.assign(Object.assign({},S),{},{value:F.originalText.slice(S.position.start.offset,S.position.end.offset)}))}function y(w){return g(w,(F,S)=>F.type==="importExport"&&S.type==="importExport",(F,S)=>({type:"importExport",value:F.value+`

`+S.value,position:{start:F.position.start,end:S.position.end}}))}function g(w,F,S){return a(w,N=>{if(!N.children)return N;let I=N.children.reduce((P,$)=>{let f=t(P);return f&&F(f,$)?P.splice(-1,1,S(f,$)):P.push($),P},[]);return Object.assign(Object.assign({},N),{},{children:I})})}function c(w){return g(w,(F,S)=>F.type==="text"&&S.type==="text",(F,S)=>({type:"text",value:F.value+S.value,position:{start:F.position.start,end:S.position.end}}))}function D(w,F){return a(w,(S,N,I)=>{let[P]=I;if(S.type!=="text")return S;let{value:$}=S;return P.type==="paragraph"&&(N===0&&($=$.trimStart()),N===P.children.length-1&&($=$.trimEnd())),{type:"sentence",position:S.position,children:n($,F)}})}function E(w,F){return a(w,(S,N,I)=>{if(S.type==="code"){let P=/^\n?(?: {4,}|\t)/.test(F.originalText.slice(S.position.start.offset,S.position.end.offset));if(S.isIndented=P,P)for(let $=0;$<I.length;$++){let f=I[$];if(f.hasIndentedCodeblock)break;f.type==="list"&&(f.hasIndentedCodeblock=!0)}}return S})}function _(w,F){return a(w,(I,P,$)=>{if(I.type==="list"&&I.children.length>0){for(let f=0;f<$.length;f++){let T=$[f];if(T.type==="list"&&!T.isAligned)return I.isAligned=!1,I}I.isAligned=N(I)}return I});function S(I){return I.children.length===0?-1:I.children[0].position.start.column-1}function N(I){if(!I.ordered)return!0;let[P,$]=I.children;if(s(P,F.originalText).leadingSpaces.length>1)return!0;let T=S(P);if(T===-1)return!1;if(I.children.length===1)return T%F.tabWidth===0;let m=S($);return T!==m?!1:T%F.tabWidth===0?!0:s($,F.originalText).leadingSpaces.length>1}}r.exports=i}}),cg=te({"src/language-markdown/clean.js"(e,r){"use strict";ne();var t=Po(),{isFrontMatterNode:s}=Ue(),{startWithPragma:a}=ko(),n=new Set(["position","raw"]);function u(i,l,p){if((i.type==="front-matter"||i.type==="code"||i.type==="yaml"||i.type==="import"||i.type==="export"||i.type==="jsx")&&delete l.value,i.type==="list"&&delete l.isAligned,(i.type==="list"||i.type==="listItem")&&(delete l.spread,delete l.loose),i.type==="text"||(i.type==="inlineCode"&&(l.value=i.value.replace(/[\t\n ]+/g," ")),i.type==="wikiLink"&&(l.value=i.value.trim().replace(/[\t\n]+/g," ")),(i.type==="definition"||i.type==="linkReference"||i.type==="imageReference")&&(l.label=t(i.label)),(i.type==="definition"||i.type==="link"||i.type==="image")&&i.title&&(l.title=i.title.replace(/\\(["')])/g,"$1")),p&&p.type==="root"&&p.children.length>0&&(p.children[0]===i||s(p.children[0])&&p.children[1]===i)&&i.type==="html"&&a(i.value)))return null}u.ignoredProperties=n,r.exports=u}}),pg=te({"src/language-markdown/printer-markdown.js"(e,r){"use strict";ne();var t=Po(),{getLast:s,getMinNotPresentContinuousCount:a,getMaxContinuousCount:n,getStringWidth:u,isNonEmptyArray:i}=Ue(),{builders:{breakParent:l,join:p,line:d,literalline:y,markAsRoot:g,hardline:c,softline:D,ifBreak:E,fill:_,align:w,indent:F,group:S,hardlineWithoutBreakParent:N},utils:{normalizeDoc:I,replaceTextEndOfLine:P},printer:{printDocToString:$}}=qe(),f=og(),{insertPragma:T}=ko(),{locStart:m,locEnd:v}=Io(),o=lg(),h=cg(),{getFencedCodeBlockValue:C,hasGitDiffFriendlyOrderedList:x,splitText:b,punctuationPattern:B,INLINE_NODE_TYPES:k,INLINE_NODE_WRAPPER_TYPES:M,isAutolink:R}=iu(),q=new Set(["importExport"]),J=["heading","tableCell","link","wikiLink"],L=new Set(["listItem","definition","footnoteDefinition"]);function Q(oe,H,ce){let X=oe.getValue();if(ge(oe))return b(H.originalText.slice(X.position.start.offset,X.position.end.offset),H).map(pe=>pe.type==="word"?pe.value:pe.value===""?"":W(oe,pe.value,H));switch(X.type){case"front-matter":return H.originalText.slice(X.position.start.offset,X.position.end.offset);case"root":return X.children.length===0?"":[I(de(oe,H,ce)),q.has(z(X).type)?"":c];case"paragraph":return ue(oe,H,ce,{postprocessor:_});case"sentence":return ue(oe,H,ce);case"word":{let pe=X.value.replace(/\*/g,"\\$&").replace(new RegExp([`(^|${B})(_+)`,`(_+)(${B}|$)`].join("|"),"g"),(fe,A,G,re,ye)=>(G?`${A}${G}`:`${re}${ye}`).replace(/_/g,"\\_")),Ae=(fe,A,G)=>fe.type==="sentence"&&G===0,Ce=(fe,A,G)=>R(fe.children[G-1]);return pe!==X.value&&(oe.match(void 0,Ae,Ce)||oe.match(void 0,Ae,(fe,A,G)=>fe.type==="emphasis"&&G===0,Ce))&&(pe=pe.replace(/^(\\?[*_])+/,fe=>fe.replace(/\\/g,""))),pe}case"whitespace":{let pe=oe.getParentNode(),Ae=pe.children.indexOf(X),Ce=pe.children[Ae+1],fe=Ce&&/^>|^(?:[*+-]|#{1,6}|\d+[).])$/.test(Ce.value)?"never":H.proseWrap;return W(oe,X.value,{proseWrap:fe})}case"emphasis":{let pe;if(R(X.children[0]))pe=H.originalText[X.position.start.offset];else{let Ae=oe.getParentNode(),Ce=Ae.children.indexOf(X),fe=Ae.children[Ce-1],A=Ae.children[Ce+1];pe=fe&&fe.type==="sentence"&&fe.children.length>0&&s(fe.children).type==="word"&&!s(fe.children).hasTrailingPunctuation||A&&A.type==="sentence"&&A.children.length>0&&A.children[0].type==="word"&&!A.children[0].hasLeadingPunctuation||le(oe,"emphasis")?"*":"_"}return[pe,ue(oe,H,ce),pe]}case"strong":return["**",ue(oe,H,ce),"**"];case"delete":return["~~",ue(oe,H,ce),"~~"];case"inlineCode":{let pe=a(X.value,"`"),Ae="`".repeat(pe||1),Ce=pe&&!/^\s/.test(X.value)?" ":"";return[Ae,Ce,X.value,Ce,Ae]}case"wikiLink":{let pe="";return H.proseWrap==="preserve"?pe=X.value:pe=X.value.replace(/[\t\n]+/g," "),["[[",pe,"]]"]}case"link":switch(H.originalText[X.position.start.offset]){case"<":{let pe="mailto:";return["<",X.url.startsWith(pe)&&H.originalText.slice(X.position.start.offset+1,X.position.start.offset+1+pe.length)!==pe?X.url.slice(pe.length):X.url,">"]}case"[":return["[",ue(oe,H,ce),"](",he(X.url,")"),we(X.title,H),")"];default:return H.originalText.slice(X.position.start.offset,X.position.end.offset)}case"image":return["![",X.alt||"","](",he(X.url,")"),we(X.title,H),")"];case"blockquote":return["> ",w("> ",ue(oe,H,ce))];case"heading":return["#".repeat(X.depth)+" ",ue(oe,H,ce)];case"code":{if(X.isIndented){let Ce=" ".repeat(4);return w(Ce,[Ce,...P(X.value,c)])}let pe=H.__inJsTemplate?"~":"`",Ae=pe.repeat(Math.max(3,n(X.value,pe)+1));return[Ae,X.lang||"",X.meta?" "+X.meta:"",c,...P(C(X,H.originalText),c),c,Ae]}case"html":{let pe=oe.getParentNode(),Ae=pe.type==="root"&&s(pe.children)===X?X.value.trimEnd():X.value,Ce=/^<!--.*-->$/s.test(Ae);return P(Ae,Ce?c:g(y))}case"list":{let pe=Y(X,oe.getParentNode()),Ae=x(X,H);return ue(oe,H,ce,{processor:(Ce,fe)=>{let A=re(),G=Ce.getValue();if(G.children.length===2&&G.children[1].type==="html"&&G.children[0].position.start.column!==G.children[1].position.start.column)return[A,V(Ce,H,ce,A)];return[A,w(" ".repeat(A.length),V(Ce,H,ce,A))];function re(){let ye=X.ordered?(fe===0?X.start:Ae?1:X.start+fe)+(pe%2===0?". ":") "):pe%2===0?"- ":"* ";return X.isAligned||X.hasIndentedCodeblock?j(ye,H):ye}}})}case"thematicBreak":{let pe=ee(oe,"list");return pe===-1?"---":Y(oe.getParentNode(pe),oe.getParentNode(pe+1))%2===0?"***":"---"}case"linkReference":return["[",ue(oe,H,ce),"]",X.referenceType==="full"?Ne(X):X.referenceType==="collapsed"?"[]":""];case"imageReference":switch(X.referenceType){case"full":return["![",X.alt||"","]",Ne(X)];default:return["![",X.alt,"]",X.referenceType==="collapsed"?"[]":""]}case"definition":{let pe=H.proseWrap==="always"?d:" ";return S([Ne(X),":",F([pe,he(X.url),X.title===null?"":[pe,we(X.title,H,!1)]])])}case"footnote":return["[^",ue(oe,H,ce),"]"];case"footnoteReference":return Pe(X);case"footnoteDefinition":{let pe=oe.getParentNode().children[oe.getName()+1],Ae=X.children.length===1&&X.children[0].type==="paragraph"&&(H.proseWrap==="never"||H.proseWrap==="preserve"&&X.children[0].position.start.line===X.children[0].position.end.line);return[Pe(X),": ",Ae?ue(oe,H,ce):S([w(" ".repeat(4),ue(oe,H,ce,{processor:(Ce,fe)=>fe===0?S([D,ce()]):ce()})),pe&&pe.type==="footnoteDefinition"?D:""])]}case"table":return K(oe,H,ce);case"tableCell":return ue(oe,H,ce);case"break":return/\s/.test(H.originalText[X.position.start.offset])?["  ",g(y)]:["\\",c];case"liquidNode":return P(X.value,c);case"importExport":return[X.value,c];case"esComment":return["{/* ",X.value," */}"];case"jsx":return X.value;case"math":return["$$",c,X.value?[...P(X.value,c),c]:"","$$"];case"inlineMath":return H.originalText.slice(m(X),v(X));case"tableRow":case"listItem":default:throw new Error(`Unknown markdown type ${JSON.stringify(X.type)}`)}}function V(oe,H,ce,X){let pe=oe.getValue(),Ae=pe.checked===null?"":pe.checked?"[x] ":"[ ] ";return[Ae,ue(oe,H,ce,{processor:(Ce,fe)=>{if(fe===0&&Ce.getValue().type!=="list")return w(" ".repeat(Ae.length),ce());let A=" ".repeat(ke(H.tabWidth-X.length,0,3));return[A,w(A,ce())]}})]}function j(oe,H){let ce=X();return oe+" ".repeat(ce>=4?0:ce);function X(){let pe=oe.length%H.tabWidth;return pe===0?0:H.tabWidth-pe}}function Y(oe,H){return ie(oe,H,ce=>ce.ordered===oe.ordered)}function ie(oe,H,ce){let X=-1;for(let pe of H.children)if(pe.type===oe.type&&ce(pe)?X++:X=-1,pe===oe)return X}function ee(oe,H){let ce=Array.isArray(H)?H:[H],X=-1,pe;for(;pe=oe.getParentNode(++X);)if(ce.includes(pe.type))return X;return-1}function le(oe,H){let ce=ee(oe,H);return ce===-1?null:oe.getParentNode(ce)}function W(oe,H,ce){if(ce.proseWrap==="preserve"&&H===`
`)return c;let X=ce.proseWrap==="always"&&!le(oe,J);return H!==""?X?d:" ":X?D:""}function K(oe,H,ce){let X=oe.getValue(),pe=[],Ae=oe.map(ye=>ye.map((Ee,Be)=>{let ve=$(ce(),H).formatted,ze=u(ve);return pe[Be]=Math.max(pe[Be]||3,ze),{text:ve,width:ze}},"children"),"children"),Ce=A(!1);if(H.proseWrap!=="never")return[l,Ce];let fe=A(!0);return[l,S(E(fe,Ce))];function A(ye){let Ee=[re(Ae[0],ye),G(ye)];return Ae.length>1&&Ee.push(p(N,Ae.slice(1).map(Be=>re(Be,ye)))),p(N,Ee)}function G(ye){return`| ${pe.map((Be,ve)=>{let ze=X.align[ve],be=ze==="center"||ze==="left"?":":"-",Ye=ze==="center"||ze==="right"?":":"-",Se=ye?"-":"-".repeat(Be-2);return`${be}${Se}${Ye}`}).join(" | ")} |`}function re(ye,Ee){return`| ${ye.map((ve,ze)=>{let{text:be,width:Ye}=ve;if(Ee)return be;let Se=pe[ze]-Ye,Ie=X.align[ze],Oe=0;Ie==="right"?Oe=Se:Ie==="center"&&(Oe=Math.floor(Se/2));let Je=Se-Oe;return`${" ".repeat(Oe)}${be}${" ".repeat(Je)}`}).join(" | ")} |`}}function de(oe,H,ce){let X=[],pe=null,{children:Ae}=oe.getValue();for(let[Ce,fe]of Ae.entries())switch(U(fe)){case"start":pe===null&&(pe={index:Ce,offset:fe.position.end.offset});break;case"end":pe!==null&&(X.push({start:pe,end:{index:Ce,offset:fe.position.start.offset}}),pe=null);break;default:break}return ue(oe,H,ce,{processor:(Ce,fe)=>{if(X.length>0){let A=X[0];if(fe===A.start.index)return[Fe(Ae[A.start.index]),H.originalText.slice(A.start.offset,A.end.offset),Fe(Ae[A.end.index])];if(A.start.index<fe&&fe<A.end.index)return!1;if(fe===A.end.index)return X.shift(),!1}return ce()}})}function ue(oe,H,ce){let X=arguments.length>3&&arguments[3]!==void 0?arguments[3]:{},{postprocessor:pe}=X,Ae=X.processor||(()=>ce()),Ce=oe.getValue(),fe=[],A;return oe.each((G,re)=>{let ye=G.getValue(),Ee=Ae(G,re);if(Ee!==!1){let Be={parts:fe,prevNode:A,parentNode:Ce,options:H};Z(ye,Be)&&(fe.push(c),A&&q.has(A.type)||(se(ye,Be)||De(ye,Be))&&fe.push(c),De(ye,Be)&&fe.push(c)),fe.push(Ee),A=ye}},"children"),pe?pe(fe):fe}function Fe(oe){if(oe.type==="html")return oe.value;if(oe.type==="paragraph"&&Array.isArray(oe.children)&&oe.children.length===1&&oe.children[0].type==="esComment")return["{/* ",oe.children[0].value," */}"]}function z(oe){let H=oe;for(;i(H.children);)H=s(H.children);return H}function U(oe){let H;if(oe.type==="html")H=oe.value.match(/^<!--\s*prettier-ignore(?:-(start|end))?\s*-->$/);else{let ce;oe.type==="esComment"?ce=oe:oe.type==="paragraph"&&oe.children.length===1&&oe.children[0].type==="esComment"&&(ce=oe.children[0]),ce&&(H=ce.value.match(/^prettier-ignore(?:-(start|end))?$/))}return H?H[1]||"next":!1}function Z(oe,H){let ce=H.parts.length===0,X=k.includes(oe.type),pe=oe.type==="html"&&M.includes(H.parentNode.type);return!ce&&!X&&!pe}function se(oe,H){var ce,X,pe;let Ce=(H.prevNode&&H.prevNode.type)===oe.type&&L.has(oe.type),fe=H.parentNode.type==="listItem"&&!H.parentNode.loose,A=((ce=H.prevNode)===null||ce===void 0?void 0:ce.type)==="listItem"&&H.prevNode.loose,G=U(H.prevNode)==="next",re=oe.type==="html"&&((X=H.prevNode)===null||X===void 0?void 0:X.type)==="html"&&H.prevNode.position.end.line+1===oe.position.start.line,ye=oe.type==="html"&&H.parentNode.type==="listItem"&&((pe=H.prevNode)===null||pe===void 0?void 0:pe.type)==="paragraph"&&H.prevNode.position.end.line+1===oe.position.start.line;return A||!(Ce||fe||G||re||ye)}function De(oe,H){let ce=H.prevNode&&H.prevNode.type==="list",X=oe.type==="code"&&oe.isIndented;return ce&&X}function ge(oe){let H=le(oe,["linkReference","imageReference"]);return H&&(H.type!=="linkReference"||H.referenceType!=="full")}function he(oe){let H=arguments.length>1&&arguments[1]!==void 0?arguments[1]:[],ce=[" ",...Array.isArray(H)?H:[H]];return new RegExp(ce.map(X=>`\\${X}`).join("|")).test(oe)?`<${oe}>`:oe}function we(oe,H){let ce=arguments.length>2&&arguments[2]!==void 0?arguments[2]:!0;if(!oe)return"";if(ce)return" "+we(oe,H,!1);if(oe=oe.replace(/\\(["')])/g,"$1"),oe.includes('"')&&oe.includes("'")&&!oe.includes(")"))return`(${oe})`;let X=oe.split("'").length-1,pe=oe.split('"').length-1,Ae=X>pe?'"':pe>X||H.singleQuote?"'":'"';return oe=oe.replace(/\\/,"\\\\"),oe=oe.replace(new RegExp(`(${Ae})`,"g"),"\\$1"),`${Ae}${oe}${Ae}`}function ke(oe,H,ce){return oe<H?H:oe>ce?ce:oe}function Re(oe){let H=Number(oe.getName());if(H===0)return!1;let ce=oe.getParentNode().children[H-1];return U(ce)==="next"}function Ne(oe){return`[${t(oe.label)}]`}function Pe(oe){return`[^${oe.label}]`}r.exports={preprocess:o,print:Q,embed:f,massageAstNode:h,hasPrettierIgnore:Re,insertPragma:T}}}),fg=te({"src/language-markdown/options.js"(e,r){"use strict";ne();var t=Mt();r.exports={proseWrap:t.proseWrap,singleQuote:t.singleQuote}}}),Dg=te({"src/language-markdown/parsers.js"(){ne()}}),_a=te({"node_modules/linguist-languages/data/Markdown.json"(e,r){r.exports={name:"Markdown",type:"prose",color:"#083fa1",aliases:["pandoc"],aceMode:"markdown",codemirrorMode:"gfm",codemirrorMimeType:"text/x-gfm",wrap:!0,extensions:[".md",".livemd",".markdown",".mdown",".mdwn",".mdx",".mkd",".mkdn",".mkdown",".ronn",".scd",".workbook"],filenames:["contents.lr"],tmScope:"source.gfm",languageId:222}}}),mg=te({"src/language-markdown/index.js"(e,r){"use strict";ne();var t=_t(),s=pg(),a=fg(),n=Dg(),u=[t(_a(),l=>({since:"1.8.0",parsers:["markdown"],vscodeLanguageIds:["markdown"],filenames:[...l.filenames,"README"],extensions:l.extensions.filter(p=>p!==".mdx")})),t(_a(),()=>({name:"MDX",since:"1.15.0",parsers:["mdx"],vscodeLanguageIds:["mdx"],filenames:[],extensions:[".mdx"]}))],i={mdast:s};r.exports={languages:u,options:a,printers:i,parsers:n}}}),dg=te({"src/language-html/clean.js"(e,r){"use strict";ne();var{isFrontMatterNode:t}=Ue(),s=new Set(["sourceSpan","startSourceSpan","endSourceSpan","nameSpan","valueSpan"]);function a(n,u){if(n.type==="text"||n.type==="comment"||t(n)||n.type==="yaml"||n.type==="toml")return null;n.type==="attribute"&&delete u.value,n.type==="docType"&&delete u.value}a.ignoredProperties=s,r.exports=a}}),gg=te({"src/language-html/constants.evaluate.js"(e,r){r.exports={CSS_DISPLAY_TAGS:{area:"none",base:"none",basefont:"none",datalist:"none",head:"none",link:"none",meta:"none",noembed:"none",noframes:"none",param:"block",rp:"none",script:"block",source:"block",style:"none",template:"inline",track:"block",title:"none",html:"block",body:"block",address:"block",blockquote:"block",center:"block",div:"block",figure:"block",figcaption:"block",footer:"block",form:"block",header:"block",hr:"block",legend:"block",listing:"block",main:"block",p:"block",plaintext:"block",pre:"block",xmp:"block",slot:"contents",ruby:"ruby",rt:"ruby-text",article:"block",aside:"block",h1:"block",h2:"block",h3:"block",h4:"block",h5:"block",h6:"block",hgroup:"block",nav:"block",section:"block",dir:"block",dd:"block",dl:"block",dt:"block",ol:"block",ul:"block",li:"list-item",table:"table",caption:"table-caption",colgroup:"table-column-group",col:"table-column",thead:"table-header-group",tbody:"table-row-group",tfoot:"table-footer-group",tr:"table-row",td:"table-cell",th:"table-cell",fieldset:"block",button:"inline-block",details:"block",summary:"block",dialog:"block",meter:"inline-block",progress:"inline-block",object:"inline-block",video:"inline-block",audio:"inline-block",select:"inline-block",option:"block",optgroup:"block"},CSS_DISPLAY_DEFAULT:"inline",CSS_WHITE_SPACE_TAGS:{listing:"pre",plaintext:"pre",pre:"pre",xmp:"pre",nobr:"nowrap",table:"initial",textarea:"pre-wrap"},CSS_WHITE_SPACE_DEFAULT:"normal"}}}),yg=te({"src/language-html/utils/is-unknown-namespace.js"(e,r){"use strict";ne();function t(s){return s.type==="element"&&!s.hasExplicitNamespace&&!["html","svg"].includes(s.namespace)}r.exports=t}}),Rt=te({"src/language-html/utils/index.js"(e,r){"use strict";ne();var{inferParserByLanguage:t,isFrontMatterNode:s}=Ue(),{builders:{line:a,hardline:n,join:u},utils:{getDocParts:i,replaceTextEndOfLine:l}}=qe(),{CSS_DISPLAY_TAGS:p,CSS_DISPLAY_DEFAULT:d,CSS_WHITE_SPACE_TAGS:y,CSS_WHITE_SPACE_DEFAULT:g}=gg(),c=yg(),D=new Set(["	",`
`,"\f","\r"," "]),E=A=>A.replace(/^[\t\n\f\r ]+/,""),_=A=>A.replace(/[\t\n\f\r ]+$/,""),w=A=>E(_(A)),F=A=>A.replace(/^[\t\f\r ]*\n/g,""),S=A=>F(_(A)),N=A=>A.split(/[\t\n\f\r ]+/),I=A=>A.match(/^[\t\n\f\r ]*/)[0],P=A=>{let[,G,re,ye]=A.match(/^([\t\n\f\r ]*)(.*?)([\t\n\f\r ]*)$/s);return{leadingWhitespace:G,trailingWhitespace:ye,text:re}},$=A=>/[\t\n\f\r ]/.test(A);function f(A,G){return!!(A.type==="ieConditionalComment"&&A.lastChild&&!A.lastChild.isSelfClosing&&!A.lastChild.endSourceSpan||A.type==="ieConditionalComment"&&!A.complete||se(A)&&A.children.some(re=>re.type!=="text"&&re.type!=="interpolation")||X(A,G)&&!o(A)&&A.type!=="interpolation")}function T(A){return A.type==="attribute"||!A.parent||!A.prev?!1:m(A.prev)}function m(A){return A.type==="comment"&&A.value.trim()==="prettier-ignore"}function v(A){return A.type==="text"||A.type==="comment"}function o(A){return A.type==="element"&&(A.fullName==="script"||A.fullName==="style"||A.fullName==="svg:style"||c(A)&&(A.name==="script"||A.name==="style"))}function h(A){return A.children&&!o(A)}function C(A){return o(A)||A.type==="interpolation"||x(A)}function x(A){return we(A).startsWith("pre")}function b(A,G){let re=ye();if(re&&!A.prev&&A.parent&&A.parent.tagDefinition&&A.parent.tagDefinition.ignoreFirstLf)return A.type==="interpolation";return re;function ye(){return s(A)?!1:(A.type==="text"||A.type==="interpolation")&&A.prev&&(A.prev.type==="text"||A.prev.type==="interpolation")?!0:!A.parent||A.parent.cssDisplay==="none"?!1:se(A.parent)?!0:!(!A.prev&&(A.parent.type==="root"||se(A)&&A.parent||o(A.parent)||H(A.parent,G)||!ue(A.parent.cssDisplay))||A.prev&&!U(A.prev.cssDisplay))}}function B(A,G){return s(A)?!1:(A.type==="text"||A.type==="interpolation")&&A.next&&(A.next.type==="text"||A.next.type==="interpolation")?!0:!A.parent||A.parent.cssDisplay==="none"?!1:se(A.parent)?!0:!(!A.next&&(A.parent.type==="root"||se(A)&&A.parent||o(A.parent)||H(A.parent,G)||!Fe(A.parent.cssDisplay))||A.next&&!z(A.next.cssDisplay))}function k(A){return Z(A.cssDisplay)&&!o(A)}function M(A){return s(A)||A.next&&A.sourceSpan.end&&A.sourceSpan.end.line+1<A.next.sourceSpan.start.line}function R(A){return q(A)||A.type==="element"&&A.children.length>0&&(["body","script","style"].includes(A.name)||A.children.some(G=>ee(G)))||A.firstChild&&A.firstChild===A.lastChild&&A.firstChild.type!=="text"&&V(A.firstChild)&&(!A.lastChild.isTrailingSpaceSensitive||j(A.lastChild))}function q(A){return A.type==="element"&&A.children.length>0&&(["html","head","ul","ol","select"].includes(A.name)||A.cssDisplay.startsWith("table")&&A.cssDisplay!=="table-cell")}function J(A){return Y(A)||A.prev&&L(A.prev)||Q(A)}function L(A){return Y(A)||A.type==="element"&&A.fullName==="br"||Q(A)}function Q(A){return V(A)&&j(A)}function V(A){return A.hasLeadingSpaces&&(A.prev?A.prev.sourceSpan.end.line<A.sourceSpan.start.line:A.parent.type==="root"||A.parent.startSourceSpan.end.line<A.sourceSpan.start.line)}function j(A){return A.hasTrailingSpaces&&(A.next?A.next.sourceSpan.start.line>A.sourceSpan.end.line:A.parent.type==="root"||A.parent.endSourceSpan&&A.parent.endSourceSpan.start.line>A.sourceSpan.end.line)}function Y(A){switch(A.type){case"ieConditionalComment":case"comment":case"directive":return!0;case"element":return["script","select"].includes(A.name)}return!1}function ie(A){return A.lastChild?ie(A.lastChild):A}function ee(A){return A.children&&A.children.some(G=>G.type!=="text")}function le(A){let{type:G,lang:re}=A.attrMap;if(G==="module"||G==="text/javascript"||G==="text/babel"||G==="application/javascript"||re==="jsx")return"babel";if(G==="application/x-typescript"||re==="ts"||re==="tsx")return"typescript";if(G==="text/markdown")return"markdown";if(G==="text/html")return"html";if(G&&(G.endsWith("json")||G.endsWith("importmap"))||G==="speculationrules")return"json";if(G==="text/x-handlebars-template")return"glimmer"}function W(A,G){let{lang:re}=A.attrMap;if(!re||re==="postcss"||re==="css")return"css";if(re==="scss")return"scss";if(re==="less")return"less";if(re==="stylus")return t("stylus",G)}function K(A,G){if(A.name==="script"&&!A.attrMap.src)return!A.attrMap.lang&&!A.attrMap.type?"babel":le(A);if(A.name==="style")return W(A,G);if(G&&X(A,G))return le(A)||!("src"in A.attrMap)&&t(A.attrMap.lang,G)}function de(A){return A==="block"||A==="list-item"||A.startsWith("table")}function ue(A){return!de(A)&&A!=="inline-block"}function Fe(A){return!de(A)&&A!=="inline-block"}function z(A){return!de(A)}function U(A){return!de(A)}function Z(A){return!de(A)&&A!=="inline-block"}function se(A){return we(A).startsWith("pre")}function De(A,G){let re=0;for(let ye=A.stack.length-1;ye>=0;ye--){let Ee=A.stack[ye];Ee&&typeof Ee=="object"&&!Array.isArray(Ee)&&G(Ee)&&re++}return re}function ge(A,G){let re=A;for(;re;){if(G(re))return!0;re=re.parent}return!1}function he(A,G){if(A.prev&&A.prev.type==="comment"){let ye=A.prev.value.match(/^\s*display:\s*([a-z]+)\s*$/);if(ye)return ye[1]}let re=!1;if(A.type==="element"&&A.namespace==="svg")if(ge(A,ye=>ye.fullName==="svg:foreignObject"))re=!0;else return A.name==="svg"?"inline-block":"block";switch(G.htmlWhitespaceSensitivity){case"strict":return"inline";case"ignore":return"block";default:return G.parser==="vue"&&A.parent&&A.parent.type==="root"?"block":A.type==="element"&&(!A.namespace||re||c(A))&&p[A.name]||d}}function we(A){return A.type==="element"&&(!A.namespace||c(A))&&y[A.name]||g}function ke(A){let G=Number.POSITIVE_INFINITY;for(let re of A.split(`
`)){if(re.length===0)continue;if(!D.has(re[0]))return 0;let ye=I(re).length;re.length!==ye&&ye<G&&(G=ye)}return G===Number.POSITIVE_INFINITY?0:G}function Re(A){let G=arguments.length>1&&arguments[1]!==void 0?arguments[1]:ke(A);return G===0?A:A.split(`
`).map(re=>re.slice(G)).join(`
`)}function Ne(A,G){let re=0;for(let ye=0;ye<A.length;ye++)A[ye]===G&&re++;return re}function Pe(A){return A.replace(/&apos;/g,"'").replace(/&quot;/g,'"')}var oe=new Set(["template","style","script"]);function H(A,G){return ce(A,G)&&!oe.has(A.fullName)}function ce(A,G){return G.parser==="vue"&&A.type==="element"&&A.parent.type==="root"&&A.fullName.toLowerCase()!=="html"}function X(A,G){return ce(A,G)&&(H(A,G)||A.attrMap.lang&&A.attrMap.lang!=="html")}function pe(A){let G=A.fullName;return G.charAt(0)==="#"||G==="slot-scope"||G==="v-slot"||G.startsWith("v-slot:")}function Ae(A,G){let re=A.parent;if(!ce(re,G))return!1;let ye=re.fullName,Ee=A.fullName;return ye==="script"&&Ee==="setup"||ye==="style"&&Ee==="vars"}function Ce(A){let G=arguments.length>1&&arguments[1]!==void 0?arguments[1]:A.value;return A.parent.isWhitespaceSensitive?A.parent.isIndentationSensitive?l(G):l(Re(S(G)),n):i(u(a,N(G)))}function fe(A,G){return ce(A,G)&&A.name==="script"}r.exports={htmlTrim:w,htmlTrimPreserveIndentation:S,hasHtmlWhitespace:$,getLeadingAndTrailingHtmlWhitespace:P,canHaveInterpolation:h,countChars:Ne,countParents:De,dedentString:Re,forceBreakChildren:q,forceBreakContent:R,forceNextEmptyLine:M,getLastDescendant:ie,getNodeCssStyleDisplay:he,getNodeCssStyleWhiteSpace:we,hasPrettierIgnore:T,inferScriptParser:K,isVueCustomBlock:H,isVueNonHtmlBlock:X,isVueScriptTag:fe,isVueSlotAttribute:pe,isVueSfcBindingsAttribute:Ae,isVueSfcBlock:ce,isDanglingSpaceSensitiveNode:k,isIndentationSensitiveNode:x,isLeadingSpaceSensitiveNode:b,isPreLikeNode:se,isScriptLikeTag:o,isTextLikeNode:v,isTrailingSpaceSensitiveNode:B,isWhitespaceSensitiveNode:C,isUnknownNamespace:c,preferHardlineAsLeadingSpaces:J,preferHardlineAsTrailingSpaces:L,shouldPreserveContent:f,unescapeQuoteEntities:Pe,getTextValueParts:Ce}}}),hg=te({"node_modules/angular-html-parser/lib/compiler/src/chars.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0}),e.$EOF=0,e.$BSPACE=8,e.$TAB=9,e.$LF=10,e.$VTAB=11,e.$FF=12,e.$CR=13,e.$SPACE=32,e.$BANG=33,e.$DQ=34,e.$HASH=35,e.$$=36,e.$PERCENT=37,e.$AMPERSAND=38,e.$SQ=39,e.$LPAREN=40,e.$RPAREN=41,e.$STAR=42,e.$PLUS=43,e.$COMMA=44,e.$MINUS=45,e.$PERIOD=46,e.$SLASH=47,e.$COLON=58,e.$SEMICOLON=59,e.$LT=60,e.$EQ=61,e.$GT=62,e.$QUESTION=63,e.$0=48,e.$7=55,e.$9=57,e.$A=65,e.$E=69,e.$F=70,e.$X=88,e.$Z=90,e.$LBRACKET=91,e.$BACKSLASH=92,e.$RBRACKET=93,e.$CARET=94,e.$_=95,e.$a=97,e.$b=98,e.$e=101,e.$f=102,e.$n=110,e.$r=114,e.$t=116,e.$u=117,e.$v=118,e.$x=120,e.$z=122,e.$LBRACE=123,e.$BAR=124,e.$RBRACE=125,e.$NBSP=160,e.$PIPE=124,e.$TILDA=126,e.$AT=64,e.$BT=96;function r(i){return i>=e.$TAB&&i<=e.$SPACE||i==e.$NBSP}e.isWhitespace=r;function t(i){return e.$0<=i&&i<=e.$9}e.isDigit=t;function s(i){return i>=e.$a&&i<=e.$z||i>=e.$A&&i<=e.$Z}e.isAsciiLetter=s;function a(i){return i>=e.$a&&i<=e.$f||i>=e.$A&&i<=e.$F||t(i)}e.isAsciiHexDigit=a;function n(i){return i===e.$LF||i===e.$CR}e.isNewLine=n;function u(i){return e.$0<=i&&i<=e.$7}e.isOctalDigit=u}}),vg=te({"node_modules/angular-html-parser/lib/compiler/src/aot/static_symbol.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=class{constructor(s,a,n){this.filePath=s,this.name=a,this.members=n}assertNoMembers(){if(this.members.length)throw new Error(`Illegal state: symbol without members expected, but got ${JSON.stringify(this)}.`)}};e.StaticSymbol=r;var t=class{constructor(){this.cache=new Map}get(s,a,n){n=n||[];let u=n.length?`.${n.join(".")}`:"",i=`"${s}".${a}${u}`,l=this.cache.get(i);return l||(l=new r(s,a,n),this.cache.set(i,l)),l}};e.StaticSymbolCache=t}}),Cg=te({"node_modules/angular-html-parser/lib/compiler/src/util.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=/-+([a-z0-9])/g;function t(o){return o.replace(r,function(){for(var h=arguments.length,C=new Array(h),x=0;x<h;x++)C[x]=arguments[x];return C[1].toUpperCase()})}e.dashCaseToCamelCase=t;function s(o,h){return n(o,":",h)}e.splitAtColon=s;function a(o,h){return n(o,".",h)}e.splitAtPeriod=a;function n(o,h,C){let x=o.indexOf(h);return x==-1?C:[o.slice(0,x).trim(),o.slice(x+1).trim()]}function u(o,h,C){return Array.isArray(o)?h.visitArray(o,C):F(o)?h.visitStringMap(o,C):o==null||typeof o=="string"||typeof o=="number"||typeof o=="boolean"?h.visitPrimitive(o,C):h.visitOther(o,C)}e.visitValue=u;function i(o){return o!=null}e.isDefined=i;function l(o){return o===void 0?null:o}e.noUndefined=l;var p=class{visitArray(o,h){return o.map(C=>u(C,this,h))}visitStringMap(o,h){let C={};return Object.keys(o).forEach(x=>{C[x]=u(o[x],this,h)}),C}visitPrimitive(o,h){return o}visitOther(o,h){return o}};e.ValueTransformer=p,e.SyncAsync={assertSync:o=>{if(P(o))throw new Error("Illegal state: value cannot be a promise");return o},then:(o,h)=>P(o)?o.then(h):h(o),all:o=>o.some(P)?Promise.all(o):o};function d(o){throw new Error(`Internal Error: ${o}`)}e.error=d;function y(o,h){let C=Error(o);return C[g]=!0,h&&(C[c]=h),C}e.syntaxError=y;var g="ngSyntaxError",c="ngParseErrors";function D(o){return o[g]}e.isSyntaxError=D;function E(o){return o[c]||[]}e.getParseErrors=E;function _(o){return o.replace(/([.*+?^=!:${}()|[\]\/\\])/g,"\\$1")}e.escapeRegExp=_;var w=Object.getPrototypeOf({});function F(o){return typeof o=="object"&&o!==null&&Object.getPrototypeOf(o)===w}function S(o){let h="";for(let C=0;C<o.length;C++){let x=o.charCodeAt(C);if(x>=55296&&x<=56319&&o.length>C+1){let b=o.charCodeAt(C+1);b>=56320&&b<=57343&&(C++,x=(x-55296<<10)+b-56320+65536)}x<=127?h+=String.fromCharCode(x):x<=2047?h+=String.fromCharCode(x>>6&31|192,x&63|128):x<=65535?h+=String.fromCharCode(x>>12|224,x>>6&63|128,x&63|128):x<=2097151&&(h+=String.fromCharCode(x>>18&7|240,x>>12&63|128,x>>6&63|128,x&63|128))}return h}e.utf8Encode=S;function N(o){if(typeof o=="string")return o;if(o instanceof Array)return"["+o.map(N).join(", ")+"]";if(o==null)return""+o;if(o.overriddenName)return`${o.overriddenName}`;if(o.name)return`${o.name}`;if(!o.toString)return"object";let h=o.toString();if(h==null)return""+h;let C=h.indexOf(`
`);return C===-1?h:h.substring(0,C)}e.stringify=N;function I(o){return typeof o=="function"&&o.hasOwnProperty("__forward_ref__")?o():o}e.resolveForwardRef=I;function P(o){return!!o&&typeof o.then=="function"}e.isPromise=P;var $=class{constructor(o){this.full=o;let h=o.split(".");this.major=h[0],this.minor=h[1],this.patch=h.slice(2).join(".")}};e.Version=$;var f=typeof window<"u"&&window,T=typeof self<"u"&&typeof WorkerGlobalScope<"u"&&self instanceof WorkerGlobalScope&&self,m=typeof globalThis<"u"&&globalThis,v=m||f||T;e.global=v}}),Eg=te({"node_modules/angular-html-parser/lib/compiler/src/compile_metadata.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=vg(),t=Cg(),s=/^(?:(?:\[([^\]]+)\])|(?:\(([^\)]+)\)))|(\@[-\w]+)$/;function a(C){return C.replace(/\W/g,"_")}e.sanitizeIdentifier=a;var n=0;function u(C){if(!C||!C.reference)return null;let x=C.reference;if(x instanceof r.StaticSymbol)return x.name;if(x.__anonymousType)return x.__anonymousType;let b=t.stringify(x);return b.indexOf("(")>=0?(b=`anonymous_${n++}`,x.__anonymousType=b):b=a(b),b}e.identifierName=u;function i(C){let x=C.reference;return x instanceof r.StaticSymbol?x.filePath:`./${t.stringify(x)}`}e.identifierModuleUrl=i;function l(C,x){return`View_${u({reference:C})}_${x}`}e.viewClassName=l;function p(C){return`RenderType_${u({reference:C})}`}e.rendererTypeName=p;function d(C){return`HostView_${u({reference:C})}`}e.hostViewClassName=d;function y(C){return`${u({reference:C})}NgFactory`}e.componentFactoryName=y;var g;(function(C){C[C.Pipe=0]="Pipe",C[C.Directive=1]="Directive",C[C.NgModule=2]="NgModule",C[C.Injectable=3]="Injectable"})(g=e.CompileSummaryKind||(e.CompileSummaryKind={}));function c(C){return C.value!=null?a(C.value):u(C.identifier)}e.tokenName=c;function D(C){return C.identifier!=null?C.identifier.reference:C.value}e.tokenReference=D;var E=class{constructor(){let{moduleUrl:C,styles:x,styleUrls:b}=arguments.length>0&&arguments[0]!==void 0?arguments[0]:{};this.moduleUrl=C||null,this.styles=P(x),this.styleUrls=P(b)}};e.CompileStylesheetMetadata=E;var _=class{constructor(C){let{encapsulation:x,template:b,templateUrl:B,htmlAst:k,styles:M,styleUrls:R,externalStylesheets:q,animations:J,ngContentSelectors:L,interpolation:Q,isInline:V,preserveWhitespaces:j}=C;if(this.encapsulation=x,this.template=b,this.templateUrl=B,this.htmlAst=k,this.styles=P(M),this.styleUrls=P(R),this.externalStylesheets=P(q),this.animations=J?f(J):[],this.ngContentSelectors=L||[],Q&&Q.length!=2)throw new Error("'interpolation' should have a start and an end symbol.");this.interpolation=Q,this.isInline=V,this.preserveWhitespaces=j}toSummary(){return{ngContentSelectors:this.ngContentSelectors,encapsulation:this.encapsulation,styles:this.styles,animations:this.animations}}};e.CompileTemplateMetadata=_;var w=class{static create(C){let{isHost:x,type:b,isComponent:B,selector:k,exportAs:M,changeDetection:R,inputs:q,outputs:J,host:L,providers:Q,viewProviders:V,queries:j,guards:Y,viewQueries:ie,entryComponents:ee,template:le,componentViewType:W,rendererType:K,componentFactory:de}=C,ue={},Fe={},z={};L!=null&&Object.keys(L).forEach(se=>{let De=L[se],ge=se.match(s);ge===null?z[se]=De:ge[1]!=null?Fe[ge[1]]=De:ge[2]!=null&&(ue[ge[2]]=De)});let U={};q!=null&&q.forEach(se=>{let De=t.splitAtColon(se,[se,se]);U[De[0]]=De[1]});let Z={};return J!=null&&J.forEach(se=>{let De=t.splitAtColon(se,[se,se]);Z[De[0]]=De[1]}),new w({isHost:x,type:b,isComponent:!!B,selector:k,exportAs:M,changeDetection:R,inputs:U,outputs:Z,hostListeners:ue,hostProperties:Fe,hostAttributes:z,providers:Q,viewProviders:V,queries:j,guards:Y,viewQueries:ie,entryComponents:ee,template:le,componentViewType:W,rendererType:K,componentFactory:de})}constructor(C){let{isHost:x,type:b,isComponent:B,selector:k,exportAs:M,changeDetection:R,inputs:q,outputs:J,hostListeners:L,hostProperties:Q,hostAttributes:V,providers:j,viewProviders:Y,queries:ie,guards:ee,viewQueries:le,entryComponents:W,template:K,componentViewType:de,rendererType:ue,componentFactory:Fe}=C;this.isHost=!!x,this.type=b,this.isComponent=B,this.selector=k,this.exportAs=M,this.changeDetection=R,this.inputs=q,this.outputs=J,this.hostListeners=L,this.hostProperties=Q,this.hostAttributes=V,this.providers=P(j),this.viewProviders=P(Y),this.queries=P(ie),this.guards=ee,this.viewQueries=P(le),this.entryComponents=P(W),this.template=K,this.componentViewType=de,this.rendererType=ue,this.componentFactory=Fe}toSummary(){return{summaryKind:g.Directive,type:this.type,isComponent:this.isComponent,selector:this.selector,exportAs:this.exportAs,inputs:this.inputs,outputs:this.outputs,hostListeners:this.hostListeners,hostProperties:this.hostProperties,hostAttributes:this.hostAttributes,providers:this.providers,viewProviders:this.viewProviders,queries:this.queries,guards:this.guards,viewQueries:this.viewQueries,entryComponents:this.entryComponents,changeDetection:this.changeDetection,template:this.template&&this.template.toSummary(),componentViewType:this.componentViewType,rendererType:this.rendererType,componentFactory:this.componentFactory}}};e.CompileDirectiveMetadata=w;var F=class{constructor(C){let{type:x,name:b,pure:B}=C;this.type=x,this.name=b,this.pure=!!B}toSummary(){return{summaryKind:g.Pipe,type:this.type,name:this.name,pure:this.pure}}};e.CompilePipeMetadata=F;var S=class{};e.CompileShallowModuleMetadata=S;var N=class{constructor(C){let{type:x,providers:b,declaredDirectives:B,exportedDirectives:k,declaredPipes:M,exportedPipes:R,entryComponents:q,bootstrapComponents:J,importedModules:L,exportedModules:Q,schemas:V,transitiveModule:j,id:Y}=C;this.type=x||null,this.declaredDirectives=P(B),this.exportedDirectives=P(k),this.declaredPipes=P(M),this.exportedPipes=P(R),this.providers=P(b),this.entryComponents=P(q),this.bootstrapComponents=P(J),this.importedModules=P(L),this.exportedModules=P(Q),this.schemas=P(V),this.id=Y||null,this.transitiveModule=j||null}toSummary(){let C=this.transitiveModule;return{summaryKind:g.NgModule,type:this.type,entryComponents:C.entryComponents,providers:C.providers,modules:C.modules,exportedDirectives:C.exportedDirectives,exportedPipes:C.exportedPipes}}};e.CompileNgModuleMetadata=N;var I=class{constructor(){this.directivesSet=new Set,this.directives=[],this.exportedDirectivesSet=new Set,this.exportedDirectives=[],this.pipesSet=new Set,this.pipes=[],this.exportedPipesSet=new Set,this.exportedPipes=[],this.modulesSet=new Set,this.modules=[],this.entryComponentsSet=new Set,this.entryComponents=[],this.providers=[]}addProvider(C,x){this.providers.push({provider:C,module:x})}addDirective(C){this.directivesSet.has(C.reference)||(this.directivesSet.add(C.reference),this.directives.push(C))}addExportedDirective(C){this.exportedDirectivesSet.has(C.reference)||(this.exportedDirectivesSet.add(C.reference),this.exportedDirectives.push(C))}addPipe(C){this.pipesSet.has(C.reference)||(this.pipesSet.add(C.reference),this.pipes.push(C))}addExportedPipe(C){this.exportedPipesSet.has(C.reference)||(this.exportedPipesSet.add(C.reference),this.exportedPipes.push(C))}addModule(C){this.modulesSet.has(C.reference)||(this.modulesSet.add(C.reference),this.modules.push(C))}addEntryComponent(C){this.entryComponentsSet.has(C.componentType)||(this.entryComponentsSet.add(C.componentType),this.entryComponents.push(C))}};e.TransitiveCompileNgModuleMetadata=I;function P(C){return C||[]}var $=class{constructor(C,x){let{useClass:b,useValue:B,useExisting:k,useFactory:M,deps:R,multi:q}=x;this.token=C,this.useClass=b||null,this.useValue=B,this.useExisting=k,this.useFactory=M||null,this.dependencies=R||null,this.multi=!!q}};e.ProviderMeta=$;function f(C){return C.reduce((x,b)=>{let B=Array.isArray(b)?f(b):b;return x.concat(B)},[])}e.flatten=f;function T(C){return C.replace(/(\w+:\/\/[\w:-]+)?(\/+)?/,"ng:///")}function m(C,x,b){let B;return b.isInline?x.type.reference instanceof r.StaticSymbol?B=`${x.type.reference.filePath}.${x.type.reference.name}.html`:B=`${u(C)}/${u(x.type)}.html`:B=b.templateUrl,x.type.reference instanceof r.StaticSymbol?B:T(B)}e.templateSourceUrl=m;function v(C,x){let b=C.moduleUrl.split(/\/\\/g),B=b[b.length-1];return T(`css/${x}${B}.ngstyle.js`)}e.sharedStylesheetJitUrl=v;function o(C){return T(`${u(C.type)}/module.ngfactory.js`)}e.ngModuleJitUrl=o;function h(C,x){return T(`${u(C)}/${u(x.type)}.ngfactory.js`)}e.templateJitUrl=h}}),Fg=te({"node_modules/angular-html-parser/lib/compiler/src/parse_util.js"(e){"use strict";ne(),Object.defineProperty(e,"__esModule",{value:!0});var r=hg(),t=Eg(),s=class{constructor(d,y,g,c){this.file=d,this.offset=y,this.line=g,this.col=c}toString(){return this.offset!=null?`${this.file.url}@${this.line}:${this.col}`:this.file.url}moveBy(d){let y=this.file.content,g=y.length,c=this.offset,D=this.line,E=this.col;for(;c>0&&d<0;)if(c--,d++,y.charCodeAt(c)==r.$LF){D--;let w=y.substr(0,c-1).lastIndexOf(String.fromCharCode(r.$LF));E=w>0?c-w:c}else E--;for(;c<g&&d>0;){let _=y.charCodeAt(c);c++,d--,_==r.$LF?(D++,E=0):E++}return new s(this.file,c,D,E)}getContext(d,y){let g=this.file.content,c=this.offset;if(c!=null){c>g.length-1&&(c=g.length-1);let D=c,E=0,_=0;for(;E<d&&c>0&&(c--,E++,!(g[c]==`
`&&++_==y)););for(E=0,_=0;E<d&&D<g.length-1&&(D++,E++,!(g[D]==`
`&&++_==y)););return{before:g.substring(c,this.offset),after:g.substring(this.offset,D+1)}}return null}};e.ParseLocation=s;var a=class{constructor(d,y){this.content=d,this.url=y}};e.ParseSourceFile=a;var n=class{constructor(d,y){let g=arguments.length>2&&arguments[2]!==void 0?arguments[2]:null;this.start=d,this.end=y,this.details=g}toString(){return this.start.file.content.substring(this.start.offset,this.end.offset)}};e.ParseSourceSpan=n,e.EMPTY_PARSE_LOCATION=new s(new a("",""),0,0,0),e.EMPTY_SOURCE_SPAN=new n(e.EMPTY_PARSE_LOCATION,e.EMPTY_PARSE_LOCATION);var u;(function(d){d[d.WARNING=0]="WARNING",d[d.ERROR=1]="ERROR"})(u=e.ParseErrorLevel||(e.ParseErrorLevel={}));var i=class{constructor(d,y){let g=arguments.length>2&&arguments[2]!==void 0?arguments[2]:u.ERROR;this.span=d,this.msg=y,this.level=g}contextualMessage(){let d=this.span.start.getContext(100,3);return d?`${this.msg} ("${d.before}[${u[this.level]} ->]${d.after}")`:this.msg}toString(){let d=this.span.details?`, ${this.span.details}`:"";return`${this.contextualMessage()}: ${this.span.start}${d}`}};e.ParseError=i;function l(d,y){let g=t.identifierModuleUrl(y),c=g!=null?`in ${d} ${t.identifierName(y)} in ${g}`:`in ${d} ${t.identifierName(y)}`,D=new a("",c);return new n(new s(D,-1,-1,-1),new s(D,-1,-1,-1))}e.typeSourceSpan=l;function p(d,y,g){let c=`in ${d} ${y} in ${g}`,D=new a("",c);return new n(new s(D,-1,-1,-1),new s(D,-1,-1,-1))}e.r3JitTypeSourceSpan=p}}),Ag=te({"src/language-html/print-preprocess.js"(e,r){"use strict";ne();var{ParseSourceSpan:t}=Fg(),{htmlTrim:s,getLeadingAndTrailingHtmlWhitespace:a,hasHtmlWhitespace:n,canHaveInterpolation:u,getNodeCssStyleDisplay:i,isDanglingSpaceSensitiveNode:l,isIndentationSensitiveNode:p,isLeadingSpaceSensitiveNode:d,isTrailingSpaceSensitiveNode:y,isWhitespaceSensitiveNode:g,isVueScriptTag:c}=Rt(),D=[_,w,S,I,P,T,$,f,m,N,v];function E(o,h){for(let C of D)C(o,h);return o}function _(o){o.walk(h=>{if(h.type==="element"&&h.tagDefinition.ignoreFirstLf&&h.children.length>0&&h.children[0].type==="text"&&h.children[0].value[0]===`
`){let C=h.children[0];C.value.length===1?h.removeChild(C):C.value=C.value.slice(1)}})}function w(o){let h=C=>C.type==="element"&&C.prev&&C.prev.type==="ieConditionalStartComment"&&C.prev.sourceSpan.end.offset===C.startSourceSpan.start.offset&&C.firstChild&&C.firstChild.type==="ieConditionalEndComment"&&C.firstChild.sourceSpan.start.offset===C.startSourceSpan.end.offset;o.walk(C=>{if(C.children)for(let x=0;x<C.children.length;x++){let b=C.children[x];if(!h(b))continue;let B=b.prev,k=b.firstChild;C.removeChild(B),x--;let M=new t(B.sourceSpan.start,k.sourceSpan.end),R=new t(M.start,b.sourceSpan.end);b.condition=B.condition,b.sourceSpan=R,b.startSourceSpan=M,b.removeChild(k)}})}function F(o,h,C){o.walk(x=>{if(x.children)for(let b=0;b<x.children.length;b++){let B=x.children[b];if(B.type!=="text"&&!h(B))continue;B.type!=="text"&&(B.type="text",B.value=C(B));let k=B.prev;!k||k.type!=="text"||(k.value+=B.value,k.sourceSpan=new t(k.sourceSpan.start,B.sourceSpan.end),x.removeChild(B),b--)}})}function S(o){return F(o,h=>h.type==="cdata",h=>`<![CDATA[${h.value}]]>`)}function N(o){let h=C=>C.type==="element"&&C.attrs.length===0&&C.children.length===1&&C.firstChild.type==="text"&&!n(C.children[0].value)&&!C.firstChild.hasLeadingSpaces&&!C.firstChild.hasTrailingSpaces&&C.isLeadingSpaceSensitive&&!C.hasLeadingSpaces&&C.isTrailingSpaceSensitive&&!C.hasTrailingSpaces&&C.prev&&C.prev.type==="text"&&C.next&&C.next.type==="text";o.walk(C=>{if(C.children)for(let x=0;x<C.children.length;x++){let b=C.children[x];if(!h(b))continue;let B=b.prev,k=b.next;B.value+=`<${b.rawName}>`+b.firstChild.value+`</${b.rawName}>`+k.value,B.sourceSpan=new t(B.sourceSpan.start,k.sourceSpan.end),B.isTrailingSpaceSensitive=k.isTrailingSpaceSensitive,B.hasTrailingSpaces=k.hasTrailingSpaces,C.removeChild(b),x--,C.removeChild(k)}})}function I(o,h){if(h.parser==="html")return;let C=/{{(.+?)}}/s;o.walk(x=>{if(u(x))for(let b of x.children){if(b.type!=="text")continue;let B=b.sourceSpan.start,k=null,M=b.value.split(C);for(let R=0;R<M.length;R++,B=k){let q=M[R];if(R%2===0){k=B.moveBy(q.length),q.length>0&&x.insertChildBefore(b,{type:"text",value:q,sourceSpan:new t(B,k)});continue}k=B.moveBy(q.length+4),x.insertChildBefore(b,{type:"interpolation",sourceSpan:new t(B,k),children:q.length===0?[]:[{type:"text",value:q,sourceSpan:new t(B.moveBy(2),k.moveBy(-2))}]})}x.removeChild(b)}})}function P(o){o.walk(h=>{if(!h.children)return;if(h.children.length===0||h.children.length===1&&h.children[0].type==="text"&&s(h.children[0].value).length===0){h.hasDanglingSpaces=h.children.length>0,h.children=[];return}let C=g(h),x=p(h);if(!C)for(let b=0;b<h.children.length;b++){let B=h.children[b];if(B.type!=="text")continue;let{leadingWhitespace:k,text:M,trailingWhitespace:R}=a(B.value),q=B.prev,J=B.next;M?(B.value=M,B.sourceSpan=new t(B.sourceSpan.start.moveBy(k.length),B.sourceSpan.end.moveBy(-R.length)),k&&(q&&(q.hasTrailingSpaces=!0),B.hasLeadingSpaces=!0),R&&(B.hasTrailingSpaces=!0,J&&(J.hasLeadingSpaces=!0))):(h.removeChild(B),b--,(k||R)&&(q&&(q.hasTrailingSpaces=!0),J&&(J.hasLeadingSpaces=!0)))}h.isWhitespaceSensitive=C,h.isIndentationSensitive=x})}function $(o){o.walk(h=>{h.isSelfClosing=!h.children||h.type==="element"&&(h.tagDefinition.isVoid||h.startSourceSpan===h.endSourceSpan)})}function f(o,h){o.walk(C=>{C.type==="element"&&(C.hasHtmComponentClosingTag=C.endSourceSpan&&/^<\s*\/\s*\/\s*>$/.test(h.originalText.slice(C.endSourceSpan.start.offset,C.endSourceSpan.end.offset)))})}function T(o,h){o.walk(C=>{C.cssDisplay=i(C,h)})}function m(o,h){o.walk(C=>{let{children:x}=C;if(x){if(x.length===0){C.isDanglingSpaceSensitive=l(C);return}for(let b of x)b.isLeadingSpaceSensitive=d(b,h),b.isTrailingSpaceSensitive=y(b,h);for(let b=0;b<x.length;b++){let B=x[b];B.isLeadingSpaceSensitive=(b===0||B.prev.isTrailingSpaceSensitive)&&B.isLeadingSpaceSensitive,B.isTrailingSpaceSensitive=(b===x.length-1||B.next.isLeadingSpaceSensitive)&&B.isTrailingSpaceSensitive}}})}function v(o,h){if(h.parser==="vue"){let C=o.children.find(b=>c(b,h));if(!C)return;let{lang:x}=C.attrMap;(x==="ts"||x==="typescript")&&(h.__should_parse_vue_template_with_ts=!0)}}r.exports=E}}),Sg=te({"src/language-html/pragma.js"(e,r){"use strict";ne();function t(a){return/^\s*<!--\s*@(?:format|prettier)\s*-->/.test(a)}function s(a){return`<!-- @format -->

`+a.replace(/^\s*\n/,"")}r.exports={hasPragma:t,insertPragma:s}}}),au=te({"src/language-html/loc.js"(e,r){"use strict";ne();function t(a){return a.sourceSpan.start.offset}function s(a){return a.sourceSpan.end.offset}r.exports={locStart:t,locEnd:s}}}),ur=te({"src/language-html/print/tag.js"(e,r){"use strict";ne();var t=Zt(),{isNonEmptyArray:s}=Ue(),{builders:{indent:a,join:n,line:u,softline:i,hardline:l},utils:{replaceTextEndOfLine:p}}=qe(),{locStart:d,locEnd:y}=au(),{isTextLikeNode:g,getLastDescendant:c,isPreLikeNode:D,hasPrettierIgnore:E,shouldPreserveContent:_,isVueSfcBlock:w}=Rt();function F(L,Q){return[L.isSelfClosing?"":S(L,Q),N(L,Q)]}function S(L,Q){return L.lastChild&&o(L.lastChild)?"":[I(L,Q),$(L,Q)]}function N(L,Q){return(L.next?m(L.next):v(L.parent))?"":[f(L,Q),P(L,Q)]}function I(L,Q){return v(L)?f(L.lastChild,Q):""}function P(L,Q){return o(L)?$(L.parent,Q):h(L)?q(L.next):""}function $(L,Q){if(t(!L.isSelfClosing),T(L,Q))return"";switch(L.type){case"ieConditionalComment":return"<!";case"element":if(L.hasHtmComponentClosingTag)return"<//";default:return`</${L.rawName}`}}function f(L,Q){if(T(L,Q))return"";switch(L.type){case"ieConditionalComment":case"ieConditionalEndComment":return"[endif]-->";case"ieConditionalStartComment":return"]><!-->";case"interpolation":return"}}";case"element":if(L.isSelfClosing)return"/>";default:return">"}}function T(L,Q){return!L.isSelfClosing&&!L.endSourceSpan&&(E(L)||_(L.parent,Q))}function m(L){return L.prev&&L.prev.type!=="docType"&&!g(L.prev)&&L.isLeadingSpaceSensitive&&!L.hasLeadingSpaces}function v(L){return L.lastChild&&L.lastChild.isTrailingSpaceSensitive&&!L.lastChild.hasTrailingSpaces&&!g(c(L.lastChild))&&!D(L)}function o(L){return!L.next&&!L.hasTrailingSpaces&&L.isTrailingSpaceSensitive&&g(c(L))}function h(L){return L.next&&!g(L.next)&&g(L)&&L.isTrailingSpaceSensitive&&!L.hasTrailingSpaces}function C(L){let Q=L.trim().match(/^prettier-ignore-attribute(?:\s+(.+))?$/s);return Q?Q[1]?Q[1].split(/\s+/):!0:!1}function x(L){return!L.prev&&L.isLeadingSpaceSensitive&&!L.hasLeadingSpaces}function b(L,Q,V){let j=L.getValue();if(!s(j.attrs))return j.isSelfClosing?" ":"";let Y=j.prev&&j.prev.type==="comment"&&C(j.prev.value),ie=typeof Y=="boolean"?()=>Y:Array.isArray(Y)?ue=>Y.includes(ue.rawName):()=>!1,ee=L.map(ue=>{let Fe=ue.getValue();return ie(Fe)?p(Q.originalText.slice(d(Fe),y(Fe))):V()},"attrs"),le=j.type==="element"&&j.fullName==="script"&&j.attrs.length===1&&j.attrs[0].fullName==="src"&&j.children.length===0,K=Q.singleAttributePerLine&&j.attrs.length>1&&!w(j,Q)?l:u,de=[a([le?" ":u,n(K,ee)])];return j.firstChild&&x(j.firstChild)||j.isSelfClosing&&v(j.parent)||le?de.push(j.isSelfClosing?" ":""):de.push(Q.bracketSameLine?j.isSelfClosing?" ":"":j.isSelfClosing?u:i),de}function B(L){return L.firstChild&&x(L.firstChild)?"":J(L)}function k(L,Q,V){let j=L.getValue();return[M(j,Q),b(L,Q,V),j.isSelfClosing?"":B(j)]}function M(L,Q){return L.prev&&h(L.prev)?"":[R(L,Q),q(L)]}function R(L,Q){return x(L)?J(L.parent):m(L)?f(L.prev,Q):""}function q(L){switch(L.type){case"ieConditionalComment":case"ieConditionalStartComment":return`<!--[if ${L.condition}`;case"ieConditionalEndComment":return"<!--<!";case"interpolation":return"{{";case"docType":return"<!DOCTYPE";case"element":if(L.condition)return`<!--[if ${L.condition}]><!--><${L.rawName}`;default:return`<${L.rawName}`}}function J(L){switch(t(!L.isSelfClosing),L.type){case"ieConditionalComment":return"]>";case"element":if(L.condition)return"><!--<![endif]-->";default:return">"}}r.exports={printClosingTag:F,printClosingTagStart:S,printClosingTagStartMarker:$,printClosingTagEndMarker:f,printClosingTagSuffix:P,printClosingTagEnd:N,needsToBorrowLastChildClosingTagEndMarker:v,needsToBorrowParentClosingTagStartMarker:o,needsToBorrowPrevClosingTagEndMarker:m,printOpeningTag:k,printOpeningTagStart:M,printOpeningTagPrefix:R,printOpeningTagStartMarker:q,printOpeningTagEndMarker:J,needsToBorrowNextOpeningTagStartMarker:h,needsToBorrowParentOpeningTagEndMarker:x}}}),xg=te({"node_modules/parse-srcset/src/parse-srcset.js"(e,r){ne(),function(t,s){ true?!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_FACTORY__ = (s),
		__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
		(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)):0}(e,function(){return function(t,s){var a=s&&s.logger||console;function n($){return $===" "||$==="	"||$===`
`||$==="\f"||$==="\r"}function u($){var f,T=$.exec(t.substring(S));if(T)return f=T[0],S+=f.length,f}for(var i=t.length,l=/^[ \t\n\r\u000c]+/,p=/^[, \t\n\r\u000c]+/,d=/^[^ \t\n\r\u000c]+/,y=/[,]+$/,g=/^\d+$/,c=/^-?(?:[0-9]+|[0-9]*\.[0-9]+)(?:[eE][+-]?[0-9]+)?$/,D,E,_,w,F,S=0,N=[];;){if(u(p),S>=i)return N;D=u(d),E=[],D.slice(-1)===","?(D=D.replace(y,""),P()):I()}function I(){for(u(l),_="",w="in descriptor";;){if(F=t.charAt(S),w==="in descriptor")if(n(F))_&&(E.push(_),_="",w="after descriptor");else if(F===","){S+=1,_&&E.push(_),P();return}else if(F==="(")_=_+F,w="in parens";else if(F===""){_&&E.push(_),P();return}else _=_+F;else if(w==="in parens")if(F===")")_=_+F,w="in descriptor";else if(F===""){E.push(_),P();return}else _=_+F;else if(w==="after descriptor"&&!n(F))if(F===""){P();return}else w="in descriptor",S-=1;S+=1}}function P(){var $=!1,f,T,m,v,o={},h,C,x,b,B;for(v=0;v<E.length;v++)h=E[v],C=h[h.length-1],x=h.substring(0,h.length-1),b=parseInt(x,10),B=parseFloat(x),g.test(x)&&C==="w"?((f||T)&&($=!0),b===0?$=!0:f=b):c.test(x)&&C==="x"?((f||T||m)&&($=!0),B<0?$=!0:T=B):g.test(x)&&C==="h"?((m||T)&&($=!0),b===0?$=!0:m=b):$=!0;$?a&&a.error&&a.error("Invalid srcset descriptor found in '"+t+"' at '"+h+"'."):(o.url=D,f&&(o.w=f),T&&(o.d=T),m&&(o.h=m),N.push(o))}}})}}),bg=te({"src/language-html/syntax-attribute.js"(e,r){"use strict";ne();var t=xg(),{builders:{ifBreak:s,join:a,line:n}}=qe();function u(l){let p=t(l,{logger:{error(I){throw new Error(I)}}}),d=p.some(I=>{let{w:P}=I;return P}),y=p.some(I=>{let{h:P}=I;return P}),g=p.some(I=>{let{d:P}=I;return P});if(d+y+g>1)throw new Error("Mixed descriptor in srcset is not supported");let c=d?"w":y?"h":"d",D=d?"w":y?"h":"x",E=I=>Math.max(...I),_=p.map(I=>I.url),w=E(_.map(I=>I.length)),F=p.map(I=>I[c]).map(I=>I?I.toString():""),S=F.map(I=>{let P=I.indexOf(".");return P===-1?I.length:P}),N=E(S);return a([",",n],_.map((I,P)=>{let $=[I],f=F[P];if(f){let T=w-I.length+1,m=N-S[P],v=" ".repeat(T+m);$.push(s(v," "),f+D)}return $}))}function i(l){return l.trim().split(/\s+/).join(" ")}r.exports={printImgSrcset:u,printClassNames:i}}}),Tg=te({"src/language-html/syntax-vue.js"(e,r){"use strict";ne();var{builders:{group:t}}=qe();function s(i,l){let{left:p,operator:d,right:y}=a(i);return[t(l(`function _(${p}) {}`,{parser:"babel",__isVueForBindingLeft:!0}))," ",d," ",l(y,{parser:"__js_expression"},{stripTrailingHardline:!0})]}function a(i){let l=/(.*?)\s+(in|of)\s+(.*)/s,p=/,([^,\]}]*)(?:,([^,\]}]*))?$/,d=/^\(|\)$/g,y=i.match(l);if(!y)return;let g={};if(g.for=y[3].trim(),!g.for)return;let c=y[1].trim().replace(d,""),D=c.match(p);D?(g.alias=c.replace(p,""),g.iterator1=D[1].trim(),D[2]&&(g.iterator2=D[2].trim())):g.alias=c;let E=[g.alias,g.iterator1,g.iterator2];if(!E.some((_,w)=>!_&&(w===0||E.slice(w+1).some(Boolean))))return{left:E.filter(Boolean).join(","),operator:y[2],right:g.for}}function n(i,l){return l(`function _(${i}) {}`,{parser:"babel",__isVueBindings:!0})}function u(i){let l=/^(?:[\w$]+|\([^)]*\))\s*=>|^function\s*\(/,p=/^[$A-Z_a-z][\w$]*(?:\.[$A-Z_a-z][\w$]*|\['[^']*']|\["[^"]*"]|\[\d+]|\[[$A-Z_a-z][\w$]*])*$/,d=i.trim();return l.test(d)||p.test(d)}r.exports={isVueEventBindingExpression:u,printVueFor:s,printVueBindings:n}}}),Lo=te({"src/language-html/get-node-content.js"(e,r){"use strict";ne();var{needsToBorrowParentClosingTagStartMarker:t,printClosingTagStartMarker:s,needsToBorrowLastChildClosingTagEndMarker:a,printClosingTagEndMarker:n,needsToBorrowParentOpeningTagEndMarker:u,printOpeningTagEndMarker:i}=ur();function l(p,d){let y=p.startSourceSpan.end.offset;p.firstChild&&u(p.firstChild)&&(y-=i(p).length);let g=p.endSourceSpan.start.offset;return p.lastChild&&t(p.lastChild)?g+=s(p,d).length:a(p)&&(g-=n(p.lastChild,d).length),d.originalText.slice(y,g)}r.exports=l}}),Bg=te({"src/language-html/embed.js"(e,r){"use strict";ne();var{builders:{breakParent:t,group:s,hardline:a,indent:n,line:u,fill:i,softline:l},utils:{mapDoc:p,replaceTextEndOfLine:d}}=qe(),y=su(),{printClosingTag:g,printClosingTagSuffix:c,needsToBorrowPrevClosingTagEndMarker:D,printOpeningTagPrefix:E,printOpeningTag:_}=ur(),{printImgSrcset:w,printClassNames:F}=bg(),{printVueFor:S,printVueBindings:N,isVueEventBindingExpression:I}=Tg(),{isScriptLikeTag:P,isVueNonHtmlBlock:$,inferScriptParser:f,htmlTrimPreserveIndentation:T,dedentString:m,unescapeQuoteEntities:v,isVueSlotAttribute:o,isVueSfcBindingsAttribute:h,getTextValueParts:C}=Rt(),x=Lo();function b(k,M,R){let q=ee=>new RegExp(ee.join("|")).test(k.fullName),J=()=>v(k.value),L=!1,Q=(ee,le)=>{let W=ee.type==="NGRoot"?ee.node.type==="NGMicrosyntax"&&ee.node.body.length===1&&ee.node.body[0].type==="NGMicrosyntaxExpression"?ee.node.body[0].expression:ee.node:ee.type==="JsExpressionRoot"?ee.node:ee;W&&(W.type==="ObjectExpression"||W.type==="ArrayExpression"||le.parser==="__vue_expression"&&(W.type==="TemplateLiteral"||W.type==="StringLiteral"))&&(L=!0)},V=ee=>s(ee),j=function(ee){let le=arguments.length>1&&arguments[1]!==void 0?arguments[1]:!0;return s([n([l,ee]),le?l:""])},Y=ee=>L?V(ee):j(ee),ie=(ee,le)=>M(ee,Object.assign({__onHtmlBindingRoot:Q,__embeddedInHtml:!0},le));if(k.fullName==="srcset"&&(k.parent.fullName==="img"||k.parent.fullName==="source"))return j(w(J()));if(k.fullName==="class"&&!R.parentParser){let ee=J();if(!ee.includes("{{"))return F(ee)}if(k.fullName==="style"&&!R.parentParser){let ee=J();if(!ee.includes("{{"))return j(ie(ee,{parser:"css",__isHTMLStyleAttribute:!0}))}if(R.parser==="vue"){if(k.fullName==="v-for")return S(J(),ie);if(o(k)||h(k,R))return N(J(),ie);let ee=["^@","^v-on:"],le=["^:","^v-bind:"],W=["^v-"];if(q(ee)){let K=J(),de=I(K)?"__js_expression":R.__should_parse_vue_template_with_ts?"__vue_ts_event_binding":"__vue_event_binding";return Y(ie(K,{parser:de}))}if(q(le))return Y(ie(J(),{parser:"__vue_expression"}));if(q(W))return Y(ie(J(),{parser:"__js_expression"}))}if(R.parser==="angular"){let ee=(z,U)=>ie(z,Object.assign(Object.assign({},U),{},{trailingComma:"none"})),le=["^\\*"],W=["^\\(.+\\)$","^on-"],K=["^\\[.+\\]$","^bind(on)?-","^ng-(if|show|hide|class|style)$"],de=["^i18n(-.+)?$"];if(q(W))return Y(ee(J(),{parser:"__ng_action"}));if(q(K))return Y(ee(J(),{parser:"__ng_binding"}));if(q(de)){let z=J().trim();return j(i(C(k,z)),!z.includes("@@"))}if(q(le))return Y(ee(J(),{parser:"__ng_directive"}));let ue=/{{(.+?)}}/s,Fe=J();if(ue.test(Fe)){let z=[];for(let[U,Z]of Fe.split(ue).entries())if(U%2===0)z.push(d(Z));else try{z.push(s(["{{",n([u,ee(Z,{parser:"__ng_interpolation",__isInHtmlInterpolation:!0})]),u,"}}"]))}catch{z.push("{{",d(Z),"}}")}return s(z)}}return null}function B(k,M,R,q){let J=k.getValue();switch(J.type){case"element":{if(P(J)||J.type==="interpolation")return;if(!J.isSelfClosing&&$(J,q)){let L=f(J,q);if(!L)return;let Q=x(J,q),V=/^\s*$/.test(Q),j="";return V||(j=R(T(Q),{parser:L,__embeddedInHtml:!0},{stripTrailingHardline:!0}),V=j===""),[E(J,q),s(_(k,q,M)),V?"":a,j,V?"":a,g(J,q),c(J,q)]}break}case"text":{if(P(J.parent)){let L=f(J.parent,q);if(L){let Q=L==="markdown"?m(J.value.replace(/^[^\S\n]*\n/,"")):J.value,V={parser:L,__embeddedInHtml:!0};if(q.parser==="html"&&L==="babel"){let j="script",{attrMap:Y}=J.parent;Y&&(Y.type==="module"||Y.type==="text/babel"&&Y["data-type"]==="module")&&(j="module"),V.__babelSourceType=j}return[t,E(J,q),R(Q,V,{stripTrailingHardline:!0}),c(J,q)]}}else if(J.parent.type==="interpolation"){let L={__isInHtmlInterpolation:!0,__embeddedInHtml:!0};return q.parser==="angular"?(L.parser="__ng_interpolation",L.trailingComma="none"):q.parser==="vue"?L.parser=q.__should_parse_vue_template_with_ts?"__vue_ts_expression":"__vue_expression":L.parser="__js_expression",[n([u,R(J.value,L,{stripTrailingHardline:!0})]),J.parent.next&&D(J.parent.next)?" ":u]}break}case"attribute":{if(!J.value)break;if(/^PRETTIER_HTML_PLACEHOLDER_\d+_\d+_IN_JS$/.test(q.originalText.slice(J.valueSpan.start.offset,J.valueSpan.end.offset)))return[J.rawName,"=",J.value];if(q.parser==="lwc"&&/^{.*}$/s.test(q.originalText.slice(J.valueSpan.start.offset,J.valueSpan.end.offset)))return[J.rawName,"=",J.value];let L=b(J,(Q,V)=>R(Q,Object.assign({__isInHtmlAttribute:!0,__embeddedInHtml:!0},V),{stripTrailingHardline:!0}),q);if(L)return[J.rawName,'="',s(p(L,Q=>typeof Q=="string"?Q.replace(/"/g,"&quot;"):Q)),'"'];break}case"front-matter":return y(J,R)}}r.exports=B}}),Oo=te({"src/language-html/print/children.js"(e,r){"use strict";ne();var{builders:{breakParent:t,group:s,ifBreak:a,line:n,softline:u,hardline:i},utils:{replaceTextEndOfLine:l}}=qe(),{locStart:p,locEnd:d}=au(),{forceBreakChildren:y,forceNextEmptyLine:g,isTextLikeNode:c,hasPrettierIgnore:D,preferHardlineAsLeadingSpaces:E}=Rt(),{printOpeningTagPrefix:_,needsToBorrowNextOpeningTagStartMarker:w,printOpeningTagStartMarker:F,needsToBorrowPrevClosingTagEndMarker:S,printClosingTagEndMarker:N,printClosingTagSuffix:I,needsToBorrowParentClosingTagStartMarker:P}=ur();function $(m,v,o){let h=m.getValue();return D(h)?[_(h,v),...l(v.originalText.slice(p(h)+(h.prev&&w(h.prev)?F(h).length:0),d(h)-(h.next&&S(h.next)?N(h,v).length:0))),I(h,v)]:o()}function f(m,v){return c(m)&&c(v)?m.isTrailingSpaceSensitive?m.hasTrailingSpaces?E(v)?i:n:"":E(v)?i:u:w(m)&&(D(v)||v.firstChild||v.isSelfClosing||v.type==="element"&&v.attrs.length>0)||m.type==="element"&&m.isSelfClosing&&S(v)?"":!v.isLeadingSpaceSensitive||E(v)||S(v)&&m.lastChild&&P(m.lastChild)&&m.lastChild.lastChild&&P(m.lastChild.lastChild)?i:v.hasLeadingSpaces?n:u}function T(m,v,o){let h=m.getValue();if(y(h))return[t,...m.map(x=>{let b=x.getValue(),B=b.prev?f(b.prev,b):"";return[B?[B,g(b.prev)?i:""]:"",$(x,v,o)]},"children")];let C=h.children.map(()=>Symbol(""));return m.map((x,b)=>{let B=x.getValue();if(c(B)){if(B.prev&&c(B.prev)){let Q=f(B.prev,B);if(Q)return g(B.prev)?[i,i,$(x,v,o)]:[Q,$(x,v,o)]}return $(x,v,o)}let k=[],M=[],R=[],q=[],J=B.prev?f(B.prev,B):"",L=B.next?f(B,B.next):"";return J&&(g(B.prev)?k.push(i,i):J===i?k.push(i):c(B.prev)?M.push(J):M.push(a("",u,{groupId:C[b-1]}))),L&&(g(B)?c(B.next)&&q.push(i,i):L===i?c(B.next)&&q.push(i):R.push(L)),[...k,s([...M,s([$(x,v,o),...R],{id:C[b]})]),...q]},"children")}r.exports={printChildren:T}}}),Ng=te({"src/language-html/print/element.js"(e,r){"use strict";ne();var{builders:{breakParent:t,dedentToRoot:s,group:a,ifBreak:n,indentIfBreak:u,indent:i,line:l,softline:p},utils:{replaceTextEndOfLine:d}}=qe(),y=Lo(),{shouldPreserveContent:g,isScriptLikeTag:c,isVueCustomBlock:D,countParents:E,forceBreakContent:_}=Rt(),{printOpeningTagPrefix:w,printOpeningTag:F,printClosingTagSuffix:S,printClosingTag:N,needsToBorrowPrevClosingTagEndMarker:I,needsToBorrowLastChildClosingTagEndMarker:P}=ur(),{printChildren:$}=Oo();function f(T,m,v){let o=T.getValue();if(g(o,m))return[w(o,m),a(F(T,m,v)),...d(y(o,m)),...N(o,m),S(o,m)];let h=o.children.length===1&&o.firstChild.type==="interpolation"&&o.firstChild.isLeadingSpaceSensitive&&!o.firstChild.hasLeadingSpaces&&o.lastChild.isTrailingSpaceSensitive&&!o.lastChild.hasTrailingSpaces,C=Symbol("element-attr-group-id"),x=M=>a([a(F(T,m,v),{id:C}),M,N(o,m)]),b=M=>h?u(M,{groupId:C}):(c(o)||D(o,m))&&o.parent.type==="root"&&m.parser==="vue"&&!m.vueIndentScriptAndStyle?M:i(M),B=()=>h?n(p,"",{groupId:C}):o.firstChild.hasLeadingSpaces&&o.firstChild.isLeadingSpaceSensitive?l:o.firstChild.type==="text"&&o.isWhitespaceSensitive&&o.isIndentationSensitive?s(p):p,k=()=>(o.next?I(o.next):P(o.parent))?o.lastChild.hasTrailingSpaces&&o.lastChild.isTrailingSpaceSensitive?" ":"":h?n(p,"",{groupId:C}):o.lastChild.hasTrailingSpaces&&o.lastChild.isTrailingSpaceSensitive?l:(o.lastChild.type==="comment"||o.lastChild.type==="text"&&o.isWhitespaceSensitive&&o.isIndentationSensitive)&&new RegExp(`\\n[\\t ]{${m.tabWidth*E(T,R=>R.parent&&R.parent.type!=="root")}}$`).test(o.lastChild.value)?"":p;return o.children.length===0?x(o.hasDanglingSpaces&&o.isDanglingSpaceSensitive?l:""):x([_(o)?t:"",b([B(),$(T,m,v)]),k()])}r.exports={printElement:f}}}),wg=te({"src/language-html/printer-html.js"(e,r){"use strict";ne();var{builders:{fill:t,group:s,hardline:a,literalline:n},utils:{cleanDoc:u,getDocParts:i,isConcat:l,replaceTextEndOfLine:p}}=qe(),d=dg(),{countChars:y,unescapeQuoteEntities:g,getTextValueParts:c}=Rt(),D=Ag(),{insertPragma:E}=Sg(),{locStart:_,locEnd:w}=au(),F=Bg(),{printClosingTagSuffix:S,printClosingTagEnd:N,printOpeningTagPrefix:I,printOpeningTagStart:P}=ur(),{printElement:$}=Ng(),{printChildren:f}=Oo();function T(m,v,o){let h=m.getValue();switch(h.type){case"front-matter":return p(h.raw);case"root":return v.__onHtmlRoot&&v.__onHtmlRoot(h),[s(f(m,v,o)),a];case"element":case"ieConditionalComment":return $(m,v,o);case"ieConditionalStartComment":case"ieConditionalEndComment":return[P(h),N(h)];case"interpolation":return[P(h,v),...m.map(o,"children"),N(h,v)];case"text":{if(h.parent.type==="interpolation"){let x=/\n[^\S\n]*$/,b=x.test(h.value),B=b?h.value.replace(x,""):h.value;return[...p(B),b?a:""]}let C=u([I(h,v),...c(h),S(h,v)]);return l(C)||C.type==="fill"?t(i(C)):C}case"docType":return[s([P(h,v)," ",h.value.replace(/^html\b/i,"html").replace(/\s+/g," ")]),N(h,v)];case"comment":return[I(h,v),...p(v.originalText.slice(_(h),w(h)),n),S(h,v)];case"attribute":{if(h.value===null)return h.rawName;let C=g(h.value),x=y(C,"'"),b=y(C,'"'),B=x<b?"'":'"';return[h.rawName,"=",B,...p(B==='"'?C.replace(/"/g,"&quot;"):C.replace(/'/g,"&apos;")),B]}default:throw new Error(`Unexpected node type ${h.type}`)}}r.exports={preprocess:D,print:T,insertPragma:E,massageAstNode:d,embed:F}}}),_g=te({"src/language-html/options.js"(e,r){"use strict";ne();var t=Mt(),s="HTML";r.exports={bracketSameLine:t.bracketSameLine,htmlWhitespaceSensitivity:{since:"1.15.0",category:s,type:"choice",default:"css",description:"How to handle whitespaces in HTML.",choices:[{value:"css",description:"Respect the default value of CSS display property."},{value:"strict",description:"Whitespaces are considered sensitive."},{value:"ignore",description:"Whitespaces are considered insensitive."}]},singleAttributePerLine:t.singleAttributePerLine,vueIndentScriptAndStyle:{since:"1.19.0",category:s,type:"boolean",default:!1,description:"Indent script and style tags in Vue files."}}}}),Pg=te({"src/language-html/parsers.js"(){ne()}}),On=te({"node_modules/linguist-languages/data/HTML.json"(e,r){r.exports={name:"HTML",type:"markup",tmScope:"text.html.basic",aceMode:"html",codemirrorMode:"htmlmixed",codemirrorMimeType:"text/html",color:"#e34c26",aliases:["xhtml"],extensions:[".html",".hta",".htm",".html.hl",".inc",".xht",".xhtml"],languageId:146}}}),Ig=te({"node_modules/linguist-languages/data/Vue.json"(e,r){r.exports={name:"Vue",type:"markup",color:"#41b883",extensions:[".vue"],tmScope:"text.html.vue",aceMode:"html",languageId:391}}}),kg=te({"src/language-html/index.js"(e,r){"use strict";ne();var t=_t(),s=wg(),a=_g(),n=Pg(),u=[t(On(),()=>({name:"Angular",since:"1.15.0",parsers:["angular"],vscodeLanguageIds:["html"],extensions:[".component.html"],filenames:[]})),t(On(),l=>({since:"1.15.0",parsers:["html"],vscodeLanguageIds:["html"],extensions:[...l.extensions,".mjml"]})),t(On(),()=>({name:"Lightning Web Components",since:"1.17.0",parsers:["lwc"],vscodeLanguageIds:["html"],extensions:[],filenames:[]})),t(Ig(),()=>({since:"1.10.0",parsers:["vue"],vscodeLanguageIds:["vue"]}))],i={html:s};r.exports={languages:u,printers:i,options:a,parsers:n}}}),Lg=te({"src/language-yaml/pragma.js"(e,r){"use strict";ne();function t(n){return/^\s*@(?:prettier|format)\s*$/.test(n)}function s(n){return/^\s*#[^\S\n]*@(?:prettier|format)\s*?(?:\n|$)/.test(n)}function a(n){return`# @format

${n}`}r.exports={isPragma:t,hasPragma:s,insertPragma:a}}}),Og=te({"src/language-yaml/loc.js"(e,r){"use strict";ne();function t(a){return a.position.start.offset}function s(a){return a.position.end.offset}r.exports={locStart:t,locEnd:s}}}),jg=te({"src/language-yaml/embed.js"(e,r){"use strict";ne();function t(s,a,n,u){if(s.getValue().type==="root"&&u.filepath&&/(?:[/\\]|^)\.(?:prettier|stylelint|lintstaged)rc$/.test(u.filepath))return n(u.originalText,Object.assign(Object.assign({},u),{},{parser:"json"}))}r.exports=t}}),$t=te({"src/language-yaml/utils.js"(e,r){"use strict";ne();var{getLast:t,isNonEmptyArray:s}=Ue();function a(f,T){let m=0,v=f.stack.length-1;for(let o=0;o<v;o++){let h=f.stack[o];n(h)&&T(h)&&m++}return m}function n(f,T){return f&&typeof f.type=="string"&&(!T||T.includes(f.type))}function u(f,T,m){return T("children"in f?Object.assign(Object.assign({},f),{},{children:f.children.map(v=>u(v,T,f))}):f,m)}function i(f,T,m){Object.defineProperty(f,T,{get:m,enumerable:!1})}function l(f,T){let m=0,v=T.length;for(let o=f.position.end.offset-1;o<v;o++){let h=T[o];if(h===`
`&&m++,m===1&&/\S/.test(h))return!1;if(m===2)return!0}return!1}function p(f){switch(f.getValue().type){case"tag":case"anchor":case"comment":return!1}let m=f.stack.length;for(let v=1;v<m;v++){let o=f.stack[v],h=f.stack[v-1];if(Array.isArray(h)&&typeof o=="number"&&o!==h.length-1)return!1}return!0}function d(f){return s(f.children)?d(t(f.children)):f}function y(f){return f.value.trim()==="prettier-ignore"}function g(f){let T=f.getValue();if(T.type==="documentBody"){let m=f.getParentNode();return S(m.head)&&y(t(m.head.endComments))}return E(T)&&y(t(T.leadingComments))}function c(f){return!s(f.children)&&!D(f)}function D(f){return E(f)||_(f)||w(f)||F(f)||S(f)}function E(f){return s(f==null?void 0:f.leadingComments)}function _(f){return s(f==null?void 0:f.middleComments)}function w(f){return f==null?void 0:f.indicatorComment}function F(f){return f==null?void 0:f.trailingComment}function S(f){return s(f==null?void 0:f.endComments)}function N(f){let T=[],m;for(let v of f.split(/( +)/))v!==" "?m===" "?T.push(v):T.push((T.pop()||"")+v):m===void 0&&T.unshift(""),m=v;return m===" "&&T.push((T.pop()||"")+" "),T[0]===""&&(T.shift(),T.unshift(" "+(T.shift()||""))),T}function I(f,T,m){let v=T.split(`
`).map((o,h,C)=>h===0&&h===C.length-1?o:h!==0&&h!==C.length-1?o.trim():h===0?o.trimEnd():o.trimStart());return m.proseWrap==="preserve"?v.map(o=>o.length===0?[]:[o]):v.map(o=>o.length===0?[]:N(o)).reduce((o,h,C)=>C!==0&&v[C-1].length>0&&h.length>0&&!(f==="quoteDouble"&&t(t(o)).endsWith("\\"))?[...o.slice(0,-1),[...t(o),...h]]:[...o,h],[]).map(o=>m.proseWrap==="never"?[o.join(" ")]:o)}function P(f,T){let{parentIndent:m,isLastDescendant:v,options:o}=T,h=f.position.start.line===f.position.end.line?"":o.originalText.slice(f.position.start.offset,f.position.end.offset).match(/^[^\n]*\n(.*)$/s)[1],C;if(f.indent===null){let B=h.match(/^(?<leadingSpace> *)[^\n\r ]/m);C=B?B.groups.leadingSpace.length:Number.POSITIVE_INFINITY}else C=f.indent-1+m;let x=h.split(`
`).map(B=>B.slice(C));if(o.proseWrap==="preserve"||f.type==="blockLiteral")return b(x.map(B=>B.length===0?[]:[B]));return b(x.map(B=>B.length===0?[]:N(B)).reduce((B,k,M)=>M!==0&&x[M-1].length>0&&k.length>0&&!/^\s/.test(k[0])&&!/^\s|\s$/.test(t(B))?[...B.slice(0,-1),[...t(B),...k]]:[...B,k],[]).map(B=>B.reduce((k,M)=>k.length>0&&/\s$/.test(t(k))?[...k.slice(0,-1),t(k)+" "+M]:[...k,M],[])).map(B=>o.proseWrap==="never"?[B.join(" ")]:B));function b(B){if(f.chomping==="keep")return t(B).length===0?B.slice(0,-1):B;let k=0;for(let M=B.length-1;M>=0&&B[M].length===0;M--)k++;return k===0?B:k>=2&&!v?B.slice(0,-(k-1)):B.slice(0,-k)}}function $(f){if(!f)return!0;switch(f.type){case"plain":case"quoteDouble":case"quoteSingle":case"alias":case"flowMapping":case"flowSequence":return!0;default:return!1}}r.exports={getLast:t,getAncestorCount:a,isNode:n,isEmptyNode:c,isInlineNode:$,mapNode:u,defineShortcut:i,isNextLineEmpty:l,isLastDescendantNode:p,getBlockValueLineContents:P,getFlowScalarLineContents:I,getLastDescendantNode:d,hasPrettierIgnore:g,hasLeadingComments:E,hasMiddleComments:_,hasIndicatorComment:w,hasTrailingComment:F,hasEndComments:S}}}),qg=te({"src/language-yaml/print-preprocess.js"(e,r){"use strict";ne();var{defineShortcut:t,mapNode:s}=$t();function a(u){return s(u,n)}function n(u){switch(u.type){case"document":t(u,"head",()=>u.children[0]),t(u,"body",()=>u.children[1]);break;case"documentBody":case"sequenceItem":case"flowSequenceItem":case"mappingKey":case"mappingValue":t(u,"content",()=>u.children[0]);break;case"mappingItem":case"flowMappingItem":t(u,"key",()=>u.children[0]),t(u,"value",()=>u.children[1]);break}return u}r.exports=a}}),Mr=te({"src/language-yaml/print/misc.js"(e,r){"use strict";ne();var{builders:{softline:t,align:s}}=qe(),{hasEndComments:a,isNextLineEmpty:n,isNode:u}=$t(),i=new WeakMap;function l(y,g){let c=y.getValue(),D=y.stack[0],E;return i.has(D)?E=i.get(D):(E=new Set,i.set(D,E)),!E.has(c.position.end.line)&&(E.add(c.position.end.line),n(c,g)&&!p(y.getParentNode()))?t:""}function p(y){return a(y)&&!u(y,["documentHead","documentBody","flowMapping","flowSequence"])}function d(y,g){return s(" ".repeat(y),g)}r.exports={alignWithSpaces:d,shouldPrintEndComments:p,printNextEmptyLine:l}}}),Mg=te({"src/language-yaml/print/flow-mapping-sequence.js"(e,r){"use strict";ne();var{builders:{ifBreak:t,line:s,softline:a,hardline:n,join:u}}=qe(),{isEmptyNode:i,getLast:l,hasEndComments:p}=$t(),{printNextEmptyLine:d,alignWithSpaces:y}=Mr();function g(D,E,_){let w=D.getValue(),F=w.type==="flowMapping",S=F?"{":"[",N=F?"}":"]",I=a;F&&w.children.length>0&&_.bracketSpacing&&(I=s);let P=l(w.children),$=P&&P.type==="flowMappingItem"&&i(P.key)&&i(P.value);return[S,y(_.tabWidth,[I,c(D,E,_),_.trailingComma==="none"?"":t(","),p(w)?[n,u(n,D.map(E,"endComments"))]:""]),$?"":I,N]}function c(D,E,_){let w=D.getValue();return D.map((S,N)=>[E(),N===w.children.length-1?"":[",",s,w.children[N].position.start.line!==w.children[N+1].position.start.line?d(S,_.originalText):""]],"children")}r.exports={printFlowMapping:g,printFlowSequence:g}}}),Rg=te({"src/language-yaml/print/mapping-item.js"(e,r){"use strict";ne();var{builders:{conditionalGroup:t,group:s,hardline:a,ifBreak:n,join:u,line:i}}=qe(),{hasLeadingComments:l,hasMiddleComments:p,hasTrailingComment:d,hasEndComments:y,isNode:g,isEmptyNode:c,isInlineNode:D}=$t(),{alignWithSpaces:E}=Mr();function _(N,I,P,$,f){let{key:T,value:m}=N,v=c(T),o=c(m);if(v&&o)return": ";let h=$("key"),C=F(N)?" ":"";if(o)return N.type==="flowMappingItem"&&I.type==="flowMapping"?h:N.type==="mappingItem"&&w(T.content,f)&&!d(T.content)&&(!I.tag||I.tag.value!=="tag:yaml.org,2002:set")?[h,C,":"]:["? ",E(2,h)];let x=$("value");if(v)return[": ",E(2,x)];if(l(m)||!D(T.content))return["? ",E(2,h),a,u("",P.map($,"value","leadingComments").map(q=>[q,a])),": ",E(2,x)];if(S(T.content)&&!l(T.content)&&!p(T.content)&&!d(T.content)&&!y(T)&&!l(m.content)&&!p(m.content)&&!y(m)&&w(m.content,f))return[h,C,": ",x];let b=Symbol("mappingKey"),B=s([n("? "),s(E(2,h),{id:b})]),k=[a,": ",E(2,x)],M=[C,":"];l(m.content)||y(m)&&m.content&&!g(m.content,["mapping","sequence"])||I.type==="mapping"&&d(T.content)&&D(m.content)||g(m.content,["mapping","sequence"])&&m.content.tag===null&&m.content.anchor===null?M.push(a):m.content&&M.push(i),M.push(x);let R=E(f.tabWidth,M);return w(T.content,f)&&!l(T.content)&&!p(T.content)&&!y(T)?t([[h,R]]):t([[B,n(k,R,{groupId:b})]])}function w(N,I){if(!N)return!0;switch(N.type){case"plain":case"quoteSingle":case"quoteDouble":break;case"alias":return!0;default:return!1}if(I.proseWrap==="preserve")return N.position.start.line===N.position.end.line;if(/\\$/m.test(I.originalText.slice(N.position.start.offset,N.position.end.offset)))return!1;switch(I.proseWrap){case"never":return!N.value.includes(`
`);case"always":return!/[\n ]/.test(N.value);default:return!1}}function F(N){return N.key.content&&N.key.content.type==="alias"}function S(N){if(!N)return!0;switch(N.type){case"plain":case"quoteDouble":case"quoteSingle":return N.position.start.line===N.position.end.line;case"alias":return!0;default:return!1}}r.exports=_}}),$g=te({"src/language-yaml/print/block.js"(e,r){"use strict";ne();var{builders:{dedent:t,dedentToRoot:s,fill:a,hardline:n,join:u,line:i,literalline:l,markAsRoot:p},utils:{getDocParts:d}}=qe(),{getAncestorCount:y,getBlockValueLineContents:g,hasIndicatorComment:c,isLastDescendantNode:D,isNode:E}=$t(),{alignWithSpaces:_}=Mr();function w(F,S,N){let I=F.getValue(),P=y(F,v=>E(v,["sequence","mapping"])),$=D(F),f=[I.type==="blockFolded"?">":"|"];I.indent!==null&&f.push(I.indent.toString()),I.chomping!=="clip"&&f.push(I.chomping==="keep"?"+":"-"),c(I)&&f.push(" ",S("indicatorComment"));let T=g(I,{parentIndent:P,isLastDescendant:$,options:N}),m=[];for(let[v,o]of T.entries())v===0&&m.push(n),m.push(a(d(u(i,o)))),v!==T.length-1?m.push(o.length===0?n:p(l)):I.chomping==="keep"&&$&&m.push(s(o.length===0?n:l));return I.indent===null?f.push(t(_(N.tabWidth,m))):f.push(s(_(I.indent-1+P,m))),f}r.exports=w}}),Vg=te({"src/language-yaml/printer-yaml.js"(e,r){"use strict";ne();var{builders:{breakParent:t,fill:s,group:a,hardline:n,join:u,line:i,lineSuffix:l,literalline:p},utils:{getDocParts:d,replaceTextEndOfLine:y}}=qe(),{isPreviousLineEmpty:g}=Ue(),{insertPragma:c,isPragma:D}=Lg(),{locStart:E}=Og(),_=jg(),{getFlowScalarLineContents:w,getLastDescendantNode:F,hasLeadingComments:S,hasMiddleComments:N,hasTrailingComment:I,hasEndComments:P,hasPrettierIgnore:$,isLastDescendantNode:f,isNode:T,isInlineNode:m}=$t(),v=qg(),{alignWithSpaces:o,printNextEmptyLine:h,shouldPrintEndComments:C}=Mr(),{printFlowMapping:x,printFlowSequence:b}=Mg(),B=Rg(),k=$g();function M(j,Y,ie){let ee=j.getValue(),le=[];ee.type!=="mappingValue"&&S(ee)&&le.push([u(n,j.map(ie,"leadingComments")),n]);let{tag:W,anchor:K}=ee;W&&le.push(ie("tag")),W&&K&&le.push(" "),K&&le.push(ie("anchor"));let de="";T(ee,["mapping","sequence","comment","directive","mappingItem","sequenceItem"])&&!f(j)&&(de=h(j,Y.originalText)),(W||K)&&(T(ee,["sequence","mapping"])&&!N(ee)?le.push(n):le.push(" ")),N(ee)&&le.push([ee.middleComments.length===1?"":n,u(n,j.map(ie,"middleComments")),n]);let ue=j.getParentNode();return $(j)?le.push(y(Y.originalText.slice(ee.position.start.offset,ee.position.end.offset).trimEnd(),p)):le.push(a(R(ee,ue,j,Y,ie))),I(ee)&&!T(ee,["document","documentHead"])&&le.push(l([ee.type==="mappingValue"&&!ee.content?"":" ",ue.type==="mappingKey"&&j.getParentNode(2).type==="mapping"&&m(ee)?"":t,ie("trailingComment")])),C(ee)&&le.push(o(ee.type==="sequenceItem"?2:0,[n,u(n,j.map(Fe=>[g(Y.originalText,Fe.getValue(),E)?n:"",ie()],"endComments"))])),le.push(de),le}function R(j,Y,ie,ee,le){switch(j.type){case"root":{let{children:W}=j,K=[];ie.each((ue,Fe)=>{let z=W[Fe],U=W[Fe+1];Fe!==0&&K.push(n),K.push(le()),J(z,U)?(K.push(n,"..."),I(z)&&K.push(" ",le("trailingComment"))):U&&!I(U.head)&&K.push(n,"---")},"children");let de=F(j);return(!T(de,["blockLiteral","blockFolded"])||de.chomping!=="keep")&&K.push(n),K}case"document":{let W=Y.children[ie.getName()+1],K=[];return L(j,W,Y,ee)==="head"&&((j.head.children.length>0||j.head.endComments.length>0)&&K.push(le("head")),I(j.head)?K.push(["---"," ",le(["head","trailingComment"])]):K.push("---")),q(j)&&K.push(le("body")),u(n,K)}case"documentHead":return u(n,[...ie.map(le,"children"),...ie.map(le,"endComments")]);case"documentBody":{let{children:W,endComments:K}=j,de="";if(W.length>0&&K.length>0){let ue=F(j);T(ue,["blockFolded","blockLiteral"])?ue.chomping!=="keep"&&(de=[n,n]):de=n}return[u(n,ie.map(le,"children")),de,u(n,ie.map(le,"endComments"))]}case"directive":return["%",u(" ",[j.name,...j.parameters])];case"comment":return["#",j.value];case"alias":return["*",j.value];case"tag":return ee.originalText.slice(j.position.start.offset,j.position.end.offset);case"anchor":return["&",j.value];case"plain":return Q(j.type,ee.originalText.slice(j.position.start.offset,j.position.end.offset),ee);case"quoteDouble":case"quoteSingle":{let W="'",K='"',de=ee.originalText.slice(j.position.start.offset+1,j.position.end.offset-1);if(j.type==="quoteSingle"&&de.includes("\\")||j.type==="quoteDouble"&&/\\[^"]/.test(de)){let Fe=j.type==="quoteDouble"?K:W;return[Fe,Q(j.type,de,ee),Fe]}if(de.includes(K))return[W,Q(j.type,j.type==="quoteDouble"?de.replace(/\\"/g,K).replace(/'/g,W.repeat(2)):de,ee),W];if(de.includes(W))return[K,Q(j.type,j.type==="quoteSingle"?de.replace(/''/g,W):de,ee),K];let ue=ee.singleQuote?W:K;return[ue,Q(j.type,de,ee),ue]}case"blockFolded":case"blockLiteral":return k(ie,le,ee);case"mapping":case"sequence":return u(n,ie.map(le,"children"));case"sequenceItem":return["- ",o(2,j.content?le("content"):"")];case"mappingKey":case"mappingValue":return j.content?le("content"):"";case"mappingItem":case"flowMappingItem":return B(j,Y,ie,le,ee);case"flowMapping":return x(ie,le,ee);case"flowSequence":return b(ie,le,ee);case"flowSequenceItem":return le("content");default:throw new Error(`Unexpected node type ${j.type}`)}}function q(j){return j.body.children.length>0||P(j.body)}function J(j,Y){return I(j)||Y&&(Y.head.children.length>0||P(Y.head))}function L(j,Y,ie,ee){return ie.children[0]===j&&/---(?:\s|$)/.test(ee.originalText.slice(E(j),E(j)+4))||j.head.children.length>0||P(j.head)||I(j.head)?"head":J(j,Y)?!1:Y?"root":!1}function Q(j,Y,ie){let ee=w(j,Y,ie);return u(n,ee.map(le=>s(d(u(i,le)))))}function V(j,Y){if(T(Y))switch(delete Y.position,Y.type){case"comment":if(D(Y.value))return null;break;case"quoteDouble":case"quoteSingle":Y.type="quote";break}}r.exports={preprocess:v,embed:_,print:M,massageAstNode:V,insertPragma:c}}}),Wg=te({"src/language-yaml/options.js"(e,r){"use strict";ne();var t=Mt();r.exports={bracketSpacing:t.bracketSpacing,singleQuote:t.singleQuote,proseWrap:t.proseWrap}}}),Hg=te({"src/language-yaml/parsers.js"(){ne()}}),Gg=te({"node_modules/linguist-languages/data/YAML.json"(e,r){r.exports={name:"YAML",type:"data",color:"#cb171e",tmScope:"source.yaml",aliases:["yml"],extensions:[".yml",".mir",".reek",".rviz",".sublime-syntax",".syntax",".yaml",".yaml-tmlanguage",".yaml.sed",".yml.mysql"],filenames:[".clang-format",".clang-tidy",".gemrc","CITATION.cff","glide.lock","yarn.lock"],aceMode:"yaml",codemirrorMode:"yaml",codemirrorMimeType:"text/x-yaml",languageId:407}}}),Ug=te({"src/language-yaml/index.js"(e,r){"use strict";ne();var t=_t(),s=Vg(),a=Wg(),n=Hg(),u=[t(Gg(),i=>({since:"1.14.0",parsers:["yaml"],vscodeLanguageIds:["yaml","ansible","home-assistant"],filenames:[...i.filenames.filter(l=>l!=="yarn.lock"),".prettierrc",".stylelintrc",".lintstagedrc"]}))];r.exports={languages:u,printers:{yaml:s},options:a,parsers:n}}}),Jg=te({"src/languages.js"(e,r){"use strict";ne(),r.exports=[Td(),Gd(),Zd(),ig(),mg(),kg(),Ug()]}});ne();var{version:zg}=Ia(),Lt=Gm(),{getSupportInfo:Xg}=Xn(),Kg=Um(),Yg=Jg(),Qg=qe();function Nt(e){let r=arguments.length>1&&arguments[1]!==void 0?arguments[1]:1;return function(){for(var t=arguments.length,s=new Array(t),a=0;a<t;a++)s[a]=arguments[a];let n=s[r]||{},u=n.plugins||[];return s[r]=Object.assign(Object.assign({},n),{},{plugins:[...Yg,...Array.isArray(u)?u:Object.values(u)]}),e(...s)}}var jn=Nt(Lt.formatWithCursor);jo.exports={formatWithCursor:jn,format(e,r){return jn(e,r).formatted},check(e,r){let{formatted:t}=jn(e,r);return t===e},doc:Qg,getSupportInfo:Nt(Xg,0),version:zg,util:Kg,__debug:{parse:Nt(Lt.parse),formatAST:Nt(Lt.formatAST),formatDoc:Nt(Lt.formatDoc),printToDoc:Nt(Lt.printToDoc),printDocToString:Nt(Lt.printDocToString)}}});return Zg();});

/***/ }),

/***/ "./src/style.css":
/*!***********************!*\
  !*** ./src/style.css ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)
/* harmony export */ });
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js */ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleDomAPI.js */ "./node_modules/style-loader/dist/runtime/styleDomAPI.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertBySelector.js */ "./node_modules/style-loader/dist/runtime/insertBySelector.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js */ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/insertStyleElement.js */ "./node_modules/style-loader/dist/runtime/insertStyleElement.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4__);
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! !../node_modules/style-loader/dist/runtime/styleTagTransform.js */ "./node_modules/style-loader/dist/runtime/styleTagTransform.js");
/* harmony import */ var _node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default = /*#__PURE__*/__webpack_require__.n(_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5__);
/* harmony import */ var _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! !!../node_modules/css-loader/dist/cjs.js!./style.css */ "./node_modules/css-loader/dist/cjs.js!./src/style.css");

      
      
      
      
      
      
      
      
      

var options = {};

options.styleTagTransform = (_node_modules_style_loader_dist_runtime_styleTagTransform_js__WEBPACK_IMPORTED_MODULE_5___default());
options.setAttributes = (_node_modules_style_loader_dist_runtime_setAttributesWithoutAttributes_js__WEBPACK_IMPORTED_MODULE_3___default());

      options.insert = _node_modules_style_loader_dist_runtime_insertBySelector_js__WEBPACK_IMPORTED_MODULE_2___default().bind(null, "head");
    
options.domAPI = (_node_modules_style_loader_dist_runtime_styleDomAPI_js__WEBPACK_IMPORTED_MODULE_1___default());
options.insertStyleElement = (_node_modules_style_loader_dist_runtime_insertStyleElement_js__WEBPACK_IMPORTED_MODULE_4___default());

var update = _node_modules_style_loader_dist_runtime_injectStylesIntoStyleTag_js__WEBPACK_IMPORTED_MODULE_0___default()(_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"], options);




       /* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (_node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"] && _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals ? _node_modules_css_loader_dist_cjs_js_style_css__WEBPACK_IMPORTED_MODULE_6__["default"].locals : undefined);


/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js":
/*!****************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/injectStylesIntoStyleTag.js ***!
  \****************************************************************************/
/***/ ((module) => {

"use strict";


var stylesInDOM = [];

function getIndexByIdentifier(identifier) {
  var result = -1;

  for (var i = 0; i < stylesInDOM.length; i++) {
    if (stylesInDOM[i].identifier === identifier) {
      result = i;
      break;
    }
  }

  return result;
}

function modulesToDom(list, options) {
  var idCountMap = {};
  var identifiers = [];

  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = options.base ? item[0] + options.base : item[0];
    var count = idCountMap[id] || 0;
    var identifier = "".concat(id, " ").concat(count);
    idCountMap[id] = count + 1;
    var indexByIdentifier = getIndexByIdentifier(identifier);
    var obj = {
      css: item[1],
      media: item[2],
      sourceMap: item[3],
      supports: item[4],
      layer: item[5]
    };

    if (indexByIdentifier !== -1) {
      stylesInDOM[indexByIdentifier].references++;
      stylesInDOM[indexByIdentifier].updater(obj);
    } else {
      var updater = addElementStyle(obj, options);
      options.byIndex = i;
      stylesInDOM.splice(i, 0, {
        identifier: identifier,
        updater: updater,
        references: 1
      });
    }

    identifiers.push(identifier);
  }

  return identifiers;
}

function addElementStyle(obj, options) {
  var api = options.domAPI(options);
  api.update(obj);

  var updater = function updater(newObj) {
    if (newObj) {
      if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap && newObj.supports === obj.supports && newObj.layer === obj.layer) {
        return;
      }

      api.update(obj = newObj);
    } else {
      api.remove();
    }
  };

  return updater;
}

module.exports = function (list, options) {
  options = options || {};
  list = list || [];
  var lastIdentifiers = modulesToDom(list, options);
  return function update(newList) {
    newList = newList || [];

    for (var i = 0; i < lastIdentifiers.length; i++) {
      var identifier = lastIdentifiers[i];
      var index = getIndexByIdentifier(identifier);
      stylesInDOM[index].references--;
    }

    var newLastIdentifiers = modulesToDom(newList, options);

    for (var _i = 0; _i < lastIdentifiers.length; _i++) {
      var _identifier = lastIdentifiers[_i];

      var _index = getIndexByIdentifier(_identifier);

      if (stylesInDOM[_index].references === 0) {
        stylesInDOM[_index].updater();

        stylesInDOM.splice(_index, 1);
      }
    }

    lastIdentifiers = newLastIdentifiers;
  };
};

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertBySelector.js":
/*!********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertBySelector.js ***!
  \********************************************************************/
/***/ ((module) => {

"use strict";


var memo = {};
/* istanbul ignore next  */

function getTarget(target) {
  if (typeof memo[target] === "undefined") {
    var styleTarget = document.querySelector(target); // Special case to return head of iframe instead of iframe itself

    if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {
      try {
        // This will throw an exception if access to iframe is blocked
        // due to cross-origin restrictions
        styleTarget = styleTarget.contentDocument.head;
      } catch (e) {
        // istanbul ignore next
        styleTarget = null;
      }
    }

    memo[target] = styleTarget;
  }

  return memo[target];
}
/* istanbul ignore next  */


function insertBySelector(insert, style) {
  var target = getTarget(insert);

  if (!target) {
    throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");
  }

  target.appendChild(style);
}

module.exports = insertBySelector;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/insertStyleElement.js":
/*!**********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/insertStyleElement.js ***!
  \**********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function insertStyleElement(options) {
  var element = document.createElement("style");
  options.setAttributes(element, options.attributes);
  options.insert(element, options.options);
  return element;
}

module.exports = insertStyleElement;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js":
/*!**********************************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/setAttributesWithoutAttributes.js ***!
  \**********************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


/* istanbul ignore next  */
function setAttributesWithoutAttributes(styleElement) {
  var nonce =  true ? __webpack_require__.nc : 0;

  if (nonce) {
    styleElement.setAttribute("nonce", nonce);
  }
}

module.exports = setAttributesWithoutAttributes;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleDomAPI.js":
/*!***************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleDomAPI.js ***!
  \***************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function apply(styleElement, options, obj) {
  var css = "";

  if (obj.supports) {
    css += "@supports (".concat(obj.supports, ") {");
  }

  if (obj.media) {
    css += "@media ".concat(obj.media, " {");
  }

  var needLayer = typeof obj.layer !== "undefined";

  if (needLayer) {
    css += "@layer".concat(obj.layer.length > 0 ? " ".concat(obj.layer) : "", " {");
  }

  css += obj.css;

  if (needLayer) {
    css += "}";
  }

  if (obj.media) {
    css += "}";
  }

  if (obj.supports) {
    css += "}";
  }

  var sourceMap = obj.sourceMap;

  if (sourceMap && typeof btoa !== "undefined") {
    css += "\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))), " */");
  } // For old IE

  /* istanbul ignore if  */


  options.styleTagTransform(css, styleElement, options.options);
}

function removeStyleElement(styleElement) {
  // istanbul ignore if
  if (styleElement.parentNode === null) {
    return false;
  }

  styleElement.parentNode.removeChild(styleElement);
}
/* istanbul ignore next  */


function domAPI(options) {
  var styleElement = options.insertStyleElement(options);
  return {
    update: function update(obj) {
      apply(styleElement, options, obj);
    },
    remove: function remove() {
      removeStyleElement(styleElement);
    }
  };
}

module.exports = domAPI;

/***/ }),

/***/ "./node_modules/style-loader/dist/runtime/styleTagTransform.js":
/*!*********************************************************************!*\
  !*** ./node_modules/style-loader/dist/runtime/styleTagTransform.js ***!
  \*********************************************************************/
/***/ ((module) => {

"use strict";


/* istanbul ignore next  */
function styleTagTransform(css, styleElement) {
  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css;
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild);
    }

    styleElement.appendChild(document.createTextNode(css));
  }
}

module.exports = styleTagTransform;

/***/ }),

/***/ "./src/events.js":
/*!***********************!*\
  !*** ./src/events.js ***!
  \***********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "addEditBtnEventListener": () => (/* binding */ addEditBtnEventListener),
/* harmony export */   "addTodoBtnEventListener": () => (/* binding */ addTodoBtnEventListener),
/* harmony export */   "closeBtnEventListener": () => (/* binding */ closeBtnEventListener),
/* harmony export */   "deleteBtnEventListener": () => (/* binding */ deleteBtnEventListener),
/* harmony export */   "detailsBtnEventListener": () => (/* binding */ detailsBtnEventListener),
/* harmony export */   "editBtnEventListener": () => (/* binding */ editBtnEventListener),
/* harmony export */   "homeBtnEventListener": () => (/* binding */ homeBtnEventListener),
/* harmony export */   "insertTodoItemComponent": () => (/* binding */ insertTodoItemComponent),
/* harmony export */   "submitBtnEventListener": () => (/* binding */ submitBtnEventListener)
/* harmony export */ });
/* harmony import */ var _items__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./items */ "./src/items.js");
/* harmony import */ var _nav__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./nav */ "./src/nav.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash */ "./node_modules/lodash/lodash.js");
/* harmony import */ var lodash__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash__WEBPACK_IMPORTED_MODULE_2__);




function addTodoBtnEventListener() {
    const addTodo = document.querySelector(".add-task");

    addTodo.addEventListener("click", () => {
        overlayToggle.enable();
        document.body.appendChild((0,_items__WEBPACK_IMPORTED_MODULE_0__.todoFormGenerator)());
    })

    // For todo button in the main screen, not the form
}

function editBtnEventListener() {
    const parentForm = this.closest("[data-info]");
    const dataInfoValue = parentForm.getAttribute("data-info");
    const targetItemComponent = document.querySelector(`.main-content [data-info='${dataInfoValue}']`);

    const bodyDiv = this.closest(".form-body");
    const closeBtn = bodyDiv.parentNode.querySelector(".form-close");
    const newTitle = bodyDiv.querySelector(".form-title");
    const newDescription = bodyDiv.querySelector(".form-details");
    const newDate = bodyDiv.querySelector(".date-input");
    const newPriority = bodyDiv.querySelector("button.active");
    const newObject = (0,_items__WEBPACK_IMPORTED_MODULE_0__.todoItem)(newTitle.value, newDescription.value, newDate.value, newPriority.textContent);
    

    updateItemComponent(targetItemComponent, newObject);
    closeBtn.click();
    overlayToggle.disable();

}

function updateItemComponent(targetItemComponent,todoItem) {
    const priorityStrip = targetItemComponent.querySelector(".priority-strip");
    const title = targetItemComponent.querySelector(".todo-title");
    const date = targetItemComponent.querySelector(".todo-date");

    priorityStrip.classList.remove(priorityStrip.classList[1]);
    priorityStrip.classList.add(`priority-${todoItem.priority}`);

    title.textContent = todoItem.title;
    date.textContent = todoItem.date;


    targetItemComponent.setAttribute("data-info", JSON.stringify(todoItem));
    
}


const overlayToggle = (function() {
    const overlay = document.querySelector(".overlay");

    const enable = () => {
        overlay.classList.add("enabled");
        makeBackgroundItemsStatic(true);
    };
    const disable = () => {
        overlay.classList.remove("enabled");
        makeBackgroundItemsStatic(false);
    };

    return {enable, disable};
})();

function closeBtnEventListener() {
    const bodyNode = document.body;
    const formNode = this.closest("body>div");

    bodyNode.removeChild(formNode);
    overlayToggle.disable();
}

function submitBtnEventListener() {
    const bodyDiv = this.parentNode.parentNode;
    const closeBtn = bodyDiv.parentNode.querySelector(".form-close");
    const title = bodyDiv.querySelector(".form-title");
    const description = bodyDiv.querySelector(".form-details");
    const date = bodyDiv.querySelector(".date-input");
    const priority = bodyDiv.querySelector("button.active").textContent;



    const fields = [
        {key: "Title", element: title},
        {key:"Date", element: date}
    ];

    let emptyField;

    for (let field of fields) {
        if (field.element.value === "") {
            emptyField = field.key;
            emptyFieldAlert(emptyField);
            break;
        }
    }

    if (emptyField === undefined) {
        const newItem = (0,_items__WEBPACK_IMPORTED_MODULE_0__.todoItem)(title.value, description.value, date.value, priority);
        closeBtn.click();
        _nav__WEBPACK_IMPORTED_MODULE_1__.todos.push(newItem);
        console.log(_nav__WEBPACK_IMPORTED_MODULE_1__.todos);
        insertTodoItemComponent(newItem);
    }
}

function deleteBtnEventListener() {
    const mainContent = document.querySelector(".main-content");
    const component = this.parentNode;

    mainContent.removeChild(component);
    _.remove(_nav__WEBPACK_IMPORTED_MODULE_1__.todos, obj => JSON.stringify(obj) === component.getAttribute("data-info"));
}

function detailsBtnEventListener() {
    const parent = this.parentNode;
    const detailsPage = (0,_items__WEBPACK_IMPORTED_MODULE_0__.detailsFormGenerator)(JSON.parse(parent.getAttribute("data-info")));
    overlayToggle.enable();
    document.body.appendChild(detailsPage);
}

function addEditBtnEventListener(editButton) {
    editButton.addEventListener("click", function() {
        const parent = this.parentNode;
        const editPage = (0,_items__WEBPACK_IMPORTED_MODULE_0__.todoFormGenerator)(false, JSON.parse(parent.getAttribute("data-info")));
        overlayToggle.enable();
        document.body.appendChild(editPage);
    })
}

function homeBtnEventListener() {
    const inboxBtn = document.querySelector(".page-inbox");
    inboxBtn.click();
  }


function insertTodoItemComponent(todoItem) {
    document.querySelector(".main-content").appendChild((0,_items__WEBPACK_IMPORTED_MODULE_0__.itemComponentGenerator)(todoItem));
}

function makeBackgroundItemsStatic(makeStatic) {
    const elements = ['.header', '.content', '.add-task'];
    const pointerEvents = makeStatic ? 'none' : '';
  
    elements.forEach(element => {
        const el = document.querySelector(element);
        el.style.pointerEvents = pointerEvents;
    });
}

function emptyFieldAlert(fieldName) {
    window.alert(`${fieldName} is required`);
}

/***/ }),

/***/ "./src/items.js":
/*!**********************!*\
  !*** ./src/items.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "detailsFormGenerator": () => (/* binding */ detailsFormGenerator),
/* harmony export */   "itemComponentGenerator": () => (/* binding */ itemComponentGenerator),
/* harmony export */   "todoFormGenerator": () => (/* binding */ todoFormGenerator),
/* harmony export */   "todoItem": () => (/* binding */ todoItem)
/* harmony export */ });
/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! prettier */ "./node_modules/prettier/standalone.js");
/* harmony import */ var prettier__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(prettier__WEBPACK_IMPORTED_MODULE_0__);
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./events */ "./src/events.js");




/*
Use a factory function to return todo-items
each item should have the following properties:

String title
String description
Date dueDate
String priority
*/

function todoItem(title, description, dueDate, priorityString, projectName , done=false) {
  const Priorities = Object.freeze({
    low: "low",
    medium: "medium",
    high: "high",
  });

  const priority = Priorities[priorityString.toLowerCase()] || "low";
  const project = projectName || "inbox";
  // const date = format(parseISO(dueDate), "MM/dd/yyyy"); // parseISO parses date strings written in ISO 8601 format
  const date = dueDate;
  
  return { title, description, date, priority, project, done };
}

function itemComponentGenerator(todoItem) {
  const itemDiv = document.createElement("div");
  const priorityColor = document.createElement("div");
  const checkBox = document.createElement("input");
  const titleDiv = document.createElement("div");
  const detailsButton = document.createElement("button");
  const dateDiv = document.createElement("div");
  const editButton = document.createElement("button");
  const editImg = document.createElement("i");
  const deleteButton = document.createElement("button");
  const deleteImg = document.createElement("i");
  const checkableSubComponents = [titleDiv, detailsButton, dateDiv, editButton, deleteButton];

  itemDiv.classList.add("todo");
  itemDiv.setAttribute("data-info", JSON.stringify(todoItem));

  priorityColor.classList.add("priority-strip", `priority-${todoItem.priority}`);
  itemDiv.appendChild(priorityColor);

  checkBox.type = "checkbox";
  checkBox.classList.add("todo-checkbox");

  if (todoItem.done === false) {
    checkBoxChecker(false, checkBox, ...checkableSubComponents);
    todoItem.done = false;
    itemDiv.setAttribute("data-info", JSON.stringify(todoItem));
  } else {
      checkBoxChecker(true, checkBox, ...checkableSubComponents);
      todoItem.done = true
      itemDiv.setAttribute("data-info", JSON.stringify(todoItem));
  };


  checkBox.addEventListener("click", () => {
    if (checkBox.classList.contains("cb-checked")) {
        checkBoxChecker(false, checkBox, ...checkableSubComponents);
        todoItem.done = false;
        itemDiv.setAttribute("data-info", JSON.stringify(todoItem));
    } else {
        checkBoxChecker(true, checkBox, ...checkableSubComponents);
        todoItem.done = true
        itemDiv.setAttribute("data-info", JSON.stringify(todoItem));
    }
  })
  itemDiv.appendChild(checkBox);

  titleDiv.textContent = todoItem.title;
  titleDiv.classList.add("todo-title");
  itemDiv.appendChild(titleDiv);

  detailsButton.textContent = "DETAILS";
  detailsButton.classList.add("todo-details");
  detailsButton.addEventListener("click", _events__WEBPACK_IMPORTED_MODULE_1__.detailsBtnEventListener);
  itemDiv.appendChild(detailsButton);

  dateDiv.textContent = todoItem.date;
  dateDiv.classList.add("todo-date");
  itemDiv.appendChild(dateDiv);

  editButton.classList.add("todo-edit");
  editImg.classList.add("bi", "bi-pencil-square");
  editButton.appendChild(editImg);
  (0,_events__WEBPACK_IMPORTED_MODULE_1__.addEditBtnEventListener)(editButton);
  itemDiv.appendChild(editButton);

  deleteButton.classList.add("todo-delete");
  deleteImg.classList.add("bi", "bi-trash");
  deleteButton.appendChild(deleteImg);
  deleteButton.addEventListener("click", _events__WEBPACK_IMPORTED_MODULE_1__.deleteBtnEventListener);
  itemDiv.appendChild(deleteButton);

  return itemDiv;
}

function todoFormGenerator(newForm = true, todoItem = null) {
  const formDiv = document.createElement("div");
  const closeButton = document.createElement("div");
  const headerDiv = document.createElement("div");
  const bodyDiv = document.createElement("div");
  const titleArea = document.createElement("textarea");
  const detailsArea = document.createElement("textarea");
  const dateDiv = document.createElement("div");
  const dateInput = document.createElement("input");
  const priorityDiv = document.createElement("div");
  const lowPriorityBtn = document.createElement("button");
  const mediumPriorityBtn = document.createElement("button");
  const highPriorityBtn = document.createElement("button");
  const addTodoBtn = document.createElement("button");

  closeButton.classList.add("form-close");
  closeButton.textContent = "x";
  closeButton.addEventListener("click", _events__WEBPACK_IMPORTED_MODULE_1__.closeBtnEventListener);

  headerDiv.textContent = "Create A New To Do";
  headerDiv.classList.add("form-component", "form-header");
  bodyDiv.classList.add("form-component", "form-body");
  headerDiv.appendChild(closeButton);
  formDiv.appendChild(headerDiv);

  formDiv.classList.add("form-component", "form");
  formDiv.appendChild(bodyDiv);

  titleArea.placeholder = "Title: Pay bills";
  titleArea.classList.add("form-component", "form-title");
  bodyDiv.appendChild(titleArea);

  detailsArea.placeholder = "Details: e.g internet, phone, rent.";
  detailsArea.classList.add("form-component", "form-details");
  bodyDiv.appendChild(detailsArea);

  dateDiv.textContent = "Due Date: ";
  dateInput.type = "date";
  dateDiv.classList.add("form-component", "form-date");
  dateInput.classList.add("form-component", "date-input");
  dateDiv.appendChild(dateInput);
  bodyDiv.appendChild(dateDiv);

  priorityDiv.textContent = "Priority: ";
  lowPriorityBtn.textContent = "LOW";
  mediumPriorityBtn.textContent = "MEDIUM";
  highPriorityBtn.textContent = "HIGH";
  addTodoBtn.textContent = "ADD TO DO";
  priorityDiv.classList.add("form-component", "form-priority");
  lowPriorityBtn.classList.add("form-component", "priority-button", "btn", "btn-outline-success", "active");
  lowPriorityBtn.setAttribute("data-bs-toggle", "button");
  mediumPriorityBtn.classList.add("form-component", "priority-button", "btn", "btn-outline-warning");
  mediumPriorityBtn.setAttribute("data-bs-toggle", "button");
  highPriorityBtn.classList.add("form-component", "priority-button", "btn", "btn-outline-danger");
  highPriorityBtn.setAttribute("data-bs-toggle", "button");
  addTodoBtn.classList.add("form-component", "add-button", "btn", "btn-outline-primary");
  makeActiveButtonStateExclusive(lowPriorityBtn, mediumPriorityBtn, highPriorityBtn);
  addTodoBtn.addEventListener("click", _events__WEBPACK_IMPORTED_MODULE_1__.submitBtnEventListener);
  priorityDiv.appendChild(lowPriorityBtn);
  priorityDiv.appendChild(mediumPriorityBtn);
  priorityDiv.appendChild(highPriorityBtn);
  priorityDiv.appendChild(addTodoBtn);
  bodyDiv.appendChild(priorityDiv);

  if (newForm === false) {
    formDiv.removeChild(headerDiv);
    bodyDiv.appendChild(closeButton);
    titleArea.value = todoItem.title;
    detailsArea.value = todoItem.description;
    dateInput.value = todoItem.date;
    lowPriorityBtn.classList.remove("active");
    
    const buttons = [
      {key: "low", buttonElement: lowPriorityBtn},
      {key: "medium", buttonElement: mediumPriorityBtn},
      {key: "high", buttonElement: highPriorityBtn},
    ];

    buttons.forEach(button => {
      if (button.key === todoItem.priority) {
        button.buttonElement.classList.add("active");
      }
    })

    formDiv.setAttribute("data-info", JSON.stringify(todoItem));
    addTodoBtn.textContent = "CONFIRM EDIT";
    addTodoBtn.removeEventListener("click", _events__WEBPACK_IMPORTED_MODULE_1__.submitBtnEventListener);
    addTodoBtn.addEventListener("click", _events__WEBPACK_IMPORTED_MODULE_1__.editBtnEventListener);

  }


  return formDiv;
}

function detailsFormGenerator(todoItem) {
  const formDiv = document.createElement("div");
  formDiv.classList.add("details-form");
  const closeButton = document.createElement("div");
  closeButton.classList.add("details-close");
  closeButton.textContent = "x";
  closeButton.addEventListener("click", _events__WEBPACK_IMPORTED_MODULE_1__.closeBtnEventListener);
  const titleTag = document.createElement("h1");
  titleTag.textContent = todoItem.title;
  formDiv.appendChild(closeButton);
  formDiv.appendChild(titleTag);

  const fields = [
    { key: "project", label: "Project:", className: "details-project" },
    { key: "priority", label: "Priority:", className: "details-priority" },
    { key: "date", label: "Due Date:", className: "details-date" },
    { key: "description", label: "Description:", className: "details-description" }
  ];

  fields.forEach(field => {
    const div = document.createElement("div");
    const label = document.createElement("span");
    label.textContent = field.label;
    label.classList.add(field.className);
    div.appendChild(label);

    const content = document.createElement("span");
    content.textContent = todoItem[field.key];
    div.appendChild(content);

    formDiv.appendChild(div);
  });

  return formDiv;
}

function makeActiveButtonStateExclusive(...args) {
    args.forEach(button => {
        button.addEventListener('click', () => {
            const otherButtons = args.filter(p => p !== button);
            otherButtons.map(p => {
                p.classList.remove("active");
                p.setAttribute("aria-pressed", "false");
            })
        })
    })
}

function checkBoxChecker(check, checkbox, ...args) {
  if (check === true) {
    checkbox.classList.add("cb-checked");
    checkbox.checked = true;
    args.forEach(component => {
      component.classList.add("checked");
    })
  } else {
    checkbox.classList.remove("cb-checked");
    checkbox.checked = false;
    args.forEach(component => {
      component.classList.remove("checked");
    })
  }
}

/***/ }),

/***/ "./src/nav.js":
/*!********************!*\
  !*** ./src/nav.js ***!
  \********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "inboxPage": () => (/* binding */ inboxPage),
/* harmony export */   "pageToggler": () => (/* binding */ pageToggler),
/* harmony export */   "sidebarToggler": () => (/* binding */ sidebarToggler),
/* harmony export */   "todos": () => (/* binding */ todos)
/* harmony export */ });
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ "./src/style.css");
/* harmony import */ var _items_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./items.js */ "./src/items.js");
/* harmony import */ var _pages__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./pages */ "./src/pages.js");




const sidebar = document.querySelector(".sidebar");

function hideSidebar() {
  sidebar.style.minWidth = "0";
  sidebar.style.width = "0";
  sidebar.classList.add("hidden");
}

function showSidebar() {
  sidebar.style.minWidth = "200px";
  sidebar.style.width = "200px";
  sidebar.classList.remove("hidden");
}

//Determines whether to hide or show sidebar.
function sidebarToggler() {
  if (sidebar.classList.contains("hidden")) {
    showSidebar();
  } else {
    hideSidebar();
  }
}

const myItem = _items_js__WEBPACK_IMPORTED_MODULE_1__.todoItem("title", "description", "2023-01-01", "low");
const myDiv = _items_js__WEBPACK_IMPORTED_MODULE_1__.itemComponentGenerator(myItem);
const myItem2 = _items_js__WEBPACK_IMPORTED_MODULE_1__.todoItem("Find", "description","2023-01-01", "high");
const myDiv2 = _items_js__WEBPACK_IMPORTED_MODULE_1__.itemComponentGenerator(myItem2);
const myItem3 = _items_js__WEBPACK_IMPORTED_MODULE_1__.todoItem("hello", "any", "2024-02-14", "medium");
const myDiv3 = _items_js__WEBPACK_IMPORTED_MODULE_1__.itemComponentGenerator(myItem3);

const myItem4 = _items_js__WEBPACK_IMPORTED_MODULE_1__.todoItem("today", "any", "2023-02-08", "medium");
const myItem5 = _items_js__WEBPACK_IMPORTED_MODULE_1__.todoItem("today", "any", "2023-02-08", "low");
const myItem6 = _items_js__WEBPACK_IMPORTED_MODULE_1__.todoItem("thisWeek", "any", "2023-02-09", "high");

let todos = [myItem, myItem2, myItem3, myItem4, myItem5, myItem6];

let inboxPage = new _pages__WEBPACK_IMPORTED_MODULE_2__.Page(todos, "Inbox");
let todayPage = new _pages__WEBPACK_IMPORTED_MODULE_2__.Page(todos, "Today");
let weekPage = new _pages__WEBPACK_IMPORTED_MODULE_2__.Page(todos, "This Week");


const mainPages = {
  "Inbox": inboxPage,
  "Today": todayPage,
  "This Week": weekPage
}

function pageToggler() {
  const pages = Array.from(document.querySelectorAll(".page"));

  pages.forEach(page => {
    page.addEventListener("click", () => {

      const otherPages = pages.filter(p => p !== page);

      otherPages.forEach(p => {
        p.classList.remove("active");
        mainPages[p.textContent].clearItems();
      });

      mainPages[page.textContent].appendItems();
      page.classList.add("active");

    });
  });
}

/***/ }),

/***/ "./src/pages.js":
/*!**********************!*\
  !*** ./src/pages.js ***!
  \**********************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export */ __webpack_require__.d(__webpack_exports__, {
/* harmony export */   "Page": () => (/* binding */ Page)
/* harmony export */ });
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/parseISO/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isToday/index.js");
/* harmony import */ var date_fns__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! date-fns */ "./node_modules/date-fns/esm/isThisWeek/index.js");
/* harmony import */ var _items__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./items */ "./src/items.js");



function Page(todoItems, pageName) {
    this.todoItems = todoItems;
    const mainContent = document.querySelector(".main-content");

    const filter = (pageName) => {
        return this.todoItems.filter(item => {
            const isoDateString = item.date.split('-').join('');
            const dateObject = (0,date_fns__WEBPACK_IMPORTED_MODULE_1__["default"])(isoDateString);

            switch (pageName) {
                case "Today":
                    return (0,date_fns__WEBPACK_IMPORTED_MODULE_2__["default"])(dateObject);
                    break;
                case "This Week":
                    return (0,date_fns__WEBPACK_IMPORTED_MODULE_3__["default"])(dateObject);
                    break;
                default:
                    return true;
            }
        })
    }

    this.appendItems = function() {
        filter(pageName).forEach(element => {
            mainContent.appendChild((0,_items__WEBPACK_IMPORTED_MODULE_0__.itemComponentGenerator)(element));
        })
    }

    this.clearItems = function() {
        mainContent.innerHTML = '';
    }
}


/***/ }),

/***/ "./src/todo-icon.png":
/*!***************************!*\
  !*** ./src/todo-icon.png ***!
  \***************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
module.exports = __webpack_require__.p + "40fe090edf5faf80fc75.png";

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/publicPath */
/******/ 	(() => {
/******/ 		var scriptUrl;
/******/ 		if (__webpack_require__.g.importScripts) scriptUrl = __webpack_require__.g.location + "";
/******/ 		var document = __webpack_require__.g.document;
/******/ 		if (!scriptUrl && document) {
/******/ 			if (document.currentScript)
/******/ 				scriptUrl = document.currentScript.src
/******/ 			if (!scriptUrl) {
/******/ 				var scripts = document.getElementsByTagName("script");
/******/ 				if(scripts.length) scriptUrl = scripts[scripts.length - 1].src
/******/ 			}
/******/ 		}
/******/ 		// When supporting browsers where an automatic publicPath is not supported you must specify an output.publicPath manually via configuration
/******/ 		// or pass an empty string ("") and set the __webpack_public_path__ variable from your code to use your own logic.
/******/ 		if (!scriptUrl) throw new Error("Automatic publicPath is not supported in this browser");
/******/ 		scriptUrl = scriptUrl.replace(/#.*$/, "").replace(/\?.*$/, "").replace(/\/[^\/]+$/, "/");
/******/ 		__webpack_require__.p = scriptUrl;
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/nonce */
/******/ 	(() => {
/******/ 		__webpack_require__.nc = undefined;
/******/ 	})();
/******/ 	
/************************************************************************/
var __webpack_exports__ = {};
// This entry need to be wrapped in an IIFE because it need to be in strict mode.
(() => {
"use strict";
/*!**********************!*\
  !*** ./src/index.js ***!
  \**********************/
__webpack_require__.r(__webpack_exports__);
/* harmony import */ var _style_css__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./style.css */ "./src/style.css");
/* harmony import */ var _todo_icon_png__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./todo-icon.png */ "./src/todo-icon.png");
/* harmony import */ var _nav__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./nav */ "./src/nav.js");
/* harmony import */ var _items__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./items */ "./src/items.js");
/* harmony import */ var _events__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./events */ "./src/events.js");
/* harmony import */ var _pages__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./pages */ "./src/pages.js");







const todoIcon = document.createElement("link");
todoIcon.rel = "icon";
todoIcon.href = _todo_icon_png__WEBPACK_IMPORTED_MODULE_1__;
document.head.appendChild(todoIcon);

const toggler = document.querySelector(".navbar-toggler");
toggler.addEventListener("click", _nav__WEBPACK_IMPORTED_MODULE_2__.sidebarToggler);

const homeButton = document.querySelector(".home-button");
homeButton.addEventListener("click", _events__WEBPACK_IMPORTED_MODULE_4__.homeBtnEventListener);


(0,_nav__WEBPACK_IMPORTED_MODULE_2__.pageToggler)();
(0,_events__WEBPACK_IMPORTED_MODULE_4__.addTodoBtnEventListener)();


_nav__WEBPACK_IMPORTED_MODULE_2__.inboxPage.appendItems();


})();

/******/ })()
;
//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QVksV0FBVyxZQUFZLGFBQWEsYUFBYSxXQUFXLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFlBQVksV0FBVyxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFlBQVksT0FBTyxNQUFNLFlBQVksV0FBVyxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksYUFBYSxXQUFXLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxVQUFVLFlBQVksV0FBVyxZQUFZLGFBQWEsYUFBYSxPQUFPLEtBQUssWUFBWSxhQUFhLE9BQU8sS0FBSyxZQUFZLGFBQWEsT0FBTyxLQUFLLFVBQVUsVUFBVSxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLE9BQU8sS0FBSyxZQUFZLGFBQWEsYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsV0FBVyxZQUFZLFdBQVcsWUFBWSxPQUFPLEtBQUssWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLFVBQVUsWUFBWSxXQUFXLFVBQVUsWUFBWSxPQUFPLEtBQUssWUFBWSxXQUFXLFVBQVUsWUFBWSxPQUFPLE1BQU0sWUFBWSxPQUFPLEtBQUssVUFBVSxVQUFVLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsYUFBYSxhQUFhLGFBQWEsT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLE9BQU8sTUFBTSxVQUFVLFVBQVUsWUFBWSxPQUFPLE1BQU0sVUFBVSxVQUFVLE9BQU8sS0FBSyxVQUFVLFVBQVUsVUFBVSxVQUFVLFVBQVUsVUFBVSxZQUFZLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLE9BQU8sS0FBSyxVQUFVLFlBQVksYUFBYSxhQUFhLGFBQWEsV0FBVyxZQUFZLGFBQWEsV0FBVyxVQUFVLFlBQVksT0FBTyxLQUFLLFVBQVUsWUFBWSxhQUFhLFdBQVcsWUFBWSxXQUFXLFlBQVksYUFBYSxPQUFPLEtBQUssVUFBVSxZQUFZLFdBQVcsVUFBVSxZQUFZLGFB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QTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7O0FDZkE7QUFDTztBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ05lO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7Ozs7Ozs7Ozs7Ozs7OztBQ0plO0FBQ2Y7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7O0FBRU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGNBQWM7QUFDN0Is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UztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLE9BQU87QUFDdEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFp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M0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFNBQVM7QUFDeEIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGlCQUFpQjtBQUNoQyxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRTtBQUNwRTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsT0FBTztBQUN0QjtBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixlQUFlLE9BQU87QUFDdEI7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxpQkFBaUI7QUFDaEMsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsT0FBTztBQUN0QixlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsR0FBRztBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QjtBQUNBLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEIsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVB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QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0Esa0NBQWtDLFFBQVEsZ0JBQWdCLGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPO0FBQ3RCLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0Esc0NBQXNDLFFBQVEsZ0JBQWdCLGFBQWE7QUFDM0U7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLFFBQVE7QUFDOUM7QUFDQTtB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LFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGdCQUFnQixRQUFRO0FBQ3hCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRLFdBQVc7QUFDbEMsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0EsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxtREFBbUQsaUJBQWlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QixlQUFlLDBCQUEwQjtBQUN6QztBQUNBLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsTUFBTTtBQUNyQixpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxNQUFNO0FBQ3JCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFVBQVU7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFVBQVU7QUFDekIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVEsV0FBVztBQUNsQyxlQUFlLFNBQVM7QUFDeEI7QUFDQSxlQUFlLFNBQVM7QUFDeEI7QUFDQSxpQkFBaUIsVUFBVTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsbUJBQW1CO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixVQUFVO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCLGdCQUFnQixRQUFRO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsSUFBSSxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSw4QkFBOEIsbUJBQW1CLGlCQUFpQjtBQUNsRTtBQUNBO0FBQ0EsOEJBQThCLG1CQUFtQixpQkFBaUI7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQyxtQkFBbUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxtQkFBbUI7QUFDdEU7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQSwyQkFBMkIsUUFBUTtBQUNuQztBQUNBO0FBQ0EsMkJBQTJCLFFBQVE7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsU0FBUztB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsZUFBZTtBQUNmO0FBQ0Esa0JBQWtCLFFBQVE7QUFDMUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsR0FBRztBQUNsQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRO0FBQzFCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUIsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsUUFBUSxJQUFJLFFBQVEsSUFBSSxRQUFRO0FBQ2xELGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixRQUFRLElBQUksUUFBUSxJQUFJLFFBQVE7QUFDbEQsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8sVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVEsSUFBSSxRQUFRLElBQUksUUFBUTtBQUNwRCxlQUFlO0FBQ2Y7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFdBQVc7QUFDMUIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLE9BQU8sVUFBVSxJQUFJLE9BQU8sa0JBQWtCO0FBQ3RFLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLGtCQUFrQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQiwyQkFBMkI7QUFDakQsc0JBQXNCLDRCQUE0QjtBQUNsRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHNDQUFzQyxvQkFBb0I7QUFDMUQ7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLDBCQUEwQjtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsa0JBQWtCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDJCQUEyQjtBQUNqRCxzQkFBc0IsNEJBQTRCO0FBQ2xELHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsMENBQTBDLG9CQUFvQjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsMkJBQTJCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBLHNCQUFzQixPQUFPO0FBQzdCLDhCQUE4QixnQkFBZ0IsUUFBUSxHQUFHO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixpQkFBaUIsU0FBUztBQUMxQjtBQUNBO0FBQ0EsK0JBQStCLGdCQUFnQixRQUFRLEdBQUc7QUFDMUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1IsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLE1BQU07QUFDckIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8scUJBQXFCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixPQUFPO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0EsUUFBUTtBQUNSLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLDhCQUE4QjtBQUNwRCxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBLHdDQUF3QyxlQUFlO0FBQ3ZELGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBLGVBQWUsMkJBQTJCO0FBQzFDO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxXQUFXO0FBQzFCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixRQUFRLElBQUksUUFBUTtBQUNyQztBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsUUFBUSxJQUFJLFFBQVE7QUFDckM7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLGdCQUFnQixJQUFJLGdCQUFnQjtBQUMzRDtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsV0FBVztBQUMxQixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixxQkFBcUI7QUFDckI7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxzQkFBc0I7QUFDckMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QjtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQSxpQ0FBaUM7QUFDakMsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxHQUFHO0FBQ2xCLGlCQUFpQixHQUFHO0FBQ3BCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLGdDQUFnQztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBLHNCQUFzQixRQUFRLE9BQU8sVUFBVTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsY0FBYztBQUM3QixlQUFlLEdBQUc7QUFDbEIsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLE9BQU87QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsVUFBVTtBQUN6QixlQUFlLEdBQUc7QUFDbEIsaUJBQWlCLEdBQUc7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EscUJBQXFCLHdCQUF3QjtBQUM3QztBQUNBLFFBQVEsSUFBSTtBQUNaLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVEsU0FBUztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRLFNBQVM7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGNBQWM7QUFDN0IsZUFBZSxVQUFVO0FBQ3pCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQSxzQkFBc0IsUUFBUSxPQUFPLFVBQVU7QUFDL0M7QUFDQSxrREFBa0QsZUFBZTtBQUNqRTtBQUNBO0FBQ0E7QUFDQSxrREFBa0QsdUJBQXVCO0FBQ3pFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxjQUFjO0FBQzdCLGVBQWUsVUFBVTtBQUN6QixlQUFlLFVBQVU7QUFDekIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsT0FBTztBQUN0QjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsT0FBTztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLE9BQU87QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixTQUFTO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxTQUFTO0FBQ3hCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFNBQVM7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGtDQUFrQyxLQUFLO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixpQkFBaUIsUUFBUTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZUFBZSxRQUFRO0FBQ3ZCLGlCQUFpQixRQUFRO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLFFBQVE7QUFDdkIsZ0JBQWdCLFFBQVE7QUFDeEIsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsUUFBUTtBQUN2QixlQUFlLGVBQWU7QUFDOUIsZUFBZSxpQkFBaUI7QUFDaEMsaUJBQWlCLFFBQVE7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLFFBQVE7QUFDdkIsaUJB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsS0FBSyxPQUFPLGdCQUFnQjs7QUFFNUI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxLQUFLOztBQUVMO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSzs7QUFFTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7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O0FBQ0EsMkJBQTJCLG9EQUFVO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0MsOERBQXNCO0FBQzFELFNBQVM7QUFDVDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O1VDbENBO1VBQ0E7O1VBRUE7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7VUFDQTtVQUNBO1VBQ0E7O1VBRUE7VUFDQTs7VUFFQTtVQUNBOztVQUVBO1VBQ0E7VUFDQTs7Ozs7V0N6QkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLGlDQUFpQyxXQUFXO1dBQzVDO1dBQ0E7Ozs7O1dDUEE7V0FDQTtXQUNBO1dBQ0E7V0FDQSx5Q0FBeUMsd0NBQXdDO1dBQ2pGO1dBQ0E7V0FDQTs7Ozs7V0NQQTtXQUNBO1dBQ0E7V0FDQTtXQUNBLEdBQUc7V0FDSDtXQUNBO1dBQ0EsQ0FBQzs7Ozs7V0NQRDs7Ozs7V0NBQTtXQUNBO1dBQ0E7V0FDQSx1REFBdUQsaUJBQWlCO1dBQ3hFO1dBQ0EsZ0RBQWdELGFBQWE7V0FDN0Q7Ozs7O1dDTkE7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7V0NKQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTtXQUNBO1dBQ0E7V0FDQTs7Ozs7V0NmQTs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDQXFCO0FBQ2M7QUFDMkI7QUFDN0I7QUFDd0M7QUFDMUM7O0FBRS9CO0FBQ0E7QUFDQSxnQkFBZ0IsMkNBQUk7QUFDcEI7O0FBRUE7QUFDQSxrQ0FBa0MsZ0RBQWM7O0FBRWhEO0FBQ0EscUNBQXFDLHlEQUFvQjs7O0FBR3pELGlEQUFXO0FBQ1gsZ0VBQXVCOzs7QUFHdkIsdURBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL3N0eWxlLmNzcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvYXBpLmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2Rpc3QvcnVudGltZS9zb3VyY2VNYXBzLmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi9kZWZhdWx0T3B0aW9ucy9pbmRleC5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vX2xpYi90b0ludGVnZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9jb25zdGFudHMvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9pc1NhbWVEYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9pc1NhbWVXZWVrL2luZGV4LmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9kYXRlLWZucy9lc20vaXNUaGlzV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL2lzVG9kYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9wYXJzZUlTTy9pbmRleC5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3N0YXJ0T2ZEYXkvaW5kZXguanMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL2RhdGUtZm5zL2VzbS9zdGFydE9mV2Vlay9pbmRleC5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvZGF0ZS1mbnMvZXNtL3RvRGF0ZS9pbmRleC5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvcHJldHRpZXIvc3RhbmRhbG9uZS5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvc3R5bGUuY3NzPzcxNjMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydEJ5U2VsZWN0b3IuanMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9kaXN0L3J1bnRpbWUvaW5zZXJ0U3R5bGVFbGVtZW50LmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZURvbUFQSS5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvZXZlbnRzLmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9pdGVtcy5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3QvLi9zcmMvbmF2LmpzIiwid2VicGFjazovL3RvZG8tbGlzdC8uL3NyYy9wYWdlcy5qcyIsIndlYnBhY2s6Ly90b2RvLWxpc3Qvd2VicGFjay9ib290c3RyYXAiLCJ3ZWJwYWNrOi8vdG9kby1saXN0L3dlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0Iiwid2VicGFjazovL3RvZG8tbGlzdC93ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMiLCJ3ZWJwYWNrOi8vdG9kby1saXN0L3dlYnBhY2svcnVudGltZS9nbG9iYWwiLCJ3ZWJwYWNrOi8vdG9kby1saXN0L3dlYnBhY2svcnVudGltZS9oYXNPd25Qcm9wZXJ0eSBzaG9ydGhhbmQiLCJ3ZWJwYWNrOi8vdG9kby1saXN0L3dlYnBhY2svcnVudGltZS9tYWtlIG5hbWVzcGFjZSBvYmplY3QiLCJ3ZWJwYWNrOi8vdG9kby1saXN0L3dlYnBhY2svcnVudGltZS9ub2RlIG1vZHVsZSBkZWNvcmF0b3IiLCJ3ZWJwYWNrOi8vdG9kby1saXN0L3dlYnBhY2svcnVudGltZS9wdWJsaWNQYXRoIiwid2VicGFjazovL3RvZG8tbGlzdC93ZWJwYWNrL3J1bnRpbWUvbm9uY2UiLCJ3ZWJwYWNrOi8vdG9kby1saXN0Ly4vc3JjL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9TT1VSQ0VNQVBfSU1QT1JUX19fIGZyb20gXCIuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L3J1bnRpbWUvc291cmNlTWFwcy5qc1wiO1xuaW1wb3J0IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyBmcm9tIFwiLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9ydW50aW1lL2FwaS5qc1wiO1xudmFyIF9fX0NTU19MT0FERVJfRVhQT1JUX19fID0gX19fQ1NTX0xPQURFUl9BUElfSU1QT1JUX19fKF9fX0NTU19MT0FERVJfQVBJX1NPVVJDRU1BUF9JTVBPUlRfX18pO1xuLy8gTW9kdWxlXG5fX19DU1NfTE9BREVSX0VYUE9SVF9fXy5wdXNoKFttb2R1bGUuaWQsIFwiaHRtbCxcXG5ib2R5IHtcXG4gIGhlaWdodDogMTAwJTtcXG4gIG1hcmdpbjogMDtcXG4gIGZvbnQtZmFtaWx5OiBSYWxld2F5O1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDEgMSBub25lO1xcbiAgbWluLXdpZHRoOiBjYWxjKDEwMHZ3ICsgMTdweCk7XFxuICBvdmVyZmxvdy14OiBzY3JvbGw7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbn1cXG5cXG5cXG5cXG4uaGVhZGVyIHtcXG4gIGhlaWdodDogNjBweDtcXG4gIG1hcmdpbjogMDtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNkNDlkNmI7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGdhcDogMTBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgdG9wOiAwO1xcbn1cXG5cXG4ubmF2YmFyLXRvZ2dsZXIge1xcbiAgbWFyZ2luLWxlZnQ6IDE1cHg7XFxuICBib3JkZXItd2lkdGg6IDA7XFxuICBib3JkZXItcmFkaXVzOiA3JTtcXG4gIC0tYnMtbmF2YmFyLXRvZ2dsZXItYm9yZGVyLXJhZGl1czogMDtcXG4gIC0tYnMtbmF2YmFyLXRvZ2dsZXItZm9jdXMtd2lkdGg6IDA7XFxuICB0cmFuc2l0aW9uOiAwLjI1cztcXG59XFxuXFxuLm5hdmJhci10b2dnbGVyOmhvdmVyLFxcbi50ZXN0OmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNSk7XFxufVxcblxcbi5ob21lLWJ1dHRvbiB7XFxuICBmb250LXNpemU6IDEuNWVtO1xcbiAgY29sb3I6IHJnYmEoMCwgMCwgMCwgMC41NSk7XFxuICBoZWlnaHQ6IDM4cHg7XFxuICB3aWR0aDogNTRweDtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogNyU7XFxuICB0cmFuc2l0aW9uOiAwLjI1cztcXG59XFxuXFxuLmhvbWUtYnV0dG9uOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMjU1LCAyNTUsIDI1NSwgMC4xNSk7XFxufVxcblxcbi5jb250ZW50IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBwYWRkaW5nLXRvcDogNjBweDtcXG59XFxuXFxuLnNpZGViYXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBnYXA6IDMwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZjlmYWZiO1xcbiAgb3ZlcmZsb3c6IGhpZGRlbjtcXG4gIHRyYW5zaXRpb246IDAuNXM7XFxuICB3aWR0aDogMjAwcHg7XFxuICBtaW4td2lkdGg6IDIwMHB4O1xcbn1cXG5cXG4uc2lkZWJhciA+IGRpdiB7XFxuICBtYXJnaW46IDAgMzBweDtcXG4gIG1pbi13aWR0aDogMTQwcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBwYWRkaW5nLWxlZnQ6IDE1cHg7XFxuICBwYWRkaW5nLXRvcDogM3B4O1xcbiAgcGFkZGluZy1ib3R0b206IDNweDtcXG4gIHRyYW5zaXRpb246IDAuMXM7XFxufVxcblxcbi5wYWdlOmhvdmVyIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC4xKTtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLnBhZ2UuYWN0aXZlIHtcXG4gIGJhY2tncm91bmQtY29sb3I6IHJnYmEoMTI4LCAxMjgsIDEyOCwgMC4xKTtcXG59XFxuXFxuaHIge1xcbiAgYm9yZGVyLXRvcDogMXB4IHNvbGlkICMxOTE5MTk7XFxuICB3aWR0aDogMTIwcHg7XFxuICBtYXJnaW46IC0xNXB4IDMwcHg7XFxufVxcblxcbi5tYWluLWNvbnRlbnQsXFxuLnNpZGViYXIge1xcbiAgcGFkZGluZy10b3A6IDMwcHg7XFxuICBjb2xvcjogIzFmMjkzNztcXG59XFxuXFxuLm1haW4tY29udGVudCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleDogMSAxIG5vbmU7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgbWluLXdpZHRoOiAxMDcwcHg7XFxuICBtYXJnaW4tbGVmdDogMzBweDtcXG59XFxuXFxuLnRvZG8ge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDEgMSBub25lO1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIHdpZHRoOiAxMTAwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZWVlO1xcbiAgbWFyZ2luLWJvdHRvbTogMjBweDtcXG4gIHRyYW5zaXRpb246IDAuMnM7XFxufVxcblxcbi50b2RvID4gKjpub3QoLnByaW9yaXR5LXN0cmlwKSB7XFxuICAgIG1hcmdpbi10b3A6IDEwcHg7XFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxufVxcblxcbi50b2RvOmhvdmVyIHtcXG4gICAgdHJhbnNmb3JtOnNjYWxlKDEuMDA1KTtcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiA3cHggN3B4IDEwcHggLTZweCByZ2JhKDAsMCwwLDAuNCk7XFxufVxcblxcbi5wcmlvcml0eS1zdHJpcCB7XFxuICAgIG1pbi13aWR0aDogNHB4O1xcbiAgICBoZWlnaHQ6IDEwMCU7XFxuICAgIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG59XFxuXFxuLnByaW9yaXR5LWxvdyB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IGdyZWVuO1xcbn1cXG5cXG4ucHJpb3JpdHktbWVkaXVtIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogb3JhbmdlO1xcbn1cXG5cXG4ucHJpb3JpdHktaGlnaCB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJlZDtcXG59XFxuXFxuLnRvZG8tY2hlY2tib3gge1xcbiAgLXdlYmtpdC1hcHBlYXJhbmNlOiBub25lO1xcbiAgLW1vei1hcHBlYXJhbmNlOiBub25lO1xcbiAgYXBwZWFyYW5jZTogbm9uZTtcXG4gIG1hcmdpbi1yaWdodDogMC43NXJlbTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyOiAycHggc29saWQgIzNiYTM5NTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIG1pbi1oZWlnaHQ6IDIwcHg7XFxuICBtaW4td2lkdGg6IDIwcHg7XFxuICBtYXgtaGVpZ2h0OiAyMHB4O1xcbiAgbWF4LXdpZHRoOiAyMHB4O1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbn1cXG5cXG4udG9kby1jaGVja2JveDpjaGVja2VkIHtcXG4gIGJhY2tncm91bmQtY29sb3I6ICMzYmEzOTU7XFxufVxcblxcbi50b2RvLWNoZWNrYm94OmNoZWNrZWQ6OmJlZm9yZSB7XFxuICBjb250ZW50OiBcXFwi4pyUXFxcIjtcXG4gIGZvbnQtc2l6ZTogMTJweDtcXG4gIGNvbG9yOiB3aGl0ZTtcXG4gIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gIHRvcDogNTAlO1xcbiAgbGVmdDogNTAlO1xcbiAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxufVxcblxcbi50b2RvLXRpdGxlIHtcXG4gIG1hcmdpbi1yaWdodDogM3JlbTtcXG4gIGZvbnQtc2l6ZTogMThweDtcXG4gIHdpZHRoOiA0MnJlbTtcXG4gIG92ZXJmbG93LXg6IHNjcm9sbDtcXG59XFxuXFxuLnRvZG8tZGV0YWlscyxcXG4udG9kby1kYXRlIHtcXG4gIG1hcmdpbi1yaWdodDogMnJlbTtcXG59XFxuXFxuLnRvZG8tZGF0ZSB7XFxuICBjb2xvcjogIzc5M2QwNTtcXG4gIGZvbnQtc2l6ZTogMTRweDtcXG59XFxuXFxuLnRvZG8tZGV0YWlscyB7XFxuICBjb2xvcjogIzNiYTM5NTtcXG4gIGJvcmRlci1jb2xvcjogIzNiYTM5NTtcXG4gIGJhY2tncm91bmQtY29sb3I6IHRyYW5zcGFyZW50O1xcbiAgYm9yZGVyOiBzb2xpZCAxcHg7XFxuICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICBmb250LXNpemU6IDAuOXJlbTtcXG4gIHRyYW5zaXRpb246IDAuMnM7XFxuICBwYWRkaW5nOiAzcHggMTVweDtcXG59XFxuXFxuLnRvZG8tZGV0YWlsczpob3ZlciB7XFxuICBjb2xvcjogd2hpdGU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2JhMzk1O1xcbiAgYm9yZGVyLWNvbG9yOiAjM2JhMzk1O1xcbn1cXG5cXG4udG9kby1lZGl0LFxcbi50b2RvLWRlbGV0ZSB7XFxuICBib3JkZXItd2lkdGg6IDA7XFxuICBjb2xvcjogIzc5M2QwNTtcXG4gIHRyYW5zaXRpb246IDAuMXM7XFxufVxcblxcbi50b2RvLWVkaXQ6aG92ZXIsXFxuLnRvZG8tZGVsZXRlOmhvdmVyIHtcXG4gIGN1cnNvcjogcG9pbnRlcjtcXG4gIGNvbG9yOiAjMGY3NjZlO1xcbn1cXG5cXG4uYWRkLXRhc2sge1xcbiAgaGVpZ2h0OiA2MHB4O1xcbiAgd2lkdGg6IDYwcHg7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBib3R0b206IDUwcHg7XFxuICByaWdodDogNTBweDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBib3JkZXItd2lkdGg6IDA7XFxuICBib3JkZXItcmFkaXVzOiA1MCU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjMGY3NjZlO1xcbiAgZm9udC1zaXplOiAzNnB4O1xcbiAgY29sb3I6ICNmOWZhZmI7XFxufVxcblxcbi5mb3JtIHtcXG4gIHotaW5kZXg6IDM7XFxuICBib3gtc2hhZG93OiAwIDJyZW0gNHJlbSByZ2IoMCAwIDAgLyA2MCUpO1xcbiAgYm9yZGVyLXJhZGl1czogNXB4O1xcbiAgbWFyZ2luLXJpZ2h0OiBhdXRvO1xcbiAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICBtYXgtd2lkdGg6IDY1JTtcXG4gIG1pbi13aWR0aDogNjUwcHg7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbn1cXG5cXG4uZm9ybS1oZWFkZXIge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBwYWRkaW5nLWxlZnQ6IDE1cHg7XFxuICBmb250LXNpemU6IDI0cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDQ5ZDZiO1xcbiAgaGVpZ2h0OiA1NXB4O1xcbiAgYm9yZGVyLXRvcC1sZWZ0LXJhZGl1czogNXB4O1xcbiAgYm9yZGVyLXRvcC1yaWdodC1yYWRpdXM6IDVweDtcXG59XFxuXFxuLmZvcm0tYm9keSB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIHBhZGRpbmc6IDIwcHg7XFxuICBnYXA6IDQwcHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB3aGl0ZTtcXG4gIGJvcmRlci1ib3R0b20tbGVmdC1yYWRpdXM6IDVweDtcXG4gIGJvcmRlci1ib3R0b20tcmlnaHQtcmFkaXVzOiA1cHg7XFxufVxcblxcbi5mb3JtLXRpdGxlLFxcbi5mb3JtLWRldGFpbHMge1xcbiAgcmVzaXplOiBub25lO1xcbiAgb3V0bGluZTogbm9uZTtcXG4gIGJvcmRlci13aWR0aDogMDtcXG59XFxuXFxuLmZvcm0tdGl0bGUge1xcbiAgZm9udC1zaXplOiAyMHB4O1xcbiAgaGVpZ2h0OiA0MHB4O1xcbn1cXG5cXG4uZm9ybS1kZXRhaWxzIHtcXG4gIGhlaWdodDogMjAwcHg7XFxuICBtYXJnaW4tdG9wOiAtMzBweDtcXG4gIGZvbnQtc2l6ZTogMTZweDtcXG59XFxuXFxuLmZvcm0tcHJpb3JpdHkge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBnYXA6IDEwcHg7XFxufVxcblxcbi5hZGQtYnV0dG9uIHtcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbn1cXG5cXG4uY2hlY2tlZCB7XFxuICBvcGFjaXR5OiAwLjM7XFxufVxcblxcbi5jaGVja2VkLnRvZG8tdGl0bGUge1xcbiAgdGV4dC1kZWNvcmF0aW9uOiBsaW5lLXRocm91Z2g7XFxufVxcblxcbi5kZXRhaWxzLWZvcm0ge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuMyk7XFxuICAgIGJveC1zaGFkb3c6IDAgMnJlbSA0cmVtIHJnYigwIDAgMCAvIDYwJSk7XFxuICAgIGNvbG9yOiAjNzkzZDA1O1xcbiAgICBwYWRkaW5nOiAzMHB4O1xcbiAgICBkaXNwbGF5OiBmbGV4O1xcbiAgICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgICBnYXA6IDEwcHg7XFxuICAgIHdpZHRoOiA2NDBweDtcXG4gICAgbWluLXdpZHRoOiA1MDBweDtcXG4gICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICBib3JkZXItcmFkaXVzOiAzcHg7XFxuICAgIG1hcmdpbi1yaWdodDogYXV0bztcXG4gICAgbWFyZ2luLWxlZnQ6IGF1dG87XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiA1MCU7XFxuICAgIGxlZnQ6IDUwJTtcXG4gICAgdHJhbnNmb3JtOiB0cmFuc2xhdGUoLTUwJSwgLTUwJSk7XFxuICAgIHotaW5kZXg6IDM7XFxufVxcblxcbi5kZXRhaWxzLWNsb3NlLCAuZm9ybS1jbG9zZSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgcmlnaHQ6IDI1cHg7XFxuICAgIHRvcDogMTBweDtcXG4gICAgZm9udC1zaXplOiAyNHB4O1xcbiAgICBmb250LXdlaWdodDogYm9sZGVyO1xcbn1cXG5cXG4uZGV0YWlscy1jbG9zZTpob3ZlciB7XFxuICAgIGNvbG9yOiBnb2xkZW5yb2Q7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmZvcm0tY2xvc2U6aG92ZXIge1xcbiAgICBjb2xvcjogIzY5MzcwNTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4uZGV0YWlscy1wcm9qZWN0IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzLjFyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcblxcbi5kZXRhaWxzLXByaW9yaXR5IHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAzLjFyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcblxcbi5kZXRhaWxzLWRhdGUge1xcbiAgICBtYXJnaW4tcmlnaHQ6IDJyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcblxcbi5kZXRhaWxzLWRlc2NyaXB0aW9uIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxLjFyZW07XFxuICAgIGZvbnQtd2VpZ2h0OiA3MDA7XFxufVxcblxcbi5vdmVybGF5IHtcXG4gICAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgICB0b3A6IDA7XFxuICAgIGJvdHRvbTogMDtcXG4gICAgbGVmdDogMDtcXG4gICAgcmlnaHQ6IDA7XFxuICAgIG1peC1ibGVuZC1tb2RlOiBtdWx0aXBseTtcXG4gICAgYmFja2dyb3VuZC1yZXBlYXQ6IHJlcGVhdDtcXG4gICAgcG9pbnRlci1ldmVudHM6IG5vbmU7XFxufVxcblxcbi5vdmVybGF5LmVuYWJsZWR7XFxuICBtaW4td2lkdGg6IGNhbGMoMTAwdncgKyAxN3B4KTtcXG4gIGJhY2tkcm9wLWZpbHRlcjogYmx1cig2cHgpO1xcbiAgei1pbmRleDogMjtcXG4gIG1hcmdpbi10b3A6IC01MDBweDtcXG5cXG59XFxuXFxuLmZvb3RlciB7XFxuICBwb3NpdGlvbjogZml4ZWQ7XFxuICBib3R0b206IDA7XFxuICBsZWZ0OiAwO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBqdXN0aWZ5LWNvbnRlbnQ6IGNlbnRlcjtcXG4gIGdhcDogMTBweDtcXG4gIHdpZHRoOiAxMDAlO1xcbiAgcGFkZGluZzogMTBweDtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGNvbG9yOiAjMTkxOTE5O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y5ZmFmYjtcXG59XFxuXFxuLmZhLWdpdGh1YiB7XFxuICBjb2xvcjogIzE5MTkxOTtcXG4gIC8qIGNvbG9yOiAjZjlmYWZiOyAqL1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbiAgdHJhbnNpdGlvbjogdHJhbnNmb3JtIDAuM3MgZWFzZS1pbi1vdXQ7XFxufVxcblxcbi5mYS1naXRodWI6aG92ZXIge1xcbiAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKSBzY2FsZSgxLjIpO1xcbn1cXG5cIiwgXCJcIix7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCJ3ZWJwYWNrOi8vLi9zcmMvc3R5bGUuY3NzXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCJBQUFBOztFQUVFLFlBQVk7RUFDWixTQUFTO0VBQ1Qsb0JBQW9CO0VBQ3BCLGFBQWE7RUFDYixjQUFjO0VBQ2QsNkJBQTZCO0VBQzdCLGtCQUFrQjtFQUNsQixzQkFBc0I7QUFDeEI7Ozs7QUFJQTtFQUNFLFlBQVk7RUFDWixTQUFTO0VBQ1QseUJBQXlCO0VBQ3pCLGFBQWE7RUFDYixtQkFBbUI7RUFDbkIsU0FBUztFQUNULFdBQVc7RUFDWCxlQUFlO0VBQ2YsTUFBTTtBQUNSOztBQUVBO0VBQ0UsaUJBQWlCO0VBQ2pCLGVBQWU7RUFDZixpQkFBaUI7RUFDakIsb0NBQW9DO0VBQ3BDLGtDQUFrQztFQUNsQyxpQkFBaUI7QUFDbkI7O0FBRUE7O0VBRUUsMkNBQTJDO0FBQzdDOztBQUVBO0VBQ0UsZ0JBQWdCO0VBQ2hCLDBCQUEwQjtFQUMxQixZQUFZO0VBQ1osV0FBVztFQUNYLDZCQUE2QjtFQUM3QixlQUFlO0VBQ2YsaUJBQWlCO0VBQ2pCLGlCQUFpQjtBQUNuQjs7QUFFQTtFQUNFLDJDQUEyQztBQUM3Qzs7QUFFQTtFQUNFLGFBQWE7RUFDYixZQUFZO0VBQ1osaUJBQWlCO0FBQ25COztBQUVBO0VBQ0UsYUFBYTtFQUNiLHNCQUFzQjtFQUN0QixTQUFTO0VBQ1QseUJBQXlCO0VBQ3pCLGdCQUFnQjtFQUNoQixnQkFBZ0I7RUFDaEIsWUFBWTtFQUNaLGdCQUFnQjtBQUNsQjs7QUFFQTtFQUNFLGNBQWM7RUFD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VCxXQUFXO0VBQ1gsYUFBYTtFQUNiLGVBQWU7RUFDZixjQUFjO0VBQ2QseUJBQXlCO0FBQzNCOztBQUVBO0VBQ0UsY0FBYztFQUNkLG9CQUFvQjtFQUNwQixlQUFlO0VBQ2Ysc0NBQXNDO0FBQ3hDOztBQUVBO0VBQ0Usb0NBQW9DO0FBQ3RDXCIsXCJzb3VyY2VzQ29udGVudFwiOltcImh0bWwsXFxuYm9keSB7XFxuICBoZWlnaHQ6IDEwMCU7XFxuICBtYXJnaW46IDA7XFxuICBmb250LWZhbWlseTogUmFsZXdheTtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4OiAxIDEgbm9uZTtcXG4gIG1pbi13aWR0aDogY2FsYygxMDB2dyArIDE3cHgpO1xcbiAgb3ZlcmZsb3cteDogc2Nyb2xsO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG59XFxuXFxuXFxuXFxuLmhlYWRlciB7XFxuICBoZWlnaHQ6IDYwcHg7XFxuICBtYXJnaW46IDA7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjZDQ5ZDZiO1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICBnYXA6IDEwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBvc2l0aW9uOiBmaXhlZDtcXG4gIHRvcDogMDtcXG59XFxuXFxuLm5hdmJhci10b2dnbGVyIHtcXG4gIG1hcmdpbi1sZWZ0OiAxNXB4O1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogNyU7XFxuICAtLWJzLW5hdmJhci10b2dnbGVyLWJvcmRlci1yYWRpdXM6IDA7XFxuICAtLWJzLW5hdmJhci10b2dnbGVyLWZvY3VzLXdpZHRoOiAwO1xcbiAgdHJhbnNpdGlvbjogMC4yNXM7XFxufVxcblxcbi5uYXZiYXItdG9nZ2xlcjpob3ZlcixcXG4udGVzdDpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUpO1xcbn1cXG5cXG4uaG9tZS1idXR0b24ge1xcbiAgZm9udC1zaXplOiAxLjVlbTtcXG4gIGNvbG9yOiByZ2JhKDAsIDAsIDAsIDAuNTUpO1xcbiAgaGVpZ2h0OiAzOHB4O1xcbiAgd2lkdGg6IDU0cHg7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlci13aWR0aDogMDtcXG4gIGJvcmRlci1yYWRpdXM6IDclO1xcbiAgdHJhbnNpdGlvbjogMC4yNXM7XFxufVxcblxcbi5ob21lLWJ1dHRvbjpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDI1NSwgMjU1LCAyNTUsIDAuMTUpO1xcbn1cXG5cXG4uY29udGVudCB7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgaGVpZ2h0OiAxMDAlO1xcbiAgcGFkZGluZy10b3A6IDYwcHg7XFxufVxcblxcbi5zaWRlYmFyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4LWRpcmVjdGlvbjogY29sdW1uO1xcbiAgZ2FwOiAzMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Y5ZmFmYjtcXG4gIG92ZXJmbG93OiBoaWRkZW47XFxuICB0cmFuc2l0aW9uOiAwLjVzO1xcbiAgd2lkdGg6IDIwMHB4O1xcbiAgbWluLXdpZHRoOiAyMDBweDtcXG59XFxuXFxuLnNpZGViYXIgPiBkaXYge1xcbiAgbWFyZ2luOiAwIDMwcHg7XFxuICBtaW4td2lkdGg6IDE0MHB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgcGFkZGluZy1sZWZ0OiAxNXB4O1xcbiAgcGFkZGluZy10b3A6IDNweDtcXG4gIHBhZGRpbmctYm90dG9tOiAzcHg7XFxuICB0cmFuc2l0aW9uOiAwLjFzO1xcbn1cXG5cXG4ucGFnZTpob3ZlciB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuMSk7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5wYWdlLmFjdGl2ZSB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDEyOCwgMTI4LCAxMjgsIDAuMSk7XFxufVxcblxcbmhyIHtcXG4gIGJvcmRlci10b3A6IDFweCBzb2xpZCAjMTkxOTE5O1xcbiAgd2lkdGg6IDEyMHB4O1xcbiAgbWFyZ2luOiAtMTVweCAzMHB4O1xcbn1cXG5cXG4ubWFpbi1jb250ZW50LFxcbi5zaWRlYmFyIHtcXG4gIHBhZGRpbmctdG9wOiAzMHB4O1xcbiAgY29sb3I6ICMxZjI5Mzc7XFxufVxcblxcbi5tYWluLWNvbnRlbnQge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXg6IDEgMSBub25lO1xcbiAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB3aWR0aDogMTAwJTtcXG4gIG1pbi13aWR0aDogMTA3MHB4O1xcbiAgbWFyZ2luLWxlZnQ6IDMwcHg7XFxufVxcblxcbi50b2RvIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBmbGV4OiAxIDEgbm9uZTtcXG4gIGFsaWduLWl0ZW1zOiBjZW50ZXI7XFxuICB3aWR0aDogMTEwMHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2VlZTtcXG4gIG1hcmdpbi1ib3R0b206IDIwcHg7XFxuICB0cmFuc2l0aW9uOiAwLjJzO1xcbn1cXG5cXG4udG9kbyA+ICo6bm90KC5wcmlvcml0eS1zdHJpcCkge1xcbiAgICBtYXJnaW4tdG9wOiAxMHB4O1xcbiAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcbn1cXG5cXG4udG9kbzpob3ZlciB7XFxuICAgIHRyYW5zZm9ybTpzY2FsZSgxLjAwNSk7XFxuICAgIC13ZWJraXQtYm94LXNoYWRvdzogN3B4IDdweCAxMHB4IC02cHggcmdiYSgwLDAsMCwwLjQpO1xcbn1cXG5cXG4ucHJpb3JpdHktc3RyaXAge1xcbiAgICBtaW4td2lkdGg6IDRweDtcXG4gICAgaGVpZ2h0OiAxMDAlO1xcbiAgICBtYXJnaW4tcmlnaHQ6IDAuNzVyZW07XFxufVxcblxcbi5wcmlvcml0eS1sb3cge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiBncmVlbjtcXG59XFxuXFxuLnByaW9yaXR5LW1lZGl1bSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IG9yYW5nZTtcXG59XFxuXFxuLnByaW9yaXR5LWhpZ2gge1xcbiAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZWQ7XFxufVxcblxcbi50b2RvLWNoZWNrYm94IHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogbm9uZTtcXG4gIC1tb3otYXBwZWFyYW5jZTogbm9uZTtcXG4gIGFwcGVhcmFuY2U6IG5vbmU7XFxuICBtYXJnaW4tcmlnaHQ6IDAuNzVyZW07XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlcjogMnB4IHNvbGlkICMzYmEzOTU7XFxuICBib3JkZXItcmFkaXVzOiA1cHg7XFxuICBtaW4taGVpZ2h0OiAyMHB4O1xcbiAgbWluLXdpZHRoOiAyMHB4O1xcbiAgbWF4LWhlaWdodDogMjBweDtcXG4gIG1heC13aWR0aDogMjBweDtcXG4gIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG59XFxuXFxuLnRvZG8tY2hlY2tib3g6Y2hlY2tlZCB7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiAjM2JhMzk1O1xcbn1cXG5cXG4udG9kby1jaGVja2JveDpjaGVja2VkOjpiZWZvcmUge1xcbiAgY29udGVudDogXFxcIuKclFxcXCI7XFxuICBmb250LXNpemU6IDEycHg7XFxuICBjb2xvcjogd2hpdGU7XFxuICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICB0b3A6IDUwJTtcXG4gIGxlZnQ6IDUwJTtcXG4gIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbn1cXG5cXG4udG9kby10aXRsZSB7XFxuICBtYXJnaW4tcmlnaHQ6IDNyZW07XFxuICBmb250LXNpemU6IDE4cHg7XFxuICB3aWR0aDogNDJyZW07XFxuICBvdmVyZmxvdy14OiBzY3JvbGw7XFxufVxcblxcbi50b2RvLWRldGFpbHMsXFxuLnRvZG8tZGF0ZSB7XFxuICBtYXJnaW4tcmlnaHQ6IDJyZW07XFxufVxcblxcbi50b2RvLWRhdGUge1xcbiAgY29sb3I6ICM3OTNkMDU7XFxuICBmb250LXNpemU6IDE0cHg7XFxufVxcblxcbi50b2RvLWRldGFpbHMge1xcbiAgY29sb3I6ICMzYmEzOTU7XFxuICBib3JkZXItY29sb3I6ICMzYmEzOTU7XFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDtcXG4gIGJvcmRlcjogc29saWQgMXB4O1xcbiAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgZm9udC1zaXplOiAwLjlyZW07XFxuICB0cmFuc2l0aW9uOiAwLjJzO1xcbiAgcGFkZGluZzogM3B4IDE1cHg7XFxufVxcblxcbi50b2RvLWRldGFpbHM6aG92ZXIge1xcbiAgY29sb3I6IHdoaXRlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzNiYTM5NTtcXG4gIGJvcmRlci1jb2xvcjogIzNiYTM5NTtcXG59XFxuXFxuLnRvZG8tZWRpdCxcXG4udG9kby1kZWxldGUge1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgY29sb3I6ICM3OTNkMDU7XFxuICB0cmFuc2l0aW9uOiAwLjFzO1xcbn1cXG5cXG4udG9kby1lZGl0OmhvdmVyLFxcbi50b2RvLWRlbGV0ZTpob3ZlciB7XFxuICBjdXJzb3I6IHBvaW50ZXI7XFxuICBjb2xvcjogIzBmNzY2ZTtcXG59XFxuXFxuLmFkZC10YXNrIHtcXG4gIGhlaWdodDogNjBweDtcXG4gIHdpZHRoOiA2MHB4O1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgYm90dG9tOiA1MHB4O1xcbiAgcmlnaHQ6IDUwcHg7XFxuICBkaXNwbGF5OiBmbGV4O1xcbiAgYWxpZ24taXRlbXM6IGNlbnRlcjtcXG4gIGp1c3RpZnktY29udGVudDogY2VudGVyO1xcbiAgYm9yZGVyLXdpZHRoOiAwO1xcbiAgYm9yZGVyLXJhZGl1czogNTAlO1xcbiAgYmFja2dyb3VuZC1jb2xvcjogIzBmNzY2ZTtcXG4gIGZvbnQtc2l6ZTogMzZweDtcXG4gIGNvbG9yOiAjZjlmYWZiO1xcbn1cXG5cXG4uZm9ybSB7XFxuICB6LWluZGV4OiAzO1xcbiAgYm94LXNoYWRvdzogMCAycmVtIDRyZW0gcmdiKDAgMCAwIC8gNjAlKTtcXG4gIGJvcmRlci1yYWRpdXM6IDVweDtcXG4gIG1hcmdpbi1yaWdodDogYXV0bztcXG4gIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgbWF4LXdpZHRoOiA2NSU7XFxuICBtaW4td2lkdGg6IDY1MHB4O1xcbiAgcG9zaXRpb246IGFic29sdXRlO1xcbiAgdG9wOiA1MCU7XFxuICBsZWZ0OiA1MCU7XFxuICB0cmFuc2Zvcm06IHRyYW5zbGF0ZSgtNTAlLCAtNTAlKTtcXG59XFxuXFxuLmZvcm0taGVhZGVyIHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgcGFkZGluZy1sZWZ0OiAxNXB4O1xcbiAgZm9udC1zaXplOiAyNHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogI2Q0OWQ2YjtcXG4gIGhlaWdodDogNTVweDtcXG4gIGJvcmRlci10b3AtbGVmdC1yYWRpdXM6IDVweDtcXG4gIGJvcmRlci10b3AtcmlnaHQtcmFkaXVzOiA1cHg7XFxufVxcblxcbi5mb3JtLWJvZHkge1xcbiAgZGlzcGxheTogZmxleDtcXG4gIGZsZXgtZGlyZWN0aW9uOiBjb2x1bW47XFxuICBwYWRkaW5nOiAyMHB4O1xcbiAgZ2FwOiA0MHB4O1xcbiAgYmFja2dyb3VuZC1jb2xvcjogd2hpdGU7XFxuICBib3JkZXItYm90dG9tLWxlZnQtcmFkaXVzOiA1cHg7XFxuICBib3JkZXItYm90dG9tLXJpZ2h0LXJhZGl1czogNXB4O1xcbn1cXG5cXG4uZm9ybS10aXRsZSxcXG4uZm9ybS1kZXRhaWxzIHtcXG4gIHJlc2l6ZTogbm9uZTtcXG4gIG91dGxpbmU6IG5vbmU7XFxuICBib3JkZXItd2lkdGg6IDA7XFxufVxcblxcbi5mb3JtLXRpdGxlIHtcXG4gIGZvbnQtc2l6ZTogMjBweDtcXG4gIGhlaWdodDogNDBweDtcXG59XFxuXFxuLmZvcm0tZGV0YWlscyB7XFxuICBoZWlnaHQ6IDIwMHB4O1xcbiAgbWFyZ2luLXRvcDogLTMwcHg7XFxuICBmb250LXNpemU6IDE2cHg7XFxufVxcblxcbi5mb3JtLXByaW9yaXR5IHtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAgZ2FwOiAxMHB4O1xcbn1cXG5cXG4uYWRkLWJ1dHRvbiB7XFxuICBtYXJnaW4tbGVmdDogYXV0bztcXG59XFxuXFxuLmNoZWNrZWQge1xcbiAgb3BhY2l0eTogMC4zO1xcbn1cXG5cXG4uY2hlY2tlZC50b2RvLXRpdGxlIHtcXG4gIHRleHQtZGVjb3JhdGlvbjogbGluZS10aHJvdWdoO1xcbn1cXG5cXG4uZGV0YWlscy1mb3JtIHtcXG4gICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSgxMjgsIDEyOCwgMTI4LCAwLjMpO1xcbiAgICBib3gtc2hhZG93OiAwIDJyZW0gNHJlbSByZ2IoMCAwIDAgLyA2MCUpO1xcbiAgICBjb2xvcjogIzc5M2QwNTtcXG4gICAgcGFkZGluZzogMzBweDtcXG4gICAgZGlzcGxheTogZmxleDtcXG4gICAgZmxleC1kaXJlY3Rpb246IGNvbHVtbjtcXG4gICAgZ2FwOiAxMHB4O1xcbiAgICB3aWR0aDogNjQwcHg7XFxuICAgIG1pbi13aWR0aDogNTAwcHg7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgYm9yZGVyLXJhZGl1czogM3B4O1xcbiAgICBtYXJnaW4tcmlnaHQ6IGF1dG87XFxuICAgIG1hcmdpbi1sZWZ0OiBhdXRvO1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHRvcDogNTAlO1xcbiAgICBsZWZ0OiA1MCU7XFxuICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlKC01MCUsIC01MCUpO1xcbiAgICB6LWluZGV4OiAzO1xcbn1cXG5cXG4uZGV0YWlscy1jbG9zZSwgLmZvcm0tY2xvc2Uge1xcbiAgICBwb3NpdGlvbjogYWJzb2x1dGU7XFxuICAgIHJpZ2h0OiAyNXB4O1xcbiAgICB0b3A6IDEwcHg7XFxuICAgIGZvbnQtc2l6ZTogMjRweDtcXG4gICAgZm9udC13ZWlnaHQ6IGJvbGRlcjtcXG59XFxuXFxuLmRldGFpbHMtY2xvc2U6aG92ZXIge1xcbiAgICBjb2xvcjogZ29sZGVucm9kO1xcbiAgICBjdXJzb3I6IHBvaW50ZXI7XFxufVxcblxcbi5mb3JtLWNsb3NlOmhvdmVyIHtcXG4gICAgY29sb3I6ICM2OTM3MDU7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXFxuLmRldGFpbHMtcHJvamVjdCB7XFxuICAgIG1hcmdpbi1yaWdodDogMy4xcmVtO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbn1cXG5cXG4uZGV0YWlscy1wcmlvcml0eSB7XFxuICAgIG1hcmdpbi1yaWdodDogMy4xcmVtO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbn1cXG5cXG4uZGV0YWlscy1kYXRlIHtcXG4gICAgbWFyZ2luLXJpZ2h0OiAycmVtO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbn1cXG5cXG4uZGV0YWlscy1kZXNjcmlwdGlvbiB7XFxuICAgIG1hcmdpbi1yaWdodDogMS4xcmVtO1xcbiAgICBmb250LXdlaWdodDogNzAwO1xcbn1cXG5cXG4ub3ZlcmxheSB7XFxuICAgIHBvc2l0aW9uOiBhYnNvbHV0ZTtcXG4gICAgdG9wOiAwO1xcbiAgICBib3R0b206IDA7XFxuICAgIGxlZnQ6IDA7XFxuICAgIHJpZ2h0OiAwO1xcbiAgICBtaXgtYmxlbmQtbW9kZTogbXVsdGlwbHk7XFxuICAgIGJhY2tncm91bmQtcmVwZWF0OiByZXBlYXQ7XFxuICAgIHBvaW50ZXItZXZlbnRzOiBub25lO1xcbn1cXG5cXG4ub3ZlcmxheS5lbmFibGVke1xcbiAgbWluLXdpZHRoOiBjYWxjKDEwMHZ3ICsgMTdweCk7XFxuICBiYWNrZHJvcC1maWx0ZXI6IGJsdXIoNnB4KTtcXG4gIHotaW5kZXg6IDI7XFxuICBtYXJnaW4tdG9wOiAtNTAwcHg7XFxuXFxufVxcblxcbi5mb290ZXIge1xcbiAgcG9zaXRpb246IGZpeGVkO1xcbiAgYm90dG9tOiAwO1xcbiAgbGVmdDogMDtcXG4gIGRpc3BsYXk6IGZsZXg7XFxuICBhbGlnbi1pdGVtczogY2VudGVyO1xcbiAganVzdGlmeS1jb250ZW50OiBjZW50ZXI7XFxuICBnYXA6IDEwcHg7XFxuICB3aWR0aDogMTAwJTtcXG4gIHBhZGRpbmc6IDEwcHg7XFxuICBmb250LXNpemU6IDIwcHg7XFxuICBjb2xvcjogIzE5MTkxOTtcXG4gIGJhY2tncm91bmQtY29sb3I6ICNmOWZhZmI7XFxufVxcblxcbi5mYS1naXRodWIge1xcbiAgY29sb3I6ICMxOTE5MTk7XFxuICAvKiBjb2xvcjogI2Y5ZmFmYjsgKi9cXG4gIGZvbnQtc2l6ZTogMjRweDtcXG4gIHRyYW5zaXRpb246IHRyYW5zZm9ybSAwLjNzIGVhc2UtaW4tb3V0O1xcbn1cXG5cXG4uZmEtZ2l0aHViOmhvdmVyIHtcXG4gIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZykgc2NhbGUoMS4yKTtcXG59XFxuXCJdLFwic291cmNlUm9vdFwiOlwiXCJ9XSk7XG4vLyBFeHBvcnRzXG5leHBvcnQgZGVmYXVsdCBfX19DU1NfTE9BREVSX0VYUE9SVF9fXztcbiIsIlwidXNlIHN0cmljdFwiO1xuXG4vKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoY3NzV2l0aE1hcHBpbmdUb1N0cmluZykge1xuICB2YXIgbGlzdCA9IFtdO1xuXG4gIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgIHJldHVybiB0aGlzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgdmFyIGNvbnRlbnQgPSBcIlwiO1xuICAgICAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBpdGVtWzVdICE9PSBcInVuZGVmaW5lZFwiO1xuICAgICAgaWYgKGl0ZW1bNF0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZWVkTGF5ZXIpIHtcbiAgICAgICAgY29udGVudCArPSBcIkBsYXllclwiLmNvbmNhdChpdGVtWzVdLmxlbmd0aCA+IDAgPyBcIiBcIi5jb25jYXQoaXRlbVs1XSkgOiBcIlwiLCBcIiB7XCIpO1xuICAgICAgfVxuICAgICAgY29udGVudCArPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0pO1xuICAgICAgaWYgKG5lZWRMYXllcikge1xuICAgICAgICBjb250ZW50ICs9IFwifVwiO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW1bMl0pIHtcbiAgICAgICAgY29udGVudCArPSBcIn1cIjtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtWzRdKSB7XG4gICAgICAgIGNvbnRlbnQgKz0gXCJ9XCI7XG4gICAgICB9XG4gICAgICByZXR1cm4gY29udGVudDtcbiAgICB9KS5qb2luKFwiXCIpO1xuICB9O1xuXG4gIC8vIGltcG9ydCBhIGxpc3Qgb2YgbW9kdWxlcyBpbnRvIHRoZSBsaXN0XG4gIGxpc3QuaSA9IGZ1bmN0aW9uIGkobW9kdWxlcywgbWVkaWEsIGRlZHVwZSwgc3VwcG9ydHMsIGxheWVyKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCB1bmRlZmluZWRdXTtcbiAgICB9XG4gICAgdmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcbiAgICBpZiAoZGVkdXBlKSB7XG4gICAgICBmb3IgKHZhciBrID0gMDsgayA8IHRoaXMubGVuZ3RoOyBrKyspIHtcbiAgICAgICAgdmFyIGlkID0gdGhpc1trXVswXTtcbiAgICAgICAgaWYgKGlkICE9IG51bGwpIHtcbiAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgZm9yICh2YXIgX2sgPSAwOyBfayA8IG1vZHVsZXMubGVuZ3RoOyBfaysrKSB7XG4gICAgICB2YXIgaXRlbSA9IFtdLmNvbmNhdChtb2R1bGVzW19rXSk7XG4gICAgICBpZiAoZGVkdXBlICYmIGFscmVhZHlJbXBvcnRlZE1vZHVsZXNbaXRlbVswXV0pIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mIGxheWVyICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGlmICh0eXBlb2YgaXRlbVs1XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbGF5ZXJcIi5jb25jYXQoaXRlbVs1XS5sZW5ndGggPiAwID8gXCIgXCIuY29uY2F0KGl0ZW1bNV0pIDogXCJcIiwgXCIge1wiKS5jb25jYXQoaXRlbVsxXSwgXCJ9XCIpO1xuICAgICAgICAgIGl0ZW1bNV0gPSBsYXllcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG1lZGlhKSB7XG4gICAgICAgIGlmICghaXRlbVsyXSkge1xuICAgICAgICAgIGl0ZW1bMl0gPSBtZWRpYTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpdGVtWzFdID0gXCJAbWVkaWEgXCIuY29uY2F0KGl0ZW1bMl0sIFwiIHtcIikuY29uY2F0KGl0ZW1bMV0sIFwifVwiKTtcbiAgICAgICAgICBpdGVtWzJdID0gbWVkaWE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChzdXBwb3J0cykge1xuICAgICAgICBpZiAoIWl0ZW1bNF0pIHtcbiAgICAgICAgICBpdGVtWzRdID0gXCJcIi5jb25jYXQoc3VwcG9ydHMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGl0ZW1bMV0gPSBcIkBzdXBwb3J0cyAoXCIuY29uY2F0KGl0ZW1bNF0sIFwiKSB7XCIpLmNvbmNhdChpdGVtWzFdLCBcIn1cIik7XG4gICAgICAgICAgaXRlbVs0XSA9IHN1cHBvcnRzO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBsaXN0LnB1c2goaXRlbSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gbGlzdDtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgdmFyIGNvbnRlbnQgPSBpdGVtWzFdO1xuICB2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG4gIGlmICghY3NzTWFwcGluZykge1xuICAgIHJldHVybiBjb250ZW50O1xuICB9XG4gIGlmICh0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgdmFyIGJhc2U2NCA9IGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KGNzc01hcHBpbmcpKSkpO1xuICAgIHZhciBkYXRhID0gXCJzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCxcIi5jb25jYXQoYmFzZTY0KTtcbiAgICB2YXIgc291cmNlTWFwcGluZyA9IFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbiAgICByZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChbc291cmNlTWFwcGluZ10pLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgcmV0dXJuIFtjb250ZW50XS5qb2luKFwiXFxuXCIpO1xufTsiLCJ2YXIgZGVmYXVsdE9wdGlvbnMgPSB7fTtcbmV4cG9ydCBmdW5jdGlvbiBnZXREZWZhdWx0T3B0aW9ucygpIHtcbiAgcmV0dXJuIGRlZmF1bHRPcHRpb25zO1xufVxuZXhwb3J0IGZ1bmN0aW9uIHNldERlZmF1bHRPcHRpb25zKG5ld09wdGlvbnMpIHtcbiAgZGVmYXVsdE9wdGlvbnMgPSBuZXdPcHRpb25zO1xufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHJlcXVpcmVkQXJncyhyZXF1aXJlZCwgYXJncykge1xuICBpZiAoYXJncy5sZW5ndGggPCByZXF1aXJlZCkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocmVxdWlyZWQgKyAnIGFyZ3VtZW50JyArIChyZXF1aXJlZCA+IDEgPyAncycgOiAnJykgKyAnIHJlcXVpcmVkLCBidXQgb25seSAnICsgYXJncy5sZW5ndGggKyAnIHByZXNlbnQnKTtcbiAgfVxufSIsImV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIHRvSW50ZWdlcihkaXJ0eU51bWJlcikge1xuICBpZiAoZGlydHlOdW1iZXIgPT09IG51bGwgfHwgZGlydHlOdW1iZXIgPT09IHRydWUgfHwgZGlydHlOdW1iZXIgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuIE5hTjtcbiAgfVxuXG4gIHZhciBudW1iZXIgPSBOdW1iZXIoZGlydHlOdW1iZXIpO1xuXG4gIGlmIChpc05hTihudW1iZXIpKSB7XG4gICAgcmV0dXJuIG51bWJlcjtcbiAgfVxuXG4gIHJldHVybiBudW1iZXIgPCAwID8gTWF0aC5jZWlsKG51bWJlcikgOiBNYXRoLmZsb29yKG51bWJlcik7XG59IiwiLyoqXG4gKiBEYXlzIGluIDEgd2Vlay5cbiAqXG4gKiBAbmFtZSBkYXlzSW5XZWVrXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5leHBvcnQgdmFyIGRheXNJbldlZWsgPSA3O1xuLyoqXG4gKiBEYXlzIGluIDEgeWVhclxuICogT25lIHllYXJzIGVxdWFscyAzNjUuMjQyNSBkYXlzIGFjY29yZGluZyB0byB0aGUgZm9ybXVsYTpcbiAqXG4gKiA+IExlYXAgeWVhciBvY2N1cmVzIGV2ZXJ5IDQgeWVhcnMsIGV4Y2VwdCBmb3IgeWVhcnMgdGhhdCBhcmUgZGl2aXNhYmxlIGJ5IDEwMCBhbmQgbm90IGRpdmlzYWJsZSBieSA0MDAuXG4gKiA+IDEgbWVhbiB5ZWFyID0gKDM2NSsxLzQtMS8xMDArMS80MDApIGRheXMgPSAzNjUuMjQyNSBkYXlzXG4gKlxuICogQG5hbWUgZGF5c0luWWVhclxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIGRheXNJblllYXIgPSAzNjUuMjQyNTtcbi8qKlxuICogTWF4aW11bSBhbGxvd2VkIHRpbWUuXG4gKlxuICogQG5hbWUgbWF4VGltZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1heFRpbWUgPSBNYXRoLnBvdygxMCwgOCkgKiAyNCAqIDYwICogNjAgKiAxMDAwO1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgaW4gMSBtaW51dGVcbiAqXG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbk1pbnV0ZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1pbGxpc2Vjb25kc0luTWludXRlID0gNjAwMDA7XG4vKipcbiAqIE1pbGxpc2Vjb25kcyBpbiAxIGhvdXJcbiAqXG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJbkhvdXJcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBtaWxsaXNlY29uZHNJbkhvdXIgPSAzNjAwMDAwO1xuLyoqXG4gKiBNaWxsaXNlY29uZHMgaW4gMSBzZWNvbmRcbiAqXG4gKiBAbmFtZSBtaWxsaXNlY29uZHNJblNlY29uZFxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1pbGxpc2Vjb25kc0luU2Vjb25kID0gMTAwMDtcbi8qKlxuICogTWluaW11bSBhbGxvd2VkIHRpbWUuXG4gKlxuICogQG5hbWUgbWluVGltZVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1pblRpbWUgPSAtbWF4VGltZTtcbi8qKlxuICogTWludXRlcyBpbiAxIGhvdXJcbiAqXG4gKiBAbmFtZSBtaW51dGVzSW5Ib3VyXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgbWludXRlc0luSG91ciA9IDYwO1xuLyoqXG4gKiBNb250aHMgaW4gMSBxdWFydGVyXG4gKlxuICogQG5hbWUgbW9udGhzSW5RdWFydGVyXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgbW9udGhzSW5RdWFydGVyID0gMztcbi8qKlxuICogTW9udGhzIGluIDEgeWVhclxuICpcbiAqIEBuYW1lIG1vbnRoc0luWWVhclxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIG1vbnRoc0luWWVhciA9IDEyO1xuLyoqXG4gKiBRdWFydGVycyBpbiAxIHllYXJcbiAqXG4gKiBAbmFtZSBxdWFydGVyc0luWWVhclxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIHF1YXJ0ZXJzSW5ZZWFyID0gNDtcbi8qKlxuICogU2Vjb25kcyBpbiAxIGhvdXJcbiAqXG4gKiBAbmFtZSBzZWNvbmRzSW5Ib3VyXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgc2Vjb25kc0luSG91ciA9IDM2MDA7XG4vKipcbiAqIFNlY29uZHMgaW4gMSBtaW51dGVcbiAqXG4gKiBAbmFtZSBzZWNvbmRzSW5NaW51dGVcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBzZWNvbmRzSW5NaW51dGUgPSA2MDtcbi8qKlxuICogU2Vjb25kcyBpbiAxIGRheVxuICpcbiAqIEBuYW1lIHNlY29uZHNJbkRheVxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIHNlY29uZHNJbkRheSA9IHNlY29uZHNJbkhvdXIgKiAyNDtcbi8qKlxuICogU2Vjb25kcyBpbiAxIHdlZWtcbiAqXG4gKiBAbmFtZSBzZWNvbmRzSW5XZWVrXG4gKiBAY29uc3RhbnRcbiAqIEB0eXBlIHtudW1iZXJ9XG4gKiBAZGVmYXVsdFxuICovXG5cbmV4cG9ydCB2YXIgc2Vjb25kc0luV2VlayA9IHNlY29uZHNJbkRheSAqIDc7XG4vKipcbiAqIFNlY29uZHMgaW4gMSB5ZWFyXG4gKlxuICogQG5hbWUgc2Vjb25kc0luWWVhclxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIHNlY29uZHNJblllYXIgPSBzZWNvbmRzSW5EYXkgKiBkYXlzSW5ZZWFyO1xuLyoqXG4gKiBTZWNvbmRzIGluIDEgbW9udGhcbiAqXG4gKiBAbmFtZSBzZWNvbmRzSW5Nb250aFxuICogQGNvbnN0YW50XG4gKiBAdHlwZSB7bnVtYmVyfVxuICogQGRlZmF1bHRcbiAqL1xuXG5leHBvcnQgdmFyIHNlY29uZHNJbk1vbnRoID0gc2Vjb25kc0luWWVhciAvIDEyO1xuLyoqXG4gKiBTZWNvbmRzIGluIDEgcXVhcnRlclxuICpcbiAqIEBuYW1lIHNlY29uZHNJblF1YXJ0ZXJcbiAqIEBjb25zdGFudFxuICogQHR5cGUge251bWJlcn1cbiAqIEBkZWZhdWx0XG4gKi9cblxuZXhwb3J0IHZhciBzZWNvbmRzSW5RdWFydGVyID0gc2Vjb25kc0luTW9udGggKiAzOyIsImltcG9ydCBzdGFydE9mRGF5IGZyb20gXCIuLi9zdGFydE9mRGF5L2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBpc1NhbWVEYXlcbiAqIEBjYXRlZ29yeSBEYXkgSGVscGVyc1xuICogQHN1bW1hcnkgQXJlIHRoZSBnaXZlbiBkYXRlcyBpbiB0aGUgc2FtZSBkYXkgKGFuZCB5ZWFyIGFuZCBtb250aCk/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIGRheSAoYW5kIHllYXIgYW5kIG1vbnRoKT9cbiAqXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlTGVmdCAtIHRoZSBmaXJzdCBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0ge0RhdGV8TnVtYmVyfSBkYXRlUmlnaHQgLSB0aGUgc2Vjb25kIGRhdGUgdG8gY2hlY2tcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIGRheSAoYW5kIHllYXIgYW5kIG1vbnRoKVxuICogQHRocm93cyB7VHlwZUVycm9yfSAyIGFyZ3VtZW50cyByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBBcmUgNCBTZXB0ZW1iZXIgMDY6MDA6MDAgYW5kIDQgU2VwdGVtYmVyIDE4OjAwOjAwIGluIHRoZSBzYW1lIGRheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0LCA2LCAwKSwgbmV3IERhdGUoMjAxNCwgOCwgNCwgMTgsIDApKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciBhbmQgNCBPY3RvYmVyIGluIHRoZSBzYW1lIGRheT9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZURheShuZXcgRGF0ZSgyMDE0LCA4LCA0KSwgbmV3IERhdGUoMjAxNCwgOSwgNCkpXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSA0IFNlcHRlbWJlciwgMjAxNCBhbmQgNCBTZXB0ZW1iZXIsIDIwMTUgaW4gdGhlIHNhbWUgZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNTYW1lRGF5KG5ldyBEYXRlKDIwMTQsIDgsIDQpLCBuZXcgRGF0ZSgyMDE1LCA4LCA0KSlcbiAqIC8vPT4gZmFsc2VcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1NhbWVEYXkoZGlydHlEYXRlTGVmdCwgZGlydHlEYXRlUmlnaHQpIHtcbiAgcmVxdWlyZWRBcmdzKDIsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlTGVmdFN0YXJ0T2ZEYXkgPSBzdGFydE9mRGF5KGRpcnR5RGF0ZUxlZnQpO1xuICB2YXIgZGF0ZVJpZ2h0U3RhcnRPZkRheSA9IHN0YXJ0T2ZEYXkoZGlydHlEYXRlUmlnaHQpO1xuICByZXR1cm4gZGF0ZUxlZnRTdGFydE9mRGF5LmdldFRpbWUoKSA9PT0gZGF0ZVJpZ2h0U3RhcnRPZkRheS5nZXRUaW1lKCk7XG59IiwiaW1wb3J0IHN0YXJ0T2ZXZWVrIGZyb20gXCIuLi9zdGFydE9mV2Vlay9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcblxuLyoqXG4gKiBAbmFtZSBpc1NhbWVXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIHdlZWsgKGFuZCBtb250aCBhbmQgeWVhcik/XG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBBcmUgdGhlIGdpdmVuIGRhdGVzIGluIHRoZSBzYW1lIHdlZWsgKGFuZCBtb250aCBhbmQgeWVhcik/XG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZUxlZnQgLSB0aGUgZmlyc3QgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZVJpZ2h0IC0gdGhlIHNlY29uZCBkYXRlIHRvIGNoZWNrXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdIC0gYW4gb2JqZWN0IHdpdGggb3B0aW9ucy5cbiAqIEBwYXJhbSB7TG9jYWxlfSBbb3B0aW9ucy5sb2NhbGU9ZGVmYXVsdExvY2FsZV0gLSB0aGUgbG9jYWxlIG9iamVjdC4gU2VlIFtMb2NhbGVde0BsaW5rIGh0dHBzOi8vZGF0ZS1mbnMub3JnL2RvY3MvTG9jYWxlfVxuICogQHBhcmFtIHswfDF8MnwzfDR8NXw2fSBbb3B0aW9ucy53ZWVrU3RhcnRzT249MF0gLSB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IGRheSBvZiB0aGUgd2VlayAoMCAtIFN1bmRheSlcbiAqIEByZXR1cm5zIHtCb29sZWFufSB0aGUgZGF0ZXMgYXJlIGluIHRoZSBzYW1lIHdlZWsgKGFuZCBtb250aCBhbmQgeWVhcilcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMiBhcmd1bWVudHMgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLndlZWtTdGFydHNPbmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDZcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQXJlIDMxIEF1Z3VzdCAyMDE0IGFuZCA0IFNlcHRlbWJlciAyMDE0IGluIHRoZSBzYW1lIHdlZWs/XG4gKiBjb25zdCByZXN1bHQgPSBpc1NhbWVXZWVrKG5ldyBEYXRlKDIwMTQsIDcsIDMxKSwgbmV3IERhdGUoMjAxNCwgOCwgNCkpXG4gKiAvLz0+IHRydWVcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgd2VlayBzdGFydHMgd2l0aCBNb25kYXksXG4gKiAvLyBhcmUgMzEgQXVndXN0IDIwMTQgYW5kIDQgU2VwdGVtYmVyIDIwMTQgaW4gdGhlIHNhbWUgd2Vlaz9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZVdlZWsobmV3IERhdGUoMjAxNCwgNywgMzEpLCBuZXcgRGF0ZSgyMDE0LCA4LCA0KSwge1xuICogICB3ZWVrU3RhcnRzT246IDFcbiAqIH0pXG4gKiAvLz0+IGZhbHNlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIEFyZSAxIEphbnVhcnkgMjAxNCBhbmQgMSBKYW51YXJ5IDIwMTUgaW4gdGhlIHNhbWUgd2Vlaz9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzU2FtZVdlZWsobmV3IERhdGUoMjAxNCwgMCwgMSksIG5ldyBEYXRlKDIwMTUsIDAsIDEpKVxuICogLy89PiBmYWxzZVxuICovXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1NhbWVXZWVrKGRpcnR5RGF0ZUxlZnQsIGRpcnR5RGF0ZVJpZ2h0LCBvcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygyLCBhcmd1bWVudHMpO1xuICB2YXIgZGF0ZUxlZnRTdGFydE9mV2VlayA9IHN0YXJ0T2ZXZWVrKGRpcnR5RGF0ZUxlZnQsIG9wdGlvbnMpO1xuICB2YXIgZGF0ZVJpZ2h0U3RhcnRPZldlZWsgPSBzdGFydE9mV2VlayhkaXJ0eURhdGVSaWdodCwgb3B0aW9ucyk7XG4gIHJldHVybiBkYXRlTGVmdFN0YXJ0T2ZXZWVrLmdldFRpbWUoKSA9PT0gZGF0ZVJpZ2h0U3RhcnRPZldlZWsuZ2V0VGltZSgpO1xufSIsImltcG9ydCBpc1NhbWVXZWVrIGZyb20gXCIuLi9pc1NhbWVXZWVrL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuXG4vKipcbiAqIEBuYW1lIGlzVGhpc1dlZWtcbiAqIEBjYXRlZ29yeSBXZWVrIEhlbHBlcnNcbiAqIEBzdW1tYXJ5IElzIHRoZSBnaXZlbiBkYXRlIGluIHRoZSBzYW1lIHdlZWsgYXMgdGhlIGN1cnJlbnQgZGF0ZT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSBpbiB0aGUgc2FtZSB3ZWVrIGFzIHRoZSBjdXJyZW50IGRhdGU/XG4gKlxuICogPiDimqDvuI8gUGxlYXNlIG5vdGUgdGhhdCB0aGlzIGZ1bmN0aW9uIGlzIG5vdCBwcmVzZW50IGluIHRoZSBGUCBzdWJtb2R1bGUgYXNcbiAqID4gaXQgdXNlcyBgRGF0ZS5ub3coKWAgaW50ZXJuYWxseSBoZW5jZSBpbXB1cmUgYW5kIGNhbid0IGJlIHNhZmVseSBjdXJyaWVkLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgZGF0ZSB0byBjaGVja1xuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIHRoZSBvYmplY3Qgd2l0aCBvcHRpb25zXG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8Nn0gW29wdGlvbnMud2Vla1N0YXJ0c09uPTBdIC0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGUgaXMgaW4gdGhpcyB3ZWVrXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqIEB0aHJvd3Mge1JhbmdlRXJyb3J9IGBvcHRpb25zLndlZWtTdGFydHNPbmAgbXVzdCBiZSBiZXR3ZWVuIDAgYW5kIDZcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdG9kYXkgaXMgMjUgU2VwdGVtYmVyIDIwMTQsIGlzIDIxIFNlcHRlbWJlciAyMDE0IGluIHRoaXMgd2Vlaz9cbiAqIGNvbnN0IHJlc3VsdCA9IGlzVGhpc1dlZWsobmV3IERhdGUoMjAxNCwgOCwgMjEpKVxuICogLy89PiB0cnVlXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIElmIHRvZGF5IGlzIDI1IFNlcHRlbWJlciAyMDE0IGFuZCB3ZWVrIHN0YXJ0cyB3aXRoIE1vbmRheVxuICogLy8gaXMgMjEgU2VwdGVtYmVyIDIwMTQgaW4gdGhpcyB3ZWVrP1xuICogY29uc3QgcmVzdWx0ID0gaXNUaGlzV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyMSksIHsgd2Vla1N0YXJ0c09uOiAxIH0pXG4gKiAvLz0+IGZhbHNlXG4gKi9cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIGlzVGhpc1dlZWsoZGlydHlEYXRlLCBvcHRpb25zKSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICByZXR1cm4gaXNTYW1lV2VlayhkaXJ0eURhdGUsIERhdGUubm93KCksIG9wdGlvbnMpO1xufSIsImltcG9ydCBpc1NhbWVEYXkgZnJvbSBcIi4uL2lzU2FtZURheS9pbmRleC5qc1wiO1xuaW1wb3J0IHJlcXVpcmVkQXJncyBmcm9tIFwiLi4vX2xpYi9yZXF1aXJlZEFyZ3MvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgaXNUb2RheVxuICogQGNhdGVnb3J5IERheSBIZWxwZXJzXG4gKiBAc3VtbWFyeSBJcyB0aGUgZ2l2ZW4gZGF0ZSB0b2RheT9cbiAqIEBwdXJlIGZhbHNlXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBJcyB0aGUgZ2l2ZW4gZGF0ZSB0b2RheT9cbiAqXG4gKiA+IOKaoO+4jyBQbGVhc2Ugbm90ZSB0aGF0IHRoaXMgZnVuY3Rpb24gaXMgbm90IHByZXNlbnQgaW4gdGhlIEZQIHN1Ym1vZHVsZSBhc1xuICogPiBpdCB1c2VzIGBEYXRlLm5vdygpYCBpbnRlcm5hbGx5IGhlbmNlIGltcHVyZSBhbmQgY2FuJ3QgYmUgc2FmZWx5IGN1cnJpZWQuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gZGF0ZSAtIHRoZSBkYXRlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gdGhlIGRhdGUgaXMgdG9kYXlcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBJZiB0b2RheSBpcyA2IE9jdG9iZXIgMjAxNCwgaXMgNiBPY3RvYmVyIDE0OjAwOjAwIHRvZGF5P1xuICogY29uc3QgcmVzdWx0ID0gaXNUb2RheShuZXcgRGF0ZSgyMDE0LCA5LCA2LCAxNCwgMCkpXG4gKiAvLz0+IHRydWVcbiAqL1xuXG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBpc1RvZGF5KGRpcnR5RGF0ZSkge1xuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgcmV0dXJuIGlzU2FtZURheShkaXJ0eURhdGUsIERhdGUubm93KCkpO1xufSIsImltcG9ydCB7IG1pbGxpc2Vjb25kc0luSG91ciwgbWlsbGlzZWNvbmRzSW5NaW51dGUgfSBmcm9tIFwiLi4vY29uc3RhbnRzL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbi8qKlxuICogQG5hbWUgcGFyc2VJU09cbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgUGFyc2UgSVNPIHN0cmluZ1xuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUGFyc2UgdGhlIGdpdmVuIHN0cmluZyBpbiBJU08gODYwMSBmb3JtYXQgYW5kIHJldHVybiBhbiBpbnN0YW5jZSBvZiBEYXRlLlxuICpcbiAqIEZ1bmN0aW9uIGFjY2VwdHMgY29tcGxldGUgSVNPIDg2MDEgZm9ybWF0cyBhcyB3ZWxsIGFzIHBhcnRpYWwgaW1wbGVtZW50YXRpb25zLlxuICogSVNPIDg2MDE6IGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvSVNPXzg2MDFcbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXNuJ3QgYSBzdHJpbmcsIHRoZSBmdW5jdGlvbiBjYW5ub3QgcGFyc2UgdGhlIHN0cmluZyBvclxuICogdGhlIHZhbHVlcyBhcmUgaW52YWxpZCwgaXQgcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFyZ3VtZW50IC0gdGhlIHZhbHVlIHRvIGNvbnZlcnRcbiAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBhbiBvYmplY3Qgd2l0aCBvcHRpb25zLlxuICogQHBhcmFtIHswfDF8Mn0gW29wdGlvbnMuYWRkaXRpb25hbERpZ2l0cz0yXSAtIHRoZSBhZGRpdGlvbmFsIG51bWJlciBvZiBkaWdpdHMgaW4gdGhlIGV4dGVuZGVkIHllYXIgZm9ybWF0XG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHBhcnNlZCBkYXRlIGluIHRoZSBsb2NhbCB0aW1lIHpvbmVcbiAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gMSBhcmd1bWVudCByZXF1aXJlZFxuICogQHRocm93cyB7UmFuZ2VFcnJvcn0gYG9wdGlvbnMuYWRkaXRpb25hbERpZ2l0c2AgbXVzdCBiZSAwLCAxIG9yIDJcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCBzdHJpbmcgJzIwMTQtMDItMTFUMTE6MzA6MzAnIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSBwYXJzZUlTTygnMjAxNC0wMi0xMVQxMTozMDozMCcpXG4gKiAvLz0+IFR1ZSBGZWIgMTEgMjAxNCAxMTozMDozMFxuICpcbiAqIEBleGFtcGxlXG4gKiAvLyBDb252ZXJ0IHN0cmluZyAnKzAyMDE0MTAxJyB0byBkYXRlLFxuICogLy8gaWYgdGhlIGFkZGl0aW9uYWwgbnVtYmVyIG9mIGRpZ2l0cyBpbiB0aGUgZXh0ZW5kZWQgeWVhciBmb3JtYXQgaXMgMTpcbiAqIGNvbnN0IHJlc3VsdCA9IHBhcnNlSVNPKCcrMDIwMTQxMDEnLCB7IGFkZGl0aW9uYWxEaWdpdHM6IDEgfSlcbiAqIC8vPT4gRnJpIEFwciAxMSAyMDE0IDAwOjAwOjAwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gcGFyc2VJU08oYXJndW1lbnQsIG9wdGlvbnMpIHtcbiAgdmFyIF9vcHRpb25zJGFkZGl0aW9uYWxEaTtcblxuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGFkZGl0aW9uYWxEaWdpdHMgPSB0b0ludGVnZXIoKF9vcHRpb25zJGFkZGl0aW9uYWxEaSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hZGRpdGlvbmFsRGlnaXRzKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyRhZGRpdGlvbmFsRGkgIT09IHZvaWQgMCA/IF9vcHRpb25zJGFkZGl0aW9uYWxEaSA6IDIpO1xuXG4gIGlmIChhZGRpdGlvbmFsRGlnaXRzICE9PSAyICYmIGFkZGl0aW9uYWxEaWdpdHMgIT09IDEgJiYgYWRkaXRpb25hbERpZ2l0cyAhPT0gMCkge1xuICAgIHRocm93IG5ldyBSYW5nZUVycm9yKCdhZGRpdGlvbmFsRGlnaXRzIG11c3QgYmUgMCwgMSBvciAyJyk7XG4gIH1cblxuICBpZiAoISh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChhcmd1bWVudCkgPT09ICdbb2JqZWN0IFN0cmluZ10nKSkge1xuICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB9XG5cbiAgdmFyIGRhdGVTdHJpbmdzID0gc3BsaXREYXRlU3RyaW5nKGFyZ3VtZW50KTtcbiAgdmFyIGRhdGU7XG5cbiAgaWYgKGRhdGVTdHJpbmdzLmRhdGUpIHtcbiAgICB2YXIgcGFyc2VZZWFyUmVzdWx0ID0gcGFyc2VZZWFyKGRhdGVTdHJpbmdzLmRhdGUsIGFkZGl0aW9uYWxEaWdpdHMpO1xuICAgIGRhdGUgPSBwYXJzZURhdGUocGFyc2VZZWFyUmVzdWx0LnJlc3REYXRlU3RyaW5nLCBwYXJzZVllYXJSZXN1bHQueWVhcik7XG4gIH1cblxuICBpZiAoIWRhdGUgfHwgaXNOYU4oZGF0ZS5nZXRUaW1lKCkpKSB7XG4gICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gIH1cblxuICB2YXIgdGltZXN0YW1wID0gZGF0ZS5nZXRUaW1lKCk7XG4gIHZhciB0aW1lID0gMDtcbiAgdmFyIG9mZnNldDtcblxuICBpZiAoZGF0ZVN0cmluZ3MudGltZSkge1xuICAgIHRpbWUgPSBwYXJzZVRpbWUoZGF0ZVN0cmluZ3MudGltZSk7XG5cbiAgICBpZiAoaXNOYU4odGltZSkpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkYXRlU3RyaW5ncy50aW1lem9uZSkge1xuICAgIG9mZnNldCA9IHBhcnNlVGltZXpvbmUoZGF0ZVN0cmluZ3MudGltZXpvbmUpO1xuXG4gICAgaWYgKGlzTmFOKG9mZnNldCkpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgZGlydHlEYXRlID0gbmV3IERhdGUodGltZXN0YW1wICsgdGltZSk7IC8vIGpzIHBhcnNlZCBzdHJpbmcgYXNzdW1pbmcgaXQncyBpbiBVVEMgdGltZXpvbmVcbiAgICAvLyBidXQgd2UgbmVlZCBpdCB0byBiZSBwYXJzZWQgaW4gb3VyIHRpbWV6b25lXG4gICAgLy8gc28gd2UgdXNlIHV0YyB2YWx1ZXMgdG8gYnVpbGQgZGF0ZSBpbiBvdXIgdGltZXpvbmUuXG4gICAgLy8gWWVhciB2YWx1ZXMgZnJvbSAwIHRvIDk5IG1hcCB0byB0aGUgeWVhcnMgMTkwMCB0byAxOTk5XG4gICAgLy8gc28gc2V0IHllYXIgZXhwbGljaXRseSB3aXRoIHNldEZ1bGxZZWFyLlxuXG4gICAgdmFyIHJlc3VsdCA9IG5ldyBEYXRlKDApO1xuICAgIHJlc3VsdC5zZXRGdWxsWWVhcihkaXJ0eURhdGUuZ2V0VVRDRnVsbFllYXIoKSwgZGlydHlEYXRlLmdldFVUQ01vbnRoKCksIGRpcnR5RGF0ZS5nZXRVVENEYXRlKCkpO1xuICAgIHJlc3VsdC5zZXRIb3VycyhkaXJ0eURhdGUuZ2V0VVRDSG91cnMoKSwgZGlydHlEYXRlLmdldFVUQ01pbnV0ZXMoKSwgZGlydHlEYXRlLmdldFVUQ1NlY29uZHMoKSwgZGlydHlEYXRlLmdldFVUQ01pbGxpc2Vjb25kcygpKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBEYXRlKHRpbWVzdGFtcCArIHRpbWUgKyBvZmZzZXQpO1xufVxudmFyIHBhdHRlcm5zID0ge1xuICBkYXRlVGltZURlbGltaXRlcjogL1tUIF0vLFxuICB0aW1lWm9uZURlbGltaXRlcjogL1taIF0vaSxcbiAgdGltZXpvbmU6IC8oW1orLV0uKikkL1xufTtcbnZhciBkYXRlUmVnZXggPSAvXi0/KD86KFxcZHszfSl8KFxcZHsyfSkoPzotPyhcXGR7Mn0pKT98VyhcXGR7Mn0pKD86LT8oXFxkezF9KSk/fCkkLztcbnZhciB0aW1lUmVnZXggPSAvXihcXGR7Mn0oPzpbLixdXFxkKik/KSg/Ojo/KFxcZHsyfSg/OlsuLF1cXGQqKT8pKT8oPzo6PyhcXGR7Mn0oPzpbLixdXFxkKik/KSk/JC87XG52YXIgdGltZXpvbmVSZWdleCA9IC9eKFsrLV0pKFxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8kLztcblxuZnVuY3Rpb24gc3BsaXREYXRlU3RyaW5nKGRhdGVTdHJpbmcpIHtcbiAgdmFyIGRhdGVTdHJpbmdzID0ge307XG4gIHZhciBhcnJheSA9IGRhdGVTdHJpbmcuc3BsaXQocGF0dGVybnMuZGF0ZVRpbWVEZWxpbWl0ZXIpO1xuICB2YXIgdGltZVN0cmluZzsgLy8gVGhlIHJlZ2V4IG1hdGNoIHNob3VsZCBvbmx5IHJldHVybiBhdCBtYXhpbXVtIHR3byBhcnJheSBlbGVtZW50cy5cbiAgLy8gW2RhdGVdLCBbdGltZV0sIG9yIFtkYXRlLCB0aW1lXS5cblxuICBpZiAoYXJyYXkubGVuZ3RoID4gMikge1xuICAgIHJldHVybiBkYXRlU3RyaW5ncztcbiAgfVxuXG4gIGlmICgvOi8udGVzdChhcnJheVswXSkpIHtcbiAgICB0aW1lU3RyaW5nID0gYXJyYXlbMF07XG4gIH0gZWxzZSB7XG4gICAgZGF0ZVN0cmluZ3MuZGF0ZSA9IGFycmF5WzBdO1xuICAgIHRpbWVTdHJpbmcgPSBhcnJheVsxXTtcblxuICAgIGlmIChwYXR0ZXJucy50aW1lWm9uZURlbGltaXRlci50ZXN0KGRhdGVTdHJpbmdzLmRhdGUpKSB7XG4gICAgICBkYXRlU3RyaW5ncy5kYXRlID0gZGF0ZVN0cmluZy5zcGxpdChwYXR0ZXJucy50aW1lWm9uZURlbGltaXRlcilbMF07XG4gICAgICB0aW1lU3RyaW5nID0gZGF0ZVN0cmluZy5zdWJzdHIoZGF0ZVN0cmluZ3MuZGF0ZS5sZW5ndGgsIGRhdGVTdHJpbmcubGVuZ3RoKTtcbiAgICB9XG4gIH1cblxuICBpZiAodGltZVN0cmluZykge1xuICAgIHZhciB0b2tlbiA9IHBhdHRlcm5zLnRpbWV6b25lLmV4ZWModGltZVN0cmluZyk7XG5cbiAgICBpZiAodG9rZW4pIHtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWUgPSB0aW1lU3RyaW5nLnJlcGxhY2UodG9rZW5bMV0sICcnKTtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWV6b25lID0gdG9rZW5bMV07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRhdGVTdHJpbmdzLnRpbWUgPSB0aW1lU3RyaW5nO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBkYXRlU3RyaW5ncztcbn1cblxuZnVuY3Rpb24gcGFyc2VZZWFyKGRhdGVTdHJpbmcsIGFkZGl0aW9uYWxEaWdpdHMpIHtcbiAgdmFyIHJlZ2V4ID0gbmV3IFJlZ0V4cCgnXig/OihcXFxcZHs0fXxbKy1dXFxcXGR7JyArICg0ICsgYWRkaXRpb25hbERpZ2l0cykgKyAnfSl8KFxcXFxkezJ9fFsrLV1cXFxcZHsnICsgKDIgKyBhZGRpdGlvbmFsRGlnaXRzKSArICd9KSQpJyk7XG4gIHZhciBjYXB0dXJlcyA9IGRhdGVTdHJpbmcubWF0Y2gocmVnZXgpOyAvLyBJbnZhbGlkIElTTy1mb3JtYXR0ZWQgeWVhclxuXG4gIGlmICghY2FwdHVyZXMpIHJldHVybiB7XG4gICAgeWVhcjogTmFOLFxuICAgIHJlc3REYXRlU3RyaW5nOiAnJ1xuICB9O1xuICB2YXIgeWVhciA9IGNhcHR1cmVzWzFdID8gcGFyc2VJbnQoY2FwdHVyZXNbMV0pIDogbnVsbDtcbiAgdmFyIGNlbnR1cnkgPSBjYXB0dXJlc1syXSA/IHBhcnNlSW50KGNhcHR1cmVzWzJdKSA6IG51bGw7IC8vIGVpdGhlciB5ZWFyIG9yIGNlbnR1cnkgaXMgbnVsbCwgbm90IGJvdGhcblxuICByZXR1cm4ge1xuICAgIHllYXI6IGNlbnR1cnkgPT09IG51bGwgPyB5ZWFyIDogY2VudHVyeSAqIDEwMCxcbiAgICByZXN0RGF0ZVN0cmluZzogZGF0ZVN0cmluZy5zbGljZSgoY2FwdHVyZXNbMV0gfHwgY2FwdHVyZXNbMl0pLmxlbmd0aClcbiAgfTtcbn1cblxuZnVuY3Rpb24gcGFyc2VEYXRlKGRhdGVTdHJpbmcsIHllYXIpIHtcbiAgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHllYXJcbiAgaWYgKHllYXIgPT09IG51bGwpIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICB2YXIgY2FwdHVyZXMgPSBkYXRlU3RyaW5nLm1hdGNoKGRhdGVSZWdleCk7IC8vIEludmFsaWQgSVNPLWZvcm1hdHRlZCBzdHJpbmdcblxuICBpZiAoIWNhcHR1cmVzKSByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgdmFyIGlzV2Vla0RhdGUgPSAhIWNhcHR1cmVzWzRdO1xuICB2YXIgZGF5T2ZZZWFyID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1sxXSk7XG4gIHZhciBtb250aCA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbMl0pIC0gMTtcbiAgdmFyIGRheSA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbM10pO1xuICB2YXIgd2VlayA9IHBhcnNlRGF0ZVVuaXQoY2FwdHVyZXNbNF0pO1xuICB2YXIgZGF5T2ZXZWVrID0gcGFyc2VEYXRlVW5pdChjYXB0dXJlc1s1XSkgLSAxO1xuXG4gIGlmIChpc1dlZWtEYXRlKSB7XG4gICAgaWYgKCF2YWxpZGF0ZVdlZWtEYXRlKHllYXIsIHdlZWssIGRheU9mV2VlaykpIHtcbiAgICAgIHJldHVybiBuZXcgRGF0ZShOYU4pO1xuICAgIH1cblxuICAgIHJldHVybiBkYXlPZklTT1dlZWtZZWFyKHllYXIsIHdlZWssIGRheU9mV2Vlayk7XG4gIH0gZWxzZSB7XG4gICAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcblxuICAgIGlmICghdmFsaWRhdGVEYXRlKHllYXIsIG1vbnRoLCBkYXkpIHx8ICF2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSkge1xuICAgICAgcmV0dXJuIG5ldyBEYXRlKE5hTik7XG4gICAgfVxuXG4gICAgZGF0ZS5zZXRVVENGdWxsWWVhcih5ZWFyLCBtb250aCwgTWF0aC5tYXgoZGF5T2ZZZWFyLCBkYXkpKTtcbiAgICByZXR1cm4gZGF0ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwYXJzZURhdGVVbml0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA/IHBhcnNlSW50KHZhbHVlKSA6IDE7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZSh0aW1lU3RyaW5nKSB7XG4gIHZhciBjYXB0dXJlcyA9IHRpbWVTdHJpbmcubWF0Y2godGltZVJlZ2V4KTtcbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIE5hTjsgLy8gSW52YWxpZCBJU08tZm9ybWF0dGVkIHRpbWVcblxuICB2YXIgaG91cnMgPSBwYXJzZVRpbWVVbml0KGNhcHR1cmVzWzFdKTtcbiAgdmFyIG1pbnV0ZXMgPSBwYXJzZVRpbWVVbml0KGNhcHR1cmVzWzJdKTtcbiAgdmFyIHNlY29uZHMgPSBwYXJzZVRpbWVVbml0KGNhcHR1cmVzWzNdKTtcblxuICBpZiAoIXZhbGlkYXRlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcykpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgcmV0dXJuIGhvdXJzICogbWlsbGlzZWNvbmRzSW5Ib3VyICsgbWludXRlcyAqIG1pbGxpc2Vjb25kc0luTWludXRlICsgc2Vjb25kcyAqIDEwMDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZVVuaXQodmFsdWUpIHtcbiAgcmV0dXJuIHZhbHVlICYmIHBhcnNlRmxvYXQodmFsdWUucmVwbGFjZSgnLCcsICcuJykpIHx8IDA7XG59XG5cbmZ1bmN0aW9uIHBhcnNlVGltZXpvbmUodGltZXpvbmVTdHJpbmcpIHtcbiAgaWYgKHRpbWV6b25lU3RyaW5nID09PSAnWicpIHJldHVybiAwO1xuICB2YXIgY2FwdHVyZXMgPSB0aW1lem9uZVN0cmluZy5tYXRjaCh0aW1lem9uZVJlZ2V4KTtcbiAgaWYgKCFjYXB0dXJlcykgcmV0dXJuIDA7XG4gIHZhciBzaWduID0gY2FwdHVyZXNbMV0gPT09ICcrJyA/IC0xIDogMTtcbiAgdmFyIGhvdXJzID0gcGFyc2VJbnQoY2FwdHVyZXNbMl0pO1xuICB2YXIgbWludXRlcyA9IGNhcHR1cmVzWzNdICYmIHBhcnNlSW50KGNhcHR1cmVzWzNdKSB8fCAwO1xuXG4gIGlmICghdmFsaWRhdGVUaW1lem9uZShob3VycywgbWludXRlcykpIHtcbiAgICByZXR1cm4gTmFOO1xuICB9XG5cbiAgcmV0dXJuIHNpZ24gKiAoaG91cnMgKiBtaWxsaXNlY29uZHNJbkhvdXIgKyBtaW51dGVzICogbWlsbGlzZWNvbmRzSW5NaW51dGUpO1xufVxuXG5mdW5jdGlvbiBkYXlPZklTT1dlZWtZZWFyKGlzb1dlZWtZZWFyLCB3ZWVrLCBkYXkpIHtcbiAgdmFyIGRhdGUgPSBuZXcgRGF0ZSgwKTtcbiAgZGF0ZS5zZXRVVENGdWxsWWVhcihpc29XZWVrWWVhciwgMCwgNCk7XG4gIHZhciBmb3VydGhPZkphbnVhcnlEYXkgPSBkYXRlLmdldFVUQ0RheSgpIHx8IDc7XG4gIHZhciBkaWZmID0gKHdlZWsgLSAxKSAqIDcgKyBkYXkgKyAxIC0gZm91cnRoT2ZKYW51YXJ5RGF5O1xuICBkYXRlLnNldFVUQ0RhdGUoZGF0ZS5nZXRVVENEYXRlKCkgKyBkaWZmKTtcbiAgcmV0dXJuIGRhdGU7XG59IC8vIFZhbGlkYXRpb24gZnVuY3Rpb25zXG4vLyBGZWJydWFyeSBpcyBudWxsIHRvIGhhbmRsZSB0aGUgbGVhcCB5ZWFyICh1c2luZyB8fClcblxuXG52YXIgZGF5c0luTW9udGhzID0gWzMxLCBudWxsLCAzMSwgMzAsIDMxLCAzMCwgMzEsIDMxLCAzMCwgMzEsIDMwLCAzMV07XG5cbmZ1bmN0aW9uIGlzTGVhcFllYXJJbmRleCh5ZWFyKSB7XG4gIHJldHVybiB5ZWFyICUgNDAwID09PSAwIHx8IHllYXIgJSA0ID09PSAwICYmIHllYXIgJSAxMDAgIT09IDA7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlRGF0ZSh5ZWFyLCBtb250aCwgZGF0ZSkge1xuICByZXR1cm4gbW9udGggPj0gMCAmJiBtb250aCA8PSAxMSAmJiBkYXRlID49IDEgJiYgZGF0ZSA8PSAoZGF5c0luTW9udGhzW21vbnRoXSB8fCAoaXNMZWFwWWVhckluZGV4KHllYXIpID8gMjkgOiAyOCkpO1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZURheU9mWWVhckRhdGUoeWVhciwgZGF5T2ZZZWFyKSB7XG4gIHJldHVybiBkYXlPZlllYXIgPj0gMSAmJiBkYXlPZlllYXIgPD0gKGlzTGVhcFllYXJJbmRleCh5ZWFyKSA/IDM2NiA6IDM2NSk7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlV2Vla0RhdGUoX3llYXIsIHdlZWssIGRheSkge1xuICByZXR1cm4gd2VlayA+PSAxICYmIHdlZWsgPD0gNTMgJiYgZGF5ID49IDAgJiYgZGF5IDw9IDY7XG59XG5cbmZ1bmN0aW9uIHZhbGlkYXRlVGltZShob3VycywgbWludXRlcywgc2Vjb25kcykge1xuICBpZiAoaG91cnMgPT09IDI0KSB7XG4gICAgcmV0dXJuIG1pbnV0ZXMgPT09IDAgJiYgc2Vjb25kcyA9PT0gMDtcbiAgfVxuXG4gIHJldHVybiBzZWNvbmRzID49IDAgJiYgc2Vjb25kcyA8IDYwICYmIG1pbnV0ZXMgPj0gMCAmJiBtaW51dGVzIDwgNjAgJiYgaG91cnMgPj0gMCAmJiBob3VycyA8IDI1O1xufVxuXG5mdW5jdGlvbiB2YWxpZGF0ZVRpbWV6b25lKF9ob3VycywgbWludXRlcykge1xuICByZXR1cm4gbWludXRlcyA+PSAwICYmIG1pbnV0ZXMgPD0gNTk7XG59IiwiaW1wb3J0IHRvRGF0ZSBmcm9tIFwiLi4vdG9EYXRlL2luZGV4LmpzXCI7XG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSBzdGFydE9mRGF5XG4gKiBAY2F0ZWdvcnkgRGF5IEhlbHBlcnNcbiAqIEBzdW1tYXJ5IFJldHVybiB0aGUgc3RhcnQgb2YgYSBkYXkgZm9yIHRoZSBnaXZlbiBkYXRlLlxuICpcbiAqIEBkZXNjcmlwdGlvblxuICogUmV0dXJuIHRoZSBzdGFydCBvZiBhIGRheSBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgb3JpZ2luYWwgZGF0ZVxuICogQHJldHVybnMge0RhdGV9IHRoZSBzdGFydCBvZiBhIGRheVxuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIGRheSBmb3IgMiBTZXB0ZW1iZXIgMjAxNCAxMTo1NTowMDpcbiAqIGNvbnN0IHJlc3VsdCA9IHN0YXJ0T2ZEYXkobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSlcbiAqIC8vPT4gVHVlIFNlcCAwMiAyMDE0IDAwOjAwOjAwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RhcnRPZkRheShkaXJ0eURhdGUpIHtcbiAgcmVxdWlyZWRBcmdzKDEsIGFyZ3VtZW50cyk7XG4gIHZhciBkYXRlID0gdG9EYXRlKGRpcnR5RGF0ZSk7XG4gIGRhdGUuc2V0SG91cnMoMCwgMCwgMCwgMCk7XG4gIHJldHVybiBkYXRlO1xufSIsImltcG9ydCB0b0RhdGUgZnJvbSBcIi4uL3RvRGF0ZS9pbmRleC5qc1wiO1xuaW1wb3J0IHRvSW50ZWdlciBmcm9tIFwiLi4vX2xpYi90b0ludGVnZXIvaW5kZXguanNcIjtcbmltcG9ydCByZXF1aXJlZEFyZ3MgZnJvbSBcIi4uL19saWIvcmVxdWlyZWRBcmdzL2luZGV4LmpzXCI7XG5pbXBvcnQgeyBnZXREZWZhdWx0T3B0aW9ucyB9IGZyb20gXCIuLi9fbGliL2RlZmF1bHRPcHRpb25zL2luZGV4LmpzXCI7XG4vKipcbiAqIEBuYW1lIHN0YXJ0T2ZXZWVrXG4gKiBAY2F0ZWdvcnkgV2VlayBIZWxwZXJzXG4gKiBAc3VtbWFyeSBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKlxuICogQGRlc2NyaXB0aW9uXG4gKiBSZXR1cm4gdGhlIHN0YXJ0IG9mIGEgd2VlayBmb3IgdGhlIGdpdmVuIGRhdGUuXG4gKiBUaGUgcmVzdWx0IHdpbGwgYmUgaW4gdGhlIGxvY2FsIHRpbWV6b25lLlxuICpcbiAqIEBwYXJhbSB7RGF0ZXxOdW1iZXJ9IGRhdGUgLSB0aGUgb3JpZ2luYWwgZGF0ZVxuICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIGFuIG9iamVjdCB3aXRoIG9wdGlvbnMuXG4gKiBAcGFyYW0ge0xvY2FsZX0gW29wdGlvbnMubG9jYWxlPWRlZmF1bHRMb2NhbGVdIC0gdGhlIGxvY2FsZSBvYmplY3QuIFNlZSBbTG9jYWxlXXtAbGluayBodHRwczovL2RhdGUtZm5zLm9yZy9kb2NzL0xvY2FsZX1cbiAqIEBwYXJhbSB7MHwxfDJ8M3w0fDV8Nn0gW29wdGlvbnMud2Vla1N0YXJ0c09uPTBdIC0gdGhlIGluZGV4IG9mIHRoZSBmaXJzdCBkYXkgb2YgdGhlIHdlZWsgKDAgLSBTdW5kYXkpXG4gKiBAcmV0dXJucyB7RGF0ZX0gdGhlIHN0YXJ0IG9mIGEgd2Vla1xuICogQHRocm93cyB7VHlwZUVycm9yfSAxIGFyZ3VtZW50IHJlcXVpcmVkXG4gKiBAdGhyb3dzIHtSYW5nZUVycm9yfSBgb3B0aW9ucy53ZWVrU3RhcnRzT25gIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2XG4gKlxuICogQGV4YW1wbGVcbiAqIC8vIFRoZSBzdGFydCBvZiBhIHdlZWsgZm9yIDIgU2VwdGVtYmVyIDIwMTQgMTE6NTU6MDA6XG4gKiBjb25zdCByZXN1bHQgPSBzdGFydE9mV2VlayhuZXcgRGF0ZSgyMDE0LCA4LCAyLCAxMSwgNTUsIDApKVxuICogLy89PiBTdW4gQXVnIDMxIDIwMTQgMDA6MDA6MDBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gSWYgdGhlIHdlZWsgc3RhcnRzIG9uIE1vbmRheSwgdGhlIHN0YXJ0IG9mIHRoZSB3ZWVrIGZvciAyIFNlcHRlbWJlciAyMDE0IDExOjU1OjAwOlxuICogY29uc3QgcmVzdWx0ID0gc3RhcnRPZldlZWsobmV3IERhdGUoMjAxNCwgOCwgMiwgMTEsIDU1LCAwKSwgeyB3ZWVrU3RhcnRzT246IDEgfSlcbiAqIC8vPT4gTW9uIFNlcCAwMSAyMDE0IDAwOjAwOjAwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gc3RhcnRPZldlZWsoZGlydHlEYXRlLCBvcHRpb25zKSB7XG4gIHZhciBfcmVmLCBfcmVmMiwgX3JlZjMsIF9vcHRpb25zJHdlZWtTdGFydHNPbiwgX29wdGlvbnMkbG9jYWxlLCBfb3B0aW9ucyRsb2NhbGUkb3B0aW8sIF9kZWZhdWx0T3B0aW9ucyRsb2NhbCwgX2RlZmF1bHRPcHRpb25zJGxvY2FsMjtcblxuICByZXF1aXJlZEFyZ3MoMSwgYXJndW1lbnRzKTtcbiAgdmFyIGRlZmF1bHRPcHRpb25zID0gZ2V0RGVmYXVsdE9wdGlvbnMoKTtcbiAgdmFyIHdlZWtTdGFydHNPbiA9IHRvSW50ZWdlcigoX3JlZiA9IChfcmVmMiA9IChfcmVmMyA9IChfb3B0aW9ucyR3ZWVrU3RhcnRzT24gPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMud2Vla1N0YXJ0c09uKSAhPT0gbnVsbCAmJiBfb3B0aW9ucyR3ZWVrU3RhcnRzT24gIT09IHZvaWQgMCA/IF9vcHRpb25zJHdlZWtTdGFydHNPbiA6IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9vcHRpb25zJGxvY2FsZSA9IG9wdGlvbnMubG9jYWxlKSA9PT0gbnVsbCB8fCBfb3B0aW9ucyRsb2NhbGUgPT09IHZvaWQgMCA/IHZvaWQgMCA6IChfb3B0aW9ucyRsb2NhbGUkb3B0aW8gPSBfb3B0aW9ucyRsb2NhbGUub3B0aW9ucykgPT09IG51bGwgfHwgX29wdGlvbnMkbG9jYWxlJG9wdGlvID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfb3B0aW9ucyRsb2NhbGUkb3B0aW8ud2Vla1N0YXJ0c09uKSAhPT0gbnVsbCAmJiBfcmVmMyAhPT0gdm9pZCAwID8gX3JlZjMgOiBkZWZhdWx0T3B0aW9ucy53ZWVrU3RhcnRzT24pICE9PSBudWxsICYmIF9yZWYyICE9PSB2b2lkIDAgPyBfcmVmMiA6IChfZGVmYXVsdE9wdGlvbnMkbG9jYWwgPSBkZWZhdWx0T3B0aW9ucy5sb2NhbGUpID09PSBudWxsIHx8IF9kZWZhdWx0T3B0aW9ucyRsb2NhbCA9PT0gdm9pZCAwID8gdm9pZCAwIDogKF9kZWZhdWx0T3B0aW9ucyRsb2NhbDIgPSBfZGVmYXVsdE9wdGlvbnMkbG9jYWwub3B0aW9ucykgPT09IG51bGwgfHwgX2RlZmF1bHRPcHRpb25zJGxvY2FsMiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2RlZmF1bHRPcHRpb25zJGxvY2FsMi53ZWVrU3RhcnRzT24pICE9PSBudWxsICYmIF9yZWYgIT09IHZvaWQgMCA/IF9yZWYgOiAwKTsgLy8gVGVzdCBpZiB3ZWVrU3RhcnRzT24gaXMgYmV0d2VlbiAwIGFuZCA2IF9hbmRfIGlzIG5vdCBOYU5cblxuICBpZiAoISh3ZWVrU3RhcnRzT24gPj0gMCAmJiB3ZWVrU3RhcnRzT24gPD0gNikpIHtcbiAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignd2Vla1N0YXJ0c09uIG11c3QgYmUgYmV0d2VlbiAwIGFuZCA2IGluY2x1c2l2ZWx5Jyk7XG4gIH1cblxuICB2YXIgZGF0ZSA9IHRvRGF0ZShkaXJ0eURhdGUpO1xuICB2YXIgZGF5ID0gZGF0ZS5nZXREYXkoKTtcbiAgdmFyIGRpZmYgPSAoZGF5IDwgd2Vla1N0YXJ0c09uID8gNyA6IDApICsgZGF5IC0gd2Vla1N0YXJ0c09uO1xuICBkYXRlLnNldERhdGUoZGF0ZS5nZXREYXRlKCkgLSBkaWZmKTtcbiAgZGF0ZS5zZXRIb3VycygwLCAwLCAwLCAwKTtcbiAgcmV0dXJuIGRhdGU7XG59IiwiZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlwiOyBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHsgX3R5cGVvZiA9IGZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7IHJldHVybiB0eXBlb2Ygb2JqOyB9OyB9IGVsc2UgeyBfdHlwZW9mID0gZnVuY3Rpb24gX3R5cGVvZihvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7IH07IH0gcmV0dXJuIF90eXBlb2Yob2JqKTsgfVxuXG5pbXBvcnQgcmVxdWlyZWRBcmdzIGZyb20gXCIuLi9fbGliL3JlcXVpcmVkQXJncy9pbmRleC5qc1wiO1xuLyoqXG4gKiBAbmFtZSB0b0RhdGVcbiAqIEBjYXRlZ29yeSBDb21tb24gSGVscGVyc1xuICogQHN1bW1hcnkgQ29udmVydCB0aGUgZ2l2ZW4gYXJndW1lbnQgdG8gYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cbiAqXG4gKiBAZGVzY3JpcHRpb25cbiAqIENvbnZlcnQgdGhlIGdpdmVuIGFyZ3VtZW50IHRvIGFuIGluc3RhbmNlIG9mIERhdGUuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIGFuIGluc3RhbmNlIG9mIERhdGUsIHRoZSBmdW5jdGlvbiByZXR1cm5zIGl0cyBjbG9uZS5cbiAqXG4gKiBJZiB0aGUgYXJndW1lbnQgaXMgYSBudW1iZXIsIGl0IGlzIHRyZWF0ZWQgYXMgYSB0aW1lc3RhbXAuXG4gKlxuICogSWYgdGhlIGFyZ3VtZW50IGlzIG5vbmUgb2YgdGhlIGFib3ZlLCB0aGUgZnVuY3Rpb24gcmV0dXJucyBJbnZhbGlkIERhdGUuXG4gKlxuICogKipOb3RlKio6ICphbGwqIERhdGUgYXJndW1lbnRzIHBhc3NlZCB0byBhbnkgKmRhdGUtZm5zKiBmdW5jdGlvbiBpcyBwcm9jZXNzZWQgYnkgYHRvRGF0ZWAuXG4gKlxuICogQHBhcmFtIHtEYXRlfE51bWJlcn0gYXJndW1lbnQgLSB0aGUgdmFsdWUgdG8gY29udmVydFxuICogQHJldHVybnMge0RhdGV9IHRoZSBwYXJzZWQgZGF0ZSBpbiB0aGUgbG9jYWwgdGltZSB6b25lXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IDEgYXJndW1lbnQgcmVxdWlyZWRcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ2xvbmUgdGhlIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUobmV3IERhdGUoMjAxNCwgMSwgMTEsIDExLCAzMCwgMzApKVxuICogLy89PiBUdWUgRmViIDExIDIwMTQgMTE6MzA6MzBcbiAqXG4gKiBAZXhhbXBsZVxuICogLy8gQ29udmVydCB0aGUgdGltZXN0YW1wIHRvIGRhdGU6XG4gKiBjb25zdCByZXN1bHQgPSB0b0RhdGUoMTM5MjA5ODQzMDAwMClcbiAqIC8vPT4gVHVlIEZlYiAxMSAyMDE0IDExOjMwOjMwXG4gKi9cblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gdG9EYXRlKGFyZ3VtZW50KSB7XG4gIHJlcXVpcmVkQXJncygxLCBhcmd1bWVudHMpO1xuICB2YXIgYXJnU3RyID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKGFyZ3VtZW50KTsgLy8gQ2xvbmUgdGhlIGRhdGVcblxuICBpZiAoYXJndW1lbnQgaW5zdGFuY2VvZiBEYXRlIHx8IF90eXBlb2YoYXJndW1lbnQpID09PSAnb2JqZWN0JyAmJiBhcmdTdHIgPT09ICdbb2JqZWN0IERhdGVdJykge1xuICAgIC8vIFByZXZlbnQgdGhlIGRhdGUgdG8gbG9zZSB0aGUgbWlsbGlzZWNvbmRzIHdoZW4gcGFzc2VkIHRvIG5ldyBEYXRlKCkgaW4gSUUxMFxuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudC5nZXRUaW1lKCkpO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudCA9PT0gJ251bWJlcicgfHwgYXJnU3RyID09PSAnW29iamVjdCBOdW1iZXJdJykge1xuICAgIHJldHVybiBuZXcgRGF0ZShhcmd1bWVudCk7XG4gIH0gZWxzZSB7XG4gICAgaWYgKCh0eXBlb2YgYXJndW1lbnQgPT09ICdzdHJpbmcnIHx8IGFyZ1N0ciA9PT0gJ1tvYmplY3QgU3RyaW5nXScpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcbiAgICAgIGNvbnNvbGUud2FybihcIlN0YXJ0aW5nIHdpdGggdjIuMC4wLWJldGEuMSBkYXRlLWZucyBkb2Vzbid0IGFjY2VwdCBzdHJpbmdzIGFzIGRhdGUgYXJndW1lbnRzLiBQbGVhc2UgdXNlIGBwYXJzZUlTT2AgdG8gcGFyc2Ugc3RyaW5ncy4gU2VlOiBodHRwczovL2dpdGh1Yi5jb20vZGF0ZS1mbnMvZGF0ZS1mbnMvYmxvYi9tYXN0ZXIvZG9jcy91cGdyYWRlR3VpZGUubWQjc3RyaW5nLWFyZ3VtZW50c1wiKTsgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWNvbnNvbGVcblxuICAgICAgY29uc29sZS53YXJuKG5ldyBFcnJvcigpLnN0YWNrKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbmV3IERhdGUoTmFOKTtcbiAgfVxufSIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIExvZGFzaCA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cbiAqIENvcHlyaWdodCBPcGVuSlMgRm91bmRhdGlvbiBhbmQgb3RoZXIgY29udHJpYnV0b3JzIDxodHRwczovL29wZW5qc2Yub3JnLz5cbiAqIFJlbGVhc2VkIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XG4gKiBDb3B5cmlnaHQgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbiAqL1xuOyhmdW5jdGlvbigpIHtcblxuICAvKiogVXNlZCBhcyBhIHNhZmUgcmVmZXJlbmNlIGZvciBgdW5kZWZpbmVkYCBpbiBwcmUtRVM1IGVudmlyb25tZW50cy4gKi9cbiAgdmFyIHVuZGVmaW5lZDtcblxuICAvKiogVXNlZCBhcyB0aGUgc2VtYW50aWMgdmVyc2lvbiBudW1iZXIuICovXG4gIHZhciBWRVJTSU9OID0gJzQuMTcuMjEnO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBzaXplIHRvIGVuYWJsZSBsYXJnZSBhcnJheSBvcHRpbWl6YXRpb25zLiAqL1xuICB2YXIgTEFSR0VfQVJSQVlfU0laRSA9IDIwMDtcblxuICAvKiogRXJyb3IgbWVzc2FnZSBjb25zdGFudHMuICovXG4gIHZhciBDT1JFX0VSUk9SX1RFWFQgPSAnVW5zdXBwb3J0ZWQgY29yZS1qcyB1c2UuIFRyeSBodHRwczovL25wbXMuaW8vc2VhcmNoP3E9cG9ueWZpbGwuJyxcbiAgICAgIEZVTkNfRVJST1JfVEVYVCA9ICdFeHBlY3RlZCBhIGZ1bmN0aW9uJyxcbiAgICAgIElOVkFMSURfVEVNUExfVkFSX0VSUk9SX1RFWFQgPSAnSW52YWxpZCBgdmFyaWFibGVgIG9wdGlvbiBwYXNzZWQgaW50byBgXy50ZW1wbGF0ZWAnO1xuXG4gIC8qKiBVc2VkIHRvIHN0YW5kLWluIGZvciBgdW5kZWZpbmVkYCBoYXNoIHZhbHVlcy4gKi9cbiAgdmFyIEhBU0hfVU5ERUZJTkVEID0gJ19fbG9kYXNoX2hhc2hfdW5kZWZpbmVkX18nO1xuXG4gIC8qKiBVc2VkIGFzIHRoZSBtYXhpbXVtIG1lbW9pemUgY2FjaGUgc2l6ZS4gKi9cbiAgdmFyIE1BWF9NRU1PSVpFX1NJWkUgPSA1MDA7XG5cbiAgLyoqIFVzZWQgYXMgdGhlIGludGVybmFsIGFyZ3VtZW50IHBsYWNlaG9sZGVyLiAqL1xuICB2YXIgUExBQ0VIT0xERVIgPSAnX19sb2Rhc2hfcGxhY2Vob2xkZXJfXyc7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSBiaXRtYXNrcyBmb3IgY2xvbmluZy4gKi9cbiAgdmFyIENMT05FX0RFRVBfRkxBRyA9IDEsXG4gICAgICBDTE9ORV9GTEFUX0ZMQUcgPSAyLFxuICAgICAgQ0xPTkVfU1lNQk9MU19GTEFHID0gNDtcblxuICAvKiogVXNlZCB0byBjb21wb3NlIGJpdG1hc2tzIGZvciB2YWx1ZSBjb21wYXJpc29ucy4gKi9cbiAgdmFyIENPTVBBUkVfUEFSVElBTF9GTEFHID0gMSxcbiAgICAgIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcgPSAyO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgYml0bWFza3MgZm9yIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICB2YXIgV1JBUF9CSU5EX0ZMQUcgPSAxLFxuICAgICAgV1JBUF9CSU5EX0tFWV9GTEFHID0gMixcbiAgICAgIFdSQVBfQ1VSUllfQk9VTkRfRkxBRyA9IDQsXG4gICAgICBXUkFQX0NVUlJZX0ZMQUcgPSA4LFxuICAgICAgV1JBUF9DVVJSWV9SSUdIVF9GTEFHID0gMTYsXG4gICAgICBXUkFQX1BBUlRJQUxfRkxBRyA9IDMyLFxuICAgICAgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgPSA2NCxcbiAgICAgIFdSQVBfQVJZX0ZMQUcgPSAxMjgsXG4gICAgICBXUkFQX1JFQVJHX0ZMQUcgPSAyNTYsXG4gICAgICBXUkFQX0ZMSVBfRkxBRyA9IDUxMjtcblxuICAvKiogVXNlZCBhcyBkZWZhdWx0IG9wdGlvbnMgZm9yIGBfLnRydW5jYXRlYC4gKi9cbiAgdmFyIERFRkFVTFRfVFJVTkNfTEVOR1RIID0gMzAsXG4gICAgICBERUZBVUxUX1RSVU5DX09NSVNTSU9OID0gJy4uLic7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGhvdCBmdW5jdGlvbnMgYnkgbnVtYmVyIG9mIGNhbGxzIHdpdGhpbiBhIHNwYW4gb2YgbWlsbGlzZWNvbmRzLiAqL1xuICB2YXIgSE9UX0NPVU5UID0gODAwLFxuICAgICAgSE9UX1NQQU4gPSAxNjtcblxuICAvKiogVXNlZCB0byBpbmRpY2F0ZSB0aGUgdHlwZSBvZiBsYXp5IGl0ZXJhdGVlcy4gKi9cbiAgdmFyIExBWllfRklMVEVSX0ZMQUcgPSAxLFxuICAgICAgTEFaWV9NQVBfRkxBRyA9IDIsXG4gICAgICBMQVpZX1dISUxFX0ZMQUcgPSAzO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHZhcmlvdXMgYE51bWJlcmAgY29uc3RhbnRzLiAqL1xuICB2YXIgSU5GSU5JVFkgPSAxIC8gMCxcbiAgICAgIE1BWF9TQUZFX0lOVEVHRVIgPSA5MDA3MTk5MjU0NzQwOTkxLFxuICAgICAgTUFYX0lOVEVHRVIgPSAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOCxcbiAgICAgIE5BTiA9IDAgLyAwO1xuXG4gIC8qKiBVc2VkIGFzIHJlZmVyZW5jZXMgZm9yIHRoZSBtYXhpbXVtIGxlbmd0aCBhbmQgaW5kZXggb2YgYW4gYXJyYXkuICovXG4gIHZhciBNQVhfQVJSQVlfTEVOR1RIID0gNDI5NDk2NzI5NSxcbiAgICAgIE1BWF9BUlJBWV9JTkRFWCA9IE1BWF9BUlJBWV9MRU5HVEggLSAxLFxuICAgICAgSEFMRl9NQVhfQVJSQVlfTEVOR1RIID0gTUFYX0FSUkFZX0xFTkdUSCA+Pj4gMTtcblxuICAvKiogVXNlZCB0byBhc3NvY2lhdGUgd3JhcCBtZXRob2RzIHdpdGggdGhlaXIgYml0IGZsYWdzLiAqL1xuICB2YXIgd3JhcEZsYWdzID0gW1xuICAgIFsnYXJ5JywgV1JBUF9BUllfRkxBR10sXG4gICAgWydiaW5kJywgV1JBUF9CSU5EX0ZMQUddLFxuICAgIFsnYmluZEtleScsIFdSQVBfQklORF9LRVlfRkxBR10sXG4gICAgWydjdXJyeScsIFdSQVBfQ1VSUllfRkxBR10sXG4gICAgWydjdXJyeVJpZ2h0JywgV1JBUF9DVVJSWV9SSUdIVF9GTEFHXSxcbiAgICBbJ2ZsaXAnLCBXUkFQX0ZMSVBfRkxBR10sXG4gICAgWydwYXJ0aWFsJywgV1JBUF9QQVJUSUFMX0ZMQUddLFxuICAgIFsncGFydGlhbFJpZ2h0JywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUddLFxuICAgIFsncmVhcmcnLCBXUkFQX1JFQVJHX0ZMQUddXG4gIF07XG5cbiAgLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xuICB2YXIgYXJnc1RhZyA9ICdbb2JqZWN0IEFyZ3VtZW50c10nLFxuICAgICAgYXJyYXlUYWcgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYXN5bmNUYWcgPSAnW29iamVjdCBBc3luY0Z1bmN0aW9uXScsXG4gICAgICBib29sVGFnID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZVRhZyA9ICdbb2JqZWN0IERhdGVdJyxcbiAgICAgIGRvbUV4Y1RhZyA9ICdbb2JqZWN0IERPTUV4Y2VwdGlvbl0nLFxuICAgICAgZXJyb3JUYWcgPSAnW29iamVjdCBFcnJvcl0nLFxuICAgICAgZnVuY1RhZyA9ICdbb2JqZWN0IEZ1bmN0aW9uXScsXG4gICAgICBnZW5UYWcgPSAnW29iamVjdCBHZW5lcmF0b3JGdW5jdGlvbl0nLFxuICAgICAgbWFwVGFnID0gJ1tvYmplY3QgTWFwXScsXG4gICAgICBudW1iZXJUYWcgPSAnW29iamVjdCBOdW1iZXJdJyxcbiAgICAgIG51bGxUYWcgPSAnW29iamVjdCBOdWxsXScsXG4gICAgICBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJyxcbiAgICAgIHByb21pc2VUYWcgPSAnW29iamVjdCBQcm9taXNlXScsXG4gICAgICBwcm94eVRhZyA9ICdbb2JqZWN0IFByb3h5XScsXG4gICAgICByZWdleHBUYWcgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHNldFRhZyA9ICdbb2JqZWN0IFNldF0nLFxuICAgICAgc3RyaW5nVGFnID0gJ1tvYmplY3QgU3RyaW5nXScsXG4gICAgICBzeW1ib2xUYWcgPSAnW29iamVjdCBTeW1ib2xdJyxcbiAgICAgIHVuZGVmaW5lZFRhZyA9ICdbb2JqZWN0IFVuZGVmaW5lZF0nLFxuICAgICAgd2Vha01hcFRhZyA9ICdbb2JqZWN0IFdlYWtNYXBdJyxcbiAgICAgIHdlYWtTZXRUYWcgPSAnW29iamVjdCBXZWFrU2V0XSc7XG5cbiAgdmFyIGFycmF5QnVmZmVyVGFnID0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJyxcbiAgICAgIGRhdGFWaWV3VGFnID0gJ1tvYmplY3QgRGF0YVZpZXddJyxcbiAgICAgIGZsb2F0MzJUYWcgPSAnW29iamVjdCBGbG9hdDMyQXJyYXldJyxcbiAgICAgIGZsb2F0NjRUYWcgPSAnW29iamVjdCBGbG9hdDY0QXJyYXldJyxcbiAgICAgIGludDhUYWcgPSAnW29iamVjdCBJbnQ4QXJyYXldJyxcbiAgICAgIGludDE2VGFnID0gJ1tvYmplY3QgSW50MTZBcnJheV0nLFxuICAgICAgaW50MzJUYWcgPSAnW29iamVjdCBJbnQzMkFycmF5XScsXG4gICAgICB1aW50OFRhZyA9ICdbb2JqZWN0IFVpbnQ4QXJyYXldJyxcbiAgICAgIHVpbnQ4Q2xhbXBlZFRhZyA9ICdbb2JqZWN0IFVpbnQ4Q2xhbXBlZEFycmF5XScsXG4gICAgICB1aW50MTZUYWcgPSAnW29iamVjdCBVaW50MTZBcnJheV0nLFxuICAgICAgdWludDMyVGFnID0gJ1tvYmplY3QgVWludDMyQXJyYXldJztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlLiAqL1xuICB2YXIgcmVFbXB0eVN0cmluZ0xlYWRpbmcgPSAvXFxiX19wIFxcKz0gJyc7L2csXG4gICAgICByZUVtcHR5U3RyaW5nTWlkZGxlID0gL1xcYihfX3AgXFwrPSkgJycgXFwrL2csXG4gICAgICByZUVtcHR5U3RyaW5nVHJhaWxpbmcgPSAvKF9fZVxcKC4qP1xcKXxcXGJfX3RcXCkpIFxcK1xcbicnOy9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIEhUTUwgZW50aXRpZXMgYW5kIEhUTUwgY2hhcmFjdGVycy4gKi9cbiAgdmFyIHJlRXNjYXBlZEh0bWwgPSAvJig/OmFtcHxsdHxndHxxdW90fCMzOSk7L2csXG4gICAgICByZVVuZXNjYXBlZEh0bWwgPSAvWyY8PlwiJ10vZyxcbiAgICAgIHJlSGFzRXNjYXBlZEh0bWwgPSBSZWdFeHAocmVFc2NhcGVkSHRtbC5zb3VyY2UpLFxuICAgICAgcmVIYXNVbmVzY2FwZWRIdG1sID0gUmVnRXhwKHJlVW5lc2NhcGVkSHRtbC5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHRlbXBsYXRlIGRlbGltaXRlcnMuICovXG4gIHZhciByZUVzY2FwZSA9IC88JS0oW1xcc1xcU10rPyklPi9nLFxuICAgICAgcmVFdmFsdWF0ZSA9IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgICByZUludGVycG9sYXRlID0gLzwlPShbXFxzXFxTXSs/KSU+L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcHJvcGVydHkgbmFtZXMgd2l0aGluIHByb3BlcnR5IHBhdGhzLiAqL1xuICB2YXIgcmVJc0RlZXBQcm9wID0gL1xcLnxcXFsoPzpbXltcXF1dKnwoW1wiJ10pKD86KD8hXFwxKVteXFxcXF18XFxcXC4pKj9cXDEpXFxdLyxcbiAgICAgIHJlSXNQbGFpblByb3AgPSAvXlxcdyokLyxcbiAgICAgIHJlUHJvcE5hbWUgPSAvW14uW1xcXV0rfFxcWyg/OigtP1xcZCsoPzpcXC5cXGQrKT8pfChbXCInXSkoKD86KD8hXFwyKVteXFxcXF18XFxcXC4pKj8pXFwyKVxcXXwoPz0oPzpcXC58XFxbXFxdKSg/OlxcLnxcXFtcXF18JCkpL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gbWF0Y2ggYFJlZ0V4cGBcbiAgICogW3N5bnRheCBjaGFyYWN0ZXJzXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wYXR0ZXJucykuXG4gICAqL1xuICB2YXIgcmVSZWdFeHBDaGFyID0gL1tcXFxcXiQuKis/KClbXFxde318XS9nLFxuICAgICAgcmVIYXNSZWdFeHBDaGFyID0gUmVnRXhwKHJlUmVnRXhwQ2hhci5zb3VyY2UpO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIGxlYWRpbmcgd2hpdGVzcGFjZS4gKi9cbiAgdmFyIHJlVHJpbVN0YXJ0ID0gL15cXHMrLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBhIHNpbmdsZSB3aGl0ZXNwYWNlIGNoYXJhY3Rlci4gKi9cbiAgdmFyIHJlV2hpdGVzcGFjZSA9IC9cXHMvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdyYXAgZGV0YWlsIGNvbW1lbnRzLiAqL1xuICB2YXIgcmVXcmFwQ29tbWVudCA9IC9cXHsoPzpcXG5cXC9cXCogXFxbd3JhcHBlZCB3aXRoIC4rXFxdIFxcKlxcLyk/XFxuPy8sXG4gICAgICByZVdyYXBEZXRhaWxzID0gL1xce1xcblxcL1xcKiBcXFt3cmFwcGVkIHdpdGggKC4rKVxcXSBcXCovLFxuICAgICAgcmVTcGxpdERldGFpbHMgPSAvLD8gJiAvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHdvcmRzIGNvbXBvc2VkIG9mIGFscGhhbnVtZXJpYyBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgcmVBc2NpaVdvcmQgPSAvW15cXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHg3Zl0rL2c7XG5cbiAgLyoqXG4gICAqIFVzZWQgdG8gdmFsaWRhdGUgdGhlIGB2YWxpZGF0ZWAgb3B0aW9uIGluIGBfLnRlbXBsYXRlYCB2YXJpYWJsZS5cbiAgICpcbiAgICogRm9yYmlkcyBjaGFyYWN0ZXJzIHdoaWNoIGNvdWxkIHBvdGVudGlhbGx5IGNoYW5nZSB0aGUgbWVhbmluZyBvZiB0aGUgZnVuY3Rpb24gYXJndW1lbnQgZGVmaW5pdGlvbjpcbiAgICogLSBcIigpLFwiIChtb2RpZmljYXRpb24gb2YgZnVuY3Rpb24gcGFyYW1ldGVycylcbiAgICogLSBcIj1cIiAoZGVmYXVsdCB2YWx1ZSlcbiAgICogLSBcIltde31cIiAoZGVzdHJ1Y3R1cmluZyBvZiBmdW5jdGlvbiBwYXJhbWV0ZXJzKVxuICAgKiAtIFwiL1wiIChiZWdpbm5pbmcgb2YgYSBjb21tZW50KVxuICAgKiAtIHdoaXRlc3BhY2VcbiAgICovXG4gIHZhciByZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycyA9IC9bKCk9LHt9XFxbXFxdXFwvXFxzXS87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXG4gIHZhciByZUVzY2FwZUNoYXIgPSAvXFxcXChcXFxcKT8vZztcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaFxuICAgKiBbRVMgdGVtcGxhdGUgZGVsaW1pdGVyc10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdGVtcGxhdGUtbGl0ZXJhbC1sZXhpY2FsLWNvbXBvbmVudHMpLlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoW15cXFxcfV0qKD86XFxcXC5bXlxcXFx9XSopKilcXH0vZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBgUmVnRXhwYCBmbGFncyBmcm9tIHRoZWlyIGNvZXJjZWQgc3RyaW5nIHZhbHVlcy4gKi9cbiAgdmFyIHJlRmxhZ3MgPSAvXFx3KiQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBiYWQgc2lnbmVkIGhleGFkZWNpbWFsIHN0cmluZyB2YWx1ZXMuICovXG4gIHZhciByZUlzQmFkSGV4ID0gL15bLStdMHhbMC05YS1mXSskL2k7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGJpbmFyeSBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc0JpbmFyeSA9IC9eMGJbMDFdKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgaG9zdCBjb25zdHJ1Y3RvcnMgKFNhZmFyaSkuICovXG4gIHZhciByZUlzSG9zdEN0b3IgPSAvXlxcW29iamVjdCAuKz9Db25zdHJ1Y3RvclxcXSQvO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBvY3RhbCBzdHJpbmcgdmFsdWVzLiAqL1xuICB2YXIgcmVJc09jdGFsID0gL14wb1swLTddKyQvaTtcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdW5zaWduZWQgaW50ZWdlciB2YWx1ZXMuICovXG4gIHZhciByZUlzVWludCA9IC9eKD86MHxbMS05XVxcZCopJC87XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggTGF0aW4gVW5pY29kZSBsZXR0ZXJzIChleGNsdWRpbmcgbWF0aGVtYXRpY2FsIG9wZXJhdG9ycykuICovXG4gIHZhciByZUxhdGluID0gL1tcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx4ZmZcXHUwMTAwLVxcdTAxN2ZdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZW5zdXJlIGNhcHR1cmluZyBvcmRlciBvZiB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLiAqL1xuICB2YXIgcmVOb01hdGNoID0gLygkXikvO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHJlVW5lc2NhcGVkU3RyaW5nID0gL1snXFxuXFxyXFx1MjAyOFxcdTIwMjlcXFxcXS9nO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSBjaGFyYWN0ZXIgY2xhc3Nlcy4gKi9cbiAgdmFyIHJzQXN0cmFsUmFuZ2UgPSAnXFxcXHVkODAwLVxcXFx1ZGZmZicsXG4gICAgICByc0NvbWJvTWFya3NSYW5nZSA9ICdcXFxcdTAzMDAtXFxcXHUwMzZmJyxcbiAgICAgIHJlQ29tYm9IYWxmTWFya3NSYW5nZSA9ICdcXFxcdWZlMjAtXFxcXHVmZTJmJyxcbiAgICAgIHJzQ29tYm9TeW1ib2xzUmFuZ2UgPSAnXFxcXHUyMGQwLVxcXFx1MjBmZicsXG4gICAgICByc0NvbWJvUmFuZ2UgPSByc0NvbWJvTWFya3NSYW5nZSArIHJlQ29tYm9IYWxmTWFya3NSYW5nZSArIHJzQ29tYm9TeW1ib2xzUmFuZ2UsXG4gICAgICByc0RpbmdiYXRSYW5nZSA9ICdcXFxcdTI3MDAtXFxcXHUyN2JmJyxcbiAgICAgIHJzTG93ZXJSYW5nZSA9ICdhLXpcXFxceGRmLVxcXFx4ZjZcXFxceGY4LVxcXFx4ZmYnLFxuICAgICAgcnNNYXRoT3BSYW5nZSA9ICdcXFxceGFjXFxcXHhiMVxcXFx4ZDdcXFxceGY3JyxcbiAgICAgIHJzTm9uQ2hhclJhbmdlID0gJ1xcXFx4MDAtXFxcXHgyZlxcXFx4M2EtXFxcXHg0MFxcXFx4NWItXFxcXHg2MFxcXFx4N2ItXFxcXHhiZicsXG4gICAgICByc1B1bmN0dWF0aW9uUmFuZ2UgPSAnXFxcXHUyMDAwLVxcXFx1MjA2ZicsXG4gICAgICByc1NwYWNlUmFuZ2UgPSAnIFxcXFx0XFxcXHgwYlxcXFxmXFxcXHhhMFxcXFx1ZmVmZlxcXFxuXFxcXHJcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdTE2ODBcXFxcdTE4MGVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMGFcXFxcdTIwMmZcXFxcdTIwNWZcXFxcdTMwMDAnLFxuICAgICAgcnNVcHBlclJhbmdlID0gJ0EtWlxcXFx4YzAtXFxcXHhkNlxcXFx4ZDgtXFxcXHhkZScsXG4gICAgICByc1ZhclJhbmdlID0gJ1xcXFx1ZmUwZVxcXFx1ZmUwZicsXG4gICAgICByc0JyZWFrUmFuZ2UgPSByc01hdGhPcFJhbmdlICsgcnNOb25DaGFyUmFuZ2UgKyByc1B1bmN0dWF0aW9uUmFuZ2UgKyByc1NwYWNlUmFuZ2U7XG5cbiAgLyoqIFVzZWQgdG8gY29tcG9zZSB1bmljb2RlIGNhcHR1cmUgZ3JvdXBzLiAqL1xuICB2YXIgcnNBcG9zID0gXCJbJ1xcdTIwMTldXCIsXG4gICAgICByc0FzdHJhbCA9ICdbJyArIHJzQXN0cmFsUmFuZ2UgKyAnXScsXG4gICAgICByc0JyZWFrID0gJ1snICsgcnNCcmVha1JhbmdlICsgJ10nLFxuICAgICAgcnNDb21ibyA9ICdbJyArIHJzQ29tYm9SYW5nZSArICddJyxcbiAgICAgIHJzRGlnaXRzID0gJ1xcXFxkKycsXG4gICAgICByc0RpbmdiYXQgPSAnWycgKyByc0RpbmdiYXRSYW5nZSArICddJyxcbiAgICAgIHJzTG93ZXIgPSAnWycgKyByc0xvd2VyUmFuZ2UgKyAnXScsXG4gICAgICByc01pc2MgPSAnW14nICsgcnNBc3RyYWxSYW5nZSArIHJzQnJlYWtSYW5nZSArIHJzRGlnaXRzICsgcnNEaW5nYmF0UmFuZ2UgKyByc0xvd2VyUmFuZ2UgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc0ZpdHogPSAnXFxcXHVkODNjW1xcXFx1ZGZmYi1cXFxcdWRmZmZdJyxcbiAgICAgIHJzTW9kaWZpZXIgPSAnKD86JyArIHJzQ29tYm8gKyAnfCcgKyByc0ZpdHogKyAnKScsXG4gICAgICByc05vbkFzdHJhbCA9ICdbXicgKyByc0FzdHJhbFJhbmdlICsgJ10nLFxuICAgICAgcnNSZWdpb25hbCA9ICcoPzpcXFxcdWQ4M2NbXFxcXHVkZGU2LVxcXFx1ZGRmZl0pezJ9JyxcbiAgICAgIHJzU3VyclBhaXIgPSAnW1xcXFx1ZDgwMC1cXFxcdWRiZmZdW1xcXFx1ZGMwMC1cXFxcdWRmZmZdJyxcbiAgICAgIHJzVXBwZXIgPSAnWycgKyByc1VwcGVyUmFuZ2UgKyAnXScsXG4gICAgICByc1pXSiA9ICdcXFxcdTIwMGQnO1xuXG4gIC8qKiBVc2VkIHRvIGNvbXBvc2UgdW5pY29kZSByZWdleGVzLiAqL1xuICB2YXIgcnNNaXNjTG93ZXIgPSAnKD86JyArIHJzTG93ZXIgKyAnfCcgKyByc01pc2MgKyAnKScsXG4gICAgICByc01pc2NVcHBlciA9ICcoPzonICsgcnNVcHBlciArICd8JyArIHJzTWlzYyArICcpJyxcbiAgICAgIHJzT3B0Q29udHJMb3dlciA9ICcoPzonICsgcnNBcG9zICsgJyg/OmR8bGx8bXxyZXxzfHR8dmUpKT8nLFxuICAgICAgcnNPcHRDb250clVwcGVyID0gJyg/OicgKyByc0Fwb3MgKyAnKD86RHxMTHxNfFJFfFN8VHxWRSkpPycsXG4gICAgICByZU9wdE1vZCA9IHJzTW9kaWZpZXIgKyAnPycsXG4gICAgICByc09wdFZhciA9ICdbJyArIHJzVmFyUmFuZ2UgKyAnXT8nLFxuICAgICAgcnNPcHRKb2luID0gJyg/OicgKyByc1pXSiArICcoPzonICsgW3JzTm9uQXN0cmFsLCByc1JlZ2lvbmFsLCByc1N1cnJQYWlyXS5qb2luKCd8JykgKyAnKScgKyByc09wdFZhciArIHJlT3B0TW9kICsgJykqJyxcbiAgICAgIHJzT3JkTG93ZXIgPSAnXFxcXGQqKD86MXN0fDJuZHwzcmR8KD8hWzEyM10pXFxcXGR0aCkoPz1cXFxcYnxbQS1aX10pJyxcbiAgICAgIHJzT3JkVXBwZXIgPSAnXFxcXGQqKD86MVNUfDJORHwzUkR8KD8hWzEyM10pXFxcXGRUSCkoPz1cXFxcYnxbYS16X10pJyxcbiAgICAgIHJzU2VxID0gcnNPcHRWYXIgKyByZU9wdE1vZCArIHJzT3B0Sm9pbixcbiAgICAgIHJzRW1vamkgPSAnKD86JyArIFtyc0RpbmdiYXQsIHJzUmVnaW9uYWwsIHJzU3VyclBhaXJdLmpvaW4oJ3wnKSArICcpJyArIHJzU2VxLFxuICAgICAgcnNTeW1ib2wgPSAnKD86JyArIFtyc05vbkFzdHJhbCArIHJzQ29tYm8gKyAnPycsIHJzQ29tYm8sIHJzUmVnaW9uYWwsIHJzU3VyclBhaXIsIHJzQXN0cmFsXS5qb2luKCd8JykgKyAnKSc7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggYXBvc3Ryb3BoZXMuICovXG4gIHZhciByZUFwb3MgPSBSZWdFeHAocnNBcG9zLCAnZycpO1xuXG4gIC8qKlxuICAgKiBVc2VkIHRvIG1hdGNoIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykgYW5kXG4gICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3MgZm9yIHN5bWJvbHNdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrc19mb3JfU3ltYm9scykuXG4gICAqL1xuICB2YXIgcmVDb21ib01hcmsgPSBSZWdFeHAocnNDb21ibywgJ2cnKTtcblxuICAvKiogVXNlZCB0byBtYXRjaCBbc3RyaW5nIHN5bWJvbHNdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9qYXZhc2NyaXB0LXVuaWNvZGUpLiAqL1xuICB2YXIgcmVVbmljb2RlID0gUmVnRXhwKHJzRml0eiArICcoPz0nICsgcnNGaXR6ICsgJyl8JyArIHJzU3ltYm9sICsgcnNTZXEsICdnJyk7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggY29tcGxleCBvciBjb21wb3VuZCB3b3Jkcy4gKi9cbiAgdmFyIHJlVW5pY29kZVdvcmQgPSBSZWdFeHAoW1xuICAgIHJzVXBwZXIgKyAnPycgKyByc0xvd2VyICsgJysnICsgcnNPcHRDb250ckxvd2VyICsgJyg/PScgKyBbcnNCcmVhaywgcnNVcHBlciwgJyQnXS5qb2luKCd8JykgKyAnKScsXG4gICAgcnNNaXNjVXBwZXIgKyAnKycgKyByc09wdENvbnRyVXBwZXIgKyAnKD89JyArIFtyc0JyZWFrLCByc1VwcGVyICsgcnNNaXNjTG93ZXIsICckJ10uam9pbignfCcpICsgJyknLFxuICAgIHJzVXBwZXIgKyAnPycgKyByc01pc2NMb3dlciArICcrJyArIHJzT3B0Q29udHJMb3dlcixcbiAgICByc1VwcGVyICsgJysnICsgcnNPcHRDb250clVwcGVyLFxuICAgIHJzT3JkVXBwZXIsXG4gICAgcnNPcmRMb3dlcixcbiAgICByc0RpZ2l0cyxcbiAgICByc0Vtb2ppXG4gIF0uam9pbignfCcpLCAnZycpO1xuXG4gIC8qKiBVc2VkIHRvIGRldGVjdCBzdHJpbmdzIHdpdGggW3plcm8td2lkdGggam9pbmVycyBvciBjb2RlIHBvaW50cyBmcm9tIHRoZSBhc3RyYWwgcGxhbmVzXShodHRwOi8vZWV2LmVlL2Jsb2cvMjAxNS8wOS8xMi9kYXJrLWNvcm5lcnMtb2YtdW5pY29kZS8pLiAqL1xuICB2YXIgcmVIYXNVbmljb2RlID0gUmVnRXhwKCdbJyArIHJzWldKICsgcnNBc3RyYWxSYW5nZSAgKyByc0NvbWJvUmFuZ2UgKyByc1ZhclJhbmdlICsgJ10nKTtcblxuICAvKiogVXNlZCB0byBkZXRlY3Qgc3RyaW5ncyB0aGF0IG5lZWQgYSBtb3JlIHJvYnVzdCByZWdleHAgdG8gbWF0Y2ggd29yZHMuICovXG4gIHZhciByZUhhc1VuaWNvZGVXb3JkID0gL1thLXpdW0EtWl18W0EtWl17Mn1bYS16XXxbMC05XVthLXpBLVpdfFthLXpBLVpdWzAtOV18W15hLXpBLVowLTkgXS87XG5cbiAgLyoqIFVzZWQgdG8gYXNzaWduIGRlZmF1bHQgYGNvbnRleHRgIG9iamVjdCBwcm9wZXJ0aWVzLiAqL1xuICB2YXIgY29udGV4dFByb3BzID0gW1xuICAgICdBcnJheScsICdCdWZmZXInLCAnRGF0YVZpZXcnLCAnRGF0ZScsICdFcnJvcicsICdGbG9hdDMyQXJyYXknLCAnRmxvYXQ2NEFycmF5JyxcbiAgICAnRnVuY3Rpb24nLCAnSW50OEFycmF5JywgJ0ludDE2QXJyYXknLCAnSW50MzJBcnJheScsICdNYXAnLCAnTWF0aCcsICdPYmplY3QnLFxuICAgICdQcm9taXNlJywgJ1JlZ0V4cCcsICdTZXQnLCAnU3RyaW5nJywgJ1N5bWJvbCcsICdUeXBlRXJyb3InLCAnVWludDhBcnJheScsXG4gICAgJ1VpbnQ4Q2xhbXBlZEFycmF5JywgJ1VpbnQxNkFycmF5JywgJ1VpbnQzMkFycmF5JywgJ1dlYWtNYXAnLFxuICAgICdfJywgJ2NsZWFyVGltZW91dCcsICdpc0Zpbml0ZScsICdwYXJzZUludCcsICdzZXRUaW1lb3V0J1xuICBdO1xuXG4gIC8qKiBVc2VkIHRvIG1ha2UgdGVtcGxhdGUgc291cmNlVVJMcyBlYXNpZXIgdG8gaWRlbnRpZnkuICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAtMTtcblxuICAvKiogVXNlZCB0byBpZGVudGlmeSBgdG9TdHJpbmdUYWdgIHZhbHVlcyBvZiB0eXBlZCBhcnJheXMuICovXG4gIHZhciB0eXBlZEFycmF5VGFncyA9IHt9O1xuICB0eXBlZEFycmF5VGFnc1tmbG9hdDMyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Zsb2F0NjRUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbaW50OFRhZ10gPSB0eXBlZEFycmF5VGFnc1tpbnQxNlRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tpbnQzMlRhZ10gPSB0eXBlZEFycmF5VGFnc1t1aW50OFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1t1aW50OENsYW1wZWRUYWddID0gdHlwZWRBcnJheVRhZ3NbdWludDE2VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3VpbnQzMlRhZ10gPSB0cnVlO1xuICB0eXBlZEFycmF5VGFnc1thcmdzVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2FycmF5VGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW2FycmF5QnVmZmVyVGFnXSA9IHR5cGVkQXJyYXlUYWdzW2Jvb2xUYWddID1cbiAgdHlwZWRBcnJheVRhZ3NbZGF0YVZpZXdUYWddID0gdHlwZWRBcnJheVRhZ3NbZGF0ZVRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tlcnJvclRhZ10gPSB0eXBlZEFycmF5VGFnc1tmdW5jVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW21hcFRhZ10gPSB0eXBlZEFycmF5VGFnc1tudW1iZXJUYWddID1cbiAgdHlwZWRBcnJheVRhZ3Nbb2JqZWN0VGFnXSA9IHR5cGVkQXJyYXlUYWdzW3JlZ2V4cFRhZ10gPVxuICB0eXBlZEFycmF5VGFnc1tzZXRUYWddID0gdHlwZWRBcnJheVRhZ3Nbc3RyaW5nVGFnXSA9XG4gIHR5cGVkQXJyYXlUYWdzW3dlYWtNYXBUYWddID0gZmFsc2U7XG5cbiAgLyoqIFVzZWQgdG8gaWRlbnRpZnkgYHRvU3RyaW5nVGFnYCB2YWx1ZXMgc3VwcG9ydGVkIGJ5IGBfLmNsb25lYC4gKi9cbiAgdmFyIGNsb25lYWJsZVRhZ3MgPSB7fTtcbiAgY2xvbmVhYmxlVGFnc1thcmdzVGFnXSA9IGNsb25lYWJsZVRhZ3NbYXJyYXlUYWddID1cbiAgY2xvbmVhYmxlVGFnc1thcnJheUJ1ZmZlclRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGFWaWV3VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbYm9vbFRhZ10gPSBjbG9uZWFibGVUYWdzW2RhdGVUYWddID1cbiAgY2xvbmVhYmxlVGFnc1tmbG9hdDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbZmxvYXQ2NFRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDhUYWddID0gY2xvbmVhYmxlVGFnc1tpbnQxNlRhZ10gPVxuICBjbG9uZWFibGVUYWdzW2ludDMyVGFnXSA9IGNsb25lYWJsZVRhZ3NbbWFwVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbbnVtYmVyVGFnXSA9IGNsb25lYWJsZVRhZ3Nbb2JqZWN0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbcmVnZXhwVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc2V0VGFnXSA9XG4gIGNsb25lYWJsZVRhZ3Nbc3RyaW5nVGFnXSA9IGNsb25lYWJsZVRhZ3Nbc3ltYm9sVGFnXSA9XG4gIGNsb25lYWJsZVRhZ3NbdWludDhUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50OENsYW1wZWRUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t1aW50MTZUYWddID0gY2xvbmVhYmxlVGFnc1t1aW50MzJUYWddID0gdHJ1ZTtcbiAgY2xvbmVhYmxlVGFnc1tlcnJvclRhZ10gPSBjbG9uZWFibGVUYWdzW2Z1bmNUYWddID1cbiAgY2xvbmVhYmxlVGFnc1t3ZWFrTWFwVGFnXSA9IGZhbHNlO1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBMYXRpbiBVbmljb2RlIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy4gKi9cbiAgdmFyIGRlYnVycmVkTGV0dGVycyA9IHtcbiAgICAvLyBMYXRpbi0xIFN1cHBsZW1lbnQgYmxvY2suXG4gICAgJ1xceGMwJzogJ0EnLCAgJ1xceGMxJzogJ0EnLCAnXFx4YzInOiAnQScsICdcXHhjMyc6ICdBJywgJ1xceGM0JzogJ0EnLCAnXFx4YzUnOiAnQScsXG4gICAgJ1xceGUwJzogJ2EnLCAgJ1xceGUxJzogJ2EnLCAnXFx4ZTInOiAnYScsICdcXHhlMyc6ICdhJywgJ1xceGU0JzogJ2EnLCAnXFx4ZTUnOiAnYScsXG4gICAgJ1xceGM3JzogJ0MnLCAgJ1xceGU3JzogJ2MnLFxuICAgICdcXHhkMCc6ICdEJywgICdcXHhmMCc6ICdkJyxcbiAgICAnXFx4YzgnOiAnRScsICAnXFx4YzknOiAnRScsICdcXHhjYSc6ICdFJywgJ1xceGNiJzogJ0UnLFxuICAgICdcXHhlOCc6ICdlJywgICdcXHhlOSc6ICdlJywgJ1xceGVhJzogJ2UnLCAnXFx4ZWInOiAnZScsXG4gICAgJ1xceGNjJzogJ0knLCAgJ1xceGNkJzogJ0knLCAnXFx4Y2UnOiAnSScsICdcXHhjZic6ICdJJyxcbiAgICAnXFx4ZWMnOiAnaScsICAnXFx4ZWQnOiAnaScsICdcXHhlZSc6ICdpJywgJ1xceGVmJzogJ2knLFxuICAgICdcXHhkMSc6ICdOJywgICdcXHhmMSc6ICduJyxcbiAgICAnXFx4ZDInOiAnTycsICAnXFx4ZDMnOiAnTycsICdcXHhkNCc6ICdPJywgJ1xceGQ1JzogJ08nLCAnXFx4ZDYnOiAnTycsICdcXHhkOCc6ICdPJyxcbiAgICAnXFx4ZjInOiAnbycsICAnXFx4ZjMnOiAnbycsICdcXHhmNCc6ICdvJywgJ1xceGY1JzogJ28nLCAnXFx4ZjYnOiAnbycsICdcXHhmOCc6ICdvJyxcbiAgICAnXFx4ZDknOiAnVScsICAnXFx4ZGEnOiAnVScsICdcXHhkYic6ICdVJywgJ1xceGRjJzogJ1UnLFxuICAgICdcXHhmOSc6ICd1JywgICdcXHhmYSc6ICd1JywgJ1xceGZiJzogJ3UnLCAnXFx4ZmMnOiAndScsXG4gICAgJ1xceGRkJzogJ1knLCAgJ1xceGZkJzogJ3knLCAnXFx4ZmYnOiAneScsXG4gICAgJ1xceGM2JzogJ0FlJywgJ1xceGU2JzogJ2FlJyxcbiAgICAnXFx4ZGUnOiAnVGgnLCAnXFx4ZmUnOiAndGgnLFxuICAgICdcXHhkZic6ICdzcycsXG4gICAgLy8gTGF0aW4gRXh0ZW5kZWQtQSBibG9jay5cbiAgICAnXFx1MDEwMCc6ICdBJywgICdcXHUwMTAyJzogJ0EnLCAnXFx1MDEwNCc6ICdBJyxcbiAgICAnXFx1MDEwMSc6ICdhJywgICdcXHUwMTAzJzogJ2EnLCAnXFx1MDEwNSc6ICdhJyxcbiAgICAnXFx1MDEwNic6ICdDJywgICdcXHUwMTA4JzogJ0MnLCAnXFx1MDEwYSc6ICdDJywgJ1xcdTAxMGMnOiAnQycsXG4gICAgJ1xcdTAxMDcnOiAnYycsICAnXFx1MDEwOSc6ICdjJywgJ1xcdTAxMGInOiAnYycsICdcXHUwMTBkJzogJ2MnLFxuICAgICdcXHUwMTBlJzogJ0QnLCAgJ1xcdTAxMTAnOiAnRCcsICdcXHUwMTBmJzogJ2QnLCAnXFx1MDExMSc6ICdkJyxcbiAgICAnXFx1MDExMic6ICdFJywgICdcXHUwMTE0JzogJ0UnLCAnXFx1MDExNic6ICdFJywgJ1xcdTAxMTgnOiAnRScsICdcXHUwMTFhJzogJ0UnLFxuICAgICdcXHUwMTEzJzogJ2UnLCAgJ1xcdTAxMTUnOiAnZScsICdcXHUwMTE3JzogJ2UnLCAnXFx1MDExOSc6ICdlJywgJ1xcdTAxMWInOiAnZScsXG4gICAgJ1xcdTAxMWMnOiAnRycsICAnXFx1MDExZSc6ICdHJywgJ1xcdTAxMjAnOiAnRycsICdcXHUwMTIyJzogJ0cnLFxuICAgICdcXHUwMTFkJzogJ2cnLCAgJ1xcdTAxMWYnOiAnZycsICdcXHUwMTIxJzogJ2cnLCAnXFx1MDEyMyc6ICdnJyxcbiAgICAnXFx1MDEyNCc6ICdIJywgICdcXHUwMTI2JzogJ0gnLCAnXFx1MDEyNSc6ICdoJywgJ1xcdTAxMjcnOiAnaCcsXG4gICAgJ1xcdTAxMjgnOiAnSScsICAnXFx1MDEyYSc6ICdJJywgJ1xcdTAxMmMnOiAnSScsICdcXHUwMTJlJzogJ0knLCAnXFx1MDEzMCc6ICdJJyxcbiAgICAnXFx1MDEyOSc6ICdpJywgICdcXHUwMTJiJzogJ2knLCAnXFx1MDEyZCc6ICdpJywgJ1xcdTAxMmYnOiAnaScsICdcXHUwMTMxJzogJ2knLFxuICAgICdcXHUwMTM0JzogJ0onLCAgJ1xcdTAxMzUnOiAnaicsXG4gICAgJ1xcdTAxMzYnOiAnSycsICAnXFx1MDEzNyc6ICdrJywgJ1xcdTAxMzgnOiAnaycsXG4gICAgJ1xcdTAxMzknOiAnTCcsICAnXFx1MDEzYic6ICdMJywgJ1xcdTAxM2QnOiAnTCcsICdcXHUwMTNmJzogJ0wnLCAnXFx1MDE0MSc6ICdMJyxcbiAgICAnXFx1MDEzYSc6ICdsJywgICdcXHUwMTNjJzogJ2wnLCAnXFx1MDEzZSc6ICdsJywgJ1xcdTAxNDAnOiAnbCcsICdcXHUwMTQyJzogJ2wnLFxuICAgICdcXHUwMTQzJzogJ04nLCAgJ1xcdTAxNDUnOiAnTicsICdcXHUwMTQ3JzogJ04nLCAnXFx1MDE0YSc6ICdOJyxcbiAgICAnXFx1MDE0NCc6ICduJywgICdcXHUwMTQ2JzogJ24nLCAnXFx1MDE0OCc6ICduJywgJ1xcdTAxNGInOiAnbicsXG4gICAgJ1xcdTAxNGMnOiAnTycsICAnXFx1MDE0ZSc6ICdPJywgJ1xcdTAxNTAnOiAnTycsXG4gICAgJ1xcdTAxNGQnOiAnbycsICAnXFx1MDE0Zic6ICdvJywgJ1xcdTAxNTEnOiAnbycsXG4gICAgJ1xcdTAxNTQnOiAnUicsICAnXFx1MDE1Nic6ICdSJywgJ1xcdTAxNTgnOiAnUicsXG4gICAgJ1xcdTAxNTUnOiAncicsICAnXFx1MDE1Nyc6ICdyJywgJ1xcdTAxNTknOiAncicsXG4gICAgJ1xcdTAxNWEnOiAnUycsICAnXFx1MDE1Yyc6ICdTJywgJ1xcdTAxNWUnOiAnUycsICdcXHUwMTYwJzogJ1MnLFxuICAgICdcXHUwMTViJzogJ3MnLCAgJ1xcdTAxNWQnOiAncycsICdcXHUwMTVmJzogJ3MnLCAnXFx1MDE2MSc6ICdzJyxcbiAgICAnXFx1MDE2Mic6ICdUJywgICdcXHUwMTY0JzogJ1QnLCAnXFx1MDE2Nic6ICdUJyxcbiAgICAnXFx1MDE2Myc6ICd0JywgICdcXHUwMTY1JzogJ3QnLCAnXFx1MDE2Nyc6ICd0JyxcbiAgICAnXFx1MDE2OCc6ICdVJywgICdcXHUwMTZhJzogJ1UnLCAnXFx1MDE2Yyc6ICdVJywgJ1xcdTAxNmUnOiAnVScsICdcXHUwMTcwJzogJ1UnLCAnXFx1MDE3Mic6ICdVJyxcbiAgICAnXFx1MDE2OSc6ICd1JywgICdcXHUwMTZiJzogJ3UnLCAnXFx1MDE2ZCc6ICd1JywgJ1xcdTAxNmYnOiAndScsICdcXHUwMTcxJzogJ3UnLCAnXFx1MDE3Myc6ICd1JyxcbiAgICAnXFx1MDE3NCc6ICdXJywgICdcXHUwMTc1JzogJ3cnLFxuICAgICdcXHUwMTc2JzogJ1knLCAgJ1xcdTAxNzcnOiAneScsICdcXHUwMTc4JzogJ1knLFxuICAgICdcXHUwMTc5JzogJ1onLCAgJ1xcdTAxN2InOiAnWicsICdcXHUwMTdkJzogJ1onLFxuICAgICdcXHUwMTdhJzogJ3onLCAgJ1xcdTAxN2MnOiAneicsICdcXHUwMTdlJzogJ3onLFxuICAgICdcXHUwMTMyJzogJ0lKJywgJ1xcdTAxMzMnOiAnaWonLFxuICAgICdcXHUwMTUyJzogJ09lJywgJ1xcdTAxNTMnOiAnb2UnLFxuICAgICdcXHUwMTQ5JzogXCInblwiLCAnXFx1MDE3Zic6ICdzJ1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIG1hcCBjaGFyYWN0ZXJzIHRvIEhUTUwgZW50aXRpZXMuICovXG4gIHZhciBodG1sRXNjYXBlcyA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmIzM5OydcbiAgfTtcblxuICAvKiogVXNlZCB0byBtYXAgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLiAqL1xuICB2YXIgaHRtbFVuZXNjYXBlcyA9IHtcbiAgICAnJmFtcDsnOiAnJicsXG4gICAgJyZsdDsnOiAnPCcsXG4gICAgJyZndDsnOiAnPicsXG4gICAgJyZxdW90Oyc6ICdcIicsXG4gICAgJyYjMzk7JzogXCInXCJcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy4gKi9cbiAgdmFyIHN0cmluZ0VzY2FwZXMgPSB7XG4gICAgJ1xcXFwnOiAnXFxcXCcsXG4gICAgXCInXCI6IFwiJ1wiLFxuICAgICdcXG4nOiAnbicsXG4gICAgJ1xccic6ICdyJyxcbiAgICAnXFx1MjAyOCc6ICd1MjAyOCcsXG4gICAgJ1xcdTIwMjknOiAndTIwMjknXG4gIH07XG5cbiAgLyoqIEJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzIHdpdGhvdXQgYSBkZXBlbmRlbmN5IG9uIGByb290YC4gKi9cbiAgdmFyIGZyZWVQYXJzZUZsb2F0ID0gcGFyc2VGbG9hdCxcbiAgICAgIGZyZWVQYXJzZUludCA9IHBhcnNlSW50O1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgZ2xvYmFsYCBmcm9tIE5vZGUuanMuICovXG4gIHZhciBmcmVlR2xvYmFsID0gdHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwgJiYgZ2xvYmFsLk9iamVjdCA9PT0gT2JqZWN0ICYmIGdsb2JhbDtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHNlbGZgLiAqL1xuICB2YXIgZnJlZVNlbGYgPSB0eXBlb2Ygc2VsZiA9PSAnb2JqZWN0JyAmJiBzZWxmICYmIHNlbGYuT2JqZWN0ID09PSBPYmplY3QgJiYgc2VsZjtcblxuICAvKiogVXNlZCBhcyBhIHJlZmVyZW5jZSB0byB0aGUgZ2xvYmFsIG9iamVjdC4gKi9cbiAgdmFyIHJvb3QgPSBmcmVlR2xvYmFsIHx8IGZyZWVTZWxmIHx8IEZ1bmN0aW9uKCdyZXR1cm4gdGhpcycpKCk7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBleHBvcnRzYC4gKi9cbiAgdmFyIGZyZWVFeHBvcnRzID0gdHlwZW9mIGV4cG9ydHMgPT0gJ29iamVjdCcgJiYgZXhwb3J0cyAmJiAhZXhwb3J0cy5ub2RlVHlwZSAmJiBleHBvcnRzO1xuXG4gIC8qKiBEZXRlY3QgZnJlZSB2YXJpYWJsZSBgbW9kdWxlYC4gKi9cbiAgdmFyIGZyZWVNb2R1bGUgPSBmcmVlRXhwb3J0cyAmJiB0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiAhbW9kdWxlLm5vZGVUeXBlICYmIG1vZHVsZTtcblxuICAvKiogRGV0ZWN0IHRoZSBwb3B1bGFyIENvbW1vbkpTIGV4dGVuc2lvbiBgbW9kdWxlLmV4cG9ydHNgLiAqL1xuICB2YXIgbW9kdWxlRXhwb3J0cyA9IGZyZWVNb2R1bGUgJiYgZnJlZU1vZHVsZS5leHBvcnRzID09PSBmcmVlRXhwb3J0cztcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYHByb2Nlc3NgIGZyb20gTm9kZS5qcy4gKi9cbiAgdmFyIGZyZWVQcm9jZXNzID0gbW9kdWxlRXhwb3J0cyAmJiBmcmVlR2xvYmFsLnByb2Nlc3M7XG5cbiAgLyoqIFVzZWQgdG8gYWNjZXNzIGZhc3RlciBOb2RlLmpzIGhlbHBlcnMuICovXG4gIHZhciBub2RlVXRpbCA9IChmdW5jdGlvbigpIHtcbiAgICB0cnkge1xuICAgICAgLy8gVXNlIGB1dGlsLnR5cGVzYCBmb3IgTm9kZS5qcyAxMCsuXG4gICAgICB2YXIgdHlwZXMgPSBmcmVlTW9kdWxlICYmIGZyZWVNb2R1bGUucmVxdWlyZSAmJiBmcmVlTW9kdWxlLnJlcXVpcmUoJ3V0aWwnKS50eXBlcztcblxuICAgICAgaWYgKHR5cGVzKSB7XG4gICAgICAgIHJldHVybiB0eXBlcztcbiAgICAgIH1cblxuICAgICAgLy8gTGVnYWN5IGBwcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKWAgZm9yIE5vZGUuanMgPCAxMC5cbiAgICAgIHJldHVybiBmcmVlUHJvY2VzcyAmJiBmcmVlUHJvY2Vzcy5iaW5kaW5nICYmIGZyZWVQcm9jZXNzLmJpbmRpbmcoJ3V0aWwnKTtcbiAgICB9IGNhdGNoIChlKSB7fVxuICB9KCkpO1xuXG4gIC8qIE5vZGUuanMgaGVscGVyIHJlZmVyZW5jZXMuICovXG4gIHZhciBub2RlSXNBcnJheUJ1ZmZlciA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzQXJyYXlCdWZmZXIsXG4gICAgICBub2RlSXNEYXRlID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNEYXRlLFxuICAgICAgbm9kZUlzTWFwID0gbm9kZVV0aWwgJiYgbm9kZVV0aWwuaXNNYXAsXG4gICAgICBub2RlSXNSZWdFeHAgPSBub2RlVXRpbCAmJiBub2RlVXRpbC5pc1JlZ0V4cCxcbiAgICAgIG5vZGVJc1NldCA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzU2V0LFxuICAgICAgbm9kZUlzVHlwZWRBcnJheSA9IG5vZGVVdGlsICYmIG5vZGVVdGlsLmlzVHlwZWRBcnJheTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQSBmYXN0ZXIgYWx0ZXJuYXRpdmUgdG8gYEZ1bmN0aW9uI2FwcGx5YCwgdGhpcyBmdW5jdGlvbiBpbnZva2VzIGBmdW5jYFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2AgYW5kIHRoZSBhcmd1bWVudHMgb2YgYGFyZ3NgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBpbnZva2UuXG4gICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGBmdW5jYCB3aXRoLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzdWx0IG9mIGBmdW5jYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFwcGx5KGZ1bmMsIHRoaXNBcmcsIGFyZ3MpIHtcbiAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZyk7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSk7XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICBjYXNlIDM6IHJldHVybiBmdW5jLmNhbGwodGhpc0FyZywgYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUFnZ3JlZ2F0b3JgIGZvciBhcnJheXMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYGFjY3VtdWxhdG9yYCB2YWx1ZXMuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICogQHBhcmFtIHtPYmplY3R9IGFjY3VtdWxhdG9yIFRoZSBpbml0aWFsIGFnZ3JlZ2F0ZWQgb2JqZWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGFjY3VtdWxhdG9yYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5QWdncmVnYXRvcihhcnJheSwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBhcnJheSk7XG4gICAgfVxuICAgIHJldHVybiBhY2N1bXVsYXRvcjtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZm9yRWFjaGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2goYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkgPT09IGZhbHNlKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmZvckVhY2hSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUVhY2hSaWdodChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVtsZW5ndGhdLCBsZW5ndGgsIGFycmF5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcnJheTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZXZlcnlgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIHByZWRpY2F0ZSBjaGVjayxcbiAgICogIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5RXZlcnkoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoIXByZWRpY2F0ZShhcnJheVtpbmRleF0sIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uZmlsdGVyYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmlsdGVyZWQgYXJyYXkuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheUZpbHRlcihhcnJheSwgcHJlZGljYXRlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXNJbmRleCA9IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWU7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLmluY2x1ZGVzYCBmb3IgYXJyYXlzIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogc3BlY2lmeWluZyBhbiBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5XSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB0YXJnZXQgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdGFyZ2V0YCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlJbmNsdWRlcyhhcnJheSwgdmFsdWUpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgcmV0dXJuICEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgMCkgPiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2UgYGFycmF5SW5jbHVkZXNgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYSBjb21wYXJhdG9yLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHRhcmdldCBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHRhcmdldGAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5SW5jbHVkZXNXaXRoKGFycmF5LCB2YWx1ZSwgY29tcGFyYXRvcikge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoY29tcGFyYXRvcih2YWx1ZSwgYXJyYXlbaW5kZXhdKSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5tYXBgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGFycmF5TWFwKGFycmF5LCBpdGVyYXRlZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIGVsZW1lbnRzIG9mIGB2YWx1ZXNgIHRvIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFwcGVuZC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVB1c2goYXJyYXksIHZhbHVlcykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSB2YWx1ZXMubGVuZ3RoLFxuICAgICAgICBvZmZzZXQgPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgYXJyYXlbb2Zmc2V0ICsgaW5kZXhdID0gdmFsdWVzW2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIGFycmF5O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbaW5pdEFjY3VtXSBTcGVjaWZ5IHVzaW5nIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAgYXNcbiAgICogIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVJlZHVjZShhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG5cbiAgICBpZiAoaW5pdEFjY3VtICYmIGxlbmd0aCkge1xuICAgICAgYWNjdW11bGF0b3IgPSBhcnJheVsrK2luZGV4XTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KTtcbiAgICB9XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5yZWR1Y2VSaWdodGAgZm9yIGFycmF5cyB3aXRob3V0IHN1cHBvcnQgZm9yXG4gICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IFthcnJheV0gVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpbml0QWNjdW1dIFNwZWNpZnkgdXNpbmcgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgIGFzXG4gICAqICB0aGUgaW5pdGlhbCB2YWx1ZS5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYXJyYXlSZWR1Y2VSaWdodChhcnJheSwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yLCBpbml0QWNjdW0pIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGluaXRBY2N1bSAmJiBsZW5ndGgpIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gYXJyYXlbLS1sZW5ndGhdO1xuICAgIH1cbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaXRlcmF0ZWUoYWNjdW11bGF0b3IsIGFycmF5W2xlbmd0aF0sIGxlbmd0aCwgYXJyYXkpO1xuICAgIH1cbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBfLnNvbWVgIGZvciBhcnJheXMgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgKiBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXldIFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAqICBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBhcnJheVNvbWUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYW4gQVNDSUkgYHN0cmluZ2AuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdHJpbmcgc2l6ZS5cbiAgICovXG4gIHZhciBhc2NpaVNpemUgPSBiYXNlUHJvcGVydHkoJ2xlbmd0aCcpO1xuXG4gIC8qKlxuICAgKiBDb252ZXJ0cyBhbiBBU0NJSSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gYXNjaWlUb0FycmF5KHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcuc3BsaXQoJycpO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhbiBBU0NJSSBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICovXG4gIGZ1bmN0aW9uIGFzY2lpV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZUFzY2lpV29yZCkgfHwgW107XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmZpbmRLZXlgIGFuZCBgXy5maW5kTGFzdEtleWAsXG4gICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcywgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgY29sbGVjdGlvbmBcbiAgICogdXNpbmcgYGVhY2hGdW5jYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYGNvbGxlY3Rpb25gLlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZm91bmQgZWxlbWVudCBvciBpdHMga2V5LCBlbHNlIGB1bmRlZmluZWRgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUZpbmRLZXkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBlYWNoRnVuYykge1xuICAgIHZhciByZXN1bHQ7XG4gICAgZWFjaEZ1bmMoY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSkge1xuICAgICAgICByZXN1bHQgPSBrZXk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZpbmRJbmRleGAgYW5kIGBfLmZpbmRMYXN0SW5kZXhgIHdpdGhvdXRcbiAgICogc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlRmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCwgZnJvbVJpZ2h0KSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgaW5kZXggPSBmcm9tSW5kZXggKyAoZnJvbVJpZ2h0ID8gMSA6IC0xKTtcblxuICAgIHdoaWxlICgoZnJvbVJpZ2h0ID8gaW5kZXgtLSA6ICsraW5kZXggPCBsZW5ndGgpKSB7XG4gICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pbmRleE9mYCB3aXRob3V0IGBmcm9tSW5kZXhgIGJvdW5kcyBjaGVja3MuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgPyBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KVxuICAgICAgOiBiYXNlRmluZEluZGV4KGFycmF5LCBiYXNlSXNOYU4sIGZyb21JbmRleCk7XG4gIH1cblxuICAvKipcbiAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBiYXNlSW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBhIGNvbXBhcmF0b3IuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge251bWJlcn0gZnJvbUluZGV4IFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY29tcGFyYXRvciBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZUluZGV4T2ZXaXRoKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4LCBjb21wYXJhdG9yKSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChjb21wYXJhdG9yKGFycmF5W2luZGV4XSwgdmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmFOYCB3aXRob3V0IHN1cHBvcnQgZm9yIG51bWJlciBvYmplY3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VJc05hTih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSAhPT0gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ubWVhbmAgYW5kIGBfLm1lYW5CeWAgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgKiBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZU1lYW4oYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgIHJldHVybiBsZW5ndGggPyAoYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIC8gbGVuZ3RoKSA6IE5BTjtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eWAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHkoa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdW5kZWZpbmVkIDogb2JqZWN0W2tleV07XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5wcm9wZXJ0eU9mYCB3aXRob3V0IHN1cHBvcnQgZm9yIGRlZXAgcGF0aHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlUHJvcGVydHlPZihvYmplY3QpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBvYmplY3Rba2V5XTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnJlZHVjZWAgYW5kIGBfLnJlZHVjZVJpZ2h0YCwgd2l0aG91dCBzdXBwb3J0XG4gICAqIGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLCB3aGljaCBpdGVyYXRlcyBvdmVyIGBjb2xsZWN0aW9uYCB1c2luZyBgZWFjaEZ1bmNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7Kn0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgdmFsdWUuXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5pdEFjY3VtIFNwZWNpZnkgdXNpbmcgdGhlIGZpcnN0IG9yIGxhc3QgZWxlbWVudCBvZlxuICAgKiAgYGNvbGxlY3Rpb25gIGFzIHRoZSBpbml0aWFsIHZhbHVlLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlYWNoRnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGBjb2xsZWN0aW9uYC5cbiAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVJlZHVjZShjb2xsZWN0aW9uLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgZWFjaEZ1bmMpIHtcbiAgICBlYWNoRnVuYyhjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gaW5pdEFjY3VtXG4gICAgICAgID8gKGluaXRBY2N1bSA9IGZhbHNlLCB2YWx1ZSlcbiAgICAgICAgOiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc29ydEJ5YCB3aGljaCB1c2VzIGBjb21wYXJlcmAgdG8gZGVmaW5lIHRoZVxuICAgKiBzb3J0IG9yZGVyIG9mIGBhcnJheWAgYW5kIHJlcGxhY2VzIGNyaXRlcmlhIG9iamVjdHMgd2l0aCB0aGVpciBjb3JyZXNwb25kaW5nXG4gICAqIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNvcnQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNvbXBhcmVyIFRoZSBmdW5jdGlvbiB0byBkZWZpbmUgc29ydCBvcmRlci5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlU29ydEJ5KGFycmF5LCBjb21wYXJlcikge1xuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICBhcnJheS5zb3J0KGNvbXBhcmVyKTtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGFycmF5W2xlbmd0aF0gPSBhcnJheVtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc3VtYCBhbmQgYF8uc3VtQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3JcbiAgICogaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3VtLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVN1bShhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICB2YXIgcmVzdWx0LFxuICAgICAgICBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIGN1cnJlbnQgPSBpdGVyYXRlZShhcnJheVtpbmRleF0pO1xuICAgICAgaWYgKGN1cnJlbnQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGN1cnJlbnQgOiAocmVzdWx0ICsgY3VycmVudCk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udGltZXNgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kc1xuICAgKiBvciBtYXggYXJyYXkgbGVuZ3RoIGNoZWNrcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiB0aW1lcyB0byBpbnZva2UgYGl0ZXJhdGVlYC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRpbWVzKG4sIGl0ZXJhdGVlKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG4pO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gaXRlcmF0ZWUoaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRvUGFpcnNgIGFuZCBgXy50b1BhaXJzSW5gIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXlcbiAgICogb2Yga2V5LXZhbHVlIHBhaXJzIGZvciBgb2JqZWN0YCBjb3JyZXNwb25kaW5nIHRvIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBgcHJvcHNgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBnZXQgdmFsdWVzIGZvci5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUga2V5LXZhbHVlIHBhaXJzLlxuICAgKi9cbiAgZnVuY3Rpb24gYmFzZVRvUGFpcnMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gW2tleSwgb2JqZWN0W2tleV1dO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnRyaW1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gdHJpbS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAqL1xuICBmdW5jdGlvbiBiYXNlVHJpbShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nXG4gICAgICA/IHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpLnJlcGxhY2UocmVUcmltU3RhcnQsICcnKVxuICAgICAgOiBzdHJpbmc7XG4gIH1cblxuICAvKipcbiAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udW5hcnlgIHdpdGhvdXQgc3VwcG9ydCBmb3Igc3RvcmluZyBtZXRhZGF0YS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGNhcHBlZCBmdW5jdGlvbi5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VVbmFyeShmdW5jKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy52YWx1ZXNgIGFuZCBgXy52YWx1ZXNJbmAgd2hpY2ggY3JlYXRlcyBhblxuICAgKiBhcnJheSBvZiBgb2JqZWN0YCBwcm9wZXJ0eSB2YWx1ZXMgY29ycmVzcG9uZGluZyB0byB0aGUgcHJvcGVydHkgbmFtZXNcbiAgICogb2YgYHByb3BzYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge0FycmF5fSBwcm9wcyBUaGUgcHJvcGVydHkgbmFtZXMgdG8gZ2V0IHZhbHVlcyBmb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICovXG4gIGZ1bmN0aW9uIGJhc2VWYWx1ZXMob2JqZWN0LCBwcm9wcykge1xuICAgIHJldHVybiBhcnJheU1hcChwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqZWN0W2tleV07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGEgYGNhY2hlYCB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gY2FjaGUgVGhlIGNhY2hlIHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVIYXMoY2FjaGUsIGtleSkge1xuICAgIHJldHVybiBjYWNoZS5oYXMoa2V5KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltU3RhcnRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGZpcnN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZmlyc3QgdW5tYXRjaGVkIHN0cmluZyBzeW1ib2wuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyc1N0YXJ0SW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBzdHJTeW1ib2xzLmxlbmd0aDtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNoclN5bWJvbHMsIHN0clN5bWJvbHNbaW5kZXhdLCAwKSA+IC0xKSB7fVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRyaW1gIGFuZCBgXy50cmltRW5kYCB0byBnZXQgdGhlIGluZGV4IG9mIHRoZSBsYXN0IHN0cmluZyBzeW1ib2xcbiAgICogdGhhdCBpcyBub3QgZm91bmQgaW4gdGhlIGNoYXJhY3RlciBzeW1ib2xzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBzdHJTeW1ib2xzIFRoZSBzdHJpbmcgc3ltYm9scyB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0ge0FycmF5fSBjaHJTeW1ib2xzIFRoZSBjaGFyYWN0ZXIgc3ltYm9scyB0byBmaW5kLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbGFzdCB1bm1hdGNoZWQgc3RyaW5nIHN5bWJvbC5cbiAgICovXG4gIGZ1bmN0aW9uIGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykge1xuICAgIHZhciBpbmRleCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuXG4gICAgd2hpbGUgKGluZGV4LS0gJiYgYmFzZUluZGV4T2YoY2hyU3ltYm9scywgc3RyU3ltYm9sc1tpbmRleF0sIDApID4gLTEpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIG51bWJlciBvZiBgcGxhY2Vob2xkZXJgIG9jY3VycmVuY2VzIGluIGBhcnJheWAuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byBzZWFyY2ggZm9yLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwbGFjZWhvbGRlciBjb3VudC5cbiAgICovXG4gIGZ1bmN0aW9uIGNvdW50SG9sZGVycyhhcnJheSwgcGxhY2Vob2xkZXIpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICByZXN1bHQgPSAwO1xuXG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICBpZiAoYXJyYXlbbGVuZ3RoXSA9PT0gcGxhY2Vob2xkZXIpIHtcbiAgICAgICAgKytyZXN1bHQ7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgXy5kZWJ1cnJgIHRvIGNvbnZlcnQgTGF0aW4tMSBTdXBwbGVtZW50IGFuZCBMYXRpbiBFeHRlbmRlZC1BXG4gICAqIGxldHRlcnMgdG8gYmFzaWMgTGF0aW4gbGV0dGVycy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxldHRlciBUaGUgbWF0Y2hlZCBsZXR0ZXIgdG8gZGVidXJyLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBkZWJ1cnJlZCBsZXR0ZXIuXG4gICAqL1xuICB2YXIgZGVidXJyTGV0dGVyID0gYmFzZVByb3BlcnR5T2YoZGVidXJyZWRMZXR0ZXJzKTtcblxuICAvKipcbiAgICogVXNlZCBieSBgXy5lc2NhcGVgIHRvIGNvbnZlcnQgY2hhcmFjdGVycyB0byBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgdmFyIGVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbEVzY2FwZXMpO1xuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGBfLnRlbXBsYXRlYCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IGNociBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIoY2hyKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIHN0cmluZ0VzY2FwZXNbY2hyXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcHJvcGVydHkgdmFsdWUuXG4gICAqL1xuICBmdW5jdGlvbiBnZXRWYWx1ZShvYmplY3QsIGtleSkge1xuICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFtrZXldO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgc3RyaW5nYCBjb250YWlucyBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSBzeW1ib2wgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIGhhc1VuaWNvZGUoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHJlSGFzVW5pY29kZS50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGBzdHJpbmdgIGNvbnRhaW5zIGEgd29yZCBjb21wb3NlZCBvZiBVbmljb2RlIHN5bWJvbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYSB3b3JkIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqL1xuICBmdW5jdGlvbiBoYXNVbmljb2RlV29yZChzdHJpbmcpIHtcbiAgICByZXR1cm4gcmVIYXNVbmljb2RlV29yZC50ZXN0KHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYGl0ZXJhdG9yYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGl0ZXJhdG9yIFRoZSBpdGVyYXRvciB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIGl0ZXJhdG9yVG9BcnJheShpdGVyYXRvcikge1xuICAgIHZhciBkYXRhLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICghKGRhdGEgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKGRhdGEudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGBtYXBgIHRvIGl0cyBrZXktdmFsdWUgcGFpcnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIG1hcFRvQXJyYXkobWFwKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KG1hcC5zaXplKTtcblxuICAgIG1hcC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IFtrZXksIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSB1bmFyeSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50IHRyYW5zZm9ybWVkLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB0cmFuc2Zvcm0gVGhlIGFyZ3VtZW50IHRyYW5zZm9ybS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBvdmVyQXJnKGZ1bmMsIHRyYW5zZm9ybSkge1xuICAgIHJldHVybiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIHJldHVybiBmdW5jKHRyYW5zZm9ybShhcmcpKTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIFJlcGxhY2VzIGFsbCBgcGxhY2Vob2xkZXJgIGVsZW1lbnRzIGluIGBhcnJheWAgd2l0aCBhbiBpbnRlcm5hbCBwbGFjZWhvbGRlclxuICAgKiBhbmQgcmV0dXJucyBhbiBhcnJheSBvZiB0aGVpciBpbmRleGVzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgKiBAcGFyYW0geyp9IHBsYWNlaG9sZGVyIFRoZSBwbGFjZWhvbGRlciB0byByZXBsYWNlLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgKi9cbiAgZnVuY3Rpb24gcmVwbGFjZUhvbGRlcnMoYXJyYXksIHBsYWNlaG9sZGVyKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUgPT09IHBsYWNlaG9sZGVyIHx8IHZhbHVlID09PSBQTEFDRUhPTERFUikge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBQTEFDRUhPTERFUjtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gYW4gYXJyYXkgb2YgaXRzIHZhbHVlcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IHNldCBUaGUgc2V0IHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgdmFsdWVzLlxuICAgKi9cbiAgZnVuY3Rpb24gc2V0VG9BcnJheShzZXQpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoc2V0LnNpemUpO1xuXG4gICAgc2V0LmZvckVhY2goZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdFsrK2luZGV4XSA9IHZhbHVlO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHNldGAgdG8gaXRzIHZhbHVlLXZhbHVlIHBhaXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gc2V0IFRoZSBzZXQgdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB2YWx1ZS12YWx1ZSBwYWlycy5cbiAgICovXG4gIGZ1bmN0aW9uIHNldFRvUGFpcnMoc2V0KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KHNldC5zaXplKTtcblxuICAgIHNldC5mb3JFYWNoKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXN1bHRbKytpbmRleF0gPSBbdmFsdWUsIHZhbHVlXTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5pbmRleE9mYCB3aGljaCBwZXJmb3JtcyBzdHJpY3QgZXF1YWxpdHlcbiAgICogY29tcGFyaXNvbnMgb2YgdmFsdWVzLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb21JbmRleCBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlLCBlbHNlIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBzdHJpY3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gZnJvbUluZGV4IC0gMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIGlmIChhcnJheVtpbmRleF0gPT09IHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIC0xO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5sYXN0SW5kZXhPZmAgd2hpY2ggcGVyZm9ybXMgc3RyaWN0IGVxdWFsaXR5XG4gICAqIGNvbXBhcmlzb25zIG9mIHZhbHVlcywgaS5lLiBgPT09YC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXggVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaWN0TGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBmcm9tSW5kZXggKyAxO1xuICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbmRleDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBudW1iZXIgb2Ygc3ltYm9scyBpbiBgc3RyaW5nYC5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN0cmluZyBzaXplLlxuICAgKi9cbiAgZnVuY3Rpb24gc3RyaW5nU2l6ZShzdHJpbmcpIHtcbiAgICByZXR1cm4gaGFzVW5pY29kZShzdHJpbmcpXG4gICAgICA/IHVuaWNvZGVTaXplKHN0cmluZylcbiAgICAgIDogYXNjaWlTaXplKHN0cmluZyk7XG4gIH1cblxuICAvKipcbiAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gYXJyYXkuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICovXG4gIGZ1bmN0aW9uIHN0cmluZ1RvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIGhhc1VuaWNvZGUoc3RyaW5nKVxuICAgICAgPyB1bmljb2RlVG9BcnJheShzdHJpbmcpXG4gICAgICA6IGFzY2lpVG9BcnJheShzdHJpbmcpO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udHJpbWAgYW5kIGBfLnRyaW1FbmRgIHRvIGdldCB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2VcbiAgICogY2hhcmFjdGVyIG9mIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGxhc3Qgbm9uLXdoaXRlc3BhY2UgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdHJpbW1lZEVuZEluZGV4KHN0cmluZykge1xuICAgIHZhciBpbmRleCA9IHN0cmluZy5sZW5ndGg7XG5cbiAgICB3aGlsZSAoaW5kZXgtLSAmJiByZVdoaXRlc3BhY2UudGVzdChzdHJpbmcuY2hhckF0KGluZGV4KSkpIHt9XG4gICAgcmV0dXJuIGluZGV4O1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8udW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2hyIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byB1bmVzY2FwZS5cbiAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5lc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIHZhciB1bmVzY2FwZUh0bWxDaGFyID0gYmFzZVByb3BlcnR5T2YoaHRtbFVuZXNjYXBlcyk7XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIHNpemUgb2YgYSBVbmljb2RlIGBzdHJpbmdgLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gc3RyaW5nIFRoZSBzdHJpbmcgaW5zcGVjdC5cbiAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgc3RyaW5nIHNpemUuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlU2l6ZShzdHJpbmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gcmVVbmljb2RlLmxhc3RJbmRleCA9IDA7XG4gICAgd2hpbGUgKHJlVW5pY29kZS50ZXN0KHN0cmluZykpIHtcbiAgICAgICsrcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIGEgVW5pY29kZSBgc3RyaW5nYCB0byBhbiBhcnJheS5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY29udmVydGVkIGFycmF5LlxuICAgKi9cbiAgZnVuY3Rpb24gdW5pY29kZVRvQXJyYXkoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGUpIHx8IFtdO1xuICB9XG5cbiAgLyoqXG4gICAqIFNwbGl0cyBhIFVuaWNvZGUgYHN0cmluZ2AgaW50byBhbiBhcnJheSBvZiBpdHMgd29yZHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBUaGUgc3RyaW5nIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd29yZHMgb2YgYHN0cmluZ2AuXG4gICAqL1xuICBmdW5jdGlvbiB1bmljb2RlV29yZHMoc3RyaW5nKSB7XG4gICAgcmV0dXJuIHN0cmluZy5tYXRjaChyZVVuaWNvZGVXb3JkKSB8fCBbXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgcHJpc3RpbmUgYGxvZGFzaGAgZnVuY3Rpb24gdXNpbmcgdGhlIGBjb250ZXh0YCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHNpbmNlIDEuMS4wXG4gICAqIEBjYXRlZ29yeSBVdGlsXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbY29udGV4dD1yb290XSBUaGUgY29udGV4dCBvYmplY3QuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBhIG5ldyBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taXhpbih7ICdmb28nOiBfLmNvbnN0YW50KCdmb28nKSB9KTtcbiAgICpcbiAgICogdmFyIGxvZGFzaCA9IF8ucnVuSW5Db250ZXh0KCk7XG4gICAqIGxvZGFzaC5taXhpbih7ICdiYXInOiBsb2Rhc2guY29uc3RhbnQoJ2JhcicpIH0pO1xuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXy5mb28pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqIF8uaXNGdW5jdGlvbihfLmJhcik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIGxvZGFzaC5pc0Z1bmN0aW9uKGxvZGFzaC5mb28pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKiBsb2Rhc2guaXNGdW5jdGlvbihsb2Rhc2guYmFyKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiAvLyBDcmVhdGUgYSBzdXBlZC11cCBgZGVmZXJgIGluIE5vZGUuanMuXG4gICAqIHZhciBkZWZlciA9IF8ucnVuSW5Db250ZXh0KHsgJ3NldFRpbWVvdXQnOiBzZXRJbW1lZGlhdGUgfSkuZGVmZXI7XG4gICAqL1xuICB2YXIgcnVuSW5Db250ZXh0ID0gKGZ1bmN0aW9uIHJ1bkluQ29udGV4dChjb250ZXh0KSB7XG4gICAgY29udGV4dCA9IGNvbnRleHQgPT0gbnVsbCA/IHJvb3QgOiBfLmRlZmF1bHRzKHJvb3QuT2JqZWN0KCksIGNvbnRleHQsIF8ucGljayhyb290LCBjb250ZXh0UHJvcHMpKTtcblxuICAgIC8qKiBCdWlsdC1pbiBjb25zdHJ1Y3RvciByZWZlcmVuY2VzLiAqL1xuICAgIHZhciBBcnJheSA9IGNvbnRleHQuQXJyYXksXG4gICAgICAgIERhdGUgPSBjb250ZXh0LkRhdGUsXG4gICAgICAgIEVycm9yID0gY29udGV4dC5FcnJvcixcbiAgICAgICAgRnVuY3Rpb24gPSBjb250ZXh0LkZ1bmN0aW9uLFxuICAgICAgICBNYXRoID0gY29udGV4dC5NYXRoLFxuICAgICAgICBPYmplY3QgPSBjb250ZXh0Lk9iamVjdCxcbiAgICAgICAgUmVnRXhwID0gY29udGV4dC5SZWdFeHAsXG4gICAgICAgIFN0cmluZyA9IGNvbnRleHQuU3RyaW5nLFxuICAgICAgICBUeXBlRXJyb3IgPSBjb250ZXh0LlR5cGVFcnJvcjtcblxuICAgIC8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cbiAgICB2YXIgYXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSxcbiAgICAgICAgZnVuY1Byb3RvID0gRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgICAgICBvYmplY3RQcm90byA9IE9iamVjdC5wcm90b3R5cGU7XG5cbiAgICAvKiogVXNlZCB0byBkZXRlY3Qgb3ZlcnJlYWNoaW5nIGNvcmUtanMgc2hpbXMuICovXG4gICAgdmFyIGNvcmVKc0RhdGEgPSBjb250ZXh0WydfX2NvcmUtanNfc2hhcmVkX18nXTtcblxuICAgIC8qKiBVc2VkIHRvIHJlc29sdmUgdGhlIGRlY29tcGlsZWQgc291cmNlIG9mIGZ1bmN0aW9ucy4gKi9cbiAgICB2YXIgZnVuY1RvU3RyaW5nID0gZnVuY1Byb3RvLnRvU3RyaW5nO1xuXG4gICAgLyoqIFVzZWQgdG8gY2hlY2sgb2JqZWN0cyBmb3Igb3duIHByb3BlcnRpZXMuICovXG4gICAgdmFyIGhhc093blByb3BlcnR5ID0gb2JqZWN0UHJvdG8uaGFzT3duUHJvcGVydHk7XG5cbiAgICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzLiAqL1xuICAgIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gICAgLyoqIFVzZWQgdG8gZGV0ZWN0IG1ldGhvZHMgbWFzcXVlcmFkaW5nIGFzIG5hdGl2ZS4gKi9cbiAgICB2YXIgbWFza1NyY0tleSA9IChmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1aWQgPSAvW14uXSskLy5leGVjKGNvcmVKc0RhdGEgJiYgY29yZUpzRGF0YS5rZXlzICYmIGNvcmVKc0RhdGEua2V5cy5JRV9QUk9UTyB8fCAnJyk7XG4gICAgICByZXR1cm4gdWlkID8gKCdTeW1ib2woc3JjKV8xLicgKyB1aWQpIDogJyc7XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcbiAgICAgKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcbiAgICAgKiBvZiB2YWx1ZXMuXG4gICAgICovXG4gICAgdmFyIG5hdGl2ZU9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XG5cbiAgICAvKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXG4gICAgdmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xuXG4gICAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgXy5ub0NvbmZsaWN0YC4gKi9cbiAgICB2YXIgb2xkRGFzaCA9IHJvb3QuXztcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBpZiBhIG1ldGhvZCBpcyBuYXRpdmUuICovXG4gICAgdmFyIHJlSXNOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKGhhc093blByb3BlcnR5KS5yZXBsYWNlKHJlUmVnRXhwQ2hhciwgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvaGFzT3duUHJvcGVydHl8KGZ1bmN0aW9uKS4qPyg/PVxcXFxcXCgpfCBmb3IgLis/KD89XFxcXFxcXSkvZywgJyQxLio/JykgKyAnJCdcbiAgICApO1xuXG4gICAgLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXG4gICAgdmFyIEJ1ZmZlciA9IG1vZHVsZUV4cG9ydHMgPyBjb250ZXh0LkJ1ZmZlciA6IHVuZGVmaW5lZCxcbiAgICAgICAgU3ltYm9sID0gY29udGV4dC5TeW1ib2wsXG4gICAgICAgIFVpbnQ4QXJyYXkgPSBjb250ZXh0LlVpbnQ4QXJyYXksXG4gICAgICAgIGFsbG9jVW5zYWZlID0gQnVmZmVyID8gQnVmZmVyLmFsbG9jVW5zYWZlIDogdW5kZWZpbmVkLFxuICAgICAgICBnZXRQcm90b3R5cGUgPSBvdmVyQXJnKE9iamVjdC5nZXRQcm90b3R5cGVPZiwgT2JqZWN0KSxcbiAgICAgICAgb2JqZWN0Q3JlYXRlID0gT2JqZWN0LmNyZWF0ZSxcbiAgICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RQcm90by5wcm9wZXJ0eUlzRW51bWVyYWJsZSxcbiAgICAgICAgc3BsaWNlID0gYXJyYXlQcm90by5zcGxpY2UsXG4gICAgICAgIHNwcmVhZGFibGVTeW1ib2wgPSBTeW1ib2wgPyBTeW1ib2wuaXNDb25jYXRTcHJlYWRhYmxlIDogdW5kZWZpbmVkLFxuICAgICAgICBzeW1JdGVyYXRvciA9IFN5bWJvbCA/IFN5bWJvbC5pdGVyYXRvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltVG9TdHJpbmdUYWcgPSBTeW1ib2wgPyBTeW1ib2wudG9TdHJpbmdUYWcgOiB1bmRlZmluZWQ7XG5cbiAgICB2YXIgZGVmaW5lUHJvcGVydHkgPSAoZnVuY3Rpb24oKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgZnVuYyA9IGdldE5hdGl2ZShPYmplY3QsICdkZWZpbmVQcm9wZXJ0eScpO1xuICAgICAgICBmdW5jKHt9LCAnJywge30pO1xuICAgICAgICByZXR1cm4gZnVuYztcbiAgICAgIH0gY2F0Y2ggKGUpIHt9XG4gICAgfSgpKTtcblxuICAgIC8qKiBNb2NrZWQgYnVpbHQtaW5zLiAqL1xuICAgIHZhciBjdHhDbGVhclRpbWVvdXQgPSBjb250ZXh0LmNsZWFyVGltZW91dCAhPT0gcm9vdC5jbGVhclRpbWVvdXQgJiYgY29udGV4dC5jbGVhclRpbWVvdXQsXG4gICAgICAgIGN0eE5vdyA9IERhdGUgJiYgRGF0ZS5ub3cgIT09IHJvb3QuRGF0ZS5ub3cgJiYgRGF0ZS5ub3csXG4gICAgICAgIGN0eFNldFRpbWVvdXQgPSBjb250ZXh0LnNldFRpbWVvdXQgIT09IHJvb3Quc2V0VGltZW91dCAmJiBjb250ZXh0LnNldFRpbWVvdXQ7XG5cbiAgICAvKiBCdWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcyBmb3IgdGhvc2Ugd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMuICovXG4gICAgdmFyIG5hdGl2ZUNlaWwgPSBNYXRoLmNlaWwsXG4gICAgICAgIG5hdGl2ZUZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgICAgbmF0aXZlR2V0U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsXG4gICAgICAgIG5hdGl2ZUlzQnVmZmVyID0gQnVmZmVyID8gQnVmZmVyLmlzQnVmZmVyIDogdW5kZWZpbmVkLFxuICAgICAgICBuYXRpdmVJc0Zpbml0ZSA9IGNvbnRleHQuaXNGaW5pdGUsXG4gICAgICAgIG5hdGl2ZUpvaW4gPSBhcnJheVByb3RvLmpvaW4sXG4gICAgICAgIG5hdGl2ZUtleXMgPSBvdmVyQXJnKE9iamVjdC5rZXlzLCBPYmplY3QpLFxuICAgICAgICBuYXRpdmVNYXggPSBNYXRoLm1heCxcbiAgICAgICAgbmF0aXZlTWluID0gTWF0aC5taW4sXG4gICAgICAgIG5hdGl2ZU5vdyA9IERhdGUubm93LFxuICAgICAgICBuYXRpdmVQYXJzZUludCA9IGNvbnRleHQucGFyc2VJbnQsXG4gICAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tLFxuICAgICAgICBuYXRpdmVSZXZlcnNlID0gYXJyYXlQcm90by5yZXZlcnNlO1xuXG4gICAgLyogQnVpbHQtaW4gbWV0aG9kIHJlZmVyZW5jZXMgdGhhdCBhcmUgdmVyaWZpZWQgdG8gYmUgbmF0aXZlLiAqL1xuICAgIHZhciBEYXRhVmlldyA9IGdldE5hdGl2ZShjb250ZXh0LCAnRGF0YVZpZXcnKSxcbiAgICAgICAgTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdNYXAnKSxcbiAgICAgICAgUHJvbWlzZSA9IGdldE5hdGl2ZShjb250ZXh0LCAnUHJvbWlzZScpLFxuICAgICAgICBTZXQgPSBnZXROYXRpdmUoY29udGV4dCwgJ1NldCcpLFxuICAgICAgICBXZWFrTWFwID0gZ2V0TmF0aXZlKGNvbnRleHQsICdXZWFrTWFwJyksXG4gICAgICAgIG5hdGl2ZUNyZWF0ZSA9IGdldE5hdGl2ZShPYmplY3QsICdjcmVhdGUnKTtcblxuICAgIC8qKiBVc2VkIHRvIHN0b3JlIGZ1bmN0aW9uIG1ldGFkYXRhLiAqL1xuICAgIHZhciBtZXRhTWFwID0gV2Vha01hcCAmJiBuZXcgV2Vha01hcDtcblxuICAgIC8qKiBVc2VkIHRvIGxvb2t1cCB1bm1pbmlmaWVkIGZ1bmN0aW9uIG5hbWVzLiAqL1xuICAgIHZhciByZWFsTmFtZXMgPSB7fTtcblxuICAgIC8qKiBVc2VkIHRvIGRldGVjdCBtYXBzLCBzZXRzLCBhbmQgd2Vha21hcHMuICovXG4gICAgdmFyIGRhdGFWaWV3Q3RvclN0cmluZyA9IHRvU291cmNlKERhdGFWaWV3KSxcbiAgICAgICAgbWFwQ3RvclN0cmluZyA9IHRvU291cmNlKE1hcCksXG4gICAgICAgIHByb21pc2VDdG9yU3RyaW5nID0gdG9Tb3VyY2UoUHJvbWlzZSksXG4gICAgICAgIHNldEN0b3JTdHJpbmcgPSB0b1NvdXJjZShTZXQpLFxuICAgICAgICB3ZWFrTWFwQ3RvclN0cmluZyA9IHRvU291cmNlKFdlYWtNYXApO1xuXG4gICAgLyoqIFVzZWQgdG8gY29udmVydCBzeW1ib2xzIHRvIHByaW1pdGl2ZXMgYW5kIHN0cmluZ3MuICovXG4gICAgdmFyIHN5bWJvbFByb3RvID0gU3ltYm9sID8gU3ltYm9sLnByb3RvdHlwZSA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVmFsdWVPZiA9IHN5bWJvbFByb3RvID8gc3ltYm9sUHJvdG8udmFsdWVPZiA6IHVuZGVmaW5lZCxcbiAgICAgICAgc3ltYm9sVG9TdHJpbmcgPSBzeW1ib2xQcm90byA/IHN5bWJvbFByb3RvLnRvU3RyaW5nIDogdW5kZWZpbmVkO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBsb2Rhc2hgIG9iamVjdCB3aGljaCB3cmFwcyBgdmFsdWVgIHRvIGVuYWJsZSBpbXBsaWNpdCBtZXRob2RcbiAgICAgKiBjaGFpbiBzZXF1ZW5jZXMuIE1ldGhvZHMgdGhhdCBvcGVyYXRlIG9uIGFuZCByZXR1cm4gYXJyYXlzLCBjb2xsZWN0aW9ucyxcbiAgICAgKiBhbmQgZnVuY3Rpb25zIGNhbiBiZSBjaGFpbmVkIHRvZ2V0aGVyLiBNZXRob2RzIHRoYXQgcmV0cmlldmUgYSBzaW5nbGUgdmFsdWVcbiAgICAgKiBvciBtYXkgcmV0dXJuIGEgcHJpbWl0aXZlIHZhbHVlIHdpbGwgYXV0b21hdGljYWxseSBlbmQgdGhlIGNoYWluIHNlcXVlbmNlXG4gICAgICogYW5kIHJldHVybiB0aGUgdW53cmFwcGVkIHZhbHVlLiBPdGhlcndpc2UsIHRoZSB2YWx1ZSBtdXN0IGJlIHVud3JhcHBlZFxuICAgICAqIHdpdGggYF8jdmFsdWVgLlxuICAgICAqXG4gICAgICogRXhwbGljaXQgY2hhaW4gc2VxdWVuY2VzLCB3aGljaCBtdXN0IGJlIHVud3JhcHBlZCB3aXRoIGBfI3ZhbHVlYCwgbWF5IGJlXG4gICAgICogZW5hYmxlZCB1c2luZyBgXy5jaGFpbmAuXG4gICAgICpcbiAgICAgKiBUaGUgZXhlY3V0aW9uIG9mIGNoYWluZWQgbWV0aG9kcyBpcyBsYXp5LCB0aGF0IGlzLCBpdCdzIGRlZmVycmVkIHVudGlsXG4gICAgICogYF8jdmFsdWVgIGlzIGltcGxpY2l0bHkgb3IgZXhwbGljaXRseSBjYWxsZWQuXG4gICAgICpcbiAgICAgKiBMYXp5IGV2YWx1YXRpb24gYWxsb3dzIHNldmVyYWwgbWV0aG9kcyB0byBzdXBwb3J0IHNob3J0Y3V0IGZ1c2lvbi5cbiAgICAgKiBTaG9ydGN1dCBmdXNpb24gaXMgYW4gb3B0aW1pemF0aW9uIHRvIG1lcmdlIGl0ZXJhdGVlIGNhbGxzOyB0aGlzIGF2b2lkc1xuICAgICAqIHRoZSBjcmVhdGlvbiBvZiBpbnRlcm1lZGlhdGUgYXJyYXlzIGFuZCBjYW4gZ3JlYXRseSByZWR1Y2UgdGhlIG51bWJlciBvZlxuICAgICAqIGl0ZXJhdGVlIGV4ZWN1dGlvbnMuIFNlY3Rpb25zIG9mIGEgY2hhaW4gc2VxdWVuY2UgcXVhbGlmeSBmb3Igc2hvcnRjdXRcbiAgICAgKiBmdXNpb24gaWYgdGhlIHNlY3Rpb24gaXMgYXBwbGllZCB0byBhbiBhcnJheSBhbmQgaXRlcmF0ZWVzIGFjY2VwdCBvbmx5XG4gICAgICogb25lIGFyZ3VtZW50LiBUaGUgaGV1cmlzdGljIGZvciB3aGV0aGVyIGEgc2VjdGlvbiBxdWFsaWZpZXMgZm9yIHNob3J0Y3V0XG4gICAgICogZnVzaW9uIGlzIHN1YmplY3QgdG8gY2hhbmdlLlxuICAgICAqXG4gICAgICogQ2hhaW5pbmcgaXMgc3VwcG9ydGVkIGluIGN1c3RvbSBidWlsZHMgYXMgbG9uZyBhcyB0aGUgYF8jdmFsdWVgIG1ldGhvZCBpc1xuICAgICAqIGRpcmVjdGx5IG9yIGluZGlyZWN0bHkgaW5jbHVkZWQgaW4gdGhlIGJ1aWxkLlxuICAgICAqXG4gICAgICogSW4gYWRkaXRpb24gdG8gbG9kYXNoIG1ldGhvZHMsIHdyYXBwZXJzIGhhdmUgYEFycmF5YCBhbmQgYFN0cmluZ2AgbWV0aG9kcy5cbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIGBBcnJheWAgbWV0aG9kcyBhcmU6XG4gICAgICogYGNvbmNhdGAsIGBqb2luYCwgYHBvcGAsIGBwdXNoYCwgYHNoaWZ0YCwgYHNvcnRgLCBgc3BsaWNlYCwgYW5kIGB1bnNoaWZ0YFxuICAgICAqXG4gICAgICogVGhlIHdyYXBwZXIgYFN0cmluZ2AgbWV0aG9kcyBhcmU6XG4gICAgICogYHJlcGxhY2VgIGFuZCBgc3BsaXRgXG4gICAgICpcbiAgICAgKiBUaGUgd3JhcHBlciBtZXRob2RzIHRoYXQgc3VwcG9ydCBzaG9ydGN1dCBmdXNpb24gYXJlOlxuICAgICAqIGBhdGAsIGBjb21wYWN0YCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCwgYGRyb3BXaGlsZWAsIGBmaWx0ZXJgLCBgZmluZGAsXG4gICAgICogYGZpbmRMYXN0YCwgYGhlYWRgLCBgaW5pdGlhbGAsIGBsYXN0YCwgYG1hcGAsIGByZWplY3RgLCBgcmV2ZXJzZWAsIGBzbGljZWAsXG4gICAgICogYHRhaWxgLCBgdGFrZWAsIGB0YWtlUmlnaHRgLCBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYW5kIGB0b0FycmF5YFxuICAgICAqXG4gICAgICogVGhlIGNoYWluYWJsZSB3cmFwcGVyIG1ldGhvZHMgYXJlOlxuICAgICAqIGBhZnRlcmAsIGBhcnlgLCBgYXNzaWduYCwgYGFzc2lnbkluYCwgYGFzc2lnbkluV2l0aGAsIGBhc3NpZ25XaXRoYCwgYGF0YCxcbiAgICAgKiBgYmVmb3JlYCwgYGJpbmRgLCBgYmluZEFsbGAsIGBiaW5kS2V5YCwgYGNhc3RBcnJheWAsIGBjaGFpbmAsIGBjaHVua2AsXG4gICAgICogYGNvbW1pdGAsIGBjb21wYWN0YCwgYGNvbmNhdGAsIGBjb25mb3Jtc2AsIGBjb25zdGFudGAsIGBjb3VudEJ5YCwgYGNyZWF0ZWAsXG4gICAgICogYGN1cnJ5YCwgYGRlYm91bmNlYCwgYGRlZmF1bHRzYCwgYGRlZmF1bHRzRGVlcGAsIGBkZWZlcmAsIGBkZWxheWAsXG4gICAgICogYGRpZmZlcmVuY2VgLCBgZGlmZmVyZW5jZUJ5YCwgYGRpZmZlcmVuY2VXaXRoYCwgYGRyb3BgLCBgZHJvcFJpZ2h0YCxcbiAgICAgKiBgZHJvcFJpZ2h0V2hpbGVgLCBgZHJvcFdoaWxlYCwgYGV4dGVuZGAsIGBleHRlbmRXaXRoYCwgYGZpbGxgLCBgZmlsdGVyYCxcbiAgICAgKiBgZmxhdE1hcGAsIGBmbGF0TWFwRGVlcGAsIGBmbGF0TWFwRGVwdGhgLCBgZmxhdHRlbmAsIGBmbGF0dGVuRGVlcGAsXG4gICAgICogYGZsYXR0ZW5EZXB0aGAsIGBmbGlwYCwgYGZsb3dgLCBgZmxvd1JpZ2h0YCwgYGZyb21QYWlyc2AsIGBmdW5jdGlvbnNgLFxuICAgICAqIGBmdW5jdGlvbnNJbmAsIGBncm91cEJ5YCwgYGluaXRpYWxgLCBgaW50ZXJzZWN0aW9uYCwgYGludGVyc2VjdGlvbkJ5YCxcbiAgICAgKiBgaW50ZXJzZWN0aW9uV2l0aGAsIGBpbnZlcnRgLCBgaW52ZXJ0QnlgLCBgaW52b2tlTWFwYCwgYGl0ZXJhdGVlYCwgYGtleUJ5YCxcbiAgICAgKiBga2V5c2AsIGBrZXlzSW5gLCBgbWFwYCwgYG1hcEtleXNgLCBgbWFwVmFsdWVzYCwgYG1hdGNoZXNgLCBgbWF0Y2hlc1Byb3BlcnR5YCxcbiAgICAgKiBgbWVtb2l6ZWAsIGBtZXJnZWAsIGBtZXJnZVdpdGhgLCBgbWV0aG9kYCwgYG1ldGhvZE9mYCwgYG1peGluYCwgYG5lZ2F0ZWAsXG4gICAgICogYG50aEFyZ2AsIGBvbWl0YCwgYG9taXRCeWAsIGBvbmNlYCwgYG9yZGVyQnlgLCBgb3ZlcmAsIGBvdmVyQXJnc2AsXG4gICAgICogYG92ZXJFdmVyeWAsIGBvdmVyU29tZWAsIGBwYXJ0aWFsYCwgYHBhcnRpYWxSaWdodGAsIGBwYXJ0aXRpb25gLCBgcGlja2AsXG4gICAgICogYHBpY2tCeWAsIGBwbGFudGAsIGBwcm9wZXJ0eWAsIGBwcm9wZXJ0eU9mYCwgYHB1bGxgLCBgcHVsbEFsbGAsIGBwdWxsQWxsQnlgLFxuICAgICAqIGBwdWxsQWxsV2l0aGAsIGBwdWxsQXRgLCBgcHVzaGAsIGByYW5nZWAsIGByYW5nZVJpZ2h0YCwgYHJlYXJnYCwgYHJlamVjdGAsXG4gICAgICogYHJlbW92ZWAsIGByZXN0YCwgYHJldmVyc2VgLCBgc2FtcGxlU2l6ZWAsIGBzZXRgLCBgc2V0V2l0aGAsIGBzaHVmZmxlYCxcbiAgICAgKiBgc2xpY2VgLCBgc29ydGAsIGBzb3J0QnlgLCBgc3BsaWNlYCwgYHNwcmVhZGAsIGB0YWlsYCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGFrZVJpZ2h0V2hpbGVgLCBgdGFrZVdoaWxlYCwgYHRhcGAsIGB0aHJvdHRsZWAsIGB0aHJ1YCwgYHRvQXJyYXlgLFxuICAgICAqIGB0b1BhaXJzYCwgYHRvUGFpcnNJbmAsIGB0b1BhdGhgLCBgdG9QbGFpbk9iamVjdGAsIGB0cmFuc2Zvcm1gLCBgdW5hcnlgLFxuICAgICAqIGB1bmlvbmAsIGB1bmlvbkJ5YCwgYHVuaW9uV2l0aGAsIGB1bmlxYCwgYHVuaXFCeWAsIGB1bmlxV2l0aGAsIGB1bnNldGAsXG4gICAgICogYHVuc2hpZnRgLCBgdW56aXBgLCBgdW56aXBXaXRoYCwgYHVwZGF0ZWAsIGB1cGRhdGVXaXRoYCwgYHZhbHVlc2AsXG4gICAgICogYHZhbHVlc0luYCwgYHdpdGhvdXRgLCBgd3JhcGAsIGB4b3JgLCBgeG9yQnlgLCBgeG9yV2l0aGAsIGB6aXBgLFxuICAgICAqIGB6aXBPYmplY3RgLCBgemlwT2JqZWN0RGVlcGAsIGFuZCBgemlwV2l0aGBcbiAgICAgKlxuICAgICAqIFRoZSB3cmFwcGVyIG1ldGhvZHMgdGhhdCBhcmUgKipub3QqKiBjaGFpbmFibGUgYnkgZGVmYXVsdCBhcmU6XG4gICAgICogYGFkZGAsIGBhdHRlbXB0YCwgYGNhbWVsQ2FzZWAsIGBjYXBpdGFsaXplYCwgYGNlaWxgLCBgY2xhbXBgLCBgY2xvbmVgLFxuICAgICAqIGBjbG9uZURlZXBgLCBgY2xvbmVEZWVwV2l0aGAsIGBjbG9uZVdpdGhgLCBgY29uZm9ybXNUb2AsIGBkZWJ1cnJgLFxuICAgICAqIGBkZWZhdWx0VG9gLCBgZGl2aWRlYCwgYGVhY2hgLCBgZWFjaFJpZ2h0YCwgYGVuZHNXaXRoYCwgYGVxYCwgYGVzY2FwZWAsXG4gICAgICogYGVzY2FwZVJlZ0V4cGAsIGBldmVyeWAsIGBmaW5kYCwgYGZpbmRJbmRleGAsIGBmaW5kS2V5YCwgYGZpbmRMYXN0YCxcbiAgICAgKiBgZmluZExhc3RJbmRleGAsIGBmaW5kTGFzdEtleWAsIGBmaXJzdGAsIGBmbG9vcmAsIGBmb3JFYWNoYCwgYGZvckVhY2hSaWdodGAsXG4gICAgICogYGZvckluYCwgYGZvckluUmlnaHRgLCBgZm9yT3duYCwgYGZvck93blJpZ2h0YCwgYGdldGAsIGBndGAsIGBndGVgLCBgaGFzYCxcbiAgICAgKiBgaGFzSW5gLCBgaGVhZGAsIGBpZGVudGl0eWAsIGBpbmNsdWRlc2AsIGBpbmRleE9mYCwgYGluUmFuZ2VgLCBgaW52b2tlYCxcbiAgICAgKiBgaXNBcmd1bWVudHNgLCBgaXNBcnJheWAsIGBpc0FycmF5QnVmZmVyYCwgYGlzQXJyYXlMaWtlYCwgYGlzQXJyYXlMaWtlT2JqZWN0YCxcbiAgICAgKiBgaXNCb29sZWFuYCwgYGlzQnVmZmVyYCwgYGlzRGF0ZWAsIGBpc0VsZW1lbnRgLCBgaXNFbXB0eWAsIGBpc0VxdWFsYCxcbiAgICAgKiBgaXNFcXVhbFdpdGhgLCBgaXNFcnJvcmAsIGBpc0Zpbml0ZWAsIGBpc0Z1bmN0aW9uYCwgYGlzSW50ZWdlcmAsIGBpc0xlbmd0aGAsXG4gICAgICogYGlzTWFwYCwgYGlzTWF0Y2hgLCBgaXNNYXRjaFdpdGhgLCBgaXNOYU5gLCBgaXNOYXRpdmVgLCBgaXNOaWxgLCBgaXNOdWxsYCxcbiAgICAgKiBgaXNOdW1iZXJgLCBgaXNPYmplY3RgLCBgaXNPYmplY3RMaWtlYCwgYGlzUGxhaW5PYmplY3RgLCBgaXNSZWdFeHBgLFxuICAgICAqIGBpc1NhZmVJbnRlZ2VyYCwgYGlzU2V0YCwgYGlzU3RyaW5nYCwgYGlzVW5kZWZpbmVkYCwgYGlzVHlwZWRBcnJheWAsXG4gICAgICogYGlzV2Vha01hcGAsIGBpc1dlYWtTZXRgLCBgam9pbmAsIGBrZWJhYkNhc2VgLCBgbGFzdGAsIGBsYXN0SW5kZXhPZmAsXG4gICAgICogYGxvd2VyQ2FzZWAsIGBsb3dlckZpcnN0YCwgYGx0YCwgYGx0ZWAsIGBtYXhgLCBgbWF4QnlgLCBgbWVhbmAsIGBtZWFuQnlgLFxuICAgICAqIGBtaW5gLCBgbWluQnlgLCBgbXVsdGlwbHlgLCBgbm9Db25mbGljdGAsIGBub29wYCwgYG5vd2AsIGBudGhgLCBgcGFkYCxcbiAgICAgKiBgcGFkRW5kYCwgYHBhZFN0YXJ0YCwgYHBhcnNlSW50YCwgYHBvcGAsIGByYW5kb21gLCBgcmVkdWNlYCwgYHJlZHVjZVJpZ2h0YCxcbiAgICAgKiBgcmVwZWF0YCwgYHJlc3VsdGAsIGByb3VuZGAsIGBydW5JbkNvbnRleHRgLCBgc2FtcGxlYCwgYHNoaWZ0YCwgYHNpemVgLFxuICAgICAqIGBzbmFrZUNhc2VgLCBgc29tZWAsIGBzb3J0ZWRJbmRleGAsIGBzb3J0ZWRJbmRleEJ5YCwgYHNvcnRlZExhc3RJbmRleGAsXG4gICAgICogYHNvcnRlZExhc3RJbmRleEJ5YCwgYHN0YXJ0Q2FzZWAsIGBzdGFydHNXaXRoYCwgYHN0dWJBcnJheWAsIGBzdHViRmFsc2VgLFxuICAgICAqIGBzdHViT2JqZWN0YCwgYHN0dWJTdHJpbmdgLCBgc3R1YlRydWVgLCBgc3VidHJhY3RgLCBgc3VtYCwgYHN1bUJ5YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdGltZXNgLCBgdG9GaW5pdGVgLCBgdG9JbnRlZ2VyYCwgYHRvSlNPTmAsIGB0b0xlbmd0aGAsXG4gICAgICogYHRvTG93ZXJgLCBgdG9OdW1iZXJgLCBgdG9TYWZlSW50ZWdlcmAsIGB0b1N0cmluZ2AsIGB0b1VwcGVyYCwgYHRyaW1gLFxuICAgICAqIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGB0cnVuY2F0ZWAsIGB1bmVzY2FwZWAsIGB1bmlxdWVJZGAsIGB1cHBlckNhc2VgLFxuICAgICAqIGB1cHBlckZpcnN0YCwgYHZhbHVlYCwgYW5kIGB3b3Jkc2BcbiAgICAgKlxuICAgICAqIEBuYW1lIF9cbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBzcXVhcmUobikge1xuICAgICAqICAgcmV0dXJuIG4gKiBuO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMiwgM10pO1xuICAgICAqXG4gICAgICogLy8gUmV0dXJucyBhbiB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogd3JhcHBlZC5yZWR1Y2UoXy5hZGQpO1xuICAgICAqIC8vID0+IDZcbiAgICAgKlxuICAgICAqIC8vIFJldHVybnMgYSB3cmFwcGVkIHZhbHVlLlxuICAgICAqIHZhciBzcXVhcmVzID0gd3JhcHBlZC5tYXAoc3F1YXJlKTtcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShzcXVhcmVzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KHNxdWFyZXMudmFsdWUoKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxvZGFzaCh2YWx1ZSkge1xuICAgICAgaWYgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgIWlzQXJyYXkodmFsdWUpICYmICEodmFsdWUgaW5zdGFuY2VvZiBMYXp5V3JhcHBlcikpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTG9kYXNoV3JhcHBlcikge1xuICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ19fd3JhcHBlZF9fJykpIHtcbiAgICAgICAgICByZXR1cm4gd3JhcHBlckNsb25lKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jcmVhdGVgIHdpdGhvdXQgc3VwcG9ydCBmb3IgYXNzaWduaW5nXG4gICAgICogcHJvcGVydGllcyB0byB0aGUgY3JlYXRlZCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90byBUaGUgb2JqZWN0IHRvIGluaGVyaXQgZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqL1xuICAgIHZhciBiYXNlQ3JlYXRlID0gKGZ1bmN0aW9uKCkge1xuICAgICAgZnVuY3Rpb24gb2JqZWN0KCkge31cbiAgICAgIHJldHVybiBmdW5jdGlvbihwcm90bykge1xuICAgICAgICBpZiAoIWlzT2JqZWN0KHByb3RvKSkge1xuICAgICAgICAgIHJldHVybiB7fTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob2JqZWN0Q3JlYXRlKSB7XG4gICAgICAgICAgcmV0dXJuIG9iamVjdENyZWF0ZShwcm90byk7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHByb3RvO1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IG9iamVjdDtcbiAgICAgICAgb2JqZWN0LnByb3RvdHlwZSA9IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSgpKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBmdW5jdGlvbiB3aG9zZSBwcm90b3R5cGUgY2hhaW4gc2VxdWVuY2Ugd3JhcHBlcnMgaW5oZXJpdCBmcm9tLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlTG9kYXNoKCkge1xuICAgICAgLy8gTm8gb3BlcmF0aW9uIHBlcmZvcm1lZC5cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBjb25zdHJ1Y3RvciBmb3IgY3JlYXRpbmcgYGxvZGFzaGAgd3JhcHBlciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NoYWluQWxsXSBFbmFibGUgZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBMb2Rhc2hXcmFwcGVyKHZhbHVlLCBjaGFpbkFsbCkge1xuICAgICAgdGhpcy5fX3dyYXBwZWRfXyA9IHZhbHVlO1xuICAgICAgdGhpcy5fX2FjdGlvbnNfXyA9IFtdO1xuICAgICAgdGhpcy5fX2NoYWluX18gPSAhIWNoYWluQWxsO1xuICAgICAgdGhpcy5fX2luZGV4X18gPSAwO1xuICAgICAgdGhpcy5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEJ5IGRlZmF1bHQsIHRoZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzIHVzZWQgYnkgbG9kYXNoIGFyZSBsaWtlIHRob3NlIGluXG4gICAgICogZW1iZWRkZWQgUnVieSAoRVJCKSBhcyB3ZWxsIGFzIEVTMjAxNSB0ZW1wbGF0ZSBzdHJpbmdzLiBDaGFuZ2UgdGhlXG4gICAgICogZm9sbG93aW5nIHRlbXBsYXRlIHNldHRpbmdzIHRvIHVzZSBhbHRlcm5hdGl2ZSBkZWxpbWl0ZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKi9cbiAgICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGJlIEhUTUwtZXNjYXBlZC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnZXNjYXBlJzogcmVFc2NhcGUsXG5cbiAgICAgIC8qKlxuICAgICAgICogVXNlZCB0byBkZXRlY3QgY29kZSB0byBiZSBldmFsdWF0ZWQuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge1JlZ0V4cH1cbiAgICAgICAqL1xuICAgICAgJ2V2YWx1YXRlJzogcmVFdmFsdWF0ZSxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGRldGVjdCBgZGF0YWAgcHJvcGVydHkgdmFsdWVzIHRvIGluamVjdC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7UmVnRXhwfVxuICAgICAgICovXG4gICAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgICAvKipcbiAgICAgICAqIFVzZWQgdG8gcmVmZXJlbmNlIHRoZSBkYXRhIG9iamVjdCBpbiB0aGUgdGVtcGxhdGUgdGV4dC5cbiAgICAgICAqXG4gICAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICAgKiBAdHlwZSB7c3RyaW5nfVxuICAgICAgICovXG4gICAgICAndmFyaWFibGUnOiAnJyxcblxuICAgICAgLyoqXG4gICAgICAgKiBVc2VkIHRvIGltcG9ydCB2YXJpYWJsZXMgaW50byB0aGUgY29tcGlsZWQgdGVtcGxhdGUuXG4gICAgICAgKlxuICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5nc1xuICAgICAgICogQHR5cGUge09iamVjdH1cbiAgICAgICAqL1xuICAgICAgJ2ltcG9ydHMnOiB7XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIEEgcmVmZXJlbmNlIHRvIHRoZSBgbG9kYXNoYCBmdW5jdGlvbi5cbiAgICAgICAgICpcbiAgICAgICAgICogQG1lbWJlck9mIF8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXG4gICAgICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgICAgICovXG4gICAgICAgICdfJzogbG9kYXNoXG4gICAgICB9XG4gICAgfTtcblxuICAgIC8vIEVuc3VyZSB3cmFwcGVycyBhcmUgaW5zdGFuY2VzIG9mIGBiYXNlTG9kYXNoYC5cbiAgICBsb2Rhc2gucHJvdG90eXBlID0gYmFzZUxvZGFzaC5wcm90b3R5cGU7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IGxvZGFzaDtcblxuICAgIExvZGFzaFdyYXBwZXIucHJvdG90eXBlID0gYmFzZUNyZWF0ZShiYXNlTG9kYXNoLnByb3RvdHlwZSk7XG4gICAgTG9kYXNoV3JhcHBlci5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBMb2Rhc2hXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGxhenkgd3JhcHBlciBvYmplY3Qgd2hpY2ggd3JhcHMgYHZhbHVlYCB0byBlbmFibGUgbGF6eSBldmFsdWF0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExhenlXcmFwcGVyKHZhbHVlKSB7XG4gICAgICB0aGlzLl9fd3JhcHBlZF9fID0gdmFsdWU7XG4gICAgICB0aGlzLl9fYWN0aW9uc19fID0gW107XG4gICAgICB0aGlzLl9fZGlyX18gPSAxO1xuICAgICAgdGhpcy5fX2ZpbHRlcmVkX18gPSBmYWxzZTtcbiAgICAgIHRoaXMuX19pdGVyYXRlZXNfXyA9IFtdO1xuICAgICAgdGhpcy5fX3Rha2VDb3VudF9fID0gTUFYX0FSUkFZX0xFTkdUSDtcbiAgICAgIHRoaXMuX192aWV3c19fID0gW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBsYXp5IHdyYXBwZXIgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBjbG9uZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5Q2xvbmUoKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMuX193cmFwcGVkX18pO1xuICAgICAgcmVzdWx0Ll9fYWN0aW9uc19fID0gY29weUFycmF5KHRoaXMuX19hY3Rpb25zX18pO1xuICAgICAgcmVzdWx0Ll9fZGlyX18gPSB0aGlzLl9fZGlyX187XG4gICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdGhpcy5fX2ZpbHRlcmVkX187XG4gICAgICByZXN1bHQuX19pdGVyYXRlZXNfXyA9IGNvcHlBcnJheSh0aGlzLl9faXRlcmF0ZWVzX18pO1xuICAgICAgcmVzdWx0Ll9fdGFrZUNvdW50X18gPSB0aGlzLl9fdGFrZUNvdW50X187XG4gICAgICByZXN1bHQuX192aWV3c19fID0gY29weUFycmF5KHRoaXMuX192aWV3c19fKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmV2ZXJzZXMgdGhlIGRpcmVjdGlvbiBvZiBsYXp5IGl0ZXJhdGlvbi5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyByZXZlcnNlZCBgTGF6eVdyYXBwZXJgIG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsYXp5UmV2ZXJzZSgpIHtcbiAgICAgIGlmICh0aGlzLl9fZmlsdGVyZWRfXykge1xuICAgICAgICB2YXIgcmVzdWx0ID0gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICByZXN1bHQuX19kaXJfXyA9IC0xO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdCA9IHRoaXMuY2xvbmUoKTtcbiAgICAgICAgcmVzdWx0Ll9fZGlyX18gKj0gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHRoZSB1bndyYXBwZWQgdmFsdWUgZnJvbSBpdHMgbGF6eSB3cmFwcGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSB2YWx1ZVxuICAgICAqIEBtZW1iZXJPZiBMYXp5V3JhcHBlclxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bndyYXBwZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGF6eVZhbHVlKCkge1xuICAgICAgdmFyIGFycmF5ID0gdGhpcy5fX3dyYXBwZWRfXy52YWx1ZSgpLFxuICAgICAgICAgIGRpciA9IHRoaXMuX19kaXJfXyxcbiAgICAgICAgICBpc0FyciA9IGlzQXJyYXkoYXJyYXkpLFxuICAgICAgICAgIGlzUmlnaHQgPSBkaXIgPCAwLFxuICAgICAgICAgIGFyckxlbmd0aCA9IGlzQXJyID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgICB2aWV3ID0gZ2V0VmlldygwLCBhcnJMZW5ndGgsIHRoaXMuX192aWV3c19fKSxcbiAgICAgICAgICBzdGFydCA9IHZpZXcuc3RhcnQsXG4gICAgICAgICAgZW5kID0gdmlldy5lbmQsXG4gICAgICAgICAgbGVuZ3RoID0gZW5kIC0gc3RhcnQsXG4gICAgICAgICAgaW5kZXggPSBpc1JpZ2h0ID8gZW5kIDogKHN0YXJ0IC0gMSksXG4gICAgICAgICAgaXRlcmF0ZWVzID0gdGhpcy5fX2l0ZXJhdGVlc19fLFxuICAgICAgICAgIGl0ZXJMZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICB0YWtlQ291bnQgPSBuYXRpdmVNaW4obGVuZ3RoLCB0aGlzLl9fdGFrZUNvdW50X18pO1xuXG4gICAgICBpZiAoIWlzQXJyIHx8ICghaXNSaWdodCAmJiBhcnJMZW5ndGggPT0gbGVuZ3RoICYmIHRha2VDb3VudCA9PSBsZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKGFycmF5LCB0aGlzLl9fYWN0aW9uc19fKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBbXTtcblxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAobGVuZ3RoLS0gJiYgcmVzSW5kZXggPCB0YWtlQ291bnQpIHtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuXG4gICAgICAgIHZhciBpdGVySW5kZXggPSAtMSxcbiAgICAgICAgICAgIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAgIHdoaWxlICgrK2l0ZXJJbmRleCA8IGl0ZXJMZW5ndGgpIHtcbiAgICAgICAgICB2YXIgZGF0YSA9IGl0ZXJhdGVlc1tpdGVySW5kZXhdLFxuICAgICAgICAgICAgICBpdGVyYXRlZSA9IGRhdGEuaXRlcmF0ZWUsXG4gICAgICAgICAgICAgIHR5cGUgPSBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9NQVBfRkxBRykge1xuICAgICAgICAgICAgdmFsdWUgPSBjb21wdXRlZDtcbiAgICAgICAgICB9IGVsc2UgaWYgKCFjb21wdXRlZCkge1xuICAgICAgICAgICAgaWYgKHR5cGUgPT0gTEFaWV9GSUxURVJfRkxBRykge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGJyZWFrIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXN1bHRbcmVzSW5kZXgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLy8gRW5zdXJlIGBMYXp5V3JhcHBlcmAgaXMgYW4gaW5zdGFuY2Ugb2YgYGJhc2VMb2Rhc2hgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZSA9IGJhc2VDcmVhdGUoYmFzZUxvZGFzaC5wcm90b3R5cGUpO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IExhenlXcmFwcGVyO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGhhc2ggb2JqZWN0LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAY29uc3RydWN0b3JcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbZW50cmllc10gVGhlIGtleS12YWx1ZSBwYWlycyB0byBjYWNoZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBIYXNoKGVudHJpZXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGVudHJpZXMgPT0gbnVsbCA/IDAgOiBlbnRyaWVzLmxlbmd0aDtcblxuICAgICAgdGhpcy5jbGVhcigpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gZW50cmllc1tpbmRleF07XG4gICAgICAgIHRoaXMuc2V0KGVudHJ5WzBdLCBlbnRyeVsxXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBhbGwga2V5LXZhbHVlIGVudHJpZXMgZnJvbSB0aGUgaGFzaC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgSGFzaFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hDbGVhcigpIHtcbiAgICAgIHRoaXMuX19kYXRhX18gPSBuYXRpdmVDcmVhdGUgPyBuYXRpdmVDcmVhdGUobnVsbCkgOiB7fTtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBga2V5YCBhbmQgaXRzIHZhbHVlIGZyb20gdGhlIGhhc2guXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtPYmplY3R9IGhhc2ggVGhlIGhhc2ggdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoYXNoRGVsZXRlKGtleSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHRoaXMuaGFzKGtleSkgJiYgZGVsZXRlIHRoaXMuX19kYXRhX19ba2V5XTtcbiAgICAgIHRoaXMuc2l6ZSAtPSByZXN1bHQgPyAxIDogMDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgaGFzaCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGVudHJ5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICBpZiAobmF0aXZlQ3JlYXRlKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBkYXRhW2tleV07XG4gICAgICAgIHJldHVybiByZXN1bHQgPT09IEhBU0hfVU5ERUZJTkVEID8gdW5kZWZpbmVkIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KSA/IGRhdGFba2V5XSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBoYXNoIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBlbnRyeSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW4gZW50cnkgZm9yIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc2hIYXMoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICByZXR1cm4gbmF0aXZlQ3JlYXRlID8gKGRhdGFba2V5XSAhPT0gdW5kZWZpbmVkKSA6IGhhc093blByb3BlcnR5LmNhbGwoZGF0YSwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBoYXNoIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBIYXNoXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGhhc2ggaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzaFNldChrZXksIHZhbHVlKSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX187XG4gICAgICB0aGlzLnNpemUgKz0gdGhpcy5oYXMoa2V5KSA/IDAgOiAxO1xuICAgICAgZGF0YVtrZXldID0gKG5hdGl2ZUNyZWF0ZSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkKSA/IEhBU0hfVU5ERUZJTkVEIDogdmFsdWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgSGFzaGAuXG4gICAgSGFzaC5wcm90b3R5cGUuY2xlYXIgPSBoYXNoQ2xlYXI7XG4gICAgSGFzaC5wcm90b3R5cGVbJ2RlbGV0ZSddID0gaGFzaERlbGV0ZTtcbiAgICBIYXNoLnByb3RvdHlwZS5nZXQgPSBoYXNoR2V0O1xuICAgIEhhc2gucHJvdG90eXBlLmhhcyA9IGhhc2hIYXM7XG4gICAgSGFzaC5wcm90b3R5cGUuc2V0ID0gaGFzaFNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gbGlzdCBjYWNoZSBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtlbnRyaWVzXSBUaGUga2V5LXZhbHVlIHBhaXJzIHRvIGNhY2hlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIExpc3RDYWNoZShlbnRyaWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBlbnRyaWVzID09IG51bGwgPyAwIDogZW50cmllcy5sZW5ndGg7XG5cbiAgICAgIHRoaXMuY2xlYXIoKTtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IGVudHJpZXNbaW5kZXhdO1xuICAgICAgICB0aGlzLnNldChlbnRyeVswXSwgZW50cnlbMV0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGtleS12YWx1ZSBlbnRyaWVzIGZyb20gdGhlIGxpc3QgY2FjaGUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxpc3RDYWNoZUNsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IFtdO1xuICAgICAgdGhpcy5zaXplID0gMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGBrZXlgIGFuZCBpdHMgdmFsdWUgZnJvbSB0aGUgbGlzdCBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVEZWxldGUoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gZGF0YS5sZW5ndGggLSAxO1xuICAgICAgaWYgKGluZGV4ID09IGxhc3RJbmRleCkge1xuICAgICAgICBkYXRhLnBvcCgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3BsaWNlLmNhbGwoZGF0YSwgaW5kZXgsIDEpO1xuICAgICAgfVxuICAgICAgLS10aGlzLnNpemU7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBsaXN0IGNhY2hlIHZhbHVlIGZvciBga2V5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZ2V0XG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVHZXQoa2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IHRoaXMuX19kYXRhX18sXG4gICAgICAgICAgaW5kZXggPSBhc3NvY0luZGV4T2YoZGF0YSwga2V5KTtcblxuICAgICAgcmV0dXJuIGluZGV4IDwgMCA/IHVuZGVmaW5lZCA6IGRhdGFbaW5kZXhdWzFdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBhIGxpc3QgY2FjaGUgdmFsdWUgZm9yIGBrZXlgIGV4aXN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIExpc3RDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gYXNzb2NJbmRleE9mKHRoaXMuX19kYXRhX18sIGtleSkgPiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBsaXN0IGNhY2hlIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBMaXN0Q2FjaGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbGlzdCBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBsaXN0Q2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIGluZGV4ID0gYXNzb2NJbmRleE9mKGRhdGEsIGtleSk7XG5cbiAgICAgIGlmIChpbmRleCA8IDApIHtcbiAgICAgICAgKyt0aGlzLnNpemU7XG4gICAgICAgIGRhdGEucHVzaChba2V5LCB2YWx1ZV0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YVtpbmRleF1bMV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBMaXN0Q2FjaGVgLlxuICAgIExpc3RDYWNoZS5wcm90b3R5cGUuY2xlYXIgPSBsaXN0Q2FjaGVDbGVhcjtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlWydkZWxldGUnXSA9IGxpc3RDYWNoZURlbGV0ZTtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmdldCA9IGxpc3RDYWNoZUdldDtcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLmhhcyA9IGxpc3RDYWNoZUhhcztcbiAgICBMaXN0Q2FjaGUucHJvdG90eXBlLnNldCA9IGxpc3RDYWNoZVNldDtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBtYXAgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gTWFwQ2FjaGUoZW50cmllcykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gZW50cmllcyA9PSBudWxsID8gMCA6IGVudHJpZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLmNsZWFyKCk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZW50cnkgPSBlbnRyaWVzW2luZGV4XTtcbiAgICAgICAgdGhpcy5zZXQoZW50cnlbMF0sIGVudHJ5WzFdKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGNsZWFyXG4gICAgICogQG1lbWJlck9mIE1hcENhY2hlXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVDbGVhcigpIHtcbiAgICAgIHRoaXMuc2l6ZSA9IDA7XG4gICAgICB0aGlzLl9fZGF0YV9fID0ge1xuICAgICAgICAnaGFzaCc6IG5ldyBIYXNoLFxuICAgICAgICAnbWFwJzogbmV3IChNYXAgfHwgTGlzdENhY2hlKSxcbiAgICAgICAgJ3N0cmluZyc6IG5ldyBIYXNoXG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBtYXAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGRlbGV0ZVxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgZW50cnkgd2FzIHJlbW92ZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZURlbGV0ZShrZXkpIHtcbiAgICAgIHZhciByZXN1bHQgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSlbJ2RlbGV0ZSddKGtleSk7XG4gICAgICB0aGlzLnNpemUgLT0gcmVzdWx0ID8gMSA6IDA7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG1hcCB2YWx1ZSBmb3IgYGtleWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGdldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBlbnRyeSB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUdldChrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuZ2V0KGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGEgbWFwIHZhbHVlIGZvciBga2V5YCBleGlzdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIGhhc1xuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgZW50cnkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFuIGVudHJ5IGZvciBga2V5YCBleGlzdHMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBDYWNoZUhhcyhrZXkpIHtcbiAgICAgIHJldHVybiBnZXRNYXBEYXRhKHRoaXMsIGtleSkuaGFzKGtleSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgbWFwIGBrZXlgIHRvIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBuYW1lIHNldFxuICAgICAqIEBtZW1iZXJPZiBNYXBDYWNoZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBtYXAgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWFwQ2FjaGVTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSBnZXRNYXBEYXRhKHRoaXMsIGtleSksXG4gICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgZGF0YS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgICB0aGlzLnNpemUgKz0gZGF0YS5zaXplID09IHNpemUgPyAwIDogMTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBNYXBDYWNoZWAuXG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmNsZWFyID0gbWFwQ2FjaGVDbGVhcjtcbiAgICBNYXBDYWNoZS5wcm90b3R5cGVbJ2RlbGV0ZSddID0gbWFwQ2FjaGVEZWxldGU7XG4gICAgTWFwQ2FjaGUucHJvdG90eXBlLmdldCA9IG1hcENhY2hlR2V0O1xuICAgIE1hcENhY2hlLnByb3RvdHlwZS5oYXMgPSBtYXBDYWNoZUhhcztcbiAgICBNYXBDYWNoZS5wcm90b3R5cGUuc2V0ID0gbWFwQ2FjaGVTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIHVuaXF1ZSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBjb25zdHJ1Y3RvclxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU2V0Q2FjaGUodmFsdWVzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSB2YWx1ZXMgPT0gbnVsbCA/IDAgOiB2YWx1ZXMubGVuZ3RoO1xuXG4gICAgICB0aGlzLl9fZGF0YV9fID0gbmV3IE1hcENhY2hlO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdGhpcy5hZGQodmFsdWVzW2luZGV4XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkcyBgdmFsdWVgIHRvIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgYWRkXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQGFsaWFzIHB1c2hcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjYWNoZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjYWNoZSBpbnN0YW5jZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzZXRDYWNoZUFkZCh2YWx1ZSkge1xuICAgICAgdGhpcy5fX2RhdGFfXy5zZXQodmFsdWUsIEhBU0hfVU5ERUZJTkVEKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGluIHRoZSBhcnJheSBjYWNoZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgaGFzXG4gICAgICogQG1lbWJlck9mIFNldENhY2hlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2V0Q2FjaGVIYXModmFsdWUpIHtcbiAgICAgIHJldHVybiB0aGlzLl9fZGF0YV9fLmhhcyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYFNldENhY2hlYC5cbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuYWRkID0gU2V0Q2FjaGUucHJvdG90eXBlLnB1c2ggPSBzZXRDYWNoZUFkZDtcbiAgICBTZXRDYWNoZS5wcm90b3R5cGUuaGFzID0gc2V0Q2FjaGVIYXM7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc3RhY2sgY2FjaGUgb2JqZWN0IHRvIHN0b3JlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQGNvbnN0cnVjdG9yXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2VudHJpZXNdIFRoZSBrZXktdmFsdWUgcGFpcnMgdG8gY2FjaGUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gU3RhY2soZW50cmllcykge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fID0gbmV3IExpc3RDYWNoZShlbnRyaWVzKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBrZXktdmFsdWUgZW50cmllcyBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgY2xlYXJcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdGFja0NsZWFyKCkge1xuICAgICAgdGhpcy5fX2RhdGFfXyA9IG5ldyBMaXN0Q2FjaGU7XG4gICAgICB0aGlzLnNpemUgPSAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYGtleWAgYW5kIGl0cyB2YWx1ZSBmcm9tIHRoZSBzdGFjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQG5hbWUgZGVsZXRlXG4gICAgICogQG1lbWJlck9mIFN0YWNrXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSB2YWx1ZSB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBlbnRyeSB3YXMgcmVtb3ZlZCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0YWNrRGVsZXRlKGtleSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fLFxuICAgICAgICAgIHJlc3VsdCA9IGRhdGFbJ2RlbGV0ZSddKGtleSk7XG5cbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgc3RhY2sgdmFsdWUgZm9yIGBrZXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBnZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZW50cnkgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tHZXQoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5nZXQoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYSBzdGFjayB2YWx1ZSBmb3IgYGtleWAgZXhpc3RzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBoYXNcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIGVudHJ5IHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbiBlbnRyeSBmb3IgYGtleWAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tIYXMoa2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy5fX2RhdGFfXy5oYXMoa2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBzdGFjayBga2V5YCB0byBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAbmFtZSBzZXRcbiAgICAgKiBAbWVtYmVyT2YgU3RhY2tcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZXQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgc3RhY2sgY2FjaGUgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhY2tTZXQoa2V5LCB2YWx1ZSkge1xuICAgICAgdmFyIGRhdGEgPSB0aGlzLl9fZGF0YV9fO1xuICAgICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBMaXN0Q2FjaGUpIHtcbiAgICAgICAgdmFyIHBhaXJzID0gZGF0YS5fX2RhdGFfXztcbiAgICAgICAgaWYgKCFNYXAgfHwgKHBhaXJzLmxlbmd0aCA8IExBUkdFX0FSUkFZX1NJWkUgLSAxKSkge1xuICAgICAgICAgIHBhaXJzLnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICAgICAgICB0aGlzLnNpemUgPSArK2RhdGEuc2l6ZTtcbiAgICAgICAgICByZXR1cm4gdGhpcztcbiAgICAgICAgfVxuICAgICAgICBkYXRhID0gdGhpcy5fX2RhdGFfXyA9IG5ldyBNYXBDYWNoZShwYWlycyk7XG4gICAgICB9XG4gICAgICBkYXRhLnNldChrZXksIHZhbHVlKTtcbiAgICAgIHRoaXMuc2l6ZSA9IGRhdGEuc2l6ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8vIEFkZCBtZXRob2RzIHRvIGBTdGFja2AuXG4gICAgU3RhY2sucHJvdG90eXBlLmNsZWFyID0gc3RhY2tDbGVhcjtcbiAgICBTdGFjay5wcm90b3R5cGVbJ2RlbGV0ZSddID0gc3RhY2tEZWxldGU7XG4gICAgU3RhY2sucHJvdG90eXBlLmdldCA9IHN0YWNrR2V0O1xuICAgIFN0YWNrLnByb3RvdHlwZS5oYXMgPSBzdGFja0hhcztcbiAgICBTdGFjay5wcm90b3R5cGUuc2V0ID0gc3RhY2tTZXQ7XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIHRoZSBhcnJheS1saWtlIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gaW5oZXJpdGVkIFNwZWNpZnkgcmV0dXJuaW5nIGluaGVyaXRlZCBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5TGlrZUtleXModmFsdWUsIGluaGVyaXRlZCkge1xuICAgICAgdmFyIGlzQXJyID0gaXNBcnJheSh2YWx1ZSksXG4gICAgICAgICAgaXNBcmcgPSAhaXNBcnIgJiYgaXNBcmd1bWVudHModmFsdWUpLFxuICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiAhaXNBcmcgJiYgaXNCdWZmZXIodmFsdWUpLFxuICAgICAgICAgIGlzVHlwZSA9ICFpc0FyciAmJiAhaXNBcmcgJiYgIWlzQnVmZiAmJiBpc1R5cGVkQXJyYXkodmFsdWUpLFxuICAgICAgICAgIHNraXBJbmRleGVzID0gaXNBcnIgfHwgaXNBcmcgfHwgaXNCdWZmIHx8IGlzVHlwZSxcbiAgICAgICAgICByZXN1bHQgPSBza2lwSW5kZXhlcyA/IGJhc2VUaW1lcyh2YWx1ZS5sZW5ndGgsIFN0cmluZykgOiBbXSxcbiAgICAgICAgICBsZW5ndGggPSByZXN1bHQubGVuZ3RoO1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIHtcbiAgICAgICAgaWYgKChpbmhlcml0ZWQgfHwgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkgJiZcbiAgICAgICAgICAgICEoc2tpcEluZGV4ZXMgJiYgKFxuICAgICAgICAgICAgICAgLy8gU2FmYXJpIDkgaGFzIGVudW1lcmFibGUgYGFyZ3VtZW50cy5sZW5ndGhgIGluIHN0cmljdCBtb2RlLlxuICAgICAgICAgICAgICAga2V5ID09ICdsZW5ndGgnIHx8XG4gICAgICAgICAgICAgICAvLyBOb2RlLmpzIDAuMTAgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gYnVmZmVycy5cbiAgICAgICAgICAgICAgIChpc0J1ZmYgJiYgKGtleSA9PSAnb2Zmc2V0JyB8fCBrZXkgPT0gJ3BhcmVudCcpKSB8fFxuICAgICAgICAgICAgICAgLy8gUGhhbnRvbUpTIDIgaGFzIGVudW1lcmFibGUgbm9uLWluZGV4IHByb3BlcnRpZXMgb24gdHlwZWQgYXJyYXlzLlxuICAgICAgICAgICAgICAgKGlzVHlwZSAmJiAoa2V5ID09ICdidWZmZXInIHx8IGtleSA9PSAnYnl0ZUxlbmd0aCcgfHwga2V5ID09ICdieXRlT2Zmc2V0JykpIHx8XG4gICAgICAgICAgICAgICAvLyBTa2lwIGluZGV4IHByb3BlcnRpZXMuXG4gICAgICAgICAgICAgICBpc0luZGV4KGtleSwgbGVuZ3RoKVxuICAgICAgICAgICAgKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVgIGZvciBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGFycmF5W2Jhc2VSYW5kb20oMCwgbGVuZ3RoIC0gMSldIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgXy5zYW1wbGVTaXplYCBmb3IgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2FtcGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFycmF5U2FtcGxlU2l6ZShhcnJheSwgbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGNvcHlBcnJheShhcnJheSksIGJhc2VDbGFtcChuLCAwLCBhcnJheS5sZW5ndGgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgZm9yIGFycmF5cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYXJyYXlTaHVmZmxlKGFycmF5KSB7XG4gICAgICByZXR1cm4gc2h1ZmZsZVNlbGYoY29weUFycmF5KGFycmF5KSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBhc3NpZ25WYWx1ZWAgZXhjZXB0IHRoYXQgaXQgZG9lc24ndCBhc3NpZ25cbiAgICAgKiBgdW5kZWZpbmVkYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBhc3NpZ24uXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gICAgICBpZiAoKHZhbHVlICE9PSB1bmRlZmluZWQgJiYgIWVxKG9iamVjdFtrZXldLCB2YWx1ZSkpIHx8XG4gICAgICAgICAgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQXNzaWducyBgdmFsdWVgIHRvIGBrZXlgIG9mIGBvYmplY3RgIGlmIHRoZSBleGlzdGluZyB2YWx1ZSBpcyBub3QgZXF1aXZhbGVudFxuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgcHJvcGVydHkgdG8gYXNzaWduLlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgdmFsdWUpIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldO1xuICAgICAgaWYgKCEoaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkgJiYgZXEob2JqVmFsdWUsIHZhbHVlKSkgfHxcbiAgICAgICAgICAodmFsdWUgPT09IHVuZGVmaW5lZCAmJiAhKGtleSBpbiBvYmplY3QpKSkge1xuICAgICAgICBiYXNlQXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgYGtleWAgaXMgZm91bmQgaW4gYGFycmF5YCBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0ga2V5IFRoZSBrZXkgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGFzc29jSW5kZXhPZihhcnJheSwga2V5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmIChlcShhcnJheVtsZW5ndGhdWzBdLCBrZXkpKSB7XG4gICAgICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFnZ3JlZ2F0ZXMgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIG9uIGBhY2N1bXVsYXRvcmAgd2l0aCBrZXlzIHRyYW5zZm9ybWVkXG4gICAgICogYnkgYGl0ZXJhdGVlYCBhbmQgdmFsdWVzIHNldCBieSBgc2V0dGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0ga2V5cy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gYWNjdW11bGF0b3IgVGhlIGluaXRpYWwgYWdncmVnYXRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFnZ3JlZ2F0b3IoY29sbGVjdGlvbiwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaXRlcmF0ZWUodmFsdWUpLCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmFzc2lnbmAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzXG4gICAgICogb3IgYGN1c3RvbWl6ZXJgIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQXNzaWduKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uYXNzaWduSW5gIHdpdGhvdXQgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc291cmNlc1xuICAgICAqIG9yIGBjdXN0b21pemVyYCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnbkluKG9iamVjdCwgc291cmNlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYXNzaWduVmFsdWVgIGFuZCBgYXNzaWduTWVyZ2VWYWx1ZWAgd2l0aG91dFxuICAgICAqIHZhbHVlIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBhc3NpZ24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJyAmJiBkZWZpbmVQcm9wZXJ0eSkge1xuICAgICAgICBkZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuICAgICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAgICdlbnVtZXJhYmxlJzogdHJ1ZSxcbiAgICAgICAgICAndmFsdWUnOiB2YWx1ZSxcbiAgICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5hdGAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IHBhdGhzIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcGlja2VkIGVsZW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VBdChvYmplY3QsIHBhdGhzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRocy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKSxcbiAgICAgICAgICBza2lwID0gb2JqZWN0ID09IG51bGw7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBza2lwID8gdW5kZWZpbmVkIDogZ2V0KG9iamVjdCwgcGF0aHNbaW5kZXhdKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uY2xhbXBgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDbGFtcChudW1iZXIsIGxvd2VyLCB1cHBlcikge1xuICAgICAgaWYgKG51bWJlciA9PT0gbnVtYmVyKSB7XG4gICAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbnVtYmVyID0gbnVtYmVyIDw9IHVwcGVyID8gbnVtYmVyIDogdXBwZXI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvd2VyICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBudW1iZXIgPSBudW1iZXIgPj0gbG93ZXIgPyBudW1iZXIgOiBsb3dlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bWJlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jbG9uZWAgYW5kIGBfLmNsb25lRGVlcGAgd2hpY2ggdHJhY2tzXG4gICAgICogdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIERlZXAgY2xvbmVcbiAgICAgKiAgMiAtIEZsYXR0ZW4gaW5oZXJpdGVkIHByb3BlcnRpZXNcbiAgICAgKiAgNCAtIENsb25lIHN5bWJvbHNcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjbG9uaW5nLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBba2V5XSBUaGUga2V5IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBwYXJlbnQgb2JqZWN0IG9mIGB2YWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGFuZCB0aGVpciBjbG9uZSBjb3VudGVycGFydHMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ2xvbmUodmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGtleSwgb2JqZWN0LCBzdGFjaykge1xuICAgICAgdmFyIHJlc3VsdCxcbiAgICAgICAgICBpc0RlZXAgPSBiaXRtYXNrICYgQ0xPTkVfREVFUF9GTEFHLFxuICAgICAgICAgIGlzRmxhdCA9IGJpdG1hc2sgJiBDTE9ORV9GTEFUX0ZMQUcsXG4gICAgICAgICAgaXNGdWxsID0gYml0bWFzayAmIENMT05FX1NZTUJPTFNfRkxBRztcblxuICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgcmVzdWx0ID0gb2JqZWN0ID8gY3VzdG9taXplcih2YWx1ZSwga2V5LCBvYmplY3QsIHN0YWNrKSA6IGN1c3RvbWl6ZXIodmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3VsdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoIWlzT2JqZWN0KHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHZhbHVlKTtcbiAgICAgIGlmIChpc0Fycikge1xuICAgICAgICByZXN1bHQgPSBpbml0Q2xvbmVBcnJheSh2YWx1ZSk7XG4gICAgICAgIGlmICghaXNEZWVwKSB7XG4gICAgICAgICAgcmV0dXJuIGNvcHlBcnJheSh2YWx1ZSwgcmVzdWx0KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyh2YWx1ZSksXG4gICAgICAgICAgICBpc0Z1bmMgPSB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnO1xuXG4gICAgICAgIGlmIChpc0J1ZmZlcih2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gY2xvbmVCdWZmZXIodmFsdWUsIGlzRGVlcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBvYmplY3RUYWcgfHwgdGFnID09IGFyZ3NUYWcgfHwgKGlzRnVuYyAmJiAhb2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdCA9IChpc0ZsYXQgfHwgaXNGdW5jKSA/IHt9IDogaW5pdENsb25lT2JqZWN0KHZhbHVlKTtcbiAgICAgICAgICBpZiAoIWlzRGVlcCkge1xuICAgICAgICAgICAgcmV0dXJuIGlzRmxhdFxuICAgICAgICAgICAgICA/IGNvcHlTeW1ib2xzSW4odmFsdWUsIGJhc2VBc3NpZ25JbihyZXN1bHQsIHZhbHVlKSlcbiAgICAgICAgICAgICAgOiBjb3B5U3ltYm9scyh2YWx1ZSwgYmFzZUFzc2lnbihyZXN1bHQsIHZhbHVlKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICghY2xvbmVhYmxlVGFnc1t0YWddKSB7XG4gICAgICAgICAgICByZXR1cm4gb2JqZWN0ID8gdmFsdWUgOiB7fTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ID0gaW5pdENsb25lQnlUYWcodmFsdWUsIHRhZywgaXNEZWVwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gQ2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBpdHMgY29ycmVzcG9uZGluZyBjbG9uZS5cbiAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICB2YXIgc3RhY2tlZCA9IHN0YWNrLmdldCh2YWx1ZSk7XG4gICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gc3RhY2tlZDtcbiAgICAgIH1cbiAgICAgIHN0YWNrLnNldCh2YWx1ZSwgcmVzdWx0KTtcblxuICAgICAgaWYgKGlzU2V0KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlKSB7XG4gICAgICAgICAgcmVzdWx0LmFkZChiYXNlQ2xvbmUoc3ViVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN1YlZhbHVlLCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKGlzTWFwKHZhbHVlKSkge1xuICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uKHN1YlZhbHVlLCBrZXkpIHtcbiAgICAgICAgICByZXN1bHQuc2V0KGtleSwgYmFzZUNsb25lKHN1YlZhbHVlLCBiaXRtYXNrLCBjdXN0b21pemVyLCBrZXksIHZhbHVlLCBzdGFjaykpO1xuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdmFyIGtleXNGdW5jID0gaXNGdWxsXG4gICAgICAgID8gKGlzRmxhdCA/IGdldEFsbEtleXNJbiA6IGdldEFsbEtleXMpXG4gICAgICAgIDogKGlzRmxhdCA/IGtleXNJbiA6IGtleXMpO1xuXG4gICAgICB2YXIgcHJvcHMgPSBpc0FyciA/IHVuZGVmaW5lZCA6IGtleXNGdW5jKHZhbHVlKTtcbiAgICAgIGFycmF5RWFjaChwcm9wcyB8fCB2YWx1ZSwgZnVuY3Rpb24oc3ViVmFsdWUsIGtleSkge1xuICAgICAgICBpZiAocHJvcHMpIHtcbiAgICAgICAgICBrZXkgPSBzdWJWYWx1ZTtcbiAgICAgICAgICBzdWJWYWx1ZSA9IHZhbHVlW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgYXNzaWduVmFsdWUocmVzdWx0LCBrZXksIGJhc2VDbG9uZShzdWJWYWx1ZSwgYml0bWFzaywgY3VzdG9taXplciwga2V5LCB2YWx1ZSwgc3RhY2spKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5jb25mb3Jtc2Agd2hpY2ggZG9lc24ndCBjbG9uZSBgc291cmNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VDb25mb3Jtcyhzb3VyY2UpIHtcbiAgICAgIHZhciBwcm9wcyA9IGtleXMoc291cmNlKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VDb25mb3Jtc1RvKG9iamVjdCwgc291cmNlLCBwcm9wcyk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmNvbmZvcm1zVG9gIHdoaWNoIGFjY2VwdHMgYHByb3BzYCB0byBjaGVjay5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHByZWRpY2F0ZXMgdG8gY29uZm9ybSB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgY29uZm9ybXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwgcHJvcHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuICFsZW5ndGg7XG4gICAgICB9XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIga2V5ID0gcHJvcHNbbGVuZ3RoXSxcbiAgICAgICAgICAgIHByZWRpY2F0ZSA9IHNvdXJjZVtrZXldLFxuICAgICAgICAgICAgdmFsdWUgPSBvYmplY3Rba2V5XTtcblxuICAgICAgICBpZiAoKHZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkgfHwgIXByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmRlbGF5YCBhbmQgYF8uZGVmZXJgIHdoaWNoIGFjY2VwdHMgYGFyZ3NgXG4gICAgICogdG8gcHJvdmlkZSB0byBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5IGludm9jYXRpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJncyBUaGUgYXJndW1lbnRzIHRvIHByb3ZpZGUgdG8gYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ8T2JqZWN0fSBSZXR1cm5zIHRoZSB0aW1lciBpZCBvciB0aW1lb3V0IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRGVsYXkoZnVuYywgd2FpdCwgYXJncykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgd2FpdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLmRpZmZlcmVuY2VgIHdpdGhvdXQgc3VwcG9ydFxuICAgICAqIGZvciBleGNsdWRpbmcgbXVsdGlwbGUgYXJyYXlzIG9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlcyxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICAgIHZhbHVlc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGg7XG5cbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBpZiAoaXRlcmF0ZWUpIHtcbiAgICAgICAgdmFsdWVzID0gYXJyYXlNYXAodmFsdWVzLCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgIH1cbiAgICAgIGlmIChjb21wYXJhdG9yKSB7XG4gICAgICAgIGluY2x1ZGVzID0gYXJyYXlJbmNsdWRlc1dpdGg7XG4gICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIGlmICh2YWx1ZXMubGVuZ3RoID49IExBUkdFX0FSUkFZX1NJWkUpIHtcbiAgICAgICAgaW5jbHVkZXMgPSBjYWNoZUhhcztcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgdmFsdWVzID0gbmV3IFNldENhY2hlKHZhbHVlcyk7XG4gICAgICB9XG4gICAgICBvdXRlcjpcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPT0gbnVsbCA/IHZhbHVlIDogaXRlcmF0ZWUodmFsdWUpO1xuXG4gICAgICAgIHZhbHVlID0gKGNvbXBhcmF0b3IgfHwgdmFsdWUgIT09IDApID8gdmFsdWUgOiAwO1xuICAgICAgICBpZiAoaXNDb21tb24gJiYgY29tcHV0ZWQgPT09IGNvbXB1dGVkKSB7XG4gICAgICAgICAgdmFyIHZhbHVlc0luZGV4ID0gdmFsdWVzTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICh2YWx1ZXNJbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAodmFsdWVzW3ZhbHVlc0luZGV4XSA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICAgICAgY29udGludWUgb3V0ZXI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghaW5jbHVkZXModmFsdWVzLCBjb21wdXRlZCwgY29tcGFyYXRvcikpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yRWFjaGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2ggPSBjcmVhdGVCYXNlRWFjaChiYXNlRm9yT3duKTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvckVhY2hSaWdodGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUVhY2hSaWdodCA9IGNyZWF0ZUJhc2VFYWNoKGJhc2VGb3JPd25SaWdodCwgdHJ1ZSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5ldmVyeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcHJlZGljYXRlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFdmVyeShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJlc3VsdCA9ICEhcHJlZGljYXRlKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgbWV0aG9kcyBsaWtlIGBfLm1heGAgYW5kIGBfLm1pbmAgd2hpY2ggYWNjZXB0cyBhXG4gICAgICogYGNvbXBhcmF0b3JgIHRvIGRldGVybWluZSB0aGUgZXh0cmVtdW0gdmFsdWUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjb21wYXJhdG9yIFRoZSBjb21wYXJhdG9yIHVzZWQgdG8gY29tcGFyZSB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGV4dHJlbXVtIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VFeHRyZW11bShhcnJheSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY3VycmVudCA9IGl0ZXJhdGVlKHZhbHVlKTtcblxuICAgICAgICBpZiAoY3VycmVudCAhPSBudWxsICYmIChjb21wdXRlZCA9PT0gdW5kZWZpbmVkXG4gICAgICAgICAgICAgID8gKGN1cnJlbnQgPT09IGN1cnJlbnQgJiYgIWlzU3ltYm9sKGN1cnJlbnQpKVxuICAgICAgICAgICAgICA6IGNvbXBhcmF0b3IoY3VycmVudCwgY29tcHV0ZWQpXG4gICAgICAgICAgICApKSB7XG4gICAgICAgICAgdmFyIGNvbXB1dGVkID0gY3VycmVudCxcbiAgICAgICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmlsbGAgd2l0aG91dCBhbiBpdGVyYXRlZSBjYWxsIGd1YXJkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmlsbC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBmaWxsIGBhcnJheWAgd2l0aC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBwb3NpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2VuZD1hcnJheS5sZW5ndGhdIFRoZSBlbmQgcG9zaXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuXG4gICAgICBzdGFydCA9IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICBpZiAoc3RhcnQgPCAwKSB7XG4gICAgICAgIHN0YXJ0ID0gLXN0YXJ0ID4gbGVuZ3RoID8gMCA6IChsZW5ndGggKyBzdGFydCk7XG4gICAgICB9XG4gICAgICBlbmQgPSAoZW5kID09PSB1bmRlZmluZWQgfHwgZW5kID4gbGVuZ3RoKSA/IGxlbmd0aCA6IHRvSW50ZWdlcihlbmQpO1xuICAgICAgaWYgKGVuZCA8IDApIHtcbiAgICAgICAgZW5kICs9IGxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGVuZCA9IHN0YXJ0ID4gZW5kID8gMCA6IHRvTGVuZ3RoKGVuZCk7XG4gICAgICB3aGlsZSAoc3RhcnQgPCBlbmQpIHtcbiAgICAgICAgYXJyYXlbc3RhcnQrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5maWx0ZXJgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGaWx0ZXIoY29sbGVjdGlvbiwgcHJlZGljYXRlKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBiYXNlRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZmxhdHRlbmAgd2l0aCBzdXBwb3J0IGZvciByZXN0cmljdGluZyBmbGF0dGVuaW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGVwdGggVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3ByZWRpY2F0ZT1pc0ZsYXR0ZW5hYmxlXSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzU3RyaWN0XSBSZXN0cmljdCB0byB2YWx1ZXMgdGhhdCBwYXNzIGBwcmVkaWNhdGVgIGNoZWNrcy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0PVtdXSBUaGUgaW5pdGlhbCByZXN1bHQgdmFsdWUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSB8fCAocHJlZGljYXRlID0gaXNGbGF0dGVuYWJsZSk7XG4gICAgICByZXN1bHQgfHwgKHJlc3VsdCA9IFtdKTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuICAgICAgICBpZiAoZGVwdGggPiAwICYmIHByZWRpY2F0ZSh2YWx1ZSkpIHtcbiAgICAgICAgICBpZiAoZGVwdGggPiAxKSB7XG4gICAgICAgICAgICAvLyBSZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgICAgYmFzZUZsYXR0ZW4odmFsdWUsIGRlcHRoIC0gMSwgcHJlZGljYXRlLCBpc1N0cmljdCwgcmVzdWx0KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYXJyYXlQdXNoKHJlc3VsdCwgdmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmICghaXNTdHJpY3QpIHtcbiAgICAgICAgICByZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgYmFzZUZvck93bmAgd2hpY2ggaXRlcmF0ZXMgb3ZlciBgb2JqZWN0YFxuICAgICAqIHByb3BlcnRpZXMgcmV0dXJuZWQgYnkgYGtleXNGdW5jYCBhbmQgaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpdGVyYXRlZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZUZvciA9IGNyZWF0ZUJhc2VGb3IoKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgZnVuY3Rpb24gaXMgbGlrZSBgYmFzZUZvcmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzXG4gICAgICogaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0ga2V5c0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUga2V5cyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIHZhciBiYXNlRm9yUmlnaHQgPSBjcmVhdGVCYXNlRm9yKHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uZm9yT3duYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd24ob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAmJiBiYXNlRm9yKG9iamVjdCwgaXRlcmF0ZWUsIGtleXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmZvck93blJpZ2h0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VGb3JPd25SaWdodChvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JSaWdodChvYmplY3QsIGl0ZXJhdGVlLCBrZXlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5mdW5jdGlvbnNgIHdoaWNoIGNyZWF0ZXMgYW4gYXJyYXkgb2ZcbiAgICAgKiBgb2JqZWN0YCBmdW5jdGlvbiBwcm9wZXJ0eSBuYW1lcyBmaWx0ZXJlZCBmcm9tIGBwcm9wc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBuYW1lcyB0byBmaWx0ZXIuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlRnVuY3Rpb25zKG9iamVjdCwgcHJvcHMpIHtcbiAgICAgIHJldHVybiBhcnJheUZpbHRlcihwcm9wcywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHJldHVybiBpc0Z1bmN0aW9uKG9iamVjdFtrZXldKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmdldGAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWZhdWx0IHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXQob2JqZWN0LCBwYXRoKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gMCxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKG9iamVjdCAhPSBudWxsICYmIGluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIG9iamVjdCA9IG9iamVjdFt0b0tleShwYXRoW2luZGV4KytdKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gKGluZGV4ICYmIGluZGV4ID09IGxlbmd0aCkgPyBvYmplY3QgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYGdldEFsbEtleXNgIGFuZCBgZ2V0QWxsS2V5c0luYCB3aGljaCB1c2VzXG4gICAgICogYGtleXNGdW5jYCBhbmQgYHN5bWJvbHNGdW5jYCB0byBnZXQgdGhlIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGtleXNGdW5jIFRoZSBmdW5jdGlvbiB0byBnZXQgdGhlIGtleXMgb2YgYG9iamVjdGAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc3ltYm9sc0Z1bmMgVGhlIGZ1bmN0aW9uIHRvIGdldCB0aGUgc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0Z1bmMsIHN5bWJvbHNGdW5jKSB7XG4gICAgICB2YXIgcmVzdWx0ID0ga2V5c0Z1bmMob2JqZWN0KTtcbiAgICAgIHJldHVybiBpc0FycmF5KG9iamVjdCkgPyByZXN1bHQgOiBhcnJheVB1c2gocmVzdWx0LCBzeW1ib2xzRnVuYyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgZ2V0VGFnYCB3aXRob3V0IGZhbGxiYWNrcyBmb3IgYnVnZ3kgZW52aXJvbm1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHZXRUYWcodmFsdWUpIHtcbiAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA9PT0gdW5kZWZpbmVkID8gdW5kZWZpbmVkVGFnIDogbnVsbFRhZztcbiAgICAgIH1cbiAgICAgIHJldHVybiAoc3ltVG9TdHJpbmdUYWcgJiYgc3ltVG9TdHJpbmdUYWcgaW4gT2JqZWN0KHZhbHVlKSlcbiAgICAgICAgPyBnZXRSYXdUYWcodmFsdWUpXG4gICAgICAgIDogb2JqZWN0VG9TdHJpbmcodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmd0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VHdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA+IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmhhc2Agd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXMob2JqZWN0LCBrZXkpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5oYXNJbmAgd2l0aG91dCBzdXBwb3J0IGZvciBkZWVwIHBhdGhzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29iamVjdF0gVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30ga2V5IFRoZSBrZXkgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBrZXlgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VIYXNJbihvYmplY3QsIGtleSkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGtleSBpbiBPYmplY3Qob2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pblJhbmdlYCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgbnVtYmVyYCBpcyBpbiB0aGUgcmFuZ2UsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHJldHVybiBudW1iZXIgPj0gbmF0aXZlTWluKHN0YXJ0LCBlbmQpICYmIG51bWJlciA8IG5hdGl2ZU1heChzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCwgd2l0aG91dCBzdXBwb3J0XG4gICAgICogZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHNoYXJlZCB2YWx1ZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludGVyc2VjdGlvbihhcnJheXMsIGl0ZXJhdGVlLCBjb21wYXJhdG9yKSB7XG4gICAgICB2YXIgaW5jbHVkZXMgPSBjb21wYXJhdG9yID8gYXJyYXlJbmNsdWRlc1dpdGggOiBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5c1swXS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gYXJyYXlzLmxlbmd0aCxcbiAgICAgICAgICBvdGhJbmRleCA9IG90aExlbmd0aCxcbiAgICAgICAgICBjYWNoZXMgPSBBcnJheShvdGhMZW5ndGgpLFxuICAgICAgICAgIG1heExlbmd0aCA9IEluZmluaXR5LFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAob3RoSW5kZXgtLSkge1xuICAgICAgICB2YXIgYXJyYXkgPSBhcnJheXNbb3RoSW5kZXhdO1xuICAgICAgICBpZiAob3RoSW5kZXggJiYgaXRlcmF0ZWUpIHtcbiAgICAgICAgICBhcnJheSA9IGFycmF5TWFwKGFycmF5LCBiYXNlVW5hcnkoaXRlcmF0ZWUpKTtcbiAgICAgICAgfVxuICAgICAgICBtYXhMZW5ndGggPSBuYXRpdmVNaW4oYXJyYXkubGVuZ3RoLCBtYXhMZW5ndGgpO1xuICAgICAgICBjYWNoZXNbb3RoSW5kZXhdID0gIWNvbXBhcmF0b3IgJiYgKGl0ZXJhdGVlIHx8IChsZW5ndGggPj0gMTIwICYmIGFycmF5Lmxlbmd0aCA+PSAxMjApKVxuICAgICAgICAgID8gbmV3IFNldENhY2hlKG90aEluZGV4ICYmIGFycmF5KVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJyYXkgPSBhcnJheXNbMF07XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHNlZW4gPSBjYWNoZXNbMF07XG5cbiAgICAgIG91dGVyOlxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGggJiYgcmVzdWx0Lmxlbmd0aCA8IG1heExlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmICghKHNlZW5cbiAgICAgICAgICAgICAgPyBjYWNoZUhhcyhzZWVuLCBjb21wdXRlZClcbiAgICAgICAgICAgICAgOiBpbmNsdWRlcyhyZXN1bHQsIGNvbXB1dGVkLCBjb21wYXJhdG9yKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIG90aEluZGV4ID0gb3RoTGVuZ3RoO1xuICAgICAgICAgIHdoaWxlICgtLW90aEluZGV4KSB7XG4gICAgICAgICAgICB2YXIgY2FjaGUgPSBjYWNoZXNbb3RoSW5kZXhdO1xuICAgICAgICAgICAgaWYgKCEoY2FjaGVcbiAgICAgICAgICAgICAgICAgID8gY2FjaGVIYXMoY2FjaGUsIGNvbXB1dGVkKVxuICAgICAgICAgICAgICAgICAgOiBpbmNsdWRlcyhhcnJheXNbb3RoSW5kZXhdLCBjb21wdXRlZCwgY29tcGFyYXRvcikpXG4gICAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgIGNvbnRpbnVlIG91dGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludmVydGAgYW5kIGBfLmludmVydEJ5YCB3aGljaCBpbnZlcnRzXG4gICAgICogYG9iamVjdGAgd2l0aCB2YWx1ZXMgdHJhbnNmb3JtZWQgYnkgYGl0ZXJhdGVlYCBhbmQgc2V0IGJ5IGBzZXR0ZXJgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHNldHRlciBUaGUgZnVuY3Rpb24gdG8gc2V0IGBhY2N1bXVsYXRvcmAgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSB0byB0cmFuc2Zvcm0gdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBhY2N1bXVsYXRvciBUaGUgaW5pdGlhbCBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBhY2N1bXVsYXRvcmAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUludmVydGVyKG9iamVjdCwgc2V0dGVyLCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgc2V0dGVyKGFjY3VtdWxhdG9yLCBpdGVyYXRlZSh2YWx1ZSksIGtleSwgb2JqZWN0KTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmludm9rZWAgd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogbWV0aG9kIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFyZ3MgVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKSB7XG4gICAgICBwYXRoID0gY2FzdFBhdGgocGF0aCwgb2JqZWN0KTtcbiAgICAgIG9iamVjdCA9IHBhcmVudChvYmplY3QsIHBhdGgpO1xuICAgICAgdmFyIGZ1bmMgPSBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IG9iamVjdFt0b0tleShsYXN0KHBhdGgpKV07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gdW5kZWZpbmVkIDogYXBwbHkoZnVuYywgb2JqZWN0LCBhcmdzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0FyZ3VtZW50c2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGBhcmd1bWVudHNgIG9iamVjdCxcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNBcmd1bWVudHModmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGFyZ3NUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNBcnJheUJ1ZmZlcmAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5IGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0FycmF5QnVmZmVyKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSBhcnJheUJ1ZmZlclRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0RhdGVgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGRhdGUgb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRGF0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gZGF0ZVRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc0VxdWFsYCB3aGljaCBzdXBwb3J0cyBwYXJ0aWFsIGNvbXBhcmlzb25zXG4gICAgICogYW5kIHRyYWNrcyB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy5cbiAgICAgKiAgMSAtIFVub3JkZXJlZCBjb21wYXJpc29uXG4gICAgICogIDIgLSBQYXJ0aWFsIGNvbXBhcmlzb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGB2YWx1ZWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIHZhbHVlcyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc0VxdWFsKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIGlmICh2YWx1ZSA9PT0gb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCBvdGhlciA9PSBudWxsIHx8ICghaXNPYmplY3RMaWtlKHZhbHVlKSAmJiAhaXNPYmplY3RMaWtlKG90aGVyKSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB2YWx1ZSAmJiBvdGhlciAhPT0gb3RoZXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWxEZWVwKHZhbHVlLCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgYmFzZUlzRXF1YWwsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsYCBmb3IgYXJyYXlzIGFuZCBvYmplY3RzIHdoaWNoIHBlcmZvcm1zXG4gICAgICogZGVlcCBjb21wYXJpc29ucyBhbmQgdHJhY2tzIHRyYXZlcnNlZCBvYmplY3RzIGVuYWJsaW5nIG9iamVjdHMgd2l0aCBjaXJjdWxhclxuICAgICAqIHJlZmVyZW5jZXMgdG8gYmUgY29tcGFyZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgYmFzZUlzRXF1YWxgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY3VzdG9taXplciBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvbXBhcmlzb25zLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVxdWFsRnVuYyBUaGUgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGVxdWl2YWxlbnRzIG9mIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW3N0YWNrXSBUcmFja3MgdHJhdmVyc2VkIGBvYmplY3RgIGFuZCBgb3RoZXJgIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBvYmplY3RzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzRXF1YWxEZWVwKG9iamVjdCwgb3RoZXIsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spIHtcbiAgICAgIHZhciBvYmpJc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBvdGhJc0FyciA9IGlzQXJyYXkob3RoZXIpLFxuICAgICAgICAgIG9ialRhZyA9IG9iaklzQXJyID8gYXJyYXlUYWcgOiBnZXRUYWcob2JqZWN0KSxcbiAgICAgICAgICBvdGhUYWcgPSBvdGhJc0FyciA/IGFycmF5VGFnIDogZ2V0VGFnKG90aGVyKTtcblxuICAgICAgb2JqVGFnID0gb2JqVGFnID09IGFyZ3NUYWcgPyBvYmplY3RUYWcgOiBvYmpUYWc7XG4gICAgICBvdGhUYWcgPSBvdGhUYWcgPT0gYXJnc1RhZyA/IG9iamVjdFRhZyA6IG90aFRhZztcblxuICAgICAgdmFyIG9iaklzT2JqID0gb2JqVGFnID09IG9iamVjdFRhZyxcbiAgICAgICAgICBvdGhJc09iaiA9IG90aFRhZyA9PSBvYmplY3RUYWcsXG4gICAgICAgICAgaXNTYW1lVGFnID0gb2JqVGFnID09IG90aFRhZztcblxuICAgICAgaWYgKGlzU2FtZVRhZyAmJiBpc0J1ZmZlcihvYmplY3QpKSB7XG4gICAgICAgIGlmICghaXNCdWZmZXIob3RoZXIpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG9iaklzQXJyID0gdHJ1ZTtcbiAgICAgICAgb2JqSXNPYmogPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc1NhbWVUYWcgJiYgIW9iaklzT2JqKSB7XG4gICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgIHJldHVybiAob2JqSXNBcnIgfHwgaXNUeXBlZEFycmF5KG9iamVjdCkpXG4gICAgICAgICAgPyBlcXVhbEFycmF5cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKVxuICAgICAgICAgIDogZXF1YWxCeVRhZyhvYmplY3QsIG90aGVyLCBvYmpUYWcsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIGVxdWFsRnVuYywgc3RhY2spO1xuICAgICAgfVxuICAgICAgaWYgKCEoYml0bWFzayAmIENPTVBBUkVfUEFSVElBTF9GTEFHKSkge1xuICAgICAgICB2YXIgb2JqSXNXcmFwcGVkID0gb2JqSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsICdfX3dyYXBwZWRfXycpLFxuICAgICAgICAgICAgb3RoSXNXcmFwcGVkID0gb3RoSXNPYmogJiYgaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwgJ19fd3JhcHBlZF9fJyk7XG5cbiAgICAgICAgaWYgKG9iaklzV3JhcHBlZCB8fCBvdGhJc1dyYXBwZWQpIHtcbiAgICAgICAgICB2YXIgb2JqVW53cmFwcGVkID0gb2JqSXNXcmFwcGVkID8gb2JqZWN0LnZhbHVlKCkgOiBvYmplY3QsXG4gICAgICAgICAgICAgIG90aFVud3JhcHBlZCA9IG90aElzV3JhcHBlZCA/IG90aGVyLnZhbHVlKCkgOiBvdGhlcjtcblxuICAgICAgICAgIHN0YWNrIHx8IChzdGFjayA9IG5ldyBTdGFjayk7XG4gICAgICAgICAgcmV0dXJuIGVxdWFsRnVuYyhvYmpVbndyYXBwZWQsIG90aFVud3JhcHBlZCwgYml0bWFzaywgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAoIWlzU2FtZVRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBzdGFjayB8fCAoc3RhY2sgPSBuZXcgU3RhY2spO1xuICAgICAgcmV0dXJuIGVxdWFsT2JqZWN0cyhvYmplY3QsIG90aGVyLCBiaXRtYXNrLCBjdXN0b21pemVyLCBlcXVhbEZ1bmMsIHN0YWNrKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hcGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzTWFwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBnZXRUYWcodmFsdWUpID09IG1hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc01hdGNoYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtBcnJheX0gbWF0Y2hEYXRhIFRoZSBwcm9wZXJ0eSBuYW1lcywgdmFsdWVzLCBhbmQgY29tcGFyZSBmbGFncyB0byBtYXRjaC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG9iamVjdGAgaXMgYSBtYXRjaCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBtYXRjaERhdGEsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHZhciBpbmRleCA9IG1hdGNoRGF0YS5sZW5ndGgsXG4gICAgICAgICAgbGVuZ3RoID0gaW5kZXgsXG4gICAgICAgICAgbm9DdXN0b21pemVyID0gIWN1c3RvbWl6ZXI7XG5cbiAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gIWxlbmd0aDtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICBpZiAoKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKVxuICAgICAgICAgICAgICA/IGRhdGFbMV0gIT09IG9iamVjdFtkYXRhWzBdXVxuICAgICAgICAgICAgICA6ICEoZGF0YVswXSBpbiBvYmplY3QpXG4gICAgICAgICAgICApIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIGRhdGEgPSBtYXRjaERhdGFbaW5kZXhdO1xuICAgICAgICB2YXIga2V5ID0gZGF0YVswXSxcbiAgICAgICAgICAgIG9ialZhbHVlID0gb2JqZWN0W2tleV0sXG4gICAgICAgICAgICBzcmNWYWx1ZSA9IGRhdGFbMV07XG5cbiAgICAgICAgaWYgKG5vQ3VzdG9taXplciAmJiBkYXRhWzJdKSB7XG4gICAgICAgICAgaWYgKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgIShrZXkgaW4gb2JqZWN0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgc3RhY2sgPSBuZXcgU3RhY2s7XG4gICAgICAgICAgaWYgKGN1c3RvbWl6ZXIpIHtcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSwgc3RhY2spO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIShyZXN1bHQgPT09IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgID8gYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcsIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgICAgIDogcmVzdWx0XG4gICAgICAgICAgICAgICkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmlzTmF0aXZlYCB3aXRob3V0IGJhZCBzaGltIGNoZWNrcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlSXNOYXRpdmUodmFsdWUpIHtcbiAgICAgIGlmICghaXNPYmplY3QodmFsdWUpIHx8IGlzTWFza2VkKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcGF0dGVybiA9IGlzRnVuY3Rpb24odmFsdWUpID8gcmVJc05hdGl2ZSA6IHJlSXNIb3N0Q3RvcjtcbiAgICAgIHJldHVybiBwYXR0ZXJuLnRlc3QodG9Tb3VyY2UodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5pc1JlZ0V4cGAgd2l0aG91dCBOb2RlLmpzIG9wdGltaXphdGlvbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcmVnZXhwLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUlzUmVnRXhwKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBiYXNlR2V0VGFnKHZhbHVlKSA9PSByZWdleHBUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNTZXRgIHdpdGhvdXQgTm9kZS5qcyBvcHRpbWl6YXRpb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1NldCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgZ2V0VGFnKHZhbHVlKSA9PSBzZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXNUeXBlZEFycmF5YCB3aXRob3V0IE5vZGUuanMgb3B0aW1pemF0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB0eXBlZCBhcnJheSwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJc1R5cGVkQXJyYXkodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmXG4gICAgICAgIGlzTGVuZ3RoKHZhbHVlLmxlbmd0aCkgJiYgISF0eXBlZEFycmF5VGFnc1tiYXNlR2V0VGFnKHZhbHVlKV07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uaXRlcmF0ZWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IFt2YWx1ZT1fLmlkZW50aXR5XSBUaGUgdmFsdWUgdG8gY29udmVydCB0byBhbiBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGl0ZXJhdGVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VJdGVyYXRlZSh2YWx1ZSkge1xuICAgICAgLy8gRG9uJ3Qgc3RvcmUgdGhlIGB0eXBlb2ZgIHJlc3VsdCBpbiBhIHZhcmlhYmxlIHRvIGF2b2lkIGEgSklUIGJ1ZyBpbiBTYWZhcmkgOS5cbiAgICAgIC8vIFNlZSBodHRwczovL2J1Z3Mud2Via2l0Lm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTU2MDM0IGZvciBtb3JlIGRldGFpbHMuXG4gICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGlkZW50aXR5O1xuICAgICAgfVxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gaXNBcnJheSh2YWx1ZSlcbiAgICAgICAgICA/IGJhc2VNYXRjaGVzUHJvcGVydHkodmFsdWVbMF0sIHZhbHVlWzFdKVxuICAgICAgICAgIDogYmFzZU1hdGNoZXModmFsdWUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHByb3BlcnR5KHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzYCB3aGljaCBkb2Vzbid0IHRyZWF0IHNwYXJzZSBhcnJheXMgYXMgZGVuc2UuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VLZXlzKG9iamVjdCkge1xuICAgICAgaWYgKCFpc1Byb3RvdHlwZShvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBuYXRpdmVLZXlzKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICBmb3IgKHZhciBrZXkgaW4gT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpICYmIGtleSAhPSAnY29uc3RydWN0b3InKSB7XG4gICAgICAgICAgcmVzdWx0LnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5rZXlzSW5gIHdoaWNoIGRvZXNuJ3QgdHJlYXQgc3BhcnNlIGFycmF5cyBhcyBkZW5zZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZUtleXNJbihvYmplY3QpIHtcbiAgICAgIGlmICghaXNPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICByZXR1cm4gbmF0aXZlS2V5c0luKG9iamVjdCk7XG4gICAgICB9XG4gICAgICB2YXIgaXNQcm90byA9IGlzUHJvdG90eXBlKG9iamVjdCksXG4gICAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgaWYgKCEoa2V5ID09ICdjb25zdHJ1Y3RvcicgJiYgKGlzUHJvdG8gfHwgIWhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBrZXkpKSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLmx0YCB3aGljaCBkb2Vzbid0IGNvZXJjZSBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VMdCh2YWx1ZSwgb3RoZXIpIHtcbiAgICAgIHJldHVybiB2YWx1ZSA8IG90aGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hcGAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHRbKytpbmRleF0gPSBpdGVyYXRlZSh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tYXRjaGVzYCB3aGljaCBkb2Vzbid0IGNsb25lIGBzb3VyY2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgdmFsdWVzIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXMoc291cmNlKSB7XG4gICAgICB2YXIgbWF0Y2hEYXRhID0gZ2V0TWF0Y2hEYXRhKHNvdXJjZSk7XG4gICAgICBpZiAobWF0Y2hEYXRhLmxlbmd0aCA9PSAxICYmIG1hdGNoRGF0YVswXVsyXSkge1xuICAgICAgICByZXR1cm4gbWF0Y2hlc1N0cmljdENvbXBhcmFibGUobWF0Y2hEYXRhWzBdWzBdLCBtYXRjaERhdGFbMF1bMV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09PSBzb3VyY2UgfHwgYmFzZUlzTWF0Y2gob2JqZWN0LCBzb3VyY2UsIG1hdGNoRGF0YSk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm1hdGNoZXNQcm9wZXJ0eWAgd2hpY2ggZG9lc24ndCBjbG9uZSBgc3JjVmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHZhbHVlIHRvIG1hdGNoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBzcmNWYWx1ZSkge1xuICAgICAgaWYgKGlzS2V5KHBhdGgpICYmIGlzU3RyaWN0Q29tcGFyYWJsZShzcmNWYWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIG1hdGNoZXNTdHJpY3RDb21wYXJhYmxlKHRvS2V5KHBhdGgpLCBzcmNWYWx1ZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IGdldChvYmplY3QsIHBhdGgpO1xuICAgICAgICByZXR1cm4gKG9ialZhbHVlID09PSB1bmRlZmluZWQgJiYgb2JqVmFsdWUgPT09IHNyY1ZhbHVlKVxuICAgICAgICAgID8gaGFzSW4ob2JqZWN0LCBwYXRoKVxuICAgICAgICAgIDogYmFzZUlzRXF1YWwoc3JjVmFsdWUsIG9ialZhbHVlLCBDT01QQVJFX1BBUlRJQUxfRkxBRyB8IENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5tZXJnZWAgd2l0aG91dCBzdXBwb3J0IGZvciBtdWx0aXBsZSBzb3VyY2VzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3JjSW5kZXggVGhlIGluZGV4IG9mIGBzb3VyY2VgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIG1lcmdlZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZShvYmplY3QsIHNvdXJjZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKSB7XG4gICAgICBpZiAob2JqZWN0ID09PSBzb3VyY2UpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYmFzZUZvcihzb3VyY2UsIGZ1bmN0aW9uKHNyY1ZhbHVlLCBrZXkpIHtcbiAgICAgICAgc3RhY2sgfHwgKHN0YWNrID0gbmV3IFN0YWNrKTtcbiAgICAgICAgaWYgKGlzT2JqZWN0KHNyY1ZhbHVlKSkge1xuICAgICAgICAgIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIGJhc2VNZXJnZSwgY3VzdG9taXplciwgc3RhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHZhciBuZXdWYWx1ZSA9IGN1c3RvbWl6ZXJcbiAgICAgICAgICAgID8gY3VzdG9taXplcihzYWZlR2V0KG9iamVjdCwga2V5KSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gc3JjVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VNZXJnZWAgZm9yIGFycmF5cyBhbmQgb2JqZWN0cyB3aGljaCBwZXJmb3Jtc1xuICAgICAqIGRlZXAgbWVyZ2VzIGFuZCB0cmFja3MgdHJhdmVyc2VkIG9iamVjdHMgZW5hYmxpbmcgb2JqZWN0cyB3aXRoIGNpcmN1bGFyXG4gICAgICogcmVmZXJlbmNlcyB0byBiZSBtZXJnZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgdmFsdWUgdG8gbWVyZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHNyY0luZGV4IFRoZSBpbmRleCBvZiBgc291cmNlYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBtZXJnZUZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1lcmdlIHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtzdGFja10gVHJhY2tzIHRyYXZlcnNlZCBzb3VyY2UgdmFsdWVzIGFuZCB0aGVpciBtZXJnZWRcbiAgICAgKiAgY291bnRlcnBhcnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VNZXJnZURlZXAob2JqZWN0LCBzb3VyY2UsIGtleSwgc3JjSW5kZXgsIG1lcmdlRnVuYywgY3VzdG9taXplciwgc3RhY2spIHtcbiAgICAgIHZhciBvYmpWYWx1ZSA9IHNhZmVHZXQob2JqZWN0LCBrZXkpLFxuICAgICAgICAgIHNyY1ZhbHVlID0gc2FmZUdldChzb3VyY2UsIGtleSksXG4gICAgICAgICAgc3RhY2tlZCA9IHN0YWNrLmdldChzcmNWYWx1ZSk7XG5cbiAgICAgIGlmIChzdGFja2VkKSB7XG4gICAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIHN0YWNrZWQpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB2YXIgbmV3VmFsdWUgPSBjdXN0b21pemVyXG4gICAgICAgID8gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUsIChrZXkgKyAnJyksIG9iamVjdCwgc291cmNlLCBzdGFjaylcbiAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgIHZhciBpc0NvbW1vbiA9IG5ld1ZhbHVlID09PSB1bmRlZmluZWQ7XG5cbiAgICAgIGlmIChpc0NvbW1vbikge1xuICAgICAgICB2YXIgaXNBcnIgPSBpc0FycmF5KHNyY1ZhbHVlKSxcbiAgICAgICAgICAgIGlzQnVmZiA9ICFpc0FyciAmJiBpc0J1ZmZlcihzcmNWYWx1ZSksXG4gICAgICAgICAgICBpc1R5cGVkID0gIWlzQXJyICYmICFpc0J1ZmYgJiYgaXNUeXBlZEFycmF5KHNyY1ZhbHVlKTtcblxuICAgICAgICBuZXdWYWx1ZSA9IHNyY1ZhbHVlO1xuICAgICAgICBpZiAoaXNBcnIgfHwgaXNCdWZmIHx8IGlzVHlwZWQpIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gb2JqVmFsdWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KG9ialZhbHVlKSkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBjb3B5QXJyYXkob2JqVmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBlbHNlIGlmIChpc0J1ZmYpIHtcbiAgICAgICAgICAgIGlzQ29tbW9uID0gZmFsc2U7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IGNsb25lQnVmZmVyKHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZiAoaXNUeXBlZCkge1xuICAgICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gY2xvbmVUeXBlZEFycmF5KHNyY1ZhbHVlLCB0cnVlKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBuZXdWYWx1ZSA9IFtdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChpc1BsYWluT2JqZWN0KHNyY1ZhbHVlKSB8fCBpc0FyZ3VtZW50cyhzcmNWYWx1ZSkpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IG9ialZhbHVlO1xuICAgICAgICAgIGlmIChpc0FyZ3VtZW50cyhvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdG9QbGFpbk9iamVjdChvYmpWYWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2UgaWYgKCFpc09iamVjdChvYmpWYWx1ZSkgfHwgaXNGdW5jdGlvbihvYmpWYWx1ZSkpIHtcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gaW5pdENsb25lT2JqZWN0KHNyY1ZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGlzQ29tbW9uKSB7XG4gICAgICAgIC8vIFJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBzdGFjay5zZXQoc3JjVmFsdWUsIG5ld1ZhbHVlKTtcbiAgICAgICAgbWVyZ2VGdW5jKG5ld1ZhbHVlLCBzcmNWYWx1ZSwgc3JjSW5kZXgsIGN1c3RvbWl6ZXIsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGFzc2lnbk1lcmdlVmFsdWUob2JqZWN0LCBrZXksIG5ld1ZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5udGhgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBpbmRleCBvZiB0aGUgZWxlbWVudCB0byByZXR1cm4uXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG50aCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZU50aChhcnJheSwgbikge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG4gKz0gbiA8IDAgPyBsZW5ndGggOiAwO1xuICAgICAgcmV0dXJuIGlzSW5kZXgobiwgbGVuZ3RoKSA/IGFycmF5W25dIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLm9yZGVyQnlgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBpdGVyYXRlZXMgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IG9yZGVycyBUaGUgc29ydCBvcmRlcnMgb2YgYGl0ZXJhdGVlc2AuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGl0ZXJhdGVlcywgb3JkZXJzKSB7XG4gICAgICBpZiAoaXRlcmF0ZWVzLmxlbmd0aCkge1xuICAgICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgaWYgKGlzQXJyYXkoaXRlcmF0ZWUpKSB7XG4gICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGJhc2VHZXQodmFsdWUsIGl0ZXJhdGVlLmxlbmd0aCA9PT0gMSA/IGl0ZXJhdGVlWzBdIDogaXRlcmF0ZWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gaXRlcmF0ZWU7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gW2lkZW50aXR5XTtcbiAgICAgIH1cblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICBpdGVyYXRlZXMgPSBhcnJheU1hcChpdGVyYXRlZXMsIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciByZXN1bHQgPSBiYXNlTWFwKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgdmFyIGNyaXRlcmlhID0gYXJyYXlNYXAoaXRlcmF0ZWVzLCBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICAgIHJldHVybiBpdGVyYXRlZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4geyAnY3JpdGVyaWEnOiBjcml0ZXJpYSwgJ2luZGV4JzogKytpbmRleCwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gYmFzZVNvcnRCeShyZXN1bHQsIGZ1bmN0aW9uKG9iamVjdCwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGNvbXBhcmVNdWx0aXBsZShvYmplY3QsIG90aGVyLCBvcmRlcnMpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucGlja2Agd2l0aG91dCBzdXBwb3J0IGZvciBpbmRpdmlkdWFsXG4gICAgICogcHJvcGVydHkgaWRlbnRpZmllcnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmdbXX0gcGF0aHMgVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUGljayhvYmplY3QsIHBhdGhzKSB7XG4gICAgICByZXR1cm4gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBmdW5jdGlvbih2YWx1ZSwgcGF0aCkge1xuICAgICAgICByZXR1cm4gaGFzSW4ob2JqZWN0LCBwYXRoKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mICBgXy5waWNrQnlgIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ1tdfSBwYXRocyBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVBpY2tCeShvYmplY3QsIHBhdGhzLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHBhdGggPSBwYXRoc1tpbmRleF0sXG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcblxuICAgICAgICBpZiAocHJlZGljYXRlKHZhbHVlLCBwYXRoKSkge1xuICAgICAgICAgIGJhc2VTZXQocmVzdWx0LCBjYXN0UGF0aChwYXRoLCBvYmplY3QpLCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlUHJvcGVydHlgIHdoaWNoIHN1cHBvcnRzIGRlZXAgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYWNjZXNzb3IgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVByb3BlcnR5RGVlcChwYXRoKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnB1bGxBbGxCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZVxuICAgICAqIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBpbmRleE9mID0gY29tcGFyYXRvciA/IGJhc2VJbmRleE9mV2l0aCA6IGJhc2VJbmRleE9mLFxuICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gdmFsdWVzLmxlbmd0aCxcbiAgICAgICAgICBzZWVuID0gYXJyYXk7XG5cbiAgICAgIGlmIChhcnJheSA9PT0gdmFsdWVzKSB7XG4gICAgICAgIHZhbHVlcyA9IGNvcHlBcnJheSh2YWx1ZXMpO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIHNlZW4gPSBhcnJheU1hcChhcnJheSwgYmFzZVVuYXJ5KGl0ZXJhdGVlKSk7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZnJvbUluZGV4ID0gMCxcbiAgICAgICAgICAgIHZhbHVlID0gdmFsdWVzW2luZGV4XSxcbiAgICAgICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUgPyBpdGVyYXRlZSh2YWx1ZSkgOiB2YWx1ZTtcblxuICAgICAgICB3aGlsZSAoKGZyb21JbmRleCA9IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQsIGZyb21JbmRleCwgY29tcGFyYXRvcikpID4gLTEpIHtcbiAgICAgICAgICBpZiAoc2VlbiAhPT0gYXJyYXkpIHtcbiAgICAgICAgICAgIHNwbGljZS5jYWxsKHNlZW4sIGZyb21JbmRleCwgMSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNwbGljZS5jYWxsKGFycmF5LCBmcm9tSW5kZXgsIDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucHVsbEF0YCB3aXRob3V0IHN1cHBvcnQgZm9yIGluZGl2aWR1YWxcbiAgICAgKiBpbmRleGVzIG9yIGNhcHR1cmluZyB0aGUgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcltdfSBpbmRleGVzIFRoZSBpbmRleGVzIG9mIGVsZW1lbnRzIHRvIHJlbW92ZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUHVsbEF0KGFycmF5LCBpbmRleGVzKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPyBpbmRleGVzLmxlbmd0aCA6IDAsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGluZGV4ZXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKGxlbmd0aCA9PSBsYXN0SW5kZXggfHwgaW5kZXggIT09IHByZXZpb3VzKSB7XG4gICAgICAgICAgdmFyIHByZXZpb3VzID0gaW5kZXg7XG4gICAgICAgICAgaWYgKGlzSW5kZXgoaW5kZXgpKSB7XG4gICAgICAgICAgICBzcGxpY2UuY2FsbChhcnJheSwgaW5kZXgsIDEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBiYXNlVW5zZXQoYXJyYXksIGluZGV4KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yYW5kb21gIHdpdGhvdXQgc3VwcG9ydCBmb3IgcmV0dXJuaW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGxvd2VyIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJhbmRvbSBudW1iZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmRvbShsb3dlciwgdXBwZXIpIHtcbiAgICAgIHJldHVybiBsb3dlciArIG5hdGl2ZUZsb29yKG5hdGl2ZVJhbmRvbSgpICogKHVwcGVyIC0gbG93ZXIgKyAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmFuZ2VgIGFuZCBgXy5yYW5nZVJpZ2h0YCB3aGljaCBkb2Vzbid0XG4gICAgICogY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RlcCBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmcm9tUmlnaHRdIFNwZWNpZnkgaXRlcmF0aW5nIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXAsIGZyb21SaWdodCkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KG5hdGl2ZUNlaWwoKGVuZCAtIHN0YXJ0KSAvIChzdGVwIHx8IDEpKSwgMCksXG4gICAgICAgICAgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtmcm9tUmlnaHQgPyBsZW5ndGggOiArK2luZGV4XSA9IHN0YXJ0O1xuICAgICAgICBzdGFydCArPSBzdGVwO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5yZXBlYXRgIHdoaWNoIGRvZXNuJ3QgY29lcmNlIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHJlcGVhdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJlcGVhdGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVwZWF0KHN0cmluZywgbikge1xuICAgICAgdmFyIHJlc3VsdCA9ICcnO1xuICAgICAgaWYgKCFzdHJpbmcgfHwgbiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIC8vIExldmVyYWdlIHRoZSBleHBvbmVudGlhdGlvbiBieSBzcXVhcmluZyBhbGdvcml0aG0gZm9yIGEgZmFzdGVyIHJlcGVhdC5cbiAgICAgIC8vIFNlZSBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FeHBvbmVudGlhdGlvbl9ieV9zcXVhcmluZyBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgZG8ge1xuICAgICAgICBpZiAobiAlIDIpIHtcbiAgICAgICAgICByZXN1bHQgKz0gc3RyaW5nO1xuICAgICAgICB9XG4gICAgICAgIG4gPSBuYXRpdmVGbG9vcihuIC8gMik7XG4gICAgICAgIGlmIChuKSB7XG4gICAgICAgICAgc3RyaW5nICs9IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfSB3aGlsZSAobik7XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8ucmVzdGAgd2hpY2ggZG9lc24ndCB2YWxpZGF0ZSBvciBjb2VyY2UgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlUmVzdChmdW5jLCBzdGFydCkge1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKG92ZXJSZXN0KGZ1bmMsIHN0YXJ0LCBpZGVudGl0eSksIGZ1bmMgKyAnJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2FtcGxlYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gc2FtcGxlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU2FtcGxlKGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiBhcnJheVNhbXBsZSh2YWx1ZXMoY29sbGVjdGlvbikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNhbXBsZVNpemVgIHdpdGhvdXQgcGFyYW0gZ3VhcmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSByYW5kb20gZWxlbWVudHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNhbXBsZVNpemUoY29sbGVjdGlvbiwgbikge1xuICAgICAgdmFyIGFycmF5ID0gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKGFycmF5LCBiYXNlQ2xhbXAobiwgMCwgYXJyYXkubGVuZ3RoKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2V0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBpZiAoIWlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICBsYXN0SW5kZXggPSBsZW5ndGggLSAxLFxuICAgICAgICAgIG5lc3RlZCA9IG9iamVjdDtcblxuICAgICAgd2hpbGUgKG5lc3RlZCAhPSBudWxsICYmICsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKSxcbiAgICAgICAgICAgIG5ld1ZhbHVlID0gdmFsdWU7XG5cbiAgICAgICAgaWYgKGtleSA9PT0gJ19fcHJvdG9fXycgfHwga2V5ID09PSAnY29uc3RydWN0b3InIHx8IGtleSA9PT0gJ3Byb3RvdHlwZScpIHtcbiAgICAgICAgICByZXR1cm4gb2JqZWN0O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGluZGV4ICE9IGxhc3RJbmRleCkge1xuICAgICAgICAgIHZhciBvYmpWYWx1ZSA9IG5lc3RlZFtrZXldO1xuICAgICAgICAgIG5ld1ZhbHVlID0gY3VzdG9taXplciA/IGN1c3RvbWl6ZXIob2JqVmFsdWUsIGtleSwgbmVzdGVkKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICBpZiAobmV3VmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgbmV3VmFsdWUgPSBpc09iamVjdChvYmpWYWx1ZSlcbiAgICAgICAgICAgICAgPyBvYmpWYWx1ZVxuICAgICAgICAgICAgICA6IChpc0luZGV4KHBhdGhbaW5kZXggKyAxXSkgPyBbXSA6IHt9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYXNzaWduVmFsdWUobmVzdGVkLCBrZXksIG5ld1ZhbHVlKTtcbiAgICAgICAgbmVzdGVkID0gbmVzdGVkW2tleV07XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXREYXRhYCB3aXRob3V0IHN1cHBvcnQgZm9yIGhvdCBsb29wIHNob3J0aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NvY2lhdGUgbWV0YWRhdGEgd2l0aC5cbiAgICAgKiBAcGFyYW0geyp9IGRhdGEgVGhlIG1ldGFkYXRhLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGJhc2VTZXREYXRhID0gIW1ldGFNYXAgPyBpZGVudGl0eSA6IGZ1bmN0aW9uKGZ1bmMsIGRhdGEpIHtcbiAgICAgIG1ldGFNYXAuc2V0KGZ1bmMsIGRhdGEpO1xuICAgICAgcmV0dXJuIGZ1bmM7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBzZXRUb1N0cmluZ2Agd2l0aG91dCBzdXBwb3J0IGZvciBob3QgbG9vcCBzaG9ydGluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZyBUaGUgYHRvU3RyaW5nYCByZXN1bHQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGBmdW5jYC5cbiAgICAgKi9cbiAgICB2YXIgYmFzZVNldFRvU3RyaW5nID0gIWRlZmluZVByb3BlcnR5ID8gaWRlbnRpdHkgOiBmdW5jdGlvbihmdW5jLCBzdHJpbmcpIHtcbiAgICAgIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jLCAndG9TdHJpbmcnLCB7XG4gICAgICAgICdjb25maWd1cmFibGUnOiB0cnVlLFxuICAgICAgICAnZW51bWVyYWJsZSc6IGZhbHNlLFxuICAgICAgICAndmFsdWUnOiBjb25zdGFudChzdHJpbmcpLFxuICAgICAgICAnd3JpdGFibGUnOiB0cnVlXG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2h1ZmZsZWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgcmV0dXJuIHNodWZmbGVTZWxmKHZhbHVlcyhjb2xsZWN0aW9uKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uc2xpY2VgIHdpdGhvdXQgYW4gaXRlcmF0ZWUgY2FsbCBndWFyZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgc3RhcnQgPSAtc3RhcnQgPiBsZW5ndGggPyAwIDogKGxlbmd0aCArIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIGVuZCA9IGVuZCA+IGxlbmd0aCA/IGxlbmd0aCA6IGVuZDtcbiAgICAgIGlmIChlbmQgPCAwKSB7XG4gICAgICAgIGVuZCArPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBzdGFydCA+IGVuZCA/IDAgOiAoKGVuZCAtIHN0YXJ0KSA+Pj4gMCk7XG4gICAgICBzdGFydCA+Pj49IDA7XG5cbiAgICAgIHZhciByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W2luZGV4XSA9IGFycmF5W2luZGV4ICsgc3RhcnRdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb21lYCB3aXRob3V0IHN1cHBvcnQgZm9yIGl0ZXJhdGVlIHNob3J0aGFuZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29tZShjb2xsZWN0aW9uLCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQ7XG5cbiAgICAgIGJhc2VFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXN1bHQgPSBwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgICAgcmV0dXJuICFyZXN1bHQ7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAhIXJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleGAgYW5kIGBfLnNvcnRlZExhc3RJbmRleGAgd2hpY2hcbiAgICAgKiBwZXJmb3JtcyBhIGJpbmFyeSBzZWFyY2ggb2YgYGFycmF5YCB0byBkZXRlcm1pbmUgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWBcbiAgICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIGl0cyBzb3J0IG9yZGVyLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbcmV0SGlnaGVzdF0gU3BlY2lmeSByZXR1cm5pbmcgdGhlIGhpZ2hlc3QgcXVhbGlmaWVkIGluZGV4LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCByZXRIaWdoZXN0KSB7XG4gICAgICB2YXIgbG93ID0gMCxcbiAgICAgICAgICBoaWdoID0gYXJyYXkgPT0gbnVsbCA/IGxvdyA6IGFycmF5Lmxlbmd0aDtcblxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiB2YWx1ZSA9PT0gdmFsdWUgJiYgaGlnaCA8PSBIQUxGX01BWF9BUlJBWV9MRU5HVEgpIHtcbiAgICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxLFxuICAgICAgICAgICAgICBjb21wdXRlZCA9IGFycmF5W21pZF07XG5cbiAgICAgICAgICBpZiAoY29tcHV0ZWQgIT09IG51bGwgJiYgIWlzU3ltYm9sKGNvbXB1dGVkKSAmJlxuICAgICAgICAgICAgICAocmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSkpKSB7XG4gICAgICAgICAgICBsb3cgPSBtaWQgKyAxO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBoaWdoID0gbWlkO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gaGlnaDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlU29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGlkZW50aXR5LCByZXRIaWdoZXN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy5zb3J0ZWRJbmRleEJ5YCBhbmQgYF8uc29ydGVkTGFzdEluZGV4QnlgXG4gICAgICogd2hpY2ggaW52b2tlcyBgaXRlcmF0ZWVgIGZvciBgdmFsdWVgIGFuZCBlYWNoIGVsZW1lbnQgb2YgYGFycmF5YCB0byBjb21wdXRlXG4gICAgICogdGhlaXIgc29ydCByYW5raW5nLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDsgKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGl0ZXJhdGVlIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW3JldEhpZ2hlc3RdIFNwZWNpZnkgcmV0dXJuaW5nIHRoZSBoaWdoZXN0IHF1YWxpZmllZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSwgcmV0SGlnaGVzdCkge1xuICAgICAgdmFyIGxvdyA9IDAsXG4gICAgICAgICAgaGlnaCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGhpZ2ggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG5cbiAgICAgIHZhbHVlID0gaXRlcmF0ZWUodmFsdWUpO1xuICAgICAgdmFyIHZhbElzTmFOID0gdmFsdWUgIT09IHZhbHVlLFxuICAgICAgICAgIHZhbElzTnVsbCA9IHZhbHVlID09PSBudWxsLFxuICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpLFxuICAgICAgICAgIHZhbElzVW5kZWZpbmVkID0gdmFsdWUgPT09IHVuZGVmaW5lZDtcblxuICAgICAgd2hpbGUgKGxvdyA8IGhpZ2gpIHtcbiAgICAgICAgdmFyIG1pZCA9IG5hdGl2ZUZsb29yKChsb3cgKyBoaWdoKSAvIDIpLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZShhcnJheVttaWRdKSxcbiAgICAgICAgICAgIG90aElzRGVmaW5lZCA9IGNvbXB1dGVkICE9PSB1bmRlZmluZWQsXG4gICAgICAgICAgICBvdGhJc051bGwgPSBjb21wdXRlZCA9PT0gbnVsbCxcbiAgICAgICAgICAgIG90aElzUmVmbGV4aXZlID0gY29tcHV0ZWQgPT09IGNvbXB1dGVkLFxuICAgICAgICAgICAgb3RoSXNTeW1ib2wgPSBpc1N5bWJvbChjb21wdXRlZCk7XG5cbiAgICAgICAgaWYgKHZhbElzTmFOKSB7XG4gICAgICAgICAgdmFyIHNldExvdyA9IHJldEhpZ2hlc3QgfHwgb3RoSXNSZWZsZXhpdmU7XG4gICAgICAgIH0gZWxzZSBpZiAodmFsSXNVbmRlZmluZWQpIHtcbiAgICAgICAgICBzZXRMb3cgPSBvdGhJc1JlZmxleGl2ZSAmJiAocmV0SGlnaGVzdCB8fCBvdGhJc0RlZmluZWQpO1xuICAgICAgICB9IGVsc2UgaWYgKHZhbElzTnVsbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAocmV0SGlnaGVzdCB8fCAhb3RoSXNOdWxsKTtcbiAgICAgICAgfSBlbHNlIGlmICh2YWxJc1N5bWJvbCkge1xuICAgICAgICAgIHNldExvdyA9IG90aElzUmVmbGV4aXZlICYmIG90aElzRGVmaW5lZCAmJiAhb3RoSXNOdWxsICYmIChyZXRIaWdoZXN0IHx8ICFvdGhJc1N5bWJvbCk7XG4gICAgICAgIH0gZWxzZSBpZiAob3RoSXNOdWxsIHx8IG90aElzU3ltYm9sKSB7XG4gICAgICAgICAgc2V0TG93ID0gZmFsc2U7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0TG93ID0gcmV0SGlnaGVzdCA/IChjb21wdXRlZCA8PSB2YWx1ZSkgOiAoY29tcHV0ZWQgPCB2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNldExvdykge1xuICAgICAgICAgIGxvdyA9IG1pZCArIDE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGlnaCA9IG1pZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG5hdGl2ZU1pbihoaWdoLCBNQVhfQVJSQVlfSU5ERVgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnNvcnRlZFVuaXFgIGFuZCBgXy5zb3J0ZWRVbmlxQnlgIHdpdGhvdXRcbiAgICAgKiBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VTb3J0ZWRVbmlxKGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc0luZGV4ID0gMCxcbiAgICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdLFxuICAgICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlKSA6IHZhbHVlO1xuXG4gICAgICAgIGlmICghaW5kZXggfHwgIWVxKGNvbXB1dGVkLCBzZWVuKSkge1xuICAgICAgICAgIHZhciBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gdmFsdWUgPT09IDAgPyAwIDogdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8udG9OdW1iZXJgIHdoaWNoIGRvZXNuJ3QgZW5zdXJlIGNvcnJlY3RcbiAgICAgKiBjb252ZXJzaW9ucyBvZiBiaW5hcnksIGhleGFkZWNpbWFsLCBvciBvY3RhbCBzdHJpbmcgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlVG9OdW1iZXIodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgaWYgKGlzU3ltYm9sKHZhbHVlKSkge1xuICAgICAgICByZXR1cm4gTkFOO1xuICAgICAgfVxuICAgICAgcmV0dXJuICt2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy50b1N0cmluZ2Agd2hpY2ggZG9lc24ndCBjb252ZXJ0IG51bGxpc2hcbiAgICAgKiB2YWx1ZXMgdG8gZW1wdHkgc3RyaW5ncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzdHJpbmcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICAvLyBFeGl0IGVhcmx5IGZvciBzdHJpbmdzIHRvIGF2b2lkIGEgcGVyZm9ybWFuY2UgaGl0IGluIHNvbWUgZW52aXJvbm1lbnRzLlxuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29udmVydCB2YWx1ZXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKS5cbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKHZhbHVlLCBiYXNlVG9TdHJpbmcpICsgJyc7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzeW1ib2xUb1N0cmluZyA/IHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsdWUpIDogJyc7XG4gICAgICB9XG4gICAgICB2YXIgcmVzdWx0ID0gKHZhbHVlICsgJycpO1xuICAgICAgcmV0dXJuIChyZXN1bHQgPT0gJzAnICYmICgxIC8gdmFsdWUpID09IC1JTkZJTklUWSkgPyAnLTAnIDogcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoZSBiYXNlIGltcGxlbWVudGF0aW9uIG9mIGBfLnVuaXFCeWAgd2l0aG91dCBzdXBwb3J0IGZvciBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGJhc2VVbmlxKGFycmF5LCBpdGVyYXRlZSwgY29tcGFyYXRvcikge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzLFxuICAgICAgICAgIGxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBpc0NvbW1vbiA9IHRydWUsXG4gICAgICAgICAgcmVzdWx0ID0gW10sXG4gICAgICAgICAgc2VlbiA9IHJlc3VsdDtcblxuICAgICAgaWYgKGNvbXBhcmF0b3IpIHtcbiAgICAgICAgaXNDb21tb24gPSBmYWxzZTtcbiAgICAgICAgaW5jbHVkZXMgPSBhcnJheUluY2x1ZGVzV2l0aDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGxlbmd0aCA+PSBMQVJHRV9BUlJBWV9TSVpFKSB7XG4gICAgICAgIHZhciBzZXQgPSBpdGVyYXRlZSA/IG51bGwgOiBjcmVhdGVTZXQoYXJyYXkpO1xuICAgICAgICBpZiAoc2V0KSB7XG4gICAgICAgICAgcmV0dXJuIHNldFRvQXJyYXkoc2V0KTtcbiAgICAgICAgfVxuICAgICAgICBpc0NvbW1vbiA9IGZhbHNlO1xuICAgICAgICBpbmNsdWRlcyA9IGNhY2hlSGFzO1xuICAgICAgICBzZWVuID0gbmV3IFNldENhY2hlO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHNlZW4gPSBpdGVyYXRlZSA/IFtdIDogcmVzdWx0O1xuICAgICAgfVxuICAgICAgb3V0ZXI6XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUpIDogdmFsdWU7XG5cbiAgICAgICAgdmFsdWUgPSAoY29tcGFyYXRvciB8fCB2YWx1ZSAhPT0gMCkgPyB2YWx1ZSA6IDA7XG4gICAgICAgIGlmIChpc0NvbW1vbiAmJiBjb21wdXRlZCA9PT0gY29tcHV0ZWQpIHtcbiAgICAgICAgICB2YXIgc2VlbkluZGV4ID0gc2Vlbi5sZW5ndGg7XG4gICAgICAgICAgd2hpbGUgKHNlZW5JbmRleC0tKSB7XG4gICAgICAgICAgICBpZiAoc2VlbltzZWVuSW5kZXhdID09PSBjb21wdXRlZCkge1xuICAgICAgICAgICAgICBjb250aW51ZSBvdXRlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoIWluY2x1ZGVzKHNlZW4sIGNvbXB1dGVkLCBjb21wYXJhdG9yKSkge1xuICAgICAgICAgIGlmIChzZWVuICE9PSByZXN1bHQpIHtcbiAgICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51bnNldGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHByb3BlcnR5IHBhdGggdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG4gICAgICBvYmplY3QgPSBwYXJlbnQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCB8fCBkZWxldGUgb2JqZWN0W3RvS2V5KGxhc3QocGF0aCkpXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgXy51cGRhdGVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byB1cGRhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gdXBkYXRlciBUaGUgZnVuY3Rpb24gdG8gcHJvZHVjZSB0aGUgdXBkYXRlZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBwYXRoIGNyZWF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVVwZGF0ZShvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIHJldHVybiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdXBkYXRlcihiYXNlR2V0KG9iamVjdCwgcGF0aCkpLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8uZHJvcFdoaWxlYCBhbmQgYF8udGFrZVdoaWxlYFxuICAgICAqIHdpdGhvdXQgc3VwcG9ydCBmb3IgaXRlcmF0ZWUgc2hvcnRoYW5kcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHByZWRpY2F0ZSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRHJvcF0gU3BlY2lmeSBkcm9wcGluZyBlbGVtZW50cyBpbnN0ZWFkIG9mIHRha2luZyB0aGVtLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSwgaXNEcm9wLCBmcm9tUmlnaHQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBmcm9tUmlnaHQgPyBsZW5ndGggOiAtMTtcblxuICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkgJiZcbiAgICAgICAgcHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkge31cblxuICAgICAgcmV0dXJuIGlzRHJvcFxuICAgICAgICA/IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IDAgOiBpbmRleCksIChmcm9tUmlnaHQgPyBpbmRleCArIDEgOiBsZW5ndGgpKVxuICAgICAgICA6IGJhc2VTbGljZShhcnJheSwgKGZyb21SaWdodCA/IGluZGV4ICsgMSA6IDApLCAoZnJvbVJpZ2h0ID8gbGVuZ3RoIDogaW5kZXgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBgd3JhcHBlclZhbHVlYCB3aGljaCByZXR1cm5zIHRoZSByZXN1bHQgb2ZcbiAgICAgKiBwZXJmb3JtaW5nIGEgc2VxdWVuY2Ugb2YgYWN0aW9ucyBvbiB0aGUgdW53cmFwcGVkIGB2YWx1ZWAsIHdoZXJlIGVhY2hcbiAgICAgKiBzdWNjZXNzaXZlIGFjdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdW53cmFwcGVkIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFjdGlvbnMgQWN0aW9ucyB0byBwZXJmb3JtIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVdyYXBwZXJWYWx1ZSh2YWx1ZSwgYWN0aW9ucykge1xuICAgICAgdmFyIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgaWYgKHJlc3VsdCBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHJlc3VsdCA9IHJlc3VsdC52YWx1ZSgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UmVkdWNlKGFjdGlvbnMsIGZ1bmN0aW9uKHJlc3VsdCwgYWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBhY3Rpb24uZnVuYy5hcHBseShhY3Rpb24udGhpc0FyZywgYXJyYXlQdXNoKFtyZXN1bHRdLCBhY3Rpb24uYXJncykpO1xuICAgICAgfSwgcmVzdWx0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGUgYmFzZSBpbXBsZW1lbnRhdGlvbiBvZiBtZXRob2RzIGxpa2UgYF8ueG9yYCwgd2l0aG91dCBzdXBwb3J0IGZvclxuICAgICAqIGl0ZXJhdGVlIHNob3J0aGFuZHMsIHRoYXQgYWNjZXB0cyBhbiBhcnJheSBvZiBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXlzIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWVdIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHZhbHVlcy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBiYXNlWG9yKGFycmF5cywgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VVbmlxKGFycmF5c1swXSkgOiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFycmF5c1tpbmRleF0sXG4gICAgICAgICAgICBvdGhJbmRleCA9IC0xO1xuXG4gICAgICAgIHdoaWxlICgrK290aEluZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKG90aEluZGV4ICE9IGluZGV4KSB7XG4gICAgICAgICAgICByZXN1bHRbaW5kZXhdID0gYmFzZURpZmZlcmVuY2UocmVzdWx0W2luZGV4XSB8fCBhcnJheSwgYXJyYXlzW290aEluZGV4XSwgaXRlcmF0ZWUsIGNvbXBhcmF0b3IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VVbmlxKGJhc2VGbGF0dGVuKHJlc3VsdCwgMSksIGl0ZXJhdGVlLCBjb21wYXJhdG9yKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGJhc2UgaW1wbGVtZW50YXRpb24gb2YgYF8uemlwT2JqZWN0YCB3aGljaCBhc3NpZ25zIHZhbHVlcyB1c2luZyBgYXNzaWduRnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHByb3BzIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25GdW5jIFRoZSBmdW5jdGlvbiB0byBhc3NpZ24gdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmFzZVppcE9iamVjdChwcm9wcywgdmFsdWVzLCBhc3NpZ25GdW5jKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGgsXG4gICAgICAgICAgdmFsc0xlbmd0aCA9IHZhbHVlcy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IGluZGV4IDwgdmFsc0xlbmd0aCA/IHZhbHVlc1tpbmRleF0gOiB1bmRlZmluZWQ7XG4gICAgICAgIGFzc2lnbkZ1bmMocmVzdWx0LCBwcm9wc1tpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYHZhbHVlYCB0byBhbiBlbXB0eSBhcnJheSBpZiBpdCdzIG5vdCBhbiBhcnJheSBsaWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIHRoZSBjYXN0IGFycmF5LWxpa2Ugb2JqZWN0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgdG8gYGlkZW50aXR5YCBpZiBpdCdzIG5vdCBhIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBjYXN0IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNhc3RGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnZnVuY3Rpb24nID8gdmFsdWUgOiBpZGVudGl0eTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDYXN0cyBgdmFsdWVgIHRvIGEgcGF0aCBhcnJheSBpZiBpdCdzIG5vdCBvbmUuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3RdIFRoZSBvYmplY3QgdG8gcXVlcnkga2V5cyBvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3QgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXN0UGF0aCh2YWx1ZSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzS2V5KHZhbHVlLCBvYmplY3QpID8gW3ZhbHVlXSA6IHN0cmluZ1RvUGF0aCh0b1N0cmluZyh2YWx1ZSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgYGJhc2VSZXN0YCBhbGlhcyB3aGljaCBjYW4gYmUgcmVwbGFjZWQgd2l0aCBgaWRlbnRpdHlgIGJ5IG1vZHVsZVxuICAgICAqIHJlcGxhY2VtZW50IHBsdWdpbnMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEB0eXBlIHtGdW5jdGlvbn1cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHZhciBjYXN0UmVzdCA9IGJhc2VSZXN0O1xuXG4gICAgLyoqXG4gICAgICogQ2FzdHMgYGFycmF5YCB0byBhIHNsaWNlIGlmIGl0J3MgbmVlZGVkLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gc3RhcnQgVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNhc3Qgc2xpY2UuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdFNsaWNlKGFycmF5LCBzdGFydCwgZW5kKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgZW5kID0gZW5kID09PSB1bmRlZmluZWQgPyBsZW5ndGggOiBlbmQ7XG4gICAgICByZXR1cm4gKCFzdGFydCAmJiBlbmQgPj0gbGVuZ3RoKSA/IGFycmF5IDogYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNpbXBsZSB3cmFwcGVyIGFyb3VuZCB0aGUgZ2xvYmFsIFtgY2xlYXJUaW1lb3V0YF0oaHR0cHM6Ly9tZG4uaW8vY2xlYXJUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ8T2JqZWN0fSBpZCBUaGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3Qgb2YgdGhlIHRpbWVyIHRvIGNsZWFyLlxuICAgICAqL1xuICAgIHZhciBjbGVhclRpbWVvdXQgPSBjdHhDbGVhclRpbWVvdXQgfHwgZnVuY3Rpb24oaWQpIHtcbiAgICAgIHJldHVybiByb290LmNsZWFyVGltZW91dChpZCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiAgYGJ1ZmZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QnVmZmVyfSBidWZmZXIgVGhlIGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVCdWZmZXIoYnVmZmVyLCBpc0RlZXApIHtcbiAgICAgIGlmIChpc0RlZXApIHtcbiAgICAgICAgcmV0dXJuIGJ1ZmZlci5zbGljZSgpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IGJ1ZmZlci5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gYWxsb2NVbnNhZmUgPyBhbGxvY1Vuc2FmZShsZW5ndGgpIDogbmV3IGJ1ZmZlci5jb25zdHJ1Y3RvcihsZW5ndGgpO1xuXG4gICAgICBidWZmZXIuY29weShyZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYGFycmF5QnVmZmVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheUJ1ZmZlcn0gYXJyYXlCdWZmZXIgVGhlIGFycmF5IGJ1ZmZlciB0byBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXlCdWZmZXJ9IFJldHVybnMgdGhlIGNsb25lZCBhcnJheSBidWZmZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVBcnJheUJ1ZmZlcihhcnJheUJ1ZmZlcikge1xuICAgICAgdmFyIHJlc3VsdCA9IG5ldyBhcnJheUJ1ZmZlci5jb25zdHJ1Y3RvcihhcnJheUJ1ZmZlci5ieXRlTGVuZ3RoKTtcbiAgICAgIG5ldyBVaW50OEFycmF5KHJlc3VsdCkuc2V0KG5ldyBVaW50OEFycmF5KGFycmF5QnVmZmVyKSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgZGF0YVZpZXdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gZGF0YVZpZXcgVGhlIGRhdGEgdmlldyB0byBjbG9uZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtpc0RlZXBdIFNwZWNpZnkgYSBkZWVwIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCBkYXRhIHZpZXcuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVEYXRhVmlldyhkYXRhVmlldywgaXNEZWVwKSB7XG4gICAgICB2YXIgYnVmZmVyID0gaXNEZWVwID8gY2xvbmVBcnJheUJ1ZmZlcihkYXRhVmlldy5idWZmZXIpIDogZGF0YVZpZXcuYnVmZmVyO1xuICAgICAgcmV0dXJuIG5ldyBkYXRhVmlldy5jb25zdHJ1Y3RvcihidWZmZXIsIGRhdGFWaWV3LmJ5dGVPZmZzZXQsIGRhdGFWaWV3LmJ5dGVMZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiBgcmVnZXhwYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHJlZ2V4cCBUaGUgcmVnZXhwIHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNsb25lZCByZWdleHAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVSZWdFeHAocmVnZXhwKSB7XG4gICAgICB2YXIgcmVzdWx0ID0gbmV3IHJlZ2V4cC5jb25zdHJ1Y3RvcihyZWdleHAuc291cmNlLCByZUZsYWdzLmV4ZWMocmVnZXhwKSk7XG4gICAgICByZXN1bHQubGFzdEluZGV4ID0gcmVnZXhwLmxhc3RJbmRleDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIHRoZSBgc3ltYm9sYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzeW1ib2wgVGhlIHN5bWJvbCBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHN5bWJvbCBvYmplY3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVTeW1ib2woc3ltYm9sKSB7XG4gICAgICByZXR1cm4gc3ltYm9sVmFsdWVPZiA/IE9iamVjdChzeW1ib2xWYWx1ZU9mLmNhbGwoc3ltYm9sKSkgOiB7fTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgY2xvbmUgb2YgYHR5cGVkQXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gdHlwZWRBcnJheSBUaGUgdHlwZWQgYXJyYXkgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbaXNEZWVwXSBTcGVjaWZ5IGEgZGVlcCBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjbG9uZWQgdHlwZWQgYXJyYXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVUeXBlZEFycmF5KHR5cGVkQXJyYXksIGlzRGVlcCkge1xuICAgICAgdmFyIGJ1ZmZlciA9IGlzRGVlcCA/IGNsb25lQXJyYXlCdWZmZXIodHlwZWRBcnJheS5idWZmZXIpIDogdHlwZWRBcnJheS5idWZmZXI7XG4gICAgICByZXR1cm4gbmV3IHR5cGVkQXJyYXkuY29uc3RydWN0b3IoYnVmZmVyLCB0eXBlZEFycmF5LmJ5dGVPZmZzZXQsIHR5cGVkQXJyYXkubGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wYXJlcyB2YWx1ZXMgdG8gc29ydCB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgdmFsdWVgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBhcmVBc2NlbmRpbmcodmFsdWUsIG90aGVyKSB7XG4gICAgICBpZiAodmFsdWUgIT09IG90aGVyKSB7XG4gICAgICAgIHZhciB2YWxJc0RlZmluZWQgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgdmFsSXNOdWxsID0gdmFsdWUgPT09IG51bGwsXG4gICAgICAgICAgICB2YWxJc1JlZmxleGl2ZSA9IHZhbHVlID09PSB2YWx1ZSxcbiAgICAgICAgICAgIHZhbElzU3ltYm9sID0gaXNTeW1ib2wodmFsdWUpO1xuXG4gICAgICAgIHZhciBvdGhJc0RlZmluZWQgPSBvdGhlciAhPT0gdW5kZWZpbmVkLFxuICAgICAgICAgICAgb3RoSXNOdWxsID0gb3RoZXIgPT09IG51bGwsXG4gICAgICAgICAgICBvdGhJc1JlZmxleGl2ZSA9IG90aGVyID09PSBvdGhlcixcbiAgICAgICAgICAgIG90aElzU3ltYm9sID0gaXNTeW1ib2wob3RoZXIpO1xuXG4gICAgICAgIGlmICgoIW90aElzTnVsbCAmJiAhb3RoSXNTeW1ib2wgJiYgIXZhbElzU3ltYm9sICYmIHZhbHVlID4gb3RoZXIpIHx8XG4gICAgICAgICAgICAodmFsSXNTeW1ib2wgJiYgb3RoSXNEZWZpbmVkICYmIG90aElzUmVmbGV4aXZlICYmICFvdGhJc051bGwgJiYgIW90aElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKHZhbElzTnVsbCAmJiBvdGhJc0RlZmluZWQgJiYgb3RoSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIXZhbElzRGVmaW5lZCAmJiBvdGhJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICF2YWxJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoIXZhbElzTnVsbCAmJiAhdmFsSXNTeW1ib2wgJiYgIW90aElzU3ltYm9sICYmIHZhbHVlIDwgb3RoZXIpIHx8XG4gICAgICAgICAgICAob3RoSXNTeW1ib2wgJiYgdmFsSXNEZWZpbmVkICYmIHZhbElzUmVmbGV4aXZlICYmICF2YWxJc051bGwgJiYgIXZhbElzU3ltYm9sKSB8fFxuICAgICAgICAgICAgKG90aElzTnVsbCAmJiB2YWxJc0RlZmluZWQgJiYgdmFsSXNSZWZsZXhpdmUpIHx8XG4gICAgICAgICAgICAoIW90aElzRGVmaW5lZCAmJiB2YWxJc1JlZmxleGl2ZSkgfHxcbiAgICAgICAgICAgICFvdGhJc1JlZmxleGl2ZSkge1xuICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5vcmRlckJ5YCB0byBjb21wYXJlIG11bHRpcGxlIHByb3BlcnRpZXMgb2YgYSB2YWx1ZSB0byBhbm90aGVyXG4gICAgICogYW5kIHN0YWJsZSBzb3J0IHRoZW0uXG4gICAgICpcbiAgICAgKiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlcyBhcmUgc29ydGVkIGluIGFzY2VuZGluZyBvcmRlci4gT3RoZXJ3aXNlLFxuICAgICAqIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yIGRlc2NlbmRpbmcgb3IgXCJhc2NcIiBmb3IgYXNjZW5kaW5nIHNvcnQgb3JkZXJcbiAgICAgKiBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG90aGVyIFRoZSBvdGhlciBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW5bXXxzdHJpbmdbXX0gb3JkZXJzIFRoZSBvcmRlciB0byBzb3J0IGJ5IGZvciBlYWNoIHByb3BlcnR5LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHNvcnQgb3JkZXIgaW5kaWNhdG9yIGZvciBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wYXJlTXVsdGlwbGUob2JqZWN0LCBvdGhlciwgb3JkZXJzKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBvYmpDcml0ZXJpYSA9IG9iamVjdC5jcml0ZXJpYSxcbiAgICAgICAgICBvdGhDcml0ZXJpYSA9IG90aGVyLmNyaXRlcmlhLFxuICAgICAgICAgIGxlbmd0aCA9IG9iakNyaXRlcmlhLmxlbmd0aCxcbiAgICAgICAgICBvcmRlcnNMZW5ndGggPSBvcmRlcnMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gY29tcGFyZUFzY2VuZGluZyhvYmpDcml0ZXJpYVtpbmRleF0sIG90aENyaXRlcmlhW2luZGV4XSk7XG4gICAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgICBpZiAoaW5kZXggPj0gb3JkZXJzTGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgIH1cbiAgICAgICAgICB2YXIgb3JkZXIgPSBvcmRlcnNbaW5kZXhdO1xuICAgICAgICAgIHJldHVybiByZXN1bHQgKiAob3JkZXIgPT0gJ2Rlc2MnID8gLTEgOiAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgLy8gRml4ZXMgYW4gYEFycmF5I3NvcnRgIGJ1ZyBpbiB0aGUgSlMgZW5naW5lIGVtYmVkZGVkIGluIEFkb2JlIGFwcGxpY2F0aW9uc1xuICAgICAgLy8gdGhhdCBjYXVzZXMgaXQsIHVuZGVyIGNlcnRhaW4gY2lyY3Vtc3RhbmNlcywgdG8gcHJvdmlkZSB0aGUgc2FtZSB2YWx1ZSBmb3JcbiAgICAgIC8vIGBvYmplY3RgIGFuZCBgb3RoZXJgLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2phc2hrZW5hcy91bmRlcnNjb3JlL3B1bGwvMTI0N1xuICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIGFsc28gZW5zdXJlcyBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzLlxuICAgICAgLy8gU2VlIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTkwIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICByZXR1cm4gb2JqZWN0LmluZGV4IC0gb3RoZXIuaW5kZXg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB0aGF0IGlzIHRoZSBjb21wb3NpdGlvbiBvZiBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMsXG4gICAgICogcGxhY2Vob2xkZXJzLCBhbmQgcHJvdmlkZWQgYXJndW1lbnRzIGludG8gYSBzaW5nbGUgYXJyYXkgb2YgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGhvbGRlcnMgVGhlIGBwYXJ0aWFsc2AgcGxhY2Vob2xkZXIgaW5kZXhlcy5cbiAgICAgKiBAcGFyYW1zIHtib29sZWFufSBbaXNDdXJyaWVkXSBTcGVjaWZ5IGNvbXBvc2luZyBmb3IgYSBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbXBvc2VkIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKSB7XG4gICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICAgIGhvbGRlcnNMZW5ndGggPSBob2xkZXJzLmxlbmd0aCxcbiAgICAgICAgICBsZWZ0SW5kZXggPSAtMSxcbiAgICAgICAgICBsZWZ0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShsZWZ0TGVuZ3RoICsgcmFuZ2VMZW5ndGgpLFxuICAgICAgICAgIGlzVW5jdXJyaWVkID0gIWlzQ3VycmllZDtcblxuICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICByZXN1bHRbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICB9XG4gICAgICB3aGlsZSAoKythcmdzSW5kZXggPCBob2xkZXJzTGVuZ3RoKSB7XG4gICAgICAgIGlmIChpc1VuY3VycmllZCB8fCBhcmdzSW5kZXggPCBhcmdzTGVuZ3RoKSB7XG4gICAgICAgICAgcmVzdWx0W2hvbGRlcnNbYXJnc0luZGV4XV0gPSBhcmdzW2FyZ3NJbmRleF07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChyYW5nZUxlbmd0aC0tKSB7XG4gICAgICAgIHJlc3VsdFtsZWZ0SW5kZXgrK10gPSBhcmdzW2FyZ3NJbmRleCsrXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBmdW5jdGlvbiBpcyBsaWtlIGBjb21wb3NlQXJnc2AgZXhjZXB0IHRoYXQgdGhlIGFyZ3VtZW50cyBjb21wb3NpdGlvblxuICAgICAqIGlzIHRhaWxvcmVkIGZvciBgXy5wYXJ0aWFsUmlnaHRgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcmdzIFRoZSBwcm92aWRlZCBhcmd1bWVudHMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBhcHBlbmQgdG8gdGhvc2UgcHJvdmlkZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gaG9sZGVycyBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbXMge2Jvb2xlYW59IFtpc0N1cnJpZWRdIFNwZWNpZnkgY29tcG9zaW5nIGZvciBhIGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgY29tcG9zZWQgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbXBvc2VBcmdzUmlnaHQoYXJncywgcGFydGlhbHMsIGhvbGRlcnMsIGlzQ3VycmllZCkge1xuICAgICAgdmFyIGFyZ3NJbmRleCA9IC0xLFxuICAgICAgICAgIGFyZ3NMZW5ndGggPSBhcmdzLmxlbmd0aCxcbiAgICAgICAgICBob2xkZXJzSW5kZXggPSAtMSxcbiAgICAgICAgICBob2xkZXJzTGVuZ3RoID0gaG9sZGVycy5sZW5ndGgsXG4gICAgICAgICAgcmlnaHRJbmRleCA9IC0xLFxuICAgICAgICAgIHJpZ2h0TGVuZ3RoID0gcGFydGlhbHMubGVuZ3RoLFxuICAgICAgICAgIHJhbmdlTGVuZ3RoID0gbmF0aXZlTWF4KGFyZ3NMZW5ndGggLSBob2xkZXJzTGVuZ3RoLCAwKSxcbiAgICAgICAgICByZXN1bHQgPSBBcnJheShyYW5nZUxlbmd0aCArIHJpZ2h0TGVuZ3RoKSxcbiAgICAgICAgICBpc1VuY3VycmllZCA9ICFpc0N1cnJpZWQ7XG5cbiAgICAgIHdoaWxlICgrK2FyZ3NJbmRleCA8IHJhbmdlTGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFthcmdzSW5kZXhdID0gYXJnc1thcmdzSW5kZXhdO1xuICAgICAgfVxuICAgICAgdmFyIG9mZnNldCA9IGFyZ3NJbmRleDtcbiAgICAgIHdoaWxlICgrK3JpZ2h0SW5kZXggPCByaWdodExlbmd0aCkge1xuICAgICAgICByZXN1bHRbb2Zmc2V0ICsgcmlnaHRJbmRleF0gPSBwYXJ0aWFsc1tyaWdodEluZGV4XTtcbiAgICAgIH1cbiAgICAgIHdoaWxlICgrK2hvbGRlcnNJbmRleCA8IGhvbGRlcnNMZW5ndGgpIHtcbiAgICAgICAgaWYgKGlzVW5jdXJyaWVkIHx8IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGgpIHtcbiAgICAgICAgICByZXN1bHRbb2Zmc2V0ICsgaG9sZGVyc1tob2xkZXJzSW5kZXhdXSA9IGFyZ3NbYXJnc0luZGV4KytdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyB0aGUgdmFsdWVzIG9mIGBzb3VyY2VgIHRvIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHNvdXJjZSBUaGUgYXJyYXkgdG8gY29weSB2YWx1ZXMgZnJvbS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbYXJyYXk9W11dIFRoZSBhcnJheSB0byBjb3B5IHZhbHVlcyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYGFycmF5YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5QXJyYXkoc291cmNlLCBhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gc291cmNlLmxlbmd0aDtcblxuICAgICAgYXJyYXkgfHwgKGFycmF5ID0gQXJyYXkobGVuZ3RoKSk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBhcnJheVtpbmRleF0gPSBzb3VyY2VbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBwcm9wZXJ0aWVzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIGZyb20uXG4gICAgICogQHBhcmFtIHtBcnJheX0gcHJvcHMgVGhlIHByb3BlcnR5IGlkZW50aWZpZXJzIHRvIGNvcHkuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBwcm9wZXJ0aWVzIHRvLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNvcGllZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjb3B5T2JqZWN0KHNvdXJjZSwgcHJvcHMsIG9iamVjdCwgY3VzdG9taXplcikge1xuICAgICAgdmFyIGlzTmV3ID0gIW9iamVjdDtcbiAgICAgIG9iamVjdCB8fCAob2JqZWN0ID0ge30pO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBrZXkgPSBwcm9wc1tpbmRleF07XG5cbiAgICAgICAgdmFyIG5ld1ZhbHVlID0gY3VzdG9taXplclxuICAgICAgICAgID8gY3VzdG9taXplcihvYmplY3Rba2V5XSwgc291cmNlW2tleV0sIGtleSwgb2JqZWN0LCBzb3VyY2UpXG4gICAgICAgICAgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgaWYgKG5ld1ZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBuZXdWYWx1ZSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpc05ldykge1xuICAgICAgICAgIGJhc2VBc3NpZ25WYWx1ZShvYmplY3QsIGtleSwgbmV3VmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBuZXdWYWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29waWVzIG93biBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHMoc291cmNlLCBvYmplY3QpIHtcbiAgICAgIHJldHVybiBjb3B5T2JqZWN0KHNvdXJjZSwgZ2V0U3ltYm9scyhzb3VyY2UpLCBvYmplY3QpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvcGllcyBvd24gYW5kIGluaGVyaXRlZCBzeW1ib2xzIG9mIGBzb3VyY2VgIHRvIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtvYmplY3Q9e31dIFRoZSBvYmplY3QgdG8gY29weSBzeW1ib2xzIHRvLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29weVN5bWJvbHNJbihzb3VyY2UsIG9iamVjdCkge1xuICAgICAgcmV0dXJuIGNvcHlPYmplY3Qoc291cmNlLCBnZXRTeW1ib2xzSW4oc291cmNlKSwgb2JqZWN0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5ncm91cEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpbml0aWFsaXplcl0gVGhlIGFjY3VtdWxhdG9yIG9iamVjdCBpbml0aWFsaXplci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhZ2dyZWdhdG9yIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUFnZ3JlZ2F0b3Ioc2V0dGVyLCBpbml0aWFsaXplcikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5QWdncmVnYXRvciA6IGJhc2VBZ2dyZWdhdG9yLFxuICAgICAgICAgICAgYWNjdW11bGF0b3IgPSBpbml0aWFsaXplciA/IGluaXRpYWxpemVyKCkgOiB7fTtcblxuICAgICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBzZXR0ZXIsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYWNjdW11bGF0b3IpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5hc3NpZ25gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBhc3NpZ25lciBUaGUgZnVuY3Rpb24gdG8gYXNzaWduIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhc3NpZ25lciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVBc3NpZ25lcihhc3NpZ25lcikge1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKG9iamVjdCwgc291cmNlcykge1xuICAgICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHNvdXJjZXMubGVuZ3RoLFxuICAgICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA+IDEgPyBzb3VyY2VzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkLFxuICAgICAgICAgICAgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgICBjdXN0b21pemVyID0gKGFzc2lnbmVyLmxlbmd0aCA+IDMgJiYgdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICA/IChsZW5ndGgtLSwgY3VzdG9taXplcilcbiAgICAgICAgICA6IHVuZGVmaW5lZDtcblxuICAgICAgICBpZiAoZ3VhcmQgJiYgaXNJdGVyYXRlZUNhbGwoc291cmNlc1swXSwgc291cmNlc1sxXSwgZ3VhcmQpKSB7XG4gICAgICAgICAgY3VzdG9taXplciA9IGxlbmd0aCA8IDMgPyB1bmRlZmluZWQgOiBjdXN0b21pemVyO1xuICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gT2JqZWN0KG9iamVjdCk7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHNvdXJjZSA9IHNvdXJjZXNbaW5kZXhdO1xuICAgICAgICAgIGlmIChzb3VyY2UpIHtcbiAgICAgICAgICAgIGFzc2lnbmVyKG9iamVjdCwgc291cmNlLCBpbmRleCwgY3VzdG9taXplcik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYGJhc2VFYWNoYCBvciBgYmFzZUVhY2hSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhY2hGdW5jIFRoZSBmdW5jdGlvbiB0byBpdGVyYXRlIG92ZXIgYSBjb2xsZWN0aW9uLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJhc2UgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmFzZUVhY2goZWFjaEZ1bmMsIGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gY29sbGVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzQXJyYXlMaWtlKGNvbGxlY3Rpb24pKSB7XG4gICAgICAgICAgcmV0dXJuIGVhY2hGdW5jKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbGVuZ3RoID0gY29sbGVjdGlvbi5sZW5ndGgsXG4gICAgICAgICAgICBpbmRleCA9IGZyb21SaWdodCA/IGxlbmd0aCA6IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG5cbiAgICAgICAgd2hpbGUgKChmcm9tUmlnaHQgPyBpbmRleC0tIDogKytpbmRleCA8IGxlbmd0aCkpIHtcbiAgICAgICAgICBpZiAoaXRlcmF0ZWUoaXRlcmFibGVbaW5kZXhdLCBpbmRleCwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgYmFzZSBmdW5jdGlvbiBmb3IgbWV0aG9kcyBsaWtlIGBfLmZvckluYCBhbmQgYF8uZm9yT3duYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbZnJvbVJpZ2h0XSBTcGVjaWZ5IGl0ZXJhdGluZyBmcm9tIHJpZ2h0IHRvIGxlZnQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYmFzZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVCYXNlRm9yKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUsIGtleXNGdW5jKSB7XG4gICAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgICAgaXRlcmFibGUgPSBPYmplY3Qob2JqZWN0KSxcbiAgICAgICAgICAgIHByb3BzID0ga2V5c0Z1bmMob2JqZWN0KSxcbiAgICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgICB2YXIga2V5ID0gcHJvcHNbZnJvbVJpZ2h0ID8gbGVuZ3RoIDogKytpbmRleF07XG4gICAgICAgICAgaWYgKGl0ZXJhdGVlKGl0ZXJhYmxlW2tleV0sIGtleSwgaXRlcmFibGUpID09PSBmYWxzZSkge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBvYmplY3Q7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBpbnZva2UgaXQgd2l0aCB0aGUgb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQmluZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgZm4gPSAodGhpcyAmJiB0aGlzICE9PSByb290ICYmIHRoaXMgaW5zdGFuY2VvZiB3cmFwcGVyKSA/IEN0b3IgOiBmdW5jO1xuICAgICAgICByZXR1cm4gZm4uYXBwbHkoaXNCaW5kID8gdGhpc0FyZyA6IHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gd3JhcHBlcjtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5sb3dlckZpcnN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBTdHJpbmdgIGNhc2UgbWV0aG9kIHRvIHVzZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXNlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUNhc2VGaXJzdChtZXRob2ROYW1lKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG5cbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBoYXNVbmljb2RlKHN0cmluZylcbiAgICAgICAgICA/IHN0cmluZ1RvQXJyYXkoc3RyaW5nKVxuICAgICAgICAgIDogdW5kZWZpbmVkO1xuXG4gICAgICAgIHZhciBjaHIgPSBzdHJTeW1ib2xzXG4gICAgICAgICAgPyBzdHJTeW1ib2xzWzBdXG4gICAgICAgICAgOiBzdHJpbmcuY2hhckF0KDApO1xuXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHN0clN5bWJvbHNcbiAgICAgICAgICA/IGNhc3RTbGljZShzdHJTeW1ib2xzLCAxKS5qb2luKCcnKVxuICAgICAgICAgIDogc3RyaW5nLnNsaWNlKDEpO1xuXG4gICAgICAgIHJldHVybiBjaHJbbWV0aG9kTmFtZV0oKSArIHRyYWlsaW5nO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gbGlrZSBgXy5jYW1lbENhc2VgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gdG8gY29tYmluZSBlYWNoIHdvcmQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG91bmRlciBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVDb21wb3VuZGVyKGNhbGxiYWNrKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICAgIHJldHVybiBhcnJheVJlZHVjZSh3b3JkcyhkZWJ1cnIoc3RyaW5nKS5yZXBsYWNlKHJlQXBvcywgJycpKSwgY2FsbGJhY2ssICcnKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcHJvZHVjZXMgYW4gaW5zdGFuY2Ugb2YgYEN0b3JgIHJlZ2FyZGxlc3Mgb2ZcbiAgICAgKiB3aGV0aGVyIGl0IHdhcyBpbnZva2VkIGFzIHBhcnQgb2YgYSBgbmV3YCBleHByZXNzaW9uIG9yIGJ5IGBjYWxsYCBvciBgYXBwbHlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBDdG9yIFRoZSBjb25zdHJ1Y3RvciB0byB3cmFwLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlQ3RvcihDdG9yKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIC8vIFVzZSBhIGBzd2l0Y2hgIHN0YXRlbWVudCB0byB3b3JrIHdpdGggY2xhc3MgY29uc3RydWN0b3JzLiBTZWVcbiAgICAgICAgLy8gaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtZWNtYXNjcmlwdC1mdW5jdGlvbi1vYmplY3RzLWNhbGwtdGhpc2FyZ3VtZW50LWFyZ3VtZW50c2xpc3RcbiAgICAgICAgLy8gZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIHN3aXRjaCAoYXJncy5sZW5ndGgpIHtcbiAgICAgICAgICBjYXNlIDA6IHJldHVybiBuZXcgQ3RvcjtcbiAgICAgICAgICBjYXNlIDE6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBjYXNlIDM6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBjYXNlIDQ6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdKTtcbiAgICAgICAgICBjYXNlIDU6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdKTtcbiAgICAgICAgICBjYXNlIDY6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBjYXNlIDc6IHJldHVybiBuZXcgQ3RvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdLCBhcmdzWzZdKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgdGhpc0JpbmRpbmcgPSBiYXNlQ3JlYXRlKEN0b3IucHJvdG90eXBlKSxcbiAgICAgICAgICAgIHJlc3VsdCA9IEN0b3IuYXBwbHkodGhpc0JpbmRpbmcsIGFyZ3MpO1xuXG4gICAgICAgIC8vIE1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yLlxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9lczUuZ2l0aHViLmlvLyN4MTMuMi4yIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpID8gcmVzdWx0IDogdGhpc0JpbmRpbmc7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdyYXBzIGBmdW5jYCB0byBlbmFibGUgY3VycnlpbmcuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYXJpdHkgVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUN1cnJ5KGZ1bmMsIGJpdG1hc2ssIGFyaXR5KSB7XG4gICAgICB2YXIgQ3RvciA9IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aCxcbiAgICAgICAgICAgIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpO1xuXG4gICAgICAgIHdoaWxlIChpbmRleC0tKSB7XG4gICAgICAgICAgYXJnc1tpbmRleF0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBob2xkZXJzID0gKGxlbmd0aCA8IDMgJiYgYXJnc1swXSAhPT0gcGxhY2Vob2xkZXIgJiYgYXJnc1tsZW5ndGggLSAxXSAhPT0gcGxhY2Vob2xkZXIpXG4gICAgICAgICAgPyBbXVxuICAgICAgICAgIDogcmVwbGFjZUhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuXG4gICAgICAgIGxlbmd0aCAtPSBob2xkZXJzLmxlbmd0aDtcbiAgICAgICAgaWYgKGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGFyZ3MsIGhvbGRlcnMsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSAtIGxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZuID0gKHRoaXMgJiYgdGhpcyAhPT0gcm9vdCAmJiB0aGlzIGluc3RhbmNlb2Ygd3JhcHBlcikgPyBDdG9yIDogZnVuYztcbiAgICAgICAgcmV0dXJuIGFwcGx5KGZuLCB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5maW5kYCBvciBgXy5maW5kTGFzdGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZpbmRJbmRleEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGZpbmQgdGhlIGNvbGxlY3Rpb24gaW5kZXguXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmluZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVGaW5kKGZpbmRJbmRleEZ1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgICB2YXIgaXRlcmFibGUgPSBPYmplY3QoY29sbGVjdGlvbik7XG4gICAgICAgIGlmICghaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgICB2YXIgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpO1xuICAgICAgICAgIGNvbGxlY3Rpb24gPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgICAgIHByZWRpY2F0ZSA9IGZ1bmN0aW9uKGtleSkgeyByZXR1cm4gaXRlcmF0ZWUoaXRlcmFibGVba2V5XSwga2V5LCBpdGVyYWJsZSk7IH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGluZGV4ID0gZmluZEluZGV4RnVuYyhjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGZyb21JbmRleCk7XG4gICAgICAgIHJldHVybiBpbmRleCA+IC0xID8gaXRlcmFibGVbaXRlcmF0ZWUgPyBjb2xsZWN0aW9uW2luZGV4XSA6IGluZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGBfLmZsb3dgIG9yIGBfLmZsb3dSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZsb3cgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlRmxvdyhmcm9tUmlnaHQpIHtcbiAgICAgIHJldHVybiBmbGF0UmVzdChmdW5jdGlvbihmdW5jcykge1xuICAgICAgICB2YXIgbGVuZ3RoID0gZnVuY3MubGVuZ3RoLFxuICAgICAgICAgICAgaW5kZXggPSBsZW5ndGgsXG4gICAgICAgICAgICBwcmVyZXEgPSBMb2Rhc2hXcmFwcGVyLnByb3RvdHlwZS50aHJ1O1xuXG4gICAgICAgIGlmIChmcm9tUmlnaHQpIHtcbiAgICAgICAgICBmdW5jcy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgICB2YXIgZnVuYyA9IGZ1bmNzW2luZGV4XTtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocHJlcmVxICYmICF3cmFwcGVyICYmIGdldEZ1bmNOYW1lKGZ1bmMpID09ICd3cmFwcGVyJykge1xuICAgICAgICAgICAgdmFyIHdyYXBwZXIgPSBuZXcgTG9kYXNoV3JhcHBlcihbXSwgdHJ1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gd3JhcHBlciA/IGluZGV4IDogbGVuZ3RoO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGZ1bmMgPSBmdW5jc1tpbmRleF07XG5cbiAgICAgICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICAgICAgZGF0YSA9IGZ1bmNOYW1lID09ICd3cmFwcGVyJyA/IGdldERhdGEoZnVuYykgOiB1bmRlZmluZWQ7XG5cbiAgICAgICAgICBpZiAoZGF0YSAmJiBpc0xhemlhYmxlKGRhdGFbMF0pICYmXG4gICAgICAgICAgICAgICAgZGF0YVsxXSA9PSAoV1JBUF9BUllfRkxBRyB8IFdSQVBfQ1VSUllfRkxBRyB8IFdSQVBfUEFSVElBTF9GTEFHIHwgV1JBUF9SRUFSR19GTEFHKSAmJlxuICAgICAgICAgICAgICAgICFkYXRhWzRdLmxlbmd0aCAmJiBkYXRhWzldID09IDFcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICB3cmFwcGVyID0gd3JhcHBlcltnZXRGdW5jTmFtZShkYXRhWzBdKV0uYXBwbHkod3JhcHBlciwgZGF0YVszXSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHdyYXBwZXIgPSAoZnVuYy5sZW5ndGggPT0gMSAmJiBpc0xhemlhYmxlKGZ1bmMpKVxuICAgICAgICAgICAgICA/IHdyYXBwZXJbZnVuY05hbWVdKClcbiAgICAgICAgICAgICAgOiB3cmFwcGVyLnRocnUoZnVuYyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgICAgdmFsdWUgPSBhcmdzWzBdO1xuXG4gICAgICAgICAgaWYgKHdyYXBwZXIgJiYgYXJncy5sZW5ndGggPT0gMSAmJiBpc0FycmF5KHZhbHVlKSkge1xuICAgICAgICAgICAgcmV0dXJuIHdyYXBwZXIucGxhbnQodmFsdWUpLnZhbHVlKCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgICAgIHJlc3VsdCA9IGxlbmd0aCA/IGZ1bmNzW2luZGV4XS5hcHBseSh0aGlzLCBhcmdzKSA6IHZhbHVlO1xuXG4gICAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZ1bmNzW2luZGV4XS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH07XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggb3B0aW9uYWwgYHRoaXNgXG4gICAgICogYmluZGluZyBvZiBgdGhpc0FyZ2AsIHBhcnRpYWwgYXBwbGljYXRpb24sIGFuZCBjdXJyeWluZy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0geyp9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW3BhcnRpYWxzUmlnaHRdIFRoZSBhcmd1bWVudHMgdG8gYXBwZW5kIHRvIHRob3NlIHByb3ZpZGVkXG4gICAgICogIHRvIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNSaWdodF0gVGhlIGBwYXJ0aWFsc1JpZ2h0YCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUh5YnJpZChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgcGFydGlhbHNSaWdodCwgaG9sZGVyc1JpZ2h0LCBhcmdQb3MsIGFyeSwgYXJpdHkpIHtcbiAgICAgIHZhciBpc0FyeSA9IGJpdG1hc2sgJiBXUkFQX0FSWV9GTEFHLFxuICAgICAgICAgIGlzQmluZCA9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyxcbiAgICAgICAgICBpc0JpbmRLZXkgPSBiaXRtYXNrICYgV1JBUF9CSU5EX0tFWV9GTEFHLFxuICAgICAgICAgIGlzQ3VycmllZCA9IGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSxcbiAgICAgICAgICBpc0ZsaXAgPSBiaXRtYXNrICYgV1JBUF9GTElQX0ZMQUcsXG4gICAgICAgICAgQ3RvciA9IGlzQmluZEtleSA/IHVuZGVmaW5lZCA6IGNyZWF0ZUN0b3IoZnVuYyk7XG5cbiAgICAgIGZ1bmN0aW9uIHdyYXBwZXIoKSB7XG4gICAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuICAgICAgICAgICAgYXJncyA9IEFycmF5KGxlbmd0aCksXG4gICAgICAgICAgICBpbmRleCA9IGxlbmd0aDtcblxuICAgICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gYXJndW1lbnRzW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNDdXJyaWVkKSB7XG4gICAgICAgICAgdmFyIHBsYWNlaG9sZGVyID0gZ2V0SG9sZGVyKHdyYXBwZXIpLFxuICAgICAgICAgICAgICBob2xkZXJzQ291bnQgPSBjb3VudEhvbGRlcnMoYXJncywgcGxhY2Vob2xkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwYXJ0aWFscykge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJncyhhcmdzLCBwYXJ0aWFscywgaG9sZGVycywgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGFydGlhbHNSaWdodCkge1xuICAgICAgICAgIGFyZ3MgPSBjb21wb3NlQXJnc1JpZ2h0KGFyZ3MsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCwgaXNDdXJyaWVkKTtcbiAgICAgICAgfVxuICAgICAgICBsZW5ndGggLT0gaG9sZGVyc0NvdW50O1xuICAgICAgICBpZiAoaXNDdXJyaWVkICYmIGxlbmd0aCA8IGFyaXR5KSB7XG4gICAgICAgICAgdmFyIG5ld0hvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhhcmdzLCBwbGFjZWhvbGRlcik7XG4gICAgICAgICAgcmV0dXJuIGNyZWF0ZVJlY3VycnkoXG4gICAgICAgICAgICBmdW5jLCBiaXRtYXNrLCBjcmVhdGVIeWJyaWQsIHdyYXBwZXIucGxhY2Vob2xkZXIsIHRoaXNBcmcsXG4gICAgICAgICAgICBhcmdzLCBuZXdIb2xkZXJzLCBhcmdQb3MsIGFyeSwgYXJpdHkgLSBsZW5ndGhcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIHZhciB0aGlzQmluZGluZyA9IGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLFxuICAgICAgICAgICAgZm4gPSBpc0JpbmRLZXkgPyB0aGlzQmluZGluZ1tmdW5jXSA6IGZ1bmM7XG5cbiAgICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgICAgIGlmIChhcmdQb3MpIHtcbiAgICAgICAgICBhcmdzID0gcmVvcmRlcihhcmdzLCBhcmdQb3MpO1xuICAgICAgICB9IGVsc2UgaWYgKGlzRmxpcCAmJiBsZW5ndGggPiAxKSB7XG4gICAgICAgICAgYXJncy5yZXZlcnNlKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzQXJ5ICYmIGFyeSA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3MubGVuZ3RoID0gYXJ5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpIHtcbiAgICAgICAgICBmbiA9IEN0b3IgfHwgY3JlYXRlQ3Rvcihmbik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KHRoaXNCaW5kaW5nLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLmludmVydEJ5YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gc2V0dGVyIFRoZSBmdW5jdGlvbiB0byBzZXQgYWNjdW11bGF0b3IgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRvSXRlcmF0ZWUgVGhlIGZ1bmN0aW9uIHRvIHJlc29sdmUgaXRlcmF0ZWVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludmVydGVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZUludmVydGVyKHNldHRlciwgdG9JdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZlcnRlcihvYmplY3QsIHNldHRlciwgdG9JdGVyYXRlZShpdGVyYXRlZSksIHt9KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBtYXRoZW1hdGljYWwgb3BlcmF0aW9uIG9uIHR3byB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IG9wZXJhdG9yIFRoZSBmdW5jdGlvbiB0byBwZXJmb3JtIHRoZSBvcGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtkZWZhdWx0VmFsdWVdIFRoZSB2YWx1ZSB1c2VkIGZvciBgdW5kZWZpbmVkYCBhcmd1bWVudHMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWF0aGVtYXRpY2FsIG9wZXJhdGlvbiBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVNYXRoT3BlcmF0aW9uKG9wZXJhdG9yLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgdmFyIHJlc3VsdDtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgJiYgb3RoZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3RoZXIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmIChyZXN1bHQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgcmV0dXJuIG90aGVyO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdmFsdWUgPSBiYXNlVG9TdHJpbmcodmFsdWUpO1xuICAgICAgICAgICAgb3RoZXIgPSBiYXNlVG9TdHJpbmcob3RoZXIpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB2YWx1ZSA9IGJhc2VUb051bWJlcih2YWx1ZSk7XG4gICAgICAgICAgICBvdGhlciA9IGJhc2VUb051bWJlcihvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJlc3VsdCA9IG9wZXJhdG9yKHZhbHVlLCBvdGhlcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIGxpa2UgYF8ub3ZlcmAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGFycmF5RnVuYyBUaGUgZnVuY3Rpb24gdG8gaXRlcmF0ZSBvdmVyIGl0ZXJhdGVlcy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBvdmVyIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZU92ZXIoYXJyYXlGdW5jKSB7XG4gICAgICByZXR1cm4gZmxhdFJlc3QoZnVuY3Rpb24oaXRlcmF0ZWVzKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IGFycmF5TWFwKGl0ZXJhdGVlcywgYmFzZVVuYXJ5KGdldEl0ZXJhdGVlKCkpKTtcbiAgICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgICB2YXIgdGhpc0FyZyA9IHRoaXM7XG4gICAgICAgICAgcmV0dXJuIGFycmF5RnVuYyhpdGVyYXRlZXMsIGZ1bmN0aW9uKGl0ZXJhdGVlKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgdGhlIHBhZGRpbmcgZm9yIGBzdHJpbmdgIGJhc2VkIG9uIGBsZW5ndGhgLiBUaGUgYGNoYXJzYCBzdHJpbmdcbiAgICAgKiBpcyB0cnVuY2F0ZWQgaWYgdGhlIG51bWJlciBvZiBjaGFyYWN0ZXJzIGV4Y2VlZHMgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBsZW5ndGggVGhlIHBhZGRpbmcgbGVuZ3RoLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9JyAnXSBUaGUgc3RyaW5nIHVzZWQgYXMgcGFkZGluZy5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBwYWRkaW5nIGZvciBgc3RyaW5nYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYWRkaW5nKGxlbmd0aCwgY2hhcnMpIHtcbiAgICAgIGNoYXJzID0gY2hhcnMgPT09IHVuZGVmaW5lZCA/ICcgJyA6IGJhc2VUb1N0cmluZyhjaGFycyk7XG5cbiAgICAgIHZhciBjaGFyc0xlbmd0aCA9IGNoYXJzLmxlbmd0aDtcbiAgICAgIGlmIChjaGFyc0xlbmd0aCA8IDIpIHtcbiAgICAgICAgcmV0dXJuIGNoYXJzTGVuZ3RoID8gYmFzZVJlcGVhdChjaGFycywgbGVuZ3RoKSA6IGNoYXJzO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IGJhc2VSZXBlYXQoY2hhcnMsIG5hdGl2ZUNlaWwobGVuZ3RoIC8gc3RyaW5nU2l6ZShjaGFycykpKTtcbiAgICAgIHJldHVybiBoYXNVbmljb2RlKGNoYXJzKVxuICAgICAgICA/IGNhc3RTbGljZShzdHJpbmdUb0FycmF5KHJlc3VsdCksIDAsIGxlbmd0aCkuam9pbignJylcbiAgICAgICAgOiByZXN1bHQuc2xpY2UoMCwgbGVuZ3RoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCB3cmFwcyBgZnVuY2AgdG8gaW52b2tlIGl0IHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nXG4gICAgICogb2YgYHRoaXNBcmdgIGFuZCBgcGFydGlhbHNgIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHsqfSB0aGlzQXJnIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFydGlhbHMgVGhlIGFyZ3VtZW50cyB0byBwcmVwZW5kIHRvIHRob3NlIHByb3ZpZGVkIHRvXG4gICAgICogIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgd3JhcHBlZCBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjcmVhdGVQYXJ0aWFsKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgaXNCaW5kID0gYml0bWFzayAmIFdSQVBfQklORF9GTEFHLFxuICAgICAgICAgIEN0b3IgPSBjcmVhdGVDdG9yKGZ1bmMpO1xuXG4gICAgICBmdW5jdGlvbiB3cmFwcGVyKCkge1xuICAgICAgICB2YXIgYXJnc0luZGV4ID0gLTEsXG4gICAgICAgICAgICBhcmdzTGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCxcbiAgICAgICAgICAgIGxlZnRJbmRleCA9IC0xLFxuICAgICAgICAgICAgbGVmdExlbmd0aCA9IHBhcnRpYWxzLmxlbmd0aCxcbiAgICAgICAgICAgIGFyZ3MgPSBBcnJheShsZWZ0TGVuZ3RoICsgYXJnc0xlbmd0aCksXG4gICAgICAgICAgICBmbiA9ICh0aGlzICYmIHRoaXMgIT09IHJvb3QgJiYgdGhpcyBpbnN0YW5jZW9mIHdyYXBwZXIpID8gQ3RvciA6IGZ1bmM7XG5cbiAgICAgICAgd2hpbGUgKCsrbGVmdEluZGV4IDwgbGVmdExlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4XSA9IHBhcnRpYWxzW2xlZnRJbmRleF07XG4gICAgICAgIH1cbiAgICAgICAgd2hpbGUgKGFyZ3NMZW5ndGgtLSkge1xuICAgICAgICAgIGFyZ3NbbGVmdEluZGV4KytdID0gYXJndW1lbnRzWysrYXJnc0luZGV4XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXBwbHkoZm4sIGlzQmluZCA/IHRoaXNBcmcgOiB0aGlzLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB3cmFwcGVyO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy5yYW5nZWAgb3IgYF8ucmFuZ2VSaWdodGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2Zyb21SaWdodF0gU3BlY2lmeSBpdGVyYXRpbmcgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJhbmdlIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJhbmdlKGZyb21SaWdodCkge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICAgICAgaWYgKHN0ZXAgJiYgdHlwZW9mIHN0ZXAgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RhcnQsIGVuZCwgc3RlcCkpIHtcbiAgICAgICAgICBlbmQgPSBzdGVwID0gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVuc3VyZSB0aGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgICAgc3RhcnQgPSB0b0Zpbml0ZShzdGFydCk7XG4gICAgICAgIGlmIChlbmQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICAgIHN0YXJ0ID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgICB9XG4gICAgICAgIHN0ZXAgPSBzdGVwID09PSB1bmRlZmluZWQgPyAoc3RhcnQgPCBlbmQgPyAxIDogLTEpIDogdG9GaW5pdGUoc3RlcCk7XG4gICAgICAgIHJldHVybiBiYXNlUmFuZ2Uoc3RhcnQsIGVuZCwgc3RlcCwgZnJvbVJpZ2h0KTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSByZWxhdGlvbmFsIG9wZXJhdGlvbiBvbiB0d28gdmFsdWVzLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBvcGVyYXRvciBUaGUgZnVuY3Rpb24gdG8gcGVyZm9ybSB0aGUgb3BlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlbGF0aW9uYWwgb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24ob3BlcmF0b3IpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgaWYgKCEodHlwZW9mIHZhbHVlID09ICdzdHJpbmcnICYmIHR5cGVvZiBvdGhlciA9PSAnc3RyaW5nJykpIHtcbiAgICAgICAgICB2YWx1ZSA9IHRvTnVtYmVyKHZhbHVlKTtcbiAgICAgICAgICBvdGhlciA9IHRvTnVtYmVyKG90aGVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3BlcmF0b3IodmFsdWUsIG90aGVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd3JhcHMgYGZ1bmNgIHRvIGNvbnRpbnVlIGN1cnJ5aW5nLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGNyZWF0ZVdyYXBgIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgYGZ1bmNgIHdyYXBwZXIuXG4gICAgICogQHBhcmFtIHsqfSBwbGFjZWhvbGRlciBUaGUgcGxhY2Vob2xkZXIgdmFsdWUuXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gcHJlcGVuZCB0byB0aG9zZSBwcm92aWRlZCB0b1xuICAgICAqICB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFtob2xkZXJzXSBUaGUgYHBhcnRpYWxzYCBwbGFjZWhvbGRlciBpbmRleGVzLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IFthcmdQb3NdIFRoZSBhcmd1bWVudCBwb3NpdGlvbnMgb2YgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyeV0gVGhlIGFyaXR5IGNhcCBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eV0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB3cmFwcGVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVJlY3VycnkoZnVuYywgYml0bWFzaywgd3JhcEZ1bmMsIHBsYWNlaG9sZGVyLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNDdXJyeSA9IGJpdG1hc2sgJiBXUkFQX0NVUlJZX0ZMQUcsXG4gICAgICAgICAgbmV3SG9sZGVycyA9IGlzQ3VycnkgPyBob2xkZXJzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld0hvbGRlcnNSaWdodCA9IGlzQ3VycnkgPyB1bmRlZmluZWQgOiBob2xkZXJzLFxuICAgICAgICAgIG5ld1BhcnRpYWxzID0gaXNDdXJyeSA/IHBhcnRpYWxzIDogdW5kZWZpbmVkLFxuICAgICAgICAgIG5ld1BhcnRpYWxzUmlnaHQgPSBpc0N1cnJ5ID8gdW5kZWZpbmVkIDogcGFydGlhbHM7XG5cbiAgICAgIGJpdG1hc2sgfD0gKGlzQ3VycnkgPyBXUkFQX1BBUlRJQUxfRkxBRyA6IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgIGJpdG1hc2sgJj0gfihpc0N1cnJ5ID8gV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcgOiBXUkFQX1BBUlRJQUxfRkxBRyk7XG5cbiAgICAgIGlmICghKGJpdG1hc2sgJiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUcpKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX0JJTkRfRkxBRyB8IFdSQVBfQklORF9LRVlfRkxBRyk7XG4gICAgICB9XG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgbmV3UGFydGlhbHMsIG5ld0hvbGRlcnMsIG5ld1BhcnRpYWxzUmlnaHQsXG4gICAgICAgIG5ld0hvbGRlcnNSaWdodCwgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gd3JhcEZ1bmMuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIGlmIChpc0xhemlhYmxlKGZ1bmMpKSB7XG4gICAgICAgIHNldERhdGEocmVzdWx0LCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHJlc3VsdC5wbGFjZWhvbGRlciA9IHBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhyZXN1bHQsIGZ1bmMsIGJpdG1hc2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiBsaWtlIGBfLnJvdW5kYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG5hbWUgb2YgdGhlIGBNYXRoYCBtZXRob2QgdG8gdXNlIHdoZW4gcm91bmRpbmcuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcm91bmQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlUm91bmQobWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBNYXRoW21ldGhvZE5hbWVdO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKG51bWJlciwgcHJlY2lzaW9uKSB7XG4gICAgICAgIG51bWJlciA9IHRvTnVtYmVyKG51bWJlcik7XG4gICAgICAgIHByZWNpc2lvbiA9IHByZWNpc2lvbiA9PSBudWxsID8gMCA6IG5hdGl2ZU1pbih0b0ludGVnZXIocHJlY2lzaW9uKSwgMjkyKTtcbiAgICAgICAgaWYgKHByZWNpc2lvbiAmJiBuYXRpdmVJc0Zpbml0ZShudW1iZXIpKSB7XG4gICAgICAgICAgLy8gU2hpZnQgd2l0aCBleHBvbmVudGlhbCBub3RhdGlvbiB0byBhdm9pZCBmbG9hdGluZy1wb2ludCBpc3N1ZXMuXG4gICAgICAgICAgLy8gU2VlIFtNRE5dKGh0dHBzOi8vbWRuLmlvL3JvdW5kI0V4YW1wbGVzKSBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAgICAgIHZhciBwYWlyID0gKHRvU3RyaW5nKG51bWJlcikgKyAnZScpLnNwbGl0KCdlJyksXG4gICAgICAgICAgICAgIHZhbHVlID0gZnVuYyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdICsgcHJlY2lzaW9uKSk7XG5cbiAgICAgICAgICBwYWlyID0gKHRvU3RyaW5nKHZhbHVlKSArICdlJykuc3BsaXQoJ2UnKTtcbiAgICAgICAgICByZXR1cm4gKyhwYWlyWzBdICsgJ2UnICsgKCtwYWlyWzFdIC0gcHJlY2lzaW9uKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMobnVtYmVyKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNldCBvYmplY3Qgb2YgYHZhbHVlc2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHZhbHVlcyBUaGUgdmFsdWVzIHRvIGFkZCB0byB0aGUgc2V0LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBzZXQuXG4gICAgICovXG4gICAgdmFyIGNyZWF0ZVNldCA9ICEoU2V0ICYmICgxIC8gc2V0VG9BcnJheShuZXcgU2V0KFssLTBdKSlbMV0pID09IElORklOSVRZKSA/IG5vb3AgOiBmdW5jdGlvbih2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBuZXcgU2V0KHZhbHVlcyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgXy50b1BhaXJzYCBvciBgXy50b1BhaXJzSW5gIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBrZXlzRnVuYyBUaGUgZnVuY3Rpb24gdG8gZ2V0IHRoZSBrZXlzIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhaXJzIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZVRvUGFpcnMoa2V5c0Z1bmMpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgdmFyIHRhZyA9IGdldFRhZyhvYmplY3QpO1xuICAgICAgICBpZiAodGFnID09IG1hcFRhZykge1xuICAgICAgICAgIHJldHVybiBtYXBUb0FycmF5KG9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgICByZXR1cm4gc2V0VG9QYWlycyhvYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlVG9QYWlycyhvYmplY3QsIGtleXNGdW5jKG9iamVjdCkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBlaXRoZXIgY3VycmllcyBvciBpbnZva2VzIGBmdW5jYCB3aXRoIG9wdGlvbmFsXG4gICAgICogYHRoaXNgIGJpbmRpbmcgYW5kIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxzdHJpbmd9IGZ1bmMgVGhlIGZ1bmN0aW9uIG9yIG1ldGhvZCBuYW1lIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuXG4gICAgICogICAgMSAtIGBfLmJpbmRgXG4gICAgICogICAgMiAtIGBfLmJpbmRLZXlgXG4gICAgICogICAgNCAtIGBfLmN1cnJ5YCBvciBgXy5jdXJyeVJpZ2h0YCBvZiBhIGJvdW5kIGZ1bmN0aW9uXG4gICAgICogICAgOCAtIGBfLmN1cnJ5YFxuICAgICAqICAgMTYgLSBgXy5jdXJyeVJpZ2h0YFxuICAgICAqICAgMzIgLSBgXy5wYXJ0aWFsYFxuICAgICAqICAgNjQgLSBgXy5wYXJ0aWFsUmlnaHRgXG4gICAgICogIDEyOCAtIGBfLnJlYXJnYFxuICAgICAqICAyNTYgLSBgXy5hcnlgXG4gICAgICogIDUxMiAtIGBfLmZsaXBgXG4gICAgICogQHBhcmFtIHsqfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2hvbGRlcnNdIFRoZSBgcGFydGlhbHNgIHBsYWNlaG9sZGVyIGluZGV4ZXMuXG4gICAgICogQHBhcmFtIHtBcnJheX0gW2FyZ1Bvc10gVGhlIGFyZ3VtZW50IHBvc2l0aW9ucyBvZiB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJ5XSBUaGUgYXJpdHkgY2FwIG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2FyaXR5XSBUaGUgYXJpdHkgb2YgYGZ1bmNgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHdyYXBwZWQgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3JlYXRlV3JhcChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscywgaG9sZGVycywgYXJnUG9zLCBhcnksIGFyaXR5KSB7XG4gICAgICB2YXIgaXNCaW5kS2V5ID0gYml0bWFzayAmIFdSQVBfQklORF9LRVlfRkxBRztcbiAgICAgIGlmICghaXNCaW5kS2V5ICYmIHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IHBhcnRpYWxzID8gcGFydGlhbHMubGVuZ3RoIDogMDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIGJpdG1hc2sgJj0gfihXUkFQX1BBUlRJQUxfRkxBRyB8IFdSQVBfUEFSVElBTF9SSUdIVF9GTEFHKTtcbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgYXJ5ID0gYXJ5ID09PSB1bmRlZmluZWQgPyBhcnkgOiBuYXRpdmVNYXgodG9JbnRlZ2VyKGFyeSksIDApO1xuICAgICAgYXJpdHkgPSBhcml0eSA9PT0gdW5kZWZpbmVkID8gYXJpdHkgOiB0b0ludGVnZXIoYXJpdHkpO1xuICAgICAgbGVuZ3RoIC09IGhvbGRlcnMgPyBob2xkZXJzLmxlbmd0aCA6IDA7XG5cbiAgICAgIGlmIChiaXRtYXNrICYgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcpIHtcbiAgICAgICAgdmFyIHBhcnRpYWxzUmlnaHQgPSBwYXJ0aWFscyxcbiAgICAgICAgICAgIGhvbGRlcnNSaWdodCA9IGhvbGRlcnM7XG5cbiAgICAgICAgcGFydGlhbHMgPSBob2xkZXJzID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBpc0JpbmRLZXkgPyB1bmRlZmluZWQgOiBnZXREYXRhKGZ1bmMpO1xuXG4gICAgICB2YXIgbmV3RGF0YSA9IFtcbiAgICAgICAgZnVuYywgYml0bWFzaywgdGhpc0FyZywgcGFydGlhbHMsIGhvbGRlcnMsIHBhcnRpYWxzUmlnaHQsIGhvbGRlcnNSaWdodCxcbiAgICAgICAgYXJnUG9zLCBhcnksIGFyaXR5XG4gICAgICBdO1xuXG4gICAgICBpZiAoZGF0YSkge1xuICAgICAgICBtZXJnZURhdGEobmV3RGF0YSwgZGF0YSk7XG4gICAgICB9XG4gICAgICBmdW5jID0gbmV3RGF0YVswXTtcbiAgICAgIGJpdG1hc2sgPSBuZXdEYXRhWzFdO1xuICAgICAgdGhpc0FyZyA9IG5ld0RhdGFbMl07XG4gICAgICBwYXJ0aWFscyA9IG5ld0RhdGFbM107XG4gICAgICBob2xkZXJzID0gbmV3RGF0YVs0XTtcbiAgICAgIGFyaXR5ID0gbmV3RGF0YVs5XSA9IG5ld0RhdGFbOV0gPT09IHVuZGVmaW5lZFxuICAgICAgICA/IChpc0JpbmRLZXkgPyAwIDogZnVuYy5sZW5ndGgpXG4gICAgICAgIDogbmF0aXZlTWF4KG5ld0RhdGFbOV0gLSBsZW5ndGgsIDApO1xuXG4gICAgICBpZiAoIWFyaXR5ICYmIGJpdG1hc2sgJiAoV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKSkge1xuICAgICAgICBiaXRtYXNrICY9IH4oV1JBUF9DVVJSWV9GTEFHIHwgV1JBUF9DVVJSWV9SSUdIVF9GTEFHKTtcbiAgICAgIH1cbiAgICAgIGlmICghYml0bWFzayB8fCBiaXRtYXNrID09IFdSQVBfQklORF9GTEFHKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBjcmVhdGVCaW5kKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcpO1xuICAgICAgfSBlbHNlIGlmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRyB8fCBiaXRtYXNrID09IFdSQVBfQ1VSUllfUklHSFRfRkxBRykge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVDdXJyeShmdW5jLCBiaXRtYXNrLCBhcml0eSk7XG4gICAgICB9IGVsc2UgaWYgKChiaXRtYXNrID09IFdSQVBfUEFSVElBTF9GTEFHIHx8IGJpdG1hc2sgPT0gKFdSQVBfQklORF9GTEFHIHwgV1JBUF9QQVJUSUFMX0ZMQUcpKSAmJiAhaG9sZGVycy5sZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0ID0gY3JlYXRlUGFydGlhbChmdW5jLCBiaXRtYXNrLCB0aGlzQXJnLCBwYXJ0aWFscyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHQgPSBjcmVhdGVIeWJyaWQuYXBwbHkodW5kZWZpbmVkLCBuZXdEYXRhKTtcbiAgICAgIH1cbiAgICAgIHZhciBzZXR0ZXIgPSBkYXRhID8gYmFzZVNldERhdGEgOiBzZXREYXRhO1xuICAgICAgcmV0dXJuIHNldFdyYXBUb1N0cmluZyhzZXR0ZXIocmVzdWx0LCBuZXdEYXRhKSwgZnVuYywgYml0bWFzayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVXNlZCBieSBgXy5kZWZhdWx0c2AgdG8gY3VzdG9taXplIGl0cyBgXy5hc3NpZ25JbmAgdXNlIHRvIGFzc2lnbiBwcm9wZXJ0aWVzXG4gICAgICogb2Ygc291cmNlIG9iamVjdHMgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdCBmb3IgYWxsIGRlc3RpbmF0aW9uIHByb3BlcnRpZXNcbiAgICAgKiB0aGF0IHJlc29sdmUgdG8gYHVuZGVmaW5lZGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gb2JqVmFsdWUgVGhlIGRlc3RpbmF0aW9uIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7Kn0gc3JjVmFsdWUgVGhlIHNvdXJjZSB2YWx1ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSBrZXkgb2YgdGhlIHByb3BlcnR5IHRvIGFzc2lnbi5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHZhbHVlIHRvIGFzc2lnbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgIGlmIChvYmpWYWx1ZSA9PT0gdW5kZWZpbmVkIHx8XG4gICAgICAgICAgKGVxKG9ialZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgIHJldHVybiBzcmNWYWx1ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLmRlZmF1bHRzRGVlcGAgdG8gY3VzdG9taXplIGl0cyBgXy5tZXJnZWAgdXNlIHRvIG1lcmdlIHNvdXJjZVxuICAgICAqIG9iamVjdHMgaW50byBkZXN0aW5hdGlvbiBvYmplY3RzIHRoYXQgYXJlIHBhc3NlZCB0aHJ1LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IG9ialZhbHVlIFRoZSBkZXN0aW5hdGlvbiB2YWx1ZS5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSBzb3VyY2UgdmFsdWUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBtZXJnZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBwYXJlbnQgb2JqZWN0IG9mIGBvYmpWYWx1ZWAuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgcGFyZW50IG9iamVjdCBvZiBgc3JjVmFsdWVgLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbc3RhY2tdIFRyYWNrcyB0cmF2ZXJzZWQgc291cmNlIHZhbHVlcyBhbmQgdGhlaXIgbWVyZ2VkXG4gICAgICogIGNvdW50ZXJwYXJ0cy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgdmFsdWUgdG8gYXNzaWduLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1c3RvbURlZmF1bHRzTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykge1xuICAgICAgaWYgKGlzT2JqZWN0KG9ialZhbHVlKSAmJiBpc09iamVjdChzcmNWYWx1ZSkpIHtcbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgbWVyZ2Ugb2JqZWN0cyBhbmQgYXJyYXlzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIHN0YWNrLnNldChzcmNWYWx1ZSwgb2JqVmFsdWUpO1xuICAgICAgICBiYXNlTWVyZ2Uob2JqVmFsdWUsIHNyY1ZhbHVlLCB1bmRlZmluZWQsIGN1c3RvbURlZmF1bHRzTWVyZ2UsIHN0YWNrKTtcbiAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKHNyY1ZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmpWYWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VkIGJ5IGBfLm9taXRgIHRvIGN1c3RvbWl6ZSBpdHMgYF8uY2xvbmVEZWVwYCB1c2UgdG8gb25seSBjbG9uZSBwbGFpblxuICAgICAqIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSB1bmNsb25lZCB2YWx1ZSBvciBgdW5kZWZpbmVkYCB0byBkZWZlciBjbG9uaW5nIHRvIGBfLmNsb25lRGVlcGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VzdG9tT21pdENsb25lKHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB1bmRlZmluZWQgOiB2YWx1ZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYGJhc2VJc0VxdWFsRGVlcGAgZm9yIGFycmF5cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBvdGhlciBUaGUgb3RoZXIgYXJyYXkgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBiYXNlSXNFcXVhbGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjdXN0b21pemVyIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZXF1YWxGdW5jIFRoZSBmdW5jdGlvbiB0byBkZXRlcm1pbmUgZXF1aXZhbGVudHMgb2YgdmFsdWVzLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzdGFjayBUcmFja3MgdHJhdmVyc2VkIGBhcnJheWAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGFycmF5cyBhcmUgZXF1aXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGVxdWFsQXJyYXlzKGFycmF5LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBhcnJMZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgb3RoTGVuZ3RoID0gb3RoZXIubGVuZ3RoO1xuXG4gICAgICBpZiAoYXJyTGVuZ3RoICE9IG90aExlbmd0aCAmJiAhKGlzUGFydGlhbCAmJiBvdGhMZW5ndGggPiBhcnJMZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgYXJyU3RhY2tlZCA9IHN0YWNrLmdldChhcnJheSk7XG4gICAgICB2YXIgb3RoU3RhY2tlZCA9IHN0YWNrLmdldChvdGhlcik7XG4gICAgICBpZiAoYXJyU3RhY2tlZCAmJiBvdGhTdGFja2VkKSB7XG4gICAgICAgIHJldHVybiBhcnJTdGFja2VkID09IG90aGVyICYmIG90aFN0YWNrZWQgPT0gYXJyYXk7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICByZXN1bHQgPSB0cnVlLFxuICAgICAgICAgIHNlZW4gPSAoYml0bWFzayAmIENPTVBBUkVfVU5PUkRFUkVEX0ZMQUcpID8gbmV3IFNldENhY2hlIDogdW5kZWZpbmVkO1xuXG4gICAgICBzdGFjay5zZXQoYXJyYXksIG90aGVyKTtcbiAgICAgIHN0YWNrLnNldChvdGhlciwgYXJyYXkpO1xuXG4gICAgICAvLyBJZ25vcmUgbm9uLWluZGV4IHByb3BlcnRpZXMuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGFyckxlbmd0aCkge1xuICAgICAgICB2YXIgYXJyVmFsdWUgPSBhcnJheVtpbmRleF0sXG4gICAgICAgICAgICBvdGhWYWx1ZSA9IG90aGVyW2luZGV4XTtcblxuICAgICAgICBpZiAoY3VzdG9taXplcikge1xuICAgICAgICAgIHZhciBjb21wYXJlZCA9IGlzUGFydGlhbFxuICAgICAgICAgICAgPyBjdXN0b21pemVyKG90aFZhbHVlLCBhcnJWYWx1ZSwgaW5kZXgsIG90aGVyLCBhcnJheSwgc3RhY2spXG4gICAgICAgICAgICA6IGN1c3RvbWl6ZXIoYXJyVmFsdWUsIG90aFZhbHVlLCBpbmRleCwgYXJyYXksIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbXBhcmVkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoY29tcGFyZWQpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICAvLyBSZWN1cnNpdmVseSBjb21wYXJlIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICBpZiAoc2Vlbikge1xuICAgICAgICAgIGlmICghYXJyYXlTb21lKG90aGVyLCBmdW5jdGlvbihvdGhWYWx1ZSwgb3RoSW5kZXgpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhY2hlSGFzKHNlZW4sIG90aEluZGV4KSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXJyVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSkpIHtcbiAgICAgICAgICAgICAgICAgIHJldHVybiBzZWVuLnB1c2gob3RoSW5kZXgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSkpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCEoXG4gICAgICAgICAgICAgIGFyclZhbHVlID09PSBvdGhWYWx1ZSB8fFxuICAgICAgICAgICAgICAgIGVxdWFsRnVuYyhhcnJWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKVxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10oYXJyYXkpO1xuICAgICAgc3RhY2tbJ2RlbGV0ZSddKG90aGVyKTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBiYXNlSXNFcXVhbERlZXBgIGZvciBjb21wYXJpbmcgb2JqZWN0cyBvZlxuICAgICAqIHRoZSBzYW1lIGB0b1N0cmluZ1RhZ2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBmdW5jdGlvbiBvbmx5IHN1cHBvcnRzIGNvbXBhcmluZyB2YWx1ZXMgd2l0aCB0YWdzIG9mXG4gICAgICogYEJvb2xlYW5gLCBgRGF0ZWAsIGBFcnJvcmAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgb3IgYFN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvdGhlciBUaGUgb3RoZXIgb2JqZWN0IHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0cyB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbEJ5VGFnKG9iamVjdCwgb3RoZXIsIHRhZywgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgc3dpdGNoICh0YWcpIHtcbiAgICAgICAgY2FzZSBkYXRhVmlld1RhZzpcbiAgICAgICAgICBpZiAoKG9iamVjdC5ieXRlTGVuZ3RoICE9IG90aGVyLmJ5dGVMZW5ndGgpIHx8XG4gICAgICAgICAgICAgIChvYmplY3QuYnl0ZU9mZnNldCAhPSBvdGhlci5ieXRlT2Zmc2V0KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBvYmplY3QgPSBvYmplY3QuYnVmZmVyO1xuICAgICAgICAgIG90aGVyID0gb3RoZXIuYnVmZmVyO1xuXG4gICAgICAgIGNhc2UgYXJyYXlCdWZmZXJUYWc6XG4gICAgICAgICAgaWYgKChvYmplY3QuYnl0ZUxlbmd0aCAhPSBvdGhlci5ieXRlTGVuZ3RoKSB8fFxuICAgICAgICAgICAgICAhZXF1YWxGdW5jKG5ldyBVaW50OEFycmF5KG9iamVjdCksIG5ldyBVaW50OEFycmF5KG90aGVyKSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRydWU7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSBib29sZWFucyB0byBgMWAgb3IgYDBgIGFuZCBkYXRlcyB0byBtaWxsaXNlY29uZHMuXG4gICAgICAgICAgLy8gSW52YWxpZCBkYXRlcyBhcmUgY29lcmNlZCB0byBgTmFOYC5cbiAgICAgICAgICByZXR1cm4gZXEoK29iamVjdCwgK290aGVyKTtcblxuICAgICAgICBjYXNlIGVycm9yVGFnOlxuICAgICAgICAgIHJldHVybiBvYmplY3QubmFtZSA9PSBvdGhlci5uYW1lICYmIG9iamVjdC5tZXNzYWdlID09IG90aGVyLm1lc3NhZ2U7XG5cbiAgICAgICAgY2FzZSByZWdleHBUYWc6XG4gICAgICAgIGNhc2Ugc3RyaW5nVGFnOlxuICAgICAgICAgIC8vIENvZXJjZSByZWdleGVzIHRvIHN0cmluZ3MgYW5kIHRyZWF0IHN0cmluZ3MsIHByaW1pdGl2ZXMgYW5kIG9iamVjdHMsXG4gICAgICAgICAgLy8gYXMgZXF1YWwuIFNlZSBodHRwOi8vd3d3LmVjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtcmVnZXhwLnByb3RvdHlwZS50b3N0cmluZ1xuICAgICAgICAgIC8vIGZvciBtb3JlIGRldGFpbHMuXG4gICAgICAgICAgcmV0dXJuIG9iamVjdCA9PSAob3RoZXIgKyAnJyk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgdmFyIGNvbnZlcnQgPSBtYXBUb0FycmF5O1xuXG4gICAgICAgIGNhc2Ugc2V0VGFnOlxuICAgICAgICAgIHZhciBpc1BhcnRpYWwgPSBiaXRtYXNrICYgQ09NUEFSRV9QQVJUSUFMX0ZMQUc7XG4gICAgICAgICAgY29udmVydCB8fCAoY29udmVydCA9IHNldFRvQXJyYXkpO1xuXG4gICAgICAgICAgaWYgKG9iamVjdC5zaXplICE9IG90aGVyLnNpemUgJiYgIWlzUGFydGlhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBBc3N1bWUgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICAgICAgdmFyIHN0YWNrZWQgPSBzdGFjay5nZXQob2JqZWN0KTtcbiAgICAgICAgICBpZiAoc3RhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YWNrZWQgPT0gb3RoZXI7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJpdG1hc2sgfD0gQ09NUEFSRV9VTk9SREVSRURfRkxBRztcblxuICAgICAgICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpLlxuICAgICAgICAgIHN0YWNrLnNldChvYmplY3QsIG90aGVyKTtcbiAgICAgICAgICB2YXIgcmVzdWx0ID0gZXF1YWxBcnJheXMoY29udmVydChvYmplY3QpLCBjb252ZXJ0KG90aGVyKSwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjayk7XG4gICAgICAgICAgc3RhY2tbJ2RlbGV0ZSddKG9iamVjdCk7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdDtcblxuICAgICAgICBjYXNlIHN5bWJvbFRhZzpcbiAgICAgICAgICBpZiAoc3ltYm9sVmFsdWVPZikge1xuICAgICAgICAgICAgcmV0dXJuIHN5bWJvbFZhbHVlT2YuY2FsbChvYmplY3QpID09IHN5bWJvbFZhbHVlT2YuY2FsbChvdGhlcik7XG4gICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUlzRXF1YWxEZWVwYCBmb3Igb2JqZWN0cyB3aXRoIHN1cHBvcnQgZm9yXG4gICAgICogcGFydGlhbCBkZWVwIGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb3RoZXIgVGhlIG90aGVyIG9iamVjdCB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRtYXNrIFRoZSBiaXRtYXNrIGZsYWdzLiBTZWUgYGJhc2VJc0VxdWFsYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBjb21wYXJpc29ucy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBlcXVhbEZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGRldGVybWluZSBlcXVpdmFsZW50cyBvZiB2YWx1ZXMuXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHN0YWNrIFRyYWNrcyB0cmF2ZXJzZWQgYG9iamVjdGAgYW5kIGBvdGhlcmAgb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIG9iamVjdHMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlcXVhbE9iamVjdHMob2JqZWN0LCBvdGhlciwgYml0bWFzaywgY3VzdG9taXplciwgZXF1YWxGdW5jLCBzdGFjaykge1xuICAgICAgdmFyIGlzUGFydGlhbCA9IGJpdG1hc2sgJiBDT01QQVJFX1BBUlRJQUxfRkxBRyxcbiAgICAgICAgICBvYmpQcm9wcyA9IGdldEFsbEtleXMob2JqZWN0KSxcbiAgICAgICAgICBvYmpMZW5ndGggPSBvYmpQcm9wcy5sZW5ndGgsXG4gICAgICAgICAgb3RoUHJvcHMgPSBnZXRBbGxLZXlzKG90aGVyKSxcbiAgICAgICAgICBvdGhMZW5ndGggPSBvdGhQcm9wcy5sZW5ndGg7XG5cbiAgICAgIGlmIChvYmpMZW5ndGggIT0gb3RoTGVuZ3RoICYmICFpc1BhcnRpYWwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gb2JqTGVuZ3RoO1xuICAgICAgd2hpbGUgKGluZGV4LS0pIHtcbiAgICAgICAgdmFyIGtleSA9IG9ialByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKCEoaXNQYXJ0aWFsID8ga2V5IGluIG90aGVyIDogaGFzT3duUHJvcGVydHkuY2FsbChvdGhlciwga2V5KSkpIHtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHRoYXQgY3ljbGljIHZhbHVlcyBhcmUgZXF1YWwuXG4gICAgICB2YXIgb2JqU3RhY2tlZCA9IHN0YWNrLmdldChvYmplY3QpO1xuICAgICAgdmFyIG90aFN0YWNrZWQgPSBzdGFjay5nZXQob3RoZXIpO1xuICAgICAgaWYgKG9ialN0YWNrZWQgJiYgb3RoU3RhY2tlZCkge1xuICAgICAgICByZXR1cm4gb2JqU3RhY2tlZCA9PSBvdGhlciAmJiBvdGhTdGFja2VkID09IG9iamVjdDtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgICAgc3RhY2suc2V0KG9iamVjdCwgb3RoZXIpO1xuICAgICAgc3RhY2suc2V0KG90aGVyLCBvYmplY3QpO1xuXG4gICAgICB2YXIgc2tpcEN0b3IgPSBpc1BhcnRpYWw7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IG9iakxlbmd0aCkge1xuICAgICAgICBrZXkgPSBvYmpQcm9wc1tpbmRleF07XG4gICAgICAgIHZhciBvYmpWYWx1ZSA9IG9iamVjdFtrZXldLFxuICAgICAgICAgICAgb3RoVmFsdWUgPSBvdGhlcltrZXldO1xuXG4gICAgICAgIGlmIChjdXN0b21pemVyKSB7XG4gICAgICAgICAgdmFyIGNvbXBhcmVkID0gaXNQYXJ0aWFsXG4gICAgICAgICAgICA/IGN1c3RvbWl6ZXIob3RoVmFsdWUsIG9ialZhbHVlLCBrZXksIG90aGVyLCBvYmplY3QsIHN0YWNrKVxuICAgICAgICAgICAgOiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSwga2V5LCBvYmplY3QsIG90aGVyLCBzdGFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIChzdXNjZXB0aWJsZSB0byBjYWxsIHN0YWNrIGxpbWl0cykuXG4gICAgICAgIGlmICghKGNvbXBhcmVkID09PSB1bmRlZmluZWRcbiAgICAgICAgICAgICAgPyAob2JqVmFsdWUgPT09IG90aFZhbHVlIHx8IGVxdWFsRnVuYyhvYmpWYWx1ZSwgb3RoVmFsdWUsIGJpdG1hc2ssIGN1c3RvbWl6ZXIsIHN0YWNrKSlcbiAgICAgICAgICAgICAgOiBjb21wYXJlZFxuICAgICAgICAgICAgKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHNraXBDdG9yIHx8IChza2lwQ3RvciA9IGtleSA9PSAnY29uc3RydWN0b3InKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXN1bHQgJiYgIXNraXBDdG9yKSB7XG4gICAgICAgIHZhciBvYmpDdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yLFxuICAgICAgICAgICAgb3RoQ3RvciA9IG90aGVyLmNvbnN0cnVjdG9yO1xuXG4gICAgICAgIC8vIE5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsLlxuICAgICAgICBpZiAob2JqQ3RvciAhPSBvdGhDdG9yICYmXG4gICAgICAgICAgICAoJ2NvbnN0cnVjdG9yJyBpbiBvYmplY3QgJiYgJ2NvbnN0cnVjdG9yJyBpbiBvdGhlcikgJiZcbiAgICAgICAgICAgICEodHlwZW9mIG9iakN0b3IgPT0gJ2Z1bmN0aW9uJyAmJiBvYmpDdG9yIGluc3RhbmNlb2Ygb2JqQ3RvciAmJlxuICAgICAgICAgICAgICB0eXBlb2Ygb3RoQ3RvciA9PSAnZnVuY3Rpb24nICYmIG90aEN0b3IgaW5zdGFuY2VvZiBvdGhDdG9yKSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBzdGFja1snZGVsZXRlJ10ob2JqZWN0KTtcbiAgICAgIHN0YWNrWydkZWxldGUnXShvdGhlcik7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIGZsYXR0ZW5zIHRoZSByZXN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRSZXN0KGZ1bmMpIHtcbiAgICAgIHJldHVybiBzZXRUb1N0cmluZyhvdmVyUmVzdChmdW5jLCB1bmRlZmluZWQsIGZsYXR0ZW4pLCBmdW5jICsgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzIGFuZCBzeW1ib2xzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEFsbEtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gYmFzZUdldEFsbEtleXMob2JqZWN0LCBrZXlzLCBnZXRTeW1ib2xzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgYW5kXG4gICAgICogc3ltYm9scyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMgYW5kIHN5bWJvbHMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0QWxsS2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGJhc2VHZXRBbGxLZXlzKG9iamVjdCwga2V5c0luLCBnZXRTeW1ib2xzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgbWV0YWRhdGEgZm9yIGBmdW5jYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIGdldERhdGEgPSAhbWV0YU1hcCA/IG5vb3AgOiBmdW5jdGlvbihmdW5jKSB7XG4gICAgICByZXR1cm4gbWV0YU1hcC5nZXQoZnVuYyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hbWUgb2YgYGZ1bmNgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEZ1bmNOYW1lKGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQgPSAoZnVuYy5uYW1lICsgJycpLFxuICAgICAgICAgIGFycmF5ID0gcmVhbE5hbWVzW3Jlc3VsdF0sXG4gICAgICAgICAgbGVuZ3RoID0gaGFzT3duUHJvcGVydHkuY2FsbChyZWFsTmFtZXMsIHJlc3VsdCkgPyBhcnJheS5sZW5ndGggOiAwO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGRhdGEgPSBhcnJheVtsZW5ndGhdLFxuICAgICAgICAgICAgb3RoZXJGdW5jID0gZGF0YS5mdW5jO1xuICAgICAgICBpZiAob3RoZXJGdW5jID09IG51bGwgfHwgb3RoZXJGdW5jID09IGZ1bmMpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS5uYW1lO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50IHBsYWNlaG9sZGVyIHZhbHVlIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBsYWNlaG9sZGVyIHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEhvbGRlcihmdW5jKSB7XG4gICAgICB2YXIgb2JqZWN0ID0gaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gsICdwbGFjZWhvbGRlcicpID8gbG9kYXNoIDogZnVuYztcbiAgICAgIHJldHVybiBvYmplY3QucGxhY2Vob2xkZXI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYXBwcm9wcmlhdGUgXCJpdGVyYXRlZVwiIGZ1bmN0aW9uLiBJZiBgXy5pdGVyYXRlZWAgaXMgY3VzdG9taXplZCxcbiAgICAgKiB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGN1c3RvbSBtZXRob2QsIG90aGVyd2lzZSBpdCByZXR1cm5zIGBiYXNlSXRlcmF0ZWVgLlxuICAgICAqIElmIGFyZ3VtZW50cyBhcmUgcHJvdmlkZWQsIHRoZSBjaG9zZW4gZnVuY3Rpb24gaXMgaW52b2tlZCB3aXRoIHRoZW0gYW5kXG4gICAgICogaXRzIHJlc3VsdCBpcyByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSBbdmFsdWVdIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGFuIGl0ZXJhdGVlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHldIFRoZSBhcml0eSBvZiB0aGUgY3JlYXRlZCBpdGVyYXRlZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGNob3NlbiBmdW5jdGlvbiBvciBpdHMgcmVzdWx0LlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldEl0ZXJhdGVlKCkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaC5pdGVyYXRlZSB8fCBpdGVyYXRlZTtcbiAgICAgIHJlc3VsdCA9IHJlc3VsdCA9PT0gaXRlcmF0ZWUgPyBiYXNlSXRlcmF0ZWUgOiByZXN1bHQ7XG4gICAgICByZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA/IHJlc3VsdChhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSkgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZGF0YSBmb3IgYG1hcGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBtYXAgVGhlIG1hcCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30ga2V5IFRoZSByZWZlcmVuY2Uga2V5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXAgZGF0YS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRNYXBEYXRhKG1hcCwga2V5KSB7XG4gICAgICB2YXIgZGF0YSA9IG1hcC5fX2RhdGFfXztcbiAgICAgIHJldHVybiBpc0tleWFibGUoa2V5KVxuICAgICAgICA/IGRhdGFbdHlwZW9mIGtleSA9PSAnc3RyaW5nJyA/ICdzdHJpbmcnIDogJ2hhc2gnXVxuICAgICAgICA6IGRhdGEubWFwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHByb3BlcnR5IG5hbWVzLCB2YWx1ZXMsIGFuZCBjb21wYXJlIGZsYWdzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBtYXRjaCBkYXRhIG9mIGBvYmplY3RgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldE1hdGNoRGF0YShvYmplY3QpIHtcbiAgICAgIHZhciByZXN1bHQgPSBrZXlzKG9iamVjdCksXG4gICAgICAgICAgbGVuZ3RoID0gcmVzdWx0Lmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIHZhciBrZXkgPSByZXN1bHRbbGVuZ3RoXSxcbiAgICAgICAgICAgIHZhbHVlID0gb2JqZWN0W2tleV07XG5cbiAgICAgICAgcmVzdWx0W2xlbmd0aF0gPSBba2V5LCB2YWx1ZSwgaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIG5hdGl2ZSBmdW5jdGlvbiBhdCBga2V5YCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBrZXkgVGhlIGtleSBvZiB0aGUgbWV0aG9kIHRvIGdldC5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZnVuY3Rpb24gaWYgaXQncyBuYXRpdmUsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gZ2V0TmF0aXZlKG9iamVjdCwga2V5KSB7XG4gICAgICB2YXIgdmFsdWUgPSBnZXRWYWx1ZShvYmplY3QsIGtleSk7XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKSA/IHZhbHVlIDogdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZUdldFRhZ2Agd2hpY2ggaWdub3JlcyBgU3ltYm9sLnRvU3RyaW5nVGFnYCB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHJhdyBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFJhd1RhZyh2YWx1ZSkge1xuICAgICAgdmFyIGlzT3duID0gaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgc3ltVG9TdHJpbmdUYWcpLFxuICAgICAgICAgIHRhZyA9IHZhbHVlW3N5bVRvU3RyaW5nVGFnXTtcblxuICAgICAgdHJ5IHtcbiAgICAgICAgdmFsdWVbc3ltVG9TdHJpbmdUYWddID0gdW5kZWZpbmVkO1xuICAgICAgICB2YXIgdW5tYXNrZWQgPSB0cnVlO1xuICAgICAgfSBjYXRjaCAoZSkge31cblxuICAgICAgdmFyIHJlc3VsdCA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgaWYgKHVubWFza2VkKSB7XG4gICAgICAgIGlmIChpc093bikge1xuICAgICAgICAgIHZhbHVlW3N5bVRvU3RyaW5nVGFnXSA9IHRhZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkZWxldGUgdmFsdWVbc3ltVG9TdHJpbmdUYWddO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHMgPSAhbmF0aXZlR2V0U3ltYm9scyA/IHN0dWJBcnJheSA6IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG9iamVjdCA9IE9iamVjdChvYmplY3QpO1xuICAgICAgcmV0dXJuIGFycmF5RmlsdGVyKG5hdGl2ZUdldFN5bWJvbHMob2JqZWN0KSwgZnVuY3Rpb24oc3ltYm9sKSB7XG4gICAgICAgIHJldHVybiBwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKTtcbiAgICAgIH0pO1xuICAgIH07XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHRoZSBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHN5bWJvbHMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHN5bWJvbHMuXG4gICAgICovXG4gICAgdmFyIGdldFN5bWJvbHNJbiA9ICFuYXRpdmVHZXRTeW1ib2xzID8gc3R1YkFycmF5IDogZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICB3aGlsZSAob2JqZWN0KSB7XG4gICAgICAgIGFycmF5UHVzaChyZXN1bHQsIGdldFN5bWJvbHMob2JqZWN0KSk7XG4gICAgICAgIG9iamVjdCA9IGdldFByb3RvdHlwZShvYmplY3QpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgYHRvU3RyaW5nVGFnYCBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBgdG9TdHJpbmdUYWdgLlxuICAgICAqL1xuICAgIHZhciBnZXRUYWcgPSBiYXNlR2V0VGFnO1xuXG4gICAgLy8gRmFsbGJhY2sgZm9yIGRhdGEgdmlld3MsIG1hcHMsIHNldHMsIGFuZCB3ZWFrIG1hcHMgaW4gSUUgMTEgYW5kIHByb21pc2VzIGluIE5vZGUuanMgPCA2LlxuICAgIGlmICgoRGF0YVZpZXcgJiYgZ2V0VGFnKG5ldyBEYXRhVmlldyhuZXcgQXJyYXlCdWZmZXIoMSkpKSAhPSBkYXRhVmlld1RhZykgfHxcbiAgICAgICAgKE1hcCAmJiBnZXRUYWcobmV3IE1hcCkgIT0gbWFwVGFnKSB8fFxuICAgICAgICAoUHJvbWlzZSAmJiBnZXRUYWcoUHJvbWlzZS5yZXNvbHZlKCkpICE9IHByb21pc2VUYWcpIHx8XG4gICAgICAgIChTZXQgJiYgZ2V0VGFnKG5ldyBTZXQpICE9IHNldFRhZykgfHxcbiAgICAgICAgKFdlYWtNYXAgJiYgZ2V0VGFnKG5ldyBXZWFrTWFwKSAhPSB3ZWFrTWFwVGFnKSkge1xuICAgICAgZ2V0VGFnID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9IGJhc2VHZXRUYWcodmFsdWUpLFxuICAgICAgICAgICAgQ3RvciA9IHJlc3VsdCA9PSBvYmplY3RUYWcgPyB2YWx1ZS5jb25zdHJ1Y3RvciA6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGN0b3JTdHJpbmcgPSBDdG9yID8gdG9Tb3VyY2UoQ3RvcikgOiAnJztcblxuICAgICAgICBpZiAoY3RvclN0cmluZykge1xuICAgICAgICAgIHN3aXRjaCAoY3RvclN0cmluZykge1xuICAgICAgICAgICAgY2FzZSBkYXRhVmlld0N0b3JTdHJpbmc6IHJldHVybiBkYXRhVmlld1RhZztcbiAgICAgICAgICAgIGNhc2UgbWFwQ3RvclN0cmluZzogcmV0dXJuIG1hcFRhZztcbiAgICAgICAgICAgIGNhc2UgcHJvbWlzZUN0b3JTdHJpbmc6IHJldHVybiBwcm9taXNlVGFnO1xuICAgICAgICAgICAgY2FzZSBzZXRDdG9yU3RyaW5nOiByZXR1cm4gc2V0VGFnO1xuICAgICAgICAgICAgY2FzZSB3ZWFrTWFwQ3RvclN0cmluZzogcmV0dXJuIHdlYWtNYXBUYWc7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZpZXcsIGFwcGx5aW5nIGFueSBgdHJhbnNmb3Jtc2AgdG8gdGhlIGBzdGFydGAgYW5kIGBlbmRgIHBvc2l0aW9ucy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHN0YXJ0IFRoZSBzdGFydCBvZiB0aGUgdmlldy5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHZpZXcuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdHJhbnNmb3JtcyBUaGUgdHJhbnNmb3JtYXRpb25zIHRvIGFwcGx5IHRvIHRoZSB2aWV3LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGBzdGFydGAgYW5kIGBlbmRgXG4gICAgICogIHBvc2l0aW9ucyBvZiB0aGUgdmlldy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRWaWV3KHN0YXJ0LCBlbmQsIHRyYW5zZm9ybXMpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgZGF0YSA9IHRyYW5zZm9ybXNbaW5kZXhdLFxuICAgICAgICAgICAgc2l6ZSA9IGRhdGEuc2l6ZTtcblxuICAgICAgICBzd2l0Y2ggKGRhdGEudHlwZSkge1xuICAgICAgICAgIGNhc2UgJ2Ryb3AnOiAgICAgIHN0YXJ0ICs9IHNpemU7IGJyZWFrO1xuICAgICAgICAgIGNhc2UgJ2Ryb3BSaWdodCc6IGVuZCAtPSBzaXplOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlJzogICAgICBlbmQgPSBuYXRpdmVNaW4oZW5kLCBzdGFydCArIHNpemUpOyBicmVhaztcbiAgICAgICAgICBjYXNlICd0YWtlUmlnaHQnOiBzdGFydCA9IG5hdGl2ZU1heChzdGFydCwgZW5kIC0gc2l6ZSk7IGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyAnc3RhcnQnOiBzdGFydCwgJ2VuZCc6IGVuZCB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEV4dHJhY3RzIHdyYXBwZXIgZGV0YWlscyBmcm9tIHRoZSBgc291cmNlYCBib2R5IGNvbW1lbnQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzb3VyY2UgVGhlIHNvdXJjZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgd3JhcHBlciBkZXRhaWxzLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGdldFdyYXBEZXRhaWxzKHNvdXJjZSkge1xuICAgICAgdmFyIG1hdGNoID0gc291cmNlLm1hdGNoKHJlV3JhcERldGFpbHMpO1xuICAgICAgcmV0dXJuIG1hdGNoID8gbWF0Y2hbMV0uc3BsaXQocmVTcGxpdERldGFpbHMpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBleGlzdHMgb24gYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBoYXNGdW5jIFRoZSBmdW5jdGlvbiB0byBjaGVjayBwcm9wZXJ0aWVzLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaGFzUGF0aChvYmplY3QsIHBhdGgsIGhhc0Z1bmMpIHtcbiAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuXG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBwYXRoLmxlbmd0aCxcbiAgICAgICAgICByZXN1bHQgPSBmYWxzZTtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHRvS2V5KHBhdGhbaW5kZXhdKTtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gb2JqZWN0ICE9IG51bGwgJiYgaGFzRnVuYyhvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgICB9XG4gICAgICBpZiAocmVzdWx0IHx8ICsraW5kZXggIT0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBsZW5ndGggPSBvYmplY3QgPT0gbnVsbCA/IDAgOiBvYmplY3QubGVuZ3RoO1xuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmIGlzTGVuZ3RoKGxlbmd0aCkgJiYgaXNJbmRleChrZXksIGxlbmd0aCkgJiZcbiAgICAgICAgKGlzQXJyYXkob2JqZWN0KSB8fCBpc0FyZ3VtZW50cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplcyBhbiBhcnJheSBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQXJyYXkoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0gbmV3IGFycmF5LmNvbnN0cnVjdG9yKGxlbmd0aCk7XG5cbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIGFzc2lnbmVkIGJ5IGBSZWdFeHAjZXhlY2AuXG4gICAgICBpZiAobGVuZ3RoICYmIHR5cGVvZiBhcnJheVswXSA9PSAnc3RyaW5nJyAmJiBoYXNPd25Qcm9wZXJ0eS5jYWxsKGFycmF5LCAnaW5kZXgnKSkge1xuICAgICAgICByZXN1bHQuaW5kZXggPSBhcnJheS5pbmRleDtcbiAgICAgICAgcmVzdWx0LmlucHV0ID0gYXJyYXkuaW5wdXQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEluaXRpYWxpemVzIGFuIG9iamVjdCBjbG9uZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGluaXRpYWxpemVkIGNsb25lLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRDbG9uZU9iamVjdChvYmplY3QpIHtcbiAgICAgIHJldHVybiAodHlwZW9mIG9iamVjdC5jb25zdHJ1Y3RvciA9PSAnZnVuY3Rpb24nICYmICFpc1Byb3RvdHlwZShvYmplY3QpKVxuICAgICAgICA/IGJhc2VDcmVhdGUoZ2V0UHJvdG90eXBlKG9iamVjdCkpXG4gICAgICAgIDoge307XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5pdGlhbGl6ZXMgYW4gb2JqZWN0IGNsb25lIGJhc2VkIG9uIGl0cyBgdG9TdHJpbmdUYWdgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgZnVuY3Rpb24gb25seSBzdXBwb3J0cyBjbG9uaW5nIHZhbHVlcyB3aXRoIHRhZ3Mgb2ZcbiAgICAgKiBgQm9vbGVhbmAsIGBEYXRlYCwgYEVycm9yYCwgYE1hcGAsIGBOdW1iZXJgLCBgUmVnRXhwYCwgYFNldGAsIG9yIGBTdHJpbmdgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gY2xvbmUuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHRhZyBUaGUgYHRvU3RyaW5nVGFnYCBvZiB0aGUgb2JqZWN0IHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2lzRGVlcF0gU3BlY2lmeSBhIGRlZXAgY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgaW5pdGlhbGl6ZWQgY2xvbmUuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5pdENsb25lQnlUYWcob2JqZWN0LCB0YWcsIGlzRGVlcCkge1xuICAgICAgdmFyIEN0b3IgPSBvYmplY3QuY29uc3RydWN0b3I7XG4gICAgICBzd2l0Y2ggKHRhZykge1xuICAgICAgICBjYXNlIGFycmF5QnVmZmVyVGFnOlxuICAgICAgICAgIHJldHVybiBjbG9uZUFycmF5QnVmZmVyKG9iamVjdCk7XG5cbiAgICAgICAgY2FzZSBib29sVGFnOlxuICAgICAgICBjYXNlIGRhdGVUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yKCtvYmplY3QpO1xuXG4gICAgICAgIGNhc2UgZGF0YVZpZXdUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lRGF0YVZpZXcob2JqZWN0LCBpc0RlZXApO1xuXG4gICAgICAgIGNhc2UgZmxvYXQzMlRhZzogY2FzZSBmbG9hdDY0VGFnOlxuICAgICAgICBjYXNlIGludDhUYWc6IGNhc2UgaW50MTZUYWc6IGNhc2UgaW50MzJUYWc6XG4gICAgICAgIGNhc2UgdWludDhUYWc6IGNhc2UgdWludDhDbGFtcGVkVGFnOiBjYXNlIHVpbnQxNlRhZzogY2FzZSB1aW50MzJUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lVHlwZWRBcnJheShvYmplY3QsIGlzRGVlcCk7XG5cbiAgICAgICAgY2FzZSBtYXBUYWc6XG4gICAgICAgICAgcmV0dXJuIG5ldyBDdG9yO1xuXG4gICAgICAgIGNhc2UgbnVtYmVyVGFnOlxuICAgICAgICBjYXNlIHN0cmluZ1RhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3Iob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHJlZ2V4cFRhZzpcbiAgICAgICAgICByZXR1cm4gY2xvbmVSZWdFeHAob2JqZWN0KTtcblxuICAgICAgICBjYXNlIHNldFRhZzpcbiAgICAgICAgICByZXR1cm4gbmV3IEN0b3I7XG5cbiAgICAgICAgY2FzZSBzeW1ib2xUYWc6XG4gICAgICAgICAgcmV0dXJuIGNsb25lU3ltYm9sKG9iamVjdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW5zZXJ0cyB3cmFwcGVyIGBkZXRhaWxzYCBpbiBhIGNvbW1lbnQgYXQgdGhlIHRvcCBvZiB0aGUgYHNvdXJjZWAgYm9keS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHNvdXJjZSBUaGUgc291cmNlIHRvIG1vZGlmeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IGRldGFpbHMgVGhlIGRldGFpbHMgdG8gaW5zZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHNvdXJjZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpbnNlcnRXcmFwRGV0YWlscyhzb3VyY2UsIGRldGFpbHMpIHtcbiAgICAgIHZhciBsZW5ndGggPSBkZXRhaWxzLmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBzb3VyY2U7XG4gICAgICB9XG4gICAgICB2YXIgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcbiAgICAgIGRldGFpbHNbbGFzdEluZGV4XSA9IChsZW5ndGggPiAxID8gJyYgJyA6ICcnKSArIGRldGFpbHNbbGFzdEluZGV4XTtcbiAgICAgIGRldGFpbHMgPSBkZXRhaWxzLmpvaW4obGVuZ3RoID4gMiA/ICcsICcgOiAnICcpO1xuICAgICAgcmV0dXJuIHNvdXJjZS5yZXBsYWNlKHJlV3JhcENvbW1lbnQsICd7XFxuLyogW3dyYXBwZWQgd2l0aCAnICsgZGV0YWlscyArICddICovXFxuJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBmbGF0dGVuYWJsZSBgYXJndW1lbnRzYCBvYmplY3Qgb3IgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGZsYXR0ZW5hYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGbGF0dGVuYWJsZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzQXJyYXkodmFsdWUpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSB8fFxuICAgICAgICAhIShzcHJlYWRhYmxlU3ltYm9sICYmIHZhbHVlICYmIHZhbHVlW3NwcmVhZGFibGVTeW1ib2xdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgaW5kZXguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPU1BWF9TQUZFX0lOVEVHRVJdIFRoZSB1cHBlciBib3VuZHMgb2YgYSB2YWxpZCBpbmRleC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGluZGV4LCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNJbmRleCh2YWx1ZSwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIGxlbmd0aCA9IGxlbmd0aCA9PSBudWxsID8gTUFYX1NBRkVfSU5URUdFUiA6IGxlbmd0aDtcblxuICAgICAgcmV0dXJuICEhbGVuZ3RoICYmXG4gICAgICAgICh0eXBlID09ICdudW1iZXInIHx8XG4gICAgICAgICAgKHR5cGUgIT0gJ3N5bWJvbCcgJiYgcmVJc1VpbnQudGVzdCh2YWx1ZSkpKSAmJlxuICAgICAgICAgICAgKHZhbHVlID4gLTEgJiYgdmFsdWUgJSAxID09IDAgJiYgdmFsdWUgPCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHBvdGVudGlhbCBpdGVyYXRlZSB2YWx1ZSBhcmd1bWVudC5cbiAgICAgKiBAcGFyYW0geyp9IGluZGV4IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgaW5kZXggb3Iga2V5IGFyZ3VtZW50LlxuICAgICAqIEBwYXJhbSB7Kn0gb2JqZWN0IFRoZSBwb3RlbnRpYWwgaXRlcmF0ZWUgb2JqZWN0IGFyZ3VtZW50LlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYXJndW1lbnRzIGFyZSBmcm9tIGFuIGl0ZXJhdGVlIGNhbGwsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0l0ZXJhdGVlQ2FsbCh2YWx1ZSwgaW5kZXgsIG9iamVjdCkge1xuICAgICAgaWYgKCFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIGluZGV4O1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcidcbiAgICAgICAgICAgID8gKGlzQXJyYXlMaWtlKG9iamVjdCkgJiYgaXNJbmRleChpbmRleCwgb2JqZWN0Lmxlbmd0aCkpXG4gICAgICAgICAgICA6ICh0eXBlID09ICdzdHJpbmcnICYmIGluZGV4IGluIG9iamVjdClcbiAgICAgICAgICApIHtcbiAgICAgICAgcmV0dXJuIGVxKG9iamVjdFtpbmRleF0sIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHByb3BlcnR5IG5hbWUgYW5kIG5vdCBhIHByb3BlcnR5IHBhdGguXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb2JqZWN0XSBUaGUgb2JqZWN0IHRvIHF1ZXJ5IGtleXMgb24uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm9wZXJ0eSBuYW1lLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXkodmFsdWUsIG9iamVjdCkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgICAgaWYgKHR5cGUgPT0gJ251bWJlcicgfHwgdHlwZSA9PSAnc3ltYm9sJyB8fCB0eXBlID09ICdib29sZWFuJyB8fFxuICAgICAgICAgIHZhbHVlID09IG51bGwgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlSXNQbGFpblByb3AudGVzdCh2YWx1ZSkgfHwgIXJlSXNEZWVwUHJvcC50ZXN0KHZhbHVlKSB8fFxuICAgICAgICAob2JqZWN0ICE9IG51bGwgJiYgdmFsdWUgaW4gT2JqZWN0KG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlIGZvciB1c2UgYXMgdW5pcXVlIG9iamVjdCBrZXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIHN1aXRhYmxlLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNLZXlhYmxlKHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiAodHlwZSA9PSAnc3RyaW5nJyB8fCB0eXBlID09ICdudW1iZXInIHx8IHR5cGUgPT0gJ3N5bWJvbCcgfHwgdHlwZSA9PSAnYm9vbGVhbicpXG4gICAgICAgID8gKHZhbHVlICE9PSAnX19wcm90b19fJylcbiAgICAgICAgOiAodmFsdWUgPT09IG51bGwpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaGFzIGEgbGF6eSBjb3VudGVycGFydC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBoYXMgYSBsYXp5IGNvdW50ZXJwYXJ0LFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNMYXppYWJsZShmdW5jKSB7XG4gICAgICB2YXIgZnVuY05hbWUgPSBnZXRGdW5jTmFtZShmdW5jKSxcbiAgICAgICAgICBvdGhlciA9IGxvZGFzaFtmdW5jTmFtZV07XG5cbiAgICAgIGlmICh0eXBlb2Ygb3RoZXIgIT0gJ2Z1bmN0aW9uJyB8fCAhKGZ1bmNOYW1lIGluIExhenlXcmFwcGVyLnByb3RvdHlwZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgaWYgKGZ1bmMgPT09IG90aGVyKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIGRhdGEgPSBnZXREYXRhKG90aGVyKTtcbiAgICAgIHJldHVybiAhIWRhdGEgJiYgZnVuYyA9PT0gZGF0YVswXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYGZ1bmNgIGhhcyBpdHMgc291cmNlIG1hc2tlZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBmdW5jYCBpcyBtYXNrZWQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc01hc2tlZChmdW5jKSB7XG4gICAgICByZXR1cm4gISFtYXNrU3JjS2V5ICYmIChtYXNrU3JjS2V5IGluIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgZnVuY2AgaXMgY2FwYWJsZSBvZiBiZWluZyBtYXNrZWQuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgZnVuY2AgaXMgbWFza2FibGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICB2YXIgaXNNYXNrYWJsZSA9IGNvcmVKc0RhdGEgPyBpc0Z1bmN0aW9uIDogc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgcHJvdG90eXBlIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwcm90b3R5cGUsIGVsc2UgYGZhbHNlYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1Byb3RvdHlwZSh2YWx1ZSkge1xuICAgICAgdmFyIEN0b3IgPSB2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBwcm90byA9ICh0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IucHJvdG90eXBlKSB8fCBvYmplY3RQcm90bztcblxuICAgICAgcmV0dXJuIHZhbHVlID09PSBwcm90bztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBzdWl0YWJsZSBmb3Igc3RyaWN0IGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpZiBzdWl0YWJsZSBmb3Igc3RyaWN0XG4gICAgICogIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBlbHNlIGBmYWxzZWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTdHJpY3RDb21wYXJhYmxlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHZhbHVlICYmICFpc09iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQSBzcGVjaWFsaXplZCB2ZXJzaW9uIG9mIGBtYXRjaGVzUHJvcGVydHlgIGZvciBzb3VyY2UgdmFsdWVzIHN1aXRhYmxlXG4gICAgICogZm9yIHN0cmljdCBlcXVhbGl0eSBjb21wYXJpc29ucywgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBzcmNWYWx1ZSBUaGUgdmFsdWUgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgc3BlYyBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXRjaGVzU3RyaWN0Q29tcGFyYWJsZShrZXksIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIGlmIChvYmplY3QgPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb2JqZWN0W2tleV0gPT09IHNyY1ZhbHVlICYmXG4gICAgICAgICAgKHNyY1ZhbHVlICE9PSB1bmRlZmluZWQgfHwgKGtleSBpbiBPYmplY3Qob2JqZWN0KSkpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8ubWVtb2l6ZWAgd2hpY2ggY2xlYXJzIHRoZSBtZW1vaXplZCBmdW5jdGlvbidzXG4gICAgICogY2FjaGUgd2hlbiBpdCBleGNlZWRzIGBNQVhfTUVNT0laRV9TSVpFYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lbW9pemVDYXBwZWQoZnVuYykge1xuICAgICAgdmFyIHJlc3VsdCA9IG1lbW9pemUoZnVuYywgZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChjYWNoZS5zaXplID09PSBNQVhfTUVNT0laRV9TSVpFKSB7XG4gICAgICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ga2V5O1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBjYWNoZSA9IHJlc3VsdC5jYWNoZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogTWVyZ2VzIHRoZSBmdW5jdGlvbiBtZXRhZGF0YSBvZiBgc291cmNlYCBpbnRvIGBkYXRhYC5cbiAgICAgKlxuICAgICAqIE1lcmdpbmcgbWV0YWRhdGEgcmVkdWNlcyB0aGUgbnVtYmVyIG9mIHdyYXBwZXJzIHVzZWQgdG8gaW52b2tlIGEgZnVuY3Rpb24uXG4gICAgICogVGhpcyBpcyBwb3NzaWJsZSBiZWNhdXNlIG1ldGhvZHMgbGlrZSBgXy5iaW5kYCwgYF8uY3VycnlgLCBhbmQgYF8ucGFydGlhbGBcbiAgICAgKiBtYXkgYmUgYXBwbGllZCByZWdhcmRsZXNzIG9mIGV4ZWN1dGlvbiBvcmRlci4gTWV0aG9kcyBsaWtlIGBfLmFyeWAgYW5kXG4gICAgICogYF8ucmVhcmdgIG1vZGlmeSBmdW5jdGlvbiBhcmd1bWVudHMsIG1ha2luZyB0aGUgb3JkZXIgaW4gd2hpY2ggdGhleSBhcmVcbiAgICAgKiBleGVjdXRlZCBpbXBvcnRhbnQsIHByZXZlbnRpbmcgdGhlIG1lcmdpbmcgb2YgbWV0YWRhdGEuIEhvd2V2ZXIsIHdlIG1ha2VcbiAgICAgKiBhbiBleGNlcHRpb24gZm9yIGEgc2FmZSBjb21iaW5lZCBjYXNlIHdoZXJlIGN1cnJpZWQgZnVuY3Rpb25zIGhhdmUgYF8uYXJ5YFxuICAgICAqIGFuZCBvciBgXy5yZWFyZ2AgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtBcnJheX0gZGF0YSBUaGUgZGVzdGluYXRpb24gbWV0YWRhdGEuXG4gICAgICogQHBhcmFtIHtBcnJheX0gc291cmNlIFRoZSBzb3VyY2UgbWV0YWRhdGEuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBkYXRhYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZXJnZURhdGEoZGF0YSwgc291cmNlKSB7XG4gICAgICB2YXIgYml0bWFzayA9IGRhdGFbMV0sXG4gICAgICAgICAgc3JjQml0bWFzayA9IHNvdXJjZVsxXSxcbiAgICAgICAgICBuZXdCaXRtYXNrID0gYml0bWFzayB8IHNyY0JpdG1hc2ssXG4gICAgICAgICAgaXNDb21tb24gPSBuZXdCaXRtYXNrIDwgKFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHIHwgV1JBUF9BUllfRkxBRyk7XG5cbiAgICAgIHZhciBpc0NvbWJvID1cbiAgICAgICAgKChzcmNCaXRtYXNrID09IFdSQVBfQVJZX0ZMQUcpICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpIHx8XG4gICAgICAgICgoc3JjQml0bWFzayA9PSBXUkFQX0FSWV9GTEFHKSAmJiAoYml0bWFzayA9PSBXUkFQX1JFQVJHX0ZMQUcpICYmIChkYXRhWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pKSB8fFxuICAgICAgICAoKHNyY0JpdG1hc2sgPT0gKFdSQVBfQVJZX0ZMQUcgfCBXUkFQX1JFQVJHX0ZMQUcpKSAmJiAoc291cmNlWzddLmxlbmd0aCA8PSBzb3VyY2VbOF0pICYmIChiaXRtYXNrID09IFdSQVBfQ1VSUllfRkxBRykpO1xuXG4gICAgICAvLyBFeGl0IGVhcmx5IGlmIG1ldGFkYXRhIGNhbid0IGJlIG1lcmdlZC5cbiAgICAgIGlmICghKGlzQ29tbW9uIHx8IGlzQ29tYm8pKSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgdGhpc0FyZ2AgaWYgYXZhaWxhYmxlLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRykge1xuICAgICAgICBkYXRhWzJdID0gc291cmNlWzJdO1xuICAgICAgICAvLyBTZXQgd2hlbiBjdXJyeWluZyBhIGJvdW5kIGZ1bmN0aW9uLlxuICAgICAgICBuZXdCaXRtYXNrIHw9IGJpdG1hc2sgJiBXUkFQX0JJTkRfRkxBRyA/IDAgOiBXUkFQX0NVUlJZX0JPVU5EX0ZMQUc7XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgYXJndW1lbnRzLlxuICAgICAgdmFyIHZhbHVlID0gc291cmNlWzNdO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHZhciBwYXJ0aWFscyA9IGRhdGFbM107XG4gICAgICAgIGRhdGFbM10gPSBwYXJ0aWFscyA/IGNvbXBvc2VBcmdzKHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzRdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzRdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzNdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNF07XG4gICAgICB9XG4gICAgICAvLyBDb21wb3NlIHBhcnRpYWwgcmlnaHQgYXJndW1lbnRzLlxuICAgICAgdmFsdWUgPSBzb3VyY2VbNV07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcGFydGlhbHMgPSBkYXRhWzVdO1xuICAgICAgICBkYXRhWzVdID0gcGFydGlhbHMgPyBjb21wb3NlQXJnc1JpZ2h0KHBhcnRpYWxzLCB2YWx1ZSwgc291cmNlWzZdKSA6IHZhbHVlO1xuICAgICAgICBkYXRhWzZdID0gcGFydGlhbHMgPyByZXBsYWNlSG9sZGVycyhkYXRhWzVdLCBQTEFDRUhPTERFUikgOiBzb3VyY2VbNl07XG4gICAgICB9XG4gICAgICAvLyBVc2Ugc291cmNlIGBhcmdQb3NgIGlmIGF2YWlsYWJsZS5cbiAgICAgIHZhbHVlID0gc291cmNlWzddO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIGRhdGFbN10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyeWAgaWYgaXQncyBzbWFsbGVyLlxuICAgICAgaWYgKHNyY0JpdG1hc2sgJiBXUkFQX0FSWV9GTEFHKSB7XG4gICAgICAgIGRhdGFbOF0gPSBkYXRhWzhdID09IG51bGwgPyBzb3VyY2VbOF0gOiBuYXRpdmVNaW4oZGF0YVs4XSwgc291cmNlWzhdKTtcbiAgICAgIH1cbiAgICAgIC8vIFVzZSBzb3VyY2UgYGFyaXR5YCBpZiBvbmUgaXMgbm90IHByb3ZpZGVkLlxuICAgICAgaWYgKGRhdGFbOV0gPT0gbnVsbCkge1xuICAgICAgICBkYXRhWzldID0gc291cmNlWzldO1xuICAgICAgfVxuICAgICAgLy8gVXNlIHNvdXJjZSBgZnVuY2AgYW5kIG1lcmdlIGJpdG1hc2tzLlxuICAgICAgZGF0YVswXSA9IHNvdXJjZVswXTtcbiAgICAgIGRhdGFbMV0gPSBuZXdCaXRtYXNrO1xuXG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIGZ1bmN0aW9uIGlzIGxpa2VcbiAgICAgKiBbYE9iamVjdC5rZXlzYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZXhjZXB0IHRoYXQgaXQgaW5jbHVkZXMgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgbmFtZXMuXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmF0aXZlS2V5c0luKG9iamVjdCkge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKG9iamVjdCAhPSBudWxsKSB7XG4gICAgICAgIGZvciAodmFyIGtleSBpbiBPYmplY3Qob2JqZWN0KSkge1xuICAgICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyB1c2luZyBgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBvYmplY3RUb1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEEgc3BlY2lhbGl6ZWQgdmVyc2lvbiBvZiBgYmFzZVJlc3RgIHdoaWNoIHRyYW5zZm9ybXMgdGhlIHJlc3QgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGFwcGx5IGEgcmVzdCBwYXJhbWV0ZXIgdG8uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD1mdW5jLmxlbmd0aC0xXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHJlc3QgcGFyYW1ldGVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHRyYW5zZm9ybSBUaGUgcmVzdCBhcnJheSB0cmFuc2Zvcm0uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3ZlclJlc3QoZnVuYywgc3RhcnQsIHRyYW5zZm9ybSkge1xuICAgICAgc3RhcnQgPSBuYXRpdmVNYXgoc3RhcnQgPT09IHVuZGVmaW5lZCA/IChmdW5jLmxlbmd0aCAtIDEpIDogc3RhcnQsIDApO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoYXJncy5sZW5ndGggLSBzdGFydCwgMCksXG4gICAgICAgICAgICBhcnJheSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgICBhcnJheVtpbmRleF0gPSBhcmdzW3N0YXJ0ICsgaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gLTE7XG4gICAgICAgIHZhciBvdGhlckFyZ3MgPSBBcnJheShzdGFydCArIDEpO1xuICAgICAgICB3aGlsZSAoKytpbmRleCA8IHN0YXJ0KSB7XG4gICAgICAgICAgb3RoZXJBcmdzW2luZGV4XSA9IGFyZ3NbaW5kZXhdO1xuICAgICAgICB9XG4gICAgICAgIG90aGVyQXJnc1tzdGFydF0gPSB0cmFuc2Zvcm0oYXJyYXkpO1xuICAgICAgICByZXR1cm4gYXBwbHkoZnVuYywgdGhpcywgb3RoZXJBcmdzKTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgcGFyZW50IHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhdGggVGhlIHBhdGggdG8gZ2V0IHRoZSBwYXJlbnQgdmFsdWUgb2YuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHBhcmVudCB2YWx1ZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYXJlbnQob2JqZWN0LCBwYXRoKSB7XG4gICAgICByZXR1cm4gcGF0aC5sZW5ndGggPCAyID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIGJhc2VTbGljZShwYXRoLCAwLCAtMSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlb3JkZXIgYGFycmF5YCBhY2NvcmRpbmcgdG8gdGhlIHNwZWNpZmllZCBpbmRleGVzIHdoZXJlIHRoZSBlbGVtZW50IGF0XG4gICAgICogdGhlIGZpcnN0IGluZGV4IGlzIGFzc2lnbmVkIGFzIHRoZSBmaXJzdCBlbGVtZW50LCB0aGUgZWxlbWVudCBhdFxuICAgICAqIHRoZSBzZWNvbmQgaW5kZXggaXMgYXNzaWduZWQgYXMgdGhlIHNlY29uZCBlbGVtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byByZW9yZGVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGluZGV4ZXMgVGhlIGFycmFuZ2VkIGFycmF5IGluZGV4ZXMuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVvcmRlcihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGFyckxlbmd0aCA9IGFycmF5Lmxlbmd0aCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oaW5kZXhlcy5sZW5ndGgsIGFyckxlbmd0aCksXG4gICAgICAgICAgb2xkQXJyYXkgPSBjb3B5QXJyYXkoYXJyYXkpO1xuXG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaW5kZXhlc1tsZW5ndGhdO1xuICAgICAgICBhcnJheVtsZW5ndGhdID0gaXNJbmRleChpbmRleCwgYXJyTGVuZ3RoKSA/IG9sZEFycmF5W2luZGV4XSA6IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSB2YWx1ZSBhdCBga2V5YCwgdW5sZXNzIGBrZXlgIGlzIFwiX19wcm90b19fXCIgb3IgXCJjb25zdHJ1Y3RvclwiLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHByb3BlcnR5IHZhbHVlLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhZmVHZXQob2JqZWN0LCBrZXkpIHtcbiAgICAgIGlmIChrZXkgPT09ICdjb25zdHJ1Y3RvcicgJiYgdHlwZW9mIG9iamVjdFtrZXldID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgaWYgKGtleSA9PSAnX19wcm90b19fJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBvYmplY3Rba2V5XTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXRzIG1ldGFkYXRhIGZvciBgZnVuY2AuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgdGhpcyBmdW5jdGlvbiBiZWNvbWVzIGhvdCwgaS5lLiBpcyBpbnZva2VkIGEgbG90IGluIGEgc2hvcnRcbiAgICAgKiBwZXJpb2Qgb2YgdGltZSwgaXQgd2lsbCB0cmlwIGl0cyBicmVha2VyIGFuZCB0cmFuc2l0aW9uIHRvIGFuIGlkZW50aXR5XG4gICAgICogZnVuY3Rpb24gdG8gYXZvaWQgZ2FyYmFnZSBjb2xsZWN0aW9uIHBhdXNlcyBpbiBWOC4gU2VlXG4gICAgICogW1Y4IGlzc3VlIDIwNzBdKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIwNzApXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYXNzb2NpYXRlIG1ldGFkYXRhIHdpdGguXG4gICAgICogQHBhcmFtIHsqfSBkYXRhIFRoZSBtZXRhZGF0YS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYGZ1bmNgLlxuICAgICAqL1xuICAgIHZhciBzZXREYXRhID0gc2hvcnRPdXQoYmFzZVNldERhdGEpO1xuXG4gICAgLyoqXG4gICAgICogQSBzaW1wbGUgd3JhcHBlciBhcm91bmQgdGhlIGdsb2JhbCBbYHNldFRpbWVvdXRgXShodHRwczovL21kbi5pby9zZXRUaW1lb3V0KS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfE9iamVjdH0gUmV0dXJucyB0aGUgdGltZXIgaWQgb3IgdGltZW91dCBvYmplY3QuXG4gICAgICovXG4gICAgdmFyIHNldFRpbWVvdXQgPSBjdHhTZXRUaW1lb3V0IHx8IGZ1bmN0aW9uKGZ1bmMsIHdhaXQpIHtcbiAgICAgIHJldHVybiByb290LnNldFRpbWVvdXQoZnVuYywgd2FpdCk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGBmdW5jYCB0byByZXR1cm4gYHN0cmluZ2AuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBzdHJpbmcgVGhlIGB0b1N0cmluZ2AgcmVzdWx0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyBgZnVuY2AuXG4gICAgICovXG4gICAgdmFyIHNldFRvU3RyaW5nID0gc2hvcnRPdXQoYmFzZVNldFRvU3RyaW5nKTtcblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIGB0b1N0cmluZ2AgbWV0aG9kIG9mIGB3cmFwcGVyYCB0byBtaW1pYyB0aGUgc291cmNlIG9mIGByZWZlcmVuY2VgXG4gICAgICogd2l0aCB3cmFwcGVyIGRldGFpbHMgaW4gYSBjb21tZW50IGF0IHRoZSB0b3Agb2YgdGhlIHNvdXJjZSBib2R5LlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSB3cmFwcGVyIFRoZSBmdW5jdGlvbiB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gcmVmZXJlbmNlIFRoZSByZWZlcmVuY2UgZnVuY3Rpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGJpdG1hc2sgVGhlIGJpdG1hc2sgZmxhZ3MuIFNlZSBgY3JlYXRlV3JhcGAgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgYHdyYXBwZXJgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdyYXBUb1N0cmluZyh3cmFwcGVyLCByZWZlcmVuY2UsIGJpdG1hc2spIHtcbiAgICAgIHZhciBzb3VyY2UgPSAocmVmZXJlbmNlICsgJycpO1xuICAgICAgcmV0dXJuIHNldFRvU3RyaW5nKHdyYXBwZXIsIGluc2VydFdyYXBEZXRhaWxzKHNvdXJjZSwgdXBkYXRlV3JhcERldGFpbHMoZ2V0V3JhcERldGFpbHMoc291cmNlKSwgYml0bWFzaykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCdsbCBzaG9ydCBvdXQgYW5kIGludm9rZSBgaWRlbnRpdHlgIGluc3RlYWRcbiAgICAgKiBvZiBgZnVuY2Agd2hlbiBpdCdzIGNhbGxlZCBgSE9UX0NPVU5UYCBvciBtb3JlIHRpbWVzIGluIGBIT1RfU1BBTmBcbiAgICAgKiBtaWxsaXNlY29uZHMuXG4gICAgICpcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNob3J0YWJsZSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaG9ydE91dChmdW5jKSB7XG4gICAgICB2YXIgY291bnQgPSAwLFxuICAgICAgICAgIGxhc3RDYWxsZWQgPSAwO1xuXG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBzdGFtcCA9IG5hdGl2ZU5vdygpLFxuICAgICAgICAgICAgcmVtYWluaW5nID0gSE9UX1NQQU4gLSAoc3RhbXAgLSBsYXN0Q2FsbGVkKTtcblxuICAgICAgICBsYXN0Q2FsbGVkID0gc3RhbXA7XG4gICAgICAgIGlmIChyZW1haW5pbmcgPiAwKSB7XG4gICAgICAgICAgaWYgKCsrY291bnQgPj0gSE9UX0NPVU5UKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJndW1lbnRzWzBdO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmd1bWVudHMpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBBIHNwZWNpYWxpemVkIHZlcnNpb24gb2YgYF8uc2h1ZmZsZWAgd2hpY2ggbXV0YXRlcyBhbmQgc2V0cyB0aGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2h1ZmZsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemU9YXJyYXkubGVuZ3RoXSBUaGUgc2l6ZSBvZiBgYXJyYXlgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGVTZWxmKGFycmF5LCBzaXplKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgbGFzdEluZGV4ID0gbGVuZ3RoIC0gMTtcblxuICAgICAgc2l6ZSA9IHNpemUgPT09IHVuZGVmaW5lZCA/IGxlbmd0aCA6IHNpemU7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IHNpemUpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBiYXNlUmFuZG9tKGluZGV4LCBsYXN0SW5kZXgpLFxuICAgICAgICAgICAgdmFsdWUgPSBhcnJheVtyYW5kXTtcblxuICAgICAgICBhcnJheVtyYW5kXSA9IGFycmF5W2luZGV4XTtcbiAgICAgICAgYXJyYXlbaW5kZXhdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBhcnJheS5sZW5ndGggPSBzaXplO1xuICAgICAgcmV0dXJuIGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGBzdHJpbmdgIHRvIGEgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwcm9wZXJ0eSBwYXRoIGFycmF5LlxuICAgICAqL1xuICAgIHZhciBzdHJpbmdUb1BhdGggPSBtZW1vaXplQ2FwcGVkKGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgICAgaWYgKHN0cmluZy5jaGFyQ29kZUF0KDApID09PSA0NiAvKiAuICovKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKCcnKTtcbiAgICAgIH1cbiAgICAgIHN0cmluZy5yZXBsYWNlKHJlUHJvcE5hbWUsIGZ1bmN0aW9uKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcbiAgICAgICAgcmVzdWx0LnB1c2gocXVvdGUgPyBzdWJTdHJpbmcucmVwbGFjZShyZUVzY2FwZUNoYXIsICckMScpIDogKG51bWJlciB8fCBtYXRjaCkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZyBrZXkgaWYgaXQncyBub3QgYSBzdHJpbmcgb3Igc3ltYm9sLlxuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8c3ltYm9sfSBSZXR1cm5zIHRoZSBrZXkuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9LZXkodmFsdWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT0gJ3N0cmluZycgfHwgaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSAodmFsdWUgKyAnJyk7XG4gICAgICByZXR1cm4gKHJlc3VsdCA9PSAnMCcgJiYgKDEgLyB2YWx1ZSkgPT0gLUlORklOSVRZKSA/ICctMCcgOiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYGZ1bmNgIHRvIGl0cyBzb3VyY2UgY29kZS5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBzb3VyY2UgY29kZS5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1NvdXJjZShmdW5jKSB7XG4gICAgICBpZiAoZnVuYyAhPSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmNUb1N0cmluZy5jYWxsKGZ1bmMpO1xuICAgICAgICB9IGNhdGNoIChlKSB7fVxuICAgICAgICB0cnkge1xuICAgICAgICAgIHJldHVybiAoZnVuYyArICcnKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge31cbiAgICAgIH1cbiAgICAgIHJldHVybiAnJztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVcGRhdGVzIHdyYXBwZXIgYGRldGFpbHNgIGJhc2VkIG9uIGBiaXRtYXNrYCBmbGFncy5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHJldHVybnMge0FycmF5fSBkZXRhaWxzIFRoZSBkZXRhaWxzIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYml0bWFzayBUaGUgYml0bWFzayBmbGFncy4gU2VlIGBjcmVhdGVXcmFwYCBmb3IgbW9yZSBkZXRhaWxzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgZGV0YWlsc2AuXG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV3JhcERldGFpbHMoZGV0YWlscywgYml0bWFzaykge1xuICAgICAgYXJyYXlFYWNoKHdyYXBGbGFncywgZnVuY3Rpb24ocGFpcikge1xuICAgICAgICB2YXIgdmFsdWUgPSAnXy4nICsgcGFpclswXTtcbiAgICAgICAgaWYgKChiaXRtYXNrICYgcGFpclsxXSkgJiYgIWFycmF5SW5jbHVkZXMoZGV0YWlscywgdmFsdWUpKSB7XG4gICAgICAgICAgZGV0YWlscy5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gZGV0YWlscy5zb3J0KCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB3cmFwcGVyYC5cbiAgICAgKlxuICAgICAqIEBwcml2YXRlXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHdyYXBwZXIgVGhlIHdyYXBwZXIgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY2xvbmVkIHdyYXBwZXIuXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNsb25lKHdyYXBwZXIpIHtcbiAgICAgIGlmICh3cmFwcGVyIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHtcbiAgICAgICAgcmV0dXJuIHdyYXBwZXIuY2xvbmUoKTtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBuZXcgTG9kYXNoV3JhcHBlcih3cmFwcGVyLl9fd3JhcHBlZF9fLCB3cmFwcGVyLl9fY2hhaW5fXyk7XG4gICAgICByZXN1bHQuX19hY3Rpb25zX18gPSBjb3B5QXJyYXkod3JhcHBlci5fX2FjdGlvbnNfXyk7XG4gICAgICByZXN1bHQuX19pbmRleF9fICA9IHdyYXBwZXIuX19pbmRleF9fO1xuICAgICAgcmVzdWx0Ll9fdmFsdWVzX18gPSB3cmFwcGVyLl9fdmFsdWVzX187XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byBncm91cHMgdGhlIGxlbmd0aCBvZiBgc2l6ZWAuXG4gICAgICogSWYgYGFycmF5YCBjYW4ndCBiZSBzcGxpdCBldmVubHksIHRoZSBmaW5hbCBjaHVuayB3aWxsIGJlIHRoZSByZW1haW5pbmdcbiAgICAgKiBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc2l6ZT0xXSBUaGUgbGVuZ3RoIG9mIGVhY2ggY2h1bmtcbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNodW5rcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jaHVuayhbJ2EnLCAnYicsICdjJywgJ2QnXSwgMik7XG4gICAgICogLy8gPT4gW1snYScsICdiJ10sIFsnYycsICdkJ11dXG4gICAgICpcbiAgICAgKiBfLmNodW5rKFsnYScsICdiJywgJ2MnLCAnZCddLCAzKTtcbiAgICAgKiAvLyA9PiBbWydhJywgJ2InLCAnYyddLCBbJ2QnXV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaHVuayhhcnJheSwgc2l6ZSwgZ3VhcmQpIHtcbiAgICAgIGlmICgoZ3VhcmQgPyBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc2l6ZSwgZ3VhcmQpIDogc2l6ZSA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBzaXplID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNpemUgPSBuYXRpdmVNYXgodG9JbnRlZ2VyKHNpemUpLCAwKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoIHx8IHNpemUgPCAxKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IDAsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IEFycmF5KG5hdGl2ZUNlaWwobGVuZ3RoIC8gc2l6ZSkpO1xuXG4gICAgICB3aGlsZSAoaW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgcmVzdWx0W3Jlc0luZGV4KytdID0gYmFzZVNsaWNlKGFycmF5LCBpbmRleCwgKGluZGV4ICs9IHNpemUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIHJlbW92ZWQuIFRoZSB2YWx1ZXMgYGZhbHNlYCwgYG51bGxgLFxuICAgICAqIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCwgYW5kIGBOYU5gIGFyZSBmYWxzZXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uY29tcGFjdChbMCwgMSwgZmFsc2UsIDIsICcnLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29tcGFjdChhcnJheSkge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGgsXG4gICAgICAgICAgcmVzSW5kZXggPSAwLFxuICAgICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIHJlc3VsdFtyZXNJbmRleCsrXSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBuZXcgYXJyYXkgY29uY2F0ZW5hdGluZyBgYXJyYXlgIHdpdGggYW55IGFkZGl0aW9uYWwgYXJyYXlzXG4gICAgICogYW5kL29yIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBjb25jYXRlbmF0ZS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gY29uY2F0ZW5hdGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29uY2F0ZW5hdGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMV07XG4gICAgICogdmFyIG90aGVyID0gXy5jb25jYXQoYXJyYXksIDIsIFszXSwgW1s0XV0pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob3RoZXIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzLCBbNF1dXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uY2F0KCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCAtIDEpLFxuICAgICAgICAgIGFycmF5ID0gYXJndW1lbnRzWzBdLFxuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuXG4gICAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgICBhcmdzW2luZGV4IC0gMV0gPSBhcmd1bWVudHNbaW5kZXhdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFycmF5UHVzaChpc0FycmF5KGFycmF5KSA/IGNvcHlBcnJheShhcnJheSkgOiBbYXJyYXldLCBiYXNlRmxhdHRlbihhcmdzLCAxKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBgYXJyYXlgIHZhbHVlcyBub3QgaW5jbHVkZWQgaW4gdGhlIG90aGVyIGdpdmVuIGFycmF5c1xuICAgICAqIHVzaW5nIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy53aXRob3V0LCBfLnhvclxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2UoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqL1xuICAgIHZhciBkaWZmZXJlbmNlID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlT2JqZWN0KGFycmF5KVxuICAgICAgICA/IGJhc2VEaWZmZXJlbmNlKGFycmF5LCBiYXNlRmxhdHRlbih2YWx1ZXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZGlmZmVyZW5jZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgb3JkZXIgYW5kIHJlZmVyZW5jZXMgb2YgcmVzdWx0IHZhbHVlcyBhcmVcbiAgICAgKiBkZXRlcm1pbmVkIGJ5IHRoZSBmaXJzdCBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucHVsbEFsbEJ5YCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gZXhjbHVkZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kaWZmZXJlbmNlQnkoW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCBbeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5LCB2YWx1ZXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QodmFsdWVzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIGJhc2VGbGF0dGVuKHZhbHVlcywgMSwgaXNBcnJheUxpa2VPYmplY3QsIHRydWUpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpXG4gICAgICAgIDogW107XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmRpZmZlcmVuY2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBvcmRlciBhbmRcbiAgICAgKiByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LiBUaGUgY29tcGFyYXRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAoYXJyVmFsLCBvdGhWYWwpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsQWxsV2l0aGAsIHRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbdmFsdWVzXSBUaGUgdmFsdWVzIHRvIGV4Y2x1ZGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLmRpZmZlcmVuY2VXaXRoKG9iamVjdHMsIFt7ICd4JzogMSwgJ3knOiAyIH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGRpZmZlcmVuY2VXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXksIHZhbHVlcykge1xuICAgICAgdmFyIGNvbXBhcmF0b3IgPSBsYXN0KHZhbHVlcyk7XG4gICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoY29tcGFyYXRvcikpIHtcbiAgICAgICAgY29tcGFyYXRvciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBpc0FycmF5TGlrZU9iamVjdChhcnJheSlcbiAgICAgICAgPyBiYXNlRGlmZmVyZW5jZShhcnJheSwgYmFzZUZsYXR0ZW4odmFsdWVzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgYmVnaW5uaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICpcbiAgICAgKiBfLmRyb3AoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wKFsxLCAyLCAzXSwgMCk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBuIDwgMCA/IDAgOiBuLCBsZW5ndGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIGRyb3BwZWQgZnJvbSB0aGUgZW5kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGRyb3AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZHJvcFJpZ2h0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLmRyb3BSaWdodChbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCA1KTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wUmlnaHQoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgICB9XG4gICAgICBuID0gKGd1YXJkIHx8IG4gPT09IHVuZGVmaW5lZCkgPyAxIDogdG9JbnRlZ2VyKG4pO1xuICAgICAgbiA9IGxlbmd0aCAtIG47XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCBleGNsdWRpbmcgZWxlbWVudHMgZHJvcHBlZCBmcm9tIHRoZSBlbmQuXG4gICAgICogRWxlbWVudHMgYXJlIGRyb3BwZWQgdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFJpZ2h0V2hpbGUodXNlcnMsIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5kcm9wUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnYmFybmV5JywgJ2ZyZWQnLCAncGViYmxlcyddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZHJvcFJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIGV4Y2x1ZGluZyBlbGVtZW50cyBkcm9wcGVkIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKiBFbGVtZW50cyBhcmUgZHJvcHBlZCB1bnRpbCBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleS4gVGhlIHByZWRpY2F0ZSBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXgsIGFycmF5KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gIW8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmRyb3BXaGlsZSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZHJvcFdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCcsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBkcm9wV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCB0cnVlKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEZpbGxzIGVsZW1lbnRzIG9mIGBhcnJheWAgd2l0aCBgdmFsdWVgIGZyb20gYHN0YXJ0YCB1cCB0bywgYnV0IG5vdFxuICAgICAqIGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbGwuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZmlsbCBgYXJyYXlgIHdpdGguXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtlbmQ9YXJyYXkubGVuZ3RoXSBUaGUgZW5kIHBvc2l0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfLmZpbGwoYXJyYXksICdhJyk7XG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdhJywgJ2EnXVxuICAgICAqXG4gICAgICogXy5maWxsKEFycmF5KDMpLCAyKTtcbiAgICAgKiAvLyA9PiBbMiwgMiwgMl1cbiAgICAgKlxuICAgICAqIF8uZmlsbChbNCwgNiwgOCwgMTBdLCAnKicsIDEsIDMpO1xuICAgICAqIC8vID0+IFs0LCAnKicsICcqJywgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsbChhcnJheSwgdmFsdWUsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCAmJiB0eXBlb2Ygc3RhcnQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoYXJyYXksIHZhbHVlLCBzdGFydCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUZpbGwoYXJyYXksIHZhbHVlLCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZpbmRgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBmaXJzdFxuICAgICAqIGVsZW1lbnQgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yIGluc3RlYWQgb2YgdGhlIGVsZW1lbnQgaXRzZWxmLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgZm91bmQgZWxlbWVudCwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmZpbmRJbmRleCh1c2VycywgZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyID09ICdiYXJuZXknOyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCB7ICd1c2VyJzogJ2ZyZWQnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMFxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kSW5kZXgodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmluZEluZGV4KGFycmF5LCBwcmVkaWNhdGUsIGZyb21JbmRleCkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKCFsZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gZnJvbUluZGV4ID09IG51bGwgPyAwIDogdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICBpZiAoaW5kZXggPCAwKSB7XG4gICAgICAgIGluZGV4ID0gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kSW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHNcbiAgICAgKiBvZiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PWFycmF5Lmxlbmd0aC0xXSBUaGUgaW5kZXggdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIGZvdW5kIGVsZW1lbnQsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdwZWJibGVzJywgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLnVzZXIgPT0gJ3BlYmJsZXMnOyB9KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RJbmRleCh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kTGFzdEluZGV4KHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoYXJyYXksIHByZWRpY2F0ZSwgZnJvbUluZGV4KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICB2YXIgaW5kZXggPSBsZW5ndGggLSAxO1xuICAgICAgaWYgKGZyb21JbmRleCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGluZGV4ID0gdG9JbnRlZ2VyKGZyb21JbmRleCk7XG4gICAgICAgIGluZGV4ID0gZnJvbUluZGV4IDwgMFxuICAgICAgICAgID8gbmF0aXZlTWF4KGxlbmd0aCArIGluZGV4LCAwKVxuICAgICAgICAgIDogbmF0aXZlTWluKGluZGV4LCBsZW5ndGggLSAxKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlRmluZEluZGV4KGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRmxhdHRlbnMgYGFycmF5YCBhIHNpbmdsZSBsZXZlbCBkZWVwLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZsYXR0ZW4uXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmZsYXR0ZW4oWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgWzMsIFs0XV0sIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdHRlbihhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCAxKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlY3Vyc2l2ZWx5IGZsYXR0ZW5zIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gZmxhdHRlbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmbGF0dGVuZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlZXAoWzEsIFsyLCBbMywgWzRdXSwgNV1dKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgNCwgNV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0dGVuRGVlcChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VGbGF0dGVuKGFycmF5LCBJTkZJTklUWSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZWN1cnNpdmVseSBmbGF0dGVuIGBhcnJheWAgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjQuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBmbGF0dGVuLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzEsIFsyLCBbMywgWzRdXSwgNV1dO1xuICAgICAqXG4gICAgICogXy5mbGF0dGVuRGVwdGgoYXJyYXksIDEpO1xuICAgICAqIC8vID0+IFsxLCAyLCBbMywgWzRdXSwgNV1cbiAgICAgKlxuICAgICAqIF8uZmxhdHRlbkRlcHRoKGFycmF5LCAyKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgMywgWzRdLCA1XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXR0ZW5EZXB0aChhcnJheSwgZGVwdGgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGRlcHRoID0gZGVwdGggPT09IHVuZGVmaW5lZCA/IDEgOiB0b0ludGVnZXIoZGVwdGgpO1xuICAgICAgcmV0dXJuIGJhc2VGbGF0dGVuKGFycmF5LCBkZXB0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8udG9QYWlyc2A7IHRoaXMgbWV0aG9kIHJldHVybnMgYW4gb2JqZWN0IGNvbXBvc2VkXG4gICAgICogZnJvbSBrZXktdmFsdWUgYHBhaXJzYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IHBhaXJzIFRoZSBrZXktdmFsdWUgcGFpcnMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5mcm9tUGFpcnMoW1snYScsIDFdLCBbJ2InLCAyXV0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZyb21QYWlycyhwYWlycykge1xuICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgbGVuZ3RoID0gcGFpcnMgPT0gbnVsbCA/IDAgOiBwYWlycy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0ID0ge307XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHZhciBwYWlyID0gcGFpcnNbaW5kZXhdO1xuICAgICAgICByZXN1bHRbcGFpclswXV0gPSBwYWlyWzFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBmaXJzdCBlbGVtZW50IG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgZmlyc3RcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5oZWFkKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqXG4gICAgICogXy5oZWFkKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBoZWFkKGFycmF5KSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkgPyBhcnJheVswXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIGluIGBhcnJheWBcbiAgICAgKiB1c2luZyBbYFNhbWVWYWx1ZVplcm9gXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1zYW1ldmFsdWV6ZXJvKVxuICAgICAqIGZvciBlcXVhbGl0eSBjb21wYXJpc29ucy4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0J3MgdXNlZCBhcyB0aGVcbiAgICAgKiBvZmZzZXQgZnJvbSB0aGUgZW5kIG9mIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmluZGV4T2YoWzEsIDIsIDEsIDJdLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICpcbiAgICAgKiAvLyBTZWFyY2ggZnJvbSB0aGUgYGZyb21JbmRleGAuXG4gICAgICogXy5pbmRleE9mKFsxLCAyLCAxLCAyXSwgMiwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGZyb21JbmRleCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICBpbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUluZGV4T2YoYXJyYXksIHZhbHVlLCBpbmRleCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyBhbGwgYnV0IHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW5pdGlhbChbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGluaXRpYWwoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBiYXNlU2xpY2UoYXJyYXksIDAsIC0xKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGFyZSBpbmNsdWRlZCBpbiBhbGwgZ2l2ZW4gYXJyYXlzXG4gICAgICogdXNpbmcgW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIFRoZSBvcmRlciBhbmQgcmVmZXJlbmNlcyBvZiByZXN1bHQgdmFsdWVzIGFyZVxuICAgICAqIGRldGVybWluZWQgYnkgdGhlIGZpcnN0IGFycmF5LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uKFsyLCAxXSwgWzIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMl1cbiAgICAgKi9cbiAgICB2YXIgaW50ZXJzZWN0aW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcbiAgICAgIHJldHVybiAobWFwcGVkLmxlbmd0aCAmJiBtYXBwZWRbMF0gPT09IGFycmF5c1swXSlcbiAgICAgICAgPyBiYXNlSW50ZXJzZWN0aW9uKG1hcHBlZClcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uXG4gICAgICogYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzIG9mIHJlc3VsdCB2YWx1ZXMgYXJlXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGludGVyc2VjdGluZyB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoWzIuMSwgMS4yXSwgWzIuMywgMy40XSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4gWzIuMV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uaW50ZXJzZWN0aW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH1dXG4gICAgICovXG4gICAgdmFyIGludGVyc2VjdGlvbkJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgaXRlcmF0ZWUgPSBsYXN0KGFycmF5cyksXG4gICAgICAgICAgbWFwcGVkID0gYXJyYXlNYXAoYXJyYXlzLCBjYXN0QXJyYXlMaWtlT2JqZWN0KTtcblxuICAgICAgaWYgKGl0ZXJhdGVlID09PSBsYXN0KG1hcHBlZCkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW50ZXJzZWN0aW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gVGhlIG9yZGVyIGFuZCByZWZlcmVuY2VzXG4gICAgICogb2YgcmVzdWx0IHZhbHVlcyBhcmUgZGV0ZXJtaW5lZCBieSB0aGUgZmlyc3QgYXJyYXkuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgaW50ZXJzZWN0aW5nIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dO1xuICAgICAqIHZhciBvdGhlcnMgPSBbeyAneCc6IDEsICd5JzogMSB9LCB7ICd4JzogMSwgJ3knOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5pbnRlcnNlY3Rpb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9XVxuICAgICAqL1xuICAgIHZhciBpbnRlcnNlY3Rpb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKSxcbiAgICAgICAgICBtYXBwZWQgPSBhcnJheU1hcChhcnJheXMsIGNhc3RBcnJheUxpa2VPYmplY3QpO1xuXG4gICAgICBjb21wYXJhdG9yID0gdHlwZW9mIGNvbXBhcmF0b3IgPT0gJ2Z1bmN0aW9uJyA/IGNvbXBhcmF0b3IgOiB1bmRlZmluZWQ7XG4gICAgICBpZiAoY29tcGFyYXRvcikge1xuICAgICAgICBtYXBwZWQucG9wKCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gKG1hcHBlZC5sZW5ndGggJiYgbWFwcGVkWzBdID09PSBhcnJheXNbMF0pXG4gICAgICAgID8gYmFzZUludGVyc2VjdGlvbihtYXBwZWQsIHVuZGVmaW5lZCwgY29tcGFyYXRvcilcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGFsbCBlbGVtZW50cyBpbiBgYXJyYXlgIGludG8gYSBzdHJpbmcgc2VwYXJhdGVkIGJ5IGBzZXBhcmF0b3JgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbnZlcnQuXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzZXBhcmF0b3I9JywnXSBUaGUgZWxlbWVudCBzZXBhcmF0b3IuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgam9pbmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5qb2luKFsnYScsICdiJywgJ2MnXSwgJ34nKTtcbiAgICAgKiAvLyA9PiAnYX5ifmMnXG4gICAgICovXG4gICAgZnVuY3Rpb24gam9pbihhcnJheSwgc2VwYXJhdG9yKSB7XG4gICAgICByZXR1cm4gYXJyYXkgPT0gbnVsbCA/ICcnIDogbmF0aXZlSm9pbi5jYWxsKGFycmF5LCBzZXBhcmF0b3IpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBsYXN0IGVsZW1lbnQgb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sYXN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGxhc3QoYXJyYXkpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIHJldHVybiBsZW5ndGggPyBhcnJheVtsZW5ndGggLSAxXSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmluZGV4T2ZgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgYXJyYXlgIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmxhc3RJbmRleE9mKFsxLCAyLCAxLCAyXSwgMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogLy8gU2VhcmNoIGZyb20gdGhlIGBmcm9tSW5kZXhgLlxuICAgICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDEsIDJdLCAyLCAyKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiAtMTtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IGxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBpbmRleCA9IHRvSW50ZWdlcihmcm9tSW5kZXgpO1xuICAgICAgICBpbmRleCA9IGluZGV4IDwgMCA/IG5hdGl2ZU1heChsZW5ndGggKyBpbmRleCwgMCkgOiBuYXRpdmVNaW4oaW5kZXgsIGxlbmd0aCAtIDEpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlID09PSB2YWx1ZVxuICAgICAgICA/IHN0cmljdExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSwgaW5kZXgpXG4gICAgICAgIDogYmFzZUZpbmRJbmRleChhcnJheSwgYmFzZUlzTmFOLCBpbmRleCwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0cyB0aGUgZWxlbWVudCBhdCBpbmRleCBgbmAgb2YgYGFycmF5YC4gSWYgYG5gIGlzIG5lZ2F0aXZlLCB0aGUgbnRoXG4gICAgICogZWxlbWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdG8gcmV0dXJuLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBudGggZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2QnXTtcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAxKTtcbiAgICAgKiAvLyA9PiAnYidcbiAgICAgKlxuICAgICAqIF8ubnRoKGFycmF5LCAtMik7XG4gICAgICogLy8gPT4gJ2MnO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aChhcnJheSwgbikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZU50aChhcnJheSwgdG9JbnRlZ2VyKG4pKSA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGFsbCBnaXZlbiB2YWx1ZXMgZnJvbSBgYXJyYXlgIHVzaW5nXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLndpdGhvdXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5yZW1vdmVgXG4gICAgICogdG8gcmVtb3ZlIGVsZW1lbnRzIGZyb20gYW4gYXJyYXkgYnkgcHJlZGljYXRlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0gey4uLip9IFt2YWx1ZXNdIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGwoYXJyYXksICdhJywgJ2MnKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWydiJywgJ2InXVxuICAgICAqL1xuICAgIHZhciBwdWxsID0gYmFzZVJlc3QocHVsbEFsbCk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgdmFsdWVzIHRvIHJlbW92ZS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZWAsIHRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtBcnJheX0gdmFsdWVzIFRoZSB2YWx1ZXMgdG8gcmVtb3ZlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbJ2EnLCAnYicsICdjJywgJ2EnLCAnYicsICdjJ107XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGwoYXJyYXksIFsnYScsICdjJ10pO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbJ2InLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbChhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aCAmJiB2YWx1ZXMgJiYgdmFsdWVzLmxlbmd0aClcbiAgICAgICAgPyBiYXNlUHVsbEFsbChhcnJheSwgdmFsdWVzKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucHVsbEFsbGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgYW5kIGB2YWx1ZXNgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb25cbiAgICAgKiBieSB3aGljaCB0aGV5J3JlIGNvbXBhcmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uZGlmZmVyZW5jZUJ5YCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDMgfSwgeyAneCc6IDEgfV07XG4gICAgICpcbiAgICAgKiBfLnB1bGxBbGxCeShhcnJheSwgW3sgJ3gnOiAxIH0sIHsgJ3gnOiAzIH1dLCAneCcpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDIgfV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwdWxsQWxsQnkoYXJyYXksIHZhbHVlcywgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoICYmIHZhbHVlcyAmJiB2YWx1ZXMubGVuZ3RoKVxuICAgICAgICA/IGJhc2VQdWxsQWxsKGFycmF5LCB2YWx1ZXMsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSlcbiAgICAgICAgOiBhcnJheTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnB1bGxBbGxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAgdG8gYHZhbHVlc2AuIFRoZSBjb21wYXJhdG9yIGlzXG4gICAgICogaW52b2tlZCB3aXRoIHR3byBhcmd1bWVudHM6IChhcnJWYWwsIG90aFZhbCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVW5saWtlIGBfLmRpZmZlcmVuY2VXaXRoYCwgdGhpcyBtZXRob2QgbXV0YXRlcyBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSB2YWx1ZXMgVGhlIHZhbHVlcyB0byByZW1vdmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NvbXBhcmF0b3JdIFRoZSBjb21wYXJhdG9yIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAzLCAneSc6IDQgfSwgeyAneCc6IDUsICd5JzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ucHVsbEFsbFdpdGgoYXJyYXksIFt7ICd4JzogMywgJ3knOiA0IH1dLCBfLmlzRXF1YWwpO1xuICAgICAqIGNvbnNvbGUubG9nKGFycmF5KTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogNSwgJ3knOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHVsbEFsbFdpdGgoYXJyYXksIHZhbHVlcywgY29tcGFyYXRvcikge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGggJiYgdmFsdWVzICYmIHZhbHVlcy5sZW5ndGgpXG4gICAgICAgID8gYmFzZVB1bGxBbGwoYXJyYXksIHZhbHVlcywgdW5kZWZpbmVkLCBjb21wYXJhdG9yKVxuICAgICAgICA6IGFycmF5O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgZWxlbWVudHMgZnJvbSBgYXJyYXlgIGNvcnJlc3BvbmRpbmcgdG8gYGluZGV4ZXNgIGFuZCByZXR1cm5zIGFuXG4gICAgICogYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8uYXRgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7Li4uKG51bWJlcnxudW1iZXJbXSl9IFtpbmRleGVzXSBUaGUgaW5kZXhlcyBvZiBlbGVtZW50cyB0byByZW1vdmUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgcmVtb3ZlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWydhJywgJ2InLCAnYycsICdkJ107XG4gICAgICogdmFyIHB1bGxlZCA9IF8ucHVsbEF0KGFycmF5LCBbMSwgM10pO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFsnYScsICdjJ11cbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKHB1bGxlZCk7XG4gICAgICogLy8gPT4gWydiJywgJ2QnXVxuICAgICAqL1xuICAgIHZhciBwdWxsQXQgPSBmbGF0UmVzdChmdW5jdGlvbihhcnJheSwgaW5kZXhlcykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdCA9IGJhc2VBdChhcnJheSwgaW5kZXhlcyk7XG5cbiAgICAgIGJhc2VQdWxsQXQoYXJyYXksIGFycmF5TWFwKGluZGV4ZXMsIGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICAgIHJldHVybiBpc0luZGV4KGluZGV4LCBsZW5ndGgpID8gK2luZGV4IDogaW5kZXg7XG4gICAgICB9KS5zb3J0KGNvbXBhcmVBc2NlbmRpbmcpKTtcblxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgYWxsIGVsZW1lbnRzIGZyb20gYGFycmF5YCB0aGF0IGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvclxuICAgICAqIGFuZCByZXR1cm5zIGFuIGFycmF5IG9mIHRoZSByZW1vdmVkIGVsZW1lbnRzLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5maWx0ZXJgLCB0aGlzIG1ldGhvZCBtdXRhdGVzIGBhcnJheWAuIFVzZSBgXy5wdWxsYFxuICAgICAqIHRvIHB1bGwgZWxlbWVudHMgZnJvbSBhbiBhcnJheSBieSB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlbW92ZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzLCA0XTtcbiAgICAgKiB2YXIgZXZlbnMgPSBfLnJlbW92ZShhcnJheSwgZnVuY3Rpb24obikge1xuICAgICAqICAgcmV0dXJuIG4gJSAyID09IDA7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDNdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhldmVucyk7XG4gICAgICogLy8gPT4gWzIsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVtb3ZlKGFycmF5LCBwcmVkaWNhdGUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGluZGV4ZXMgPSBbXSxcbiAgICAgICAgICBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG5cbiAgICAgIHByZWRpY2F0ZSA9IGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyk7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBhcnJheSkpIHtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgICAgaW5kZXhlcy5wdXNoKGluZGV4KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgYmFzZVB1bGxBdChhcnJheSwgaW5kZXhlcyk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVyc2VzIGBhcnJheWAgc28gdGhhdCB0aGUgZmlyc3QgZWxlbWVudCBiZWNvbWVzIHRoZSBsYXN0LCB0aGUgc2Vjb25kXG4gICAgICogZWxlbWVudCBiZWNvbWVzIHRoZSBzZWNvbmQgdG8gbGFzdCwgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYGFycmF5YCBhbmQgaXMgYmFzZWQgb25cbiAgICAgKiBbYEFycmF5I3JldmVyc2VgXShodHRwczovL21kbi5pby9BcnJheS9yZXZlcnNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBtb2RpZnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKlxuICAgICAqIF8ucmV2ZXJzZShhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzMsIDIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmV2ZXJzZShhcnJheSkge1xuICAgICAgcmV0dXJuIGFycmF5ID09IG51bGwgPyBhcnJheSA6IG5hdGl2ZVJldmVyc2UuY2FsbChhcnJheSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgZnJvbSBgc3RhcnRgIHVwIHRvLCBidXQgbm90IGluY2x1ZGluZywgYGVuZGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgdXNlZCBpbnN0ZWFkIG9mXG4gICAgICogW2BBcnJheSNzbGljZWBdKGh0dHBzOi8vbWRuLmlvL0FycmF5L3NsaWNlKSB0byBlbnN1cmUgZGVuc2UgYXJyYXlzIGFyZVxuICAgICAqIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHNsaWNlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IHBvc2l0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZW5kPWFycmF5Lmxlbmd0aF0gVGhlIGVuZCBwb3NpdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICovXG4gICAgZnVuY3Rpb24gc2xpY2UoYXJyYXksIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChlbmQgJiYgdHlwZW9mIGVuZCAhPSAnbnVtYmVyJyAmJiBpc0l0ZXJhdGVlQ2FsbChhcnJheSwgc3RhcnQsIGVuZCkpIHtcbiAgICAgICAgc3RhcnQgPSAwO1xuICAgICAgICBlbmQgPSBsZW5ndGg7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IHRvSW50ZWdlcihzdGFydCk7XG4gICAgICAgIGVuZCA9IGVuZCA9PT0gdW5kZWZpbmVkID8gbGVuZ3RoIDogdG9JbnRlZ2VyKGVuZCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCBzdGFydCwgZW5kKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBVc2VzIGEgYmluYXJ5IHNlYXJjaCB0byBkZXRlcm1pbmUgdGhlIGxvd2VzdCBpbmRleCBhdCB3aGljaCBgdmFsdWVgXG4gICAgICogc2hvdWxkIGJlIGluc2VydGVkIGludG8gYGFycmF5YCBpbiBvcmRlciB0byBtYWludGFpbiBpdHMgc29ydCBvcmRlci5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBzb3J0ZWQgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBldmFsdWF0ZS5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc29ydGVkSW5kZXgoWzMwLCA1MF0sIDQwKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRJbmRleGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCBmb3IgYHZhbHVlYCBhbmQgZWFjaCBlbGVtZW50IG9mIGBhcnJheWAgdG8gY29tcHV0ZSB0aGVpclxuICAgICAqIHNvcnQgcmFua2luZy4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IGF0IHdoaWNoIGB2YWx1ZWAgc2hvdWxkIGJlIGluc2VydGVkXG4gICAgICogIGludG8gYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAneCc6IDQgfSwgeyAneCc6IDUgfV07XG4gICAgICpcbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgZnVuY3Rpb24obykgeyByZXR1cm4gby54OyB9KTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnNvcnRlZEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkSW5kZXhCeShhcnJheSwgdmFsdWUsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4QnkoYXJyYXksIHZhbHVlLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uaW5kZXhPZmAgZXhjZXB0IHRoYXQgaXQgcGVyZm9ybXMgYSBiaW5hcnlcbiAgICAgKiBzZWFyY2ggb24gYSBzb3J0ZWQgYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUsIGVsc2UgYC0xYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gMVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZEluZGV4T2YoYXJyYXksIHZhbHVlKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkgPT0gbnVsbCA/IDAgOiBhcnJheS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoKSB7XG4gICAgICAgIHZhciBpbmRleCA9IGJhc2VTb3J0ZWRJbmRleChhcnJheSwgdmFsdWUpO1xuICAgICAgICBpZiAoaW5kZXggPCBsZW5ndGggJiYgZXEoYXJyYXlbaW5kZXhdLCB2YWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRlZEluZGV4YCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBoaWdoZXN0XG4gICAgICogaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvXG4gICAgICogbWFpbnRhaW4gaXRzIHNvcnQgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgc29ydGVkIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggYXQgd2hpY2ggYHZhbHVlYCBzaG91bGQgYmUgaW5zZXJ0ZWRcbiAgICAgKiAgaW50byBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleChbNCwgNSwgNSwgNSwgNl0sIDUpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRMYXN0SW5kZXgoYXJyYXksIHZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZVNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSwgdHJ1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zb3J0ZWRMYXN0SW5kZXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYFxuICAgICAqIHdoaWNoIGlzIGludm9rZWQgZm9yIGB2YWx1ZWAgYW5kIGVhY2ggZWxlbWVudCBvZiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXJcbiAgICAgKiBzb3J0IHJhbmtpbmcuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIHNvcnRlZCBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGV2YWx1YXRlLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCBgdmFsdWVgIHNob3VsZCBiZSBpbnNlcnRlZFxuICAgICAqICBpbnRvIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiA0IH0sIHsgJ3gnOiA1IH1dO1xuICAgICAqXG4gICAgICogXy5zb3J0ZWRMYXN0SW5kZXhCeShvYmplY3RzLCB7ICd4JzogNCB9LCBmdW5jdGlvbihvKSB7IHJldHVybiBvLng7IH0pO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29ydGVkTGFzdEluZGV4Qnkob2JqZWN0cywgeyAneCc6IDQgfSwgJ3gnKTtcbiAgICAgKiAvLyA9PiAxXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkTGFzdEluZGV4QnkoYXJyYXksIHZhbHVlLCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VTb3J0ZWRJbmRleEJ5KGFycmF5LCB2YWx1ZSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpLCB0cnVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmxhc3RJbmRleE9mYCBleGNlcHQgdGhhdCBpdCBwZXJmb3JtcyBhIGJpbmFyeVxuICAgICAqIHNlYXJjaCBvbiBhIHNvcnRlZCBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBvZiB0aGUgbWF0Y2hlZCB2YWx1ZSwgZWxzZSBgLTFgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnNvcnRlZExhc3RJbmRleE9mKFs0LCA1LCA1LCA1LCA2XSwgNSk7XG4gICAgICogLy8gPT4gM1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNvcnRlZExhc3RJbmRleE9mKGFycmF5LCB2YWx1ZSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCkge1xuICAgICAgICB2YXIgaW5kZXggPSBiYXNlU29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCB0cnVlKSAtIDE7XG4gICAgICAgIGlmIChlcShhcnJheVtpbmRleF0sIHZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBpbmRleDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW5pcWAgZXhjZXB0IHRoYXQgaXQncyBkZXNpZ25lZCBhbmQgb3B0aW1pemVkXG4gICAgICogZm9yIHNvcnRlZCBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxKFsxLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc29ydGVkVW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVNvcnRlZFVuaXEoYXJyYXkpXG4gICAgICAgIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxQnlgIGV4Y2VwdCB0aGF0IGl0J3MgZGVzaWduZWQgYW5kIG9wdGltaXplZFxuICAgICAqIGZvciBzb3J0ZWQgYXJyYXlzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlXSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb3J0ZWRVbmlxQnkoWzEuMSwgMS4yLCAyLjMsIDIuNF0sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IFsxLjEsIDIuM11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb3J0ZWRVbmlxQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlU29ydGVkVW5pcShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgYWxsIGJ1dCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgYXJyYXlgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWlsKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFpbChhcnJheSkge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5ID09IG51bGwgPyAwIDogYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIGxlbmd0aCA/IGJhc2VTbGljZShhcnJheSwgMSwgbGVuZ3RoKSA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBzbGljZSBvZiBgYXJyYXlgIHdpdGggYG5gIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byB0YWtlLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBzbGljZSBvZiBgYXJyYXlgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbMV1cbiAgICAgKlxuICAgICAqIF8udGFrZShbMSwgMiwgM10sIDIpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogXy50YWtlKFsxLCAyLCAzXSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2UoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2UoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoIShhcnJheSAmJiBhcnJheS5sZW5ndGgpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICByZXR1cm4gYmFzZVNsaWNlKGFycmF5LCAwLCBuIDwgMCA/IDAgOiBuKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGBuYCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPTFdIFRoZSBudW1iZXIgb2YgZWxlbWVudHMgdG8gdGFrZS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiBbM11cbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0KFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzIsIDNdXG4gICAgICpcbiAgICAgKiBfLnRha2VSaWdodChbMSwgMiwgM10sIDUpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogXy50YWtlUmlnaHQoWzEsIDIsIDNdLCAwKTtcbiAgICAgKiAvLyA9PiBbXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRha2VSaWdodChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcnJheSA9PSBudWxsID8gMCA6IGFycmF5Lmxlbmd0aDtcbiAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIG4gPSAoZ3VhcmQgfHwgbiA9PT0gdW5kZWZpbmVkKSA/IDEgOiB0b0ludGVnZXIobik7XG4gICAgICBuID0gbGVuZ3RoIC0gbjtcbiAgICAgIHJldHVybiBiYXNlU2xpY2UoYXJyYXksIG4gPCAwID8gMCA6IG4sIGxlbmd0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIHNsaWNlIG9mIGBhcnJheWAgd2l0aCBlbGVtZW50cyB0YWtlbiBmcm9tIHRoZSBlbmQuIEVsZW1lbnRzIGFyZVxuICAgICAqIHRha2VuIHVudGlsIGBwcmVkaWNhdGVgIHJldHVybnMgZmFsc2V5LiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHNsaWNlIG9mIGBhcnJheWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8udGFrZVJpZ2h0V2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydwZWJibGVzJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnRha2VSaWdodFdoaWxlKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlUmlnaHRXaGlsZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGFrZVJpZ2h0V2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpLCBmYWxzZSwgdHJ1ZSlcbiAgICAgICAgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2xpY2Ugb2YgYGFycmF5YCB3aXRoIGVsZW1lbnRzIHRha2VuIGZyb20gdGhlIGJlZ2lubmluZy4gRWxlbWVudHNcbiAgICAgKiBhcmUgdGFrZW4gdW50aWwgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoXG4gICAgICogdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4LCBhcnJheSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgc2xpY2Ugb2YgYGFycmF5YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknLCAnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy50YWtlV2hpbGUodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leScsICdmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8udGFrZVdoaWxlKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YWtlV2hpbGUoYXJyYXksIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVdoaWxlKGFycmF5LCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKVxuICAgICAgICA6IFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIGZyb20gYWxsIGdpdmVuIGFycmF5cyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbihbMl0sIFsxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIHVuaW9uID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSkpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlvbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IG9mIGVhY2ggYGFycmF5c2AgdG8gZ2VuZXJhdGUgdGhlIGNyaXRlcmlvbiBieVxuICAgICAqIHdoaWNoIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuIFJlc3VsdCB2YWx1ZXMgYXJlIGNob3NlbiBmcm9tIHRoZSBmaXJzdFxuICAgICAqIGFycmF5IGluIHdoaWNoIHRoZSB2YWx1ZSBvY2N1cnMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OlxuICAgICAqICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGNvbWJpbmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlvbkJ5KFsyLjFdLCBbMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaW9uQnkoW3sgJ3gnOiAxIH1dLCBbeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgdmFyIHVuaW9uQnkgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHZhciBpdGVyYXRlZSA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGlmIChpc0FycmF5TGlrZU9iamVjdChpdGVyYXRlZSkpIHtcbiAgICAgICAgaXRlcmF0ZWUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZVVuaXEoYmFzZUZsYXR0ZW4oYXJyYXlzLCAxLCBpc0FycmF5TGlrZU9iamVjdCwgdHJ1ZSksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaW9uYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjb21wYXJhdG9yYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSBlbGVtZW50cyBvZiBgYXJyYXlzYC4gUmVzdWx0IHZhbHVlcyBhcmUgY2hvc2VuIGZyb21cbiAgICAgKiB0aGUgZmlyc3QgYXJyYXkgaW4gd2hpY2ggdGhlIHZhbHVlIG9jY3Vycy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBjb21iaW5lZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pb25XaXRoKG9iamVjdHMsIG90aGVycywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH0sIHsgJ3gnOiAxLCAneSc6IDEgfV1cbiAgICAgKi9cbiAgICB2YXIgdW5pb25XaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlVW5pcShiYXNlRmxhdHRlbihhcnJheXMsIDEsIGlzQXJyYXlMaWtlT2JqZWN0LCB0cnVlKSwgdW5kZWZpbmVkLCBjb21wYXJhdG9yKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIGFuIGFycmF5LCB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLCBpbiB3aGljaCBvbmx5IHRoZSBmaXJzdCBvY2N1cnJlbmNlIG9mIGVhY2ggZWxlbWVudFxuICAgICAqIGlzIGtlcHQuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXJcbiAgICAgKiBpbiB0aGUgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxKFsyLCAxLCAyXSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcShhcnJheSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXkpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy51bmlxYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgaW4gYGFycmF5YCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5IHdoaWNoXG4gICAgICogdW5pcXVlbmVzcyBpcyBjb21wdXRlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGVcbiAgICAgKiBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6XG4gICAgICogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBkdXBsaWNhdGUgZnJlZSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51bmlxQnkoWzIuMSwgMS4yLCAyLjNdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMi4xLCAxLjJdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnVuaXFCeShbeyAneCc6IDEgfSwgeyAneCc6IDIgfSwgeyAneCc6IDEgfV0sICd4Jyk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAxIH0sIHsgJ3gnOiAyIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpID8gYmFzZVVuaXEoYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSkgOiBbXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVuaXFgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheWAuIFRoZSBvcmRlciBvZiByZXN1bHQgdmFsdWVzIGlzXG4gICAgICogZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXIgdGhleSBvY2N1ciBpbiB0aGUgYXJyYXkuVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjb21wYXJhdG9yXSBUaGUgY29tcGFyYXRvciBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGR1cGxpY2F0ZSBmcmVlIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICd4JzogMSwgJ3knOiAyIH0sIHsgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8udW5pcVdpdGgob2JqZWN0cywgXy5pc0VxdWFsKTtcbiAgICAgKiAvLyA9PiBbeyAneCc6IDEsICd5JzogMiB9LCB7ICd4JzogMiwgJ3knOiAxIH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5pcVdpdGgoYXJyYXksIGNvbXBhcmF0b3IpIHtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKSA/IGJhc2VVbmlxKGFycmF5LCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpIDogW107XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYW4gYXJyYXkgb2YgZ3JvdXBlZFxuICAgICAqIGVsZW1lbnRzIGFuZCBjcmVhdGVzIGFuIGFycmF5IHJlZ3JvdXBpbmcgdGhlIGVsZW1lbnRzIHRvIHRoZWlyIHByZS16aXBcbiAgICAgKiBjb25maWd1cmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMi4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMgdG8gcHJvY2Vzcy5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiByZWdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB6aXBwZWQgPSBfLnppcChbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxLCB0cnVlXSwgWydiJywgMiwgZmFsc2VdXVxuICAgICAqXG4gICAgICogXy51bnppcCh6aXBwZWQpO1xuICAgICAqIC8vID0+IFtbJ2EnLCAnYiddLCBbMSwgMl0sIFt0cnVlLCBmYWxzZV1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW56aXAoYXJyYXkpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGxlbmd0aCA9IDA7XG4gICAgICBhcnJheSA9IGFycmF5RmlsdGVyKGFycmF5LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICBpZiAoaXNBcnJheUxpa2VPYmplY3QoZ3JvdXApKSB7XG4gICAgICAgICAgbGVuZ3RoID0gbmF0aXZlTWF4KGdyb3VwLmxlbmd0aCwgbGVuZ3RoKTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByZXR1cm4gYmFzZVRpbWVzKGxlbmd0aCwgZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgICAgcmV0dXJuIGFycmF5TWFwKGFycmF5LCBiYXNlUHJvcGVydHkoaW5kZXgpKTtcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8udW56aXBgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB0byBzcGVjaWZ5XG4gICAgICogaG93IHJlZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cyB0byBwcm9jZXNzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gdG8gY29tYmluZVxuICAgICAqICByZWdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIHJlZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHppcHBlZCA9IF8uemlwKFsxLCAyXSwgWzEwLCAyMF0sIFsxMDAsIDIwMF0pO1xuICAgICAqIC8vID0+IFtbMSwgMTAsIDEwMF0sIFsyLCAyMCwgMjAwXV1cbiAgICAgKlxuICAgICAqIF8udW56aXBXaXRoKHppcHBlZCwgXy5hZGQpO1xuICAgICAqIC8vID0+IFszLCAzMCwgMzAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuemlwV2l0aChhcnJheSwgaXRlcmF0ZWUpIHtcbiAgICAgIGlmICghKGFycmF5ICYmIGFycmF5Lmxlbmd0aCkpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIHJlc3VsdCA9IHVuemlwKGFycmF5KTtcbiAgICAgIGlmIChpdGVyYXRlZSA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJyYXlNYXAocmVzdWx0LCBmdW5jdGlvbihncm91cCkge1xuICAgICAgICByZXR1cm4gYXBwbHkoaXRlcmF0ZWUsIHVuZGVmaW5lZCwgZ3JvdXApO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBleGNsdWRpbmcgYWxsIGdpdmVuIHZhbHVlcyB1c2luZ1xuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogZm9yIGVxdWFsaXR5IGNvbXBhcmlzb25zLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFVubGlrZSBgXy5wdWxsYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3ZhbHVlc10gVGhlIHZhbHVlcyB0byBleGNsdWRlLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAc2VlIF8uZGlmZmVyZW5jZSwgXy54b3JcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53aXRob3V0KFsyLCAxLCAyLCAzXSwgMSwgMik7XG4gICAgICogLy8gPT4gWzNdXG4gICAgICovXG4gICAgdmFyIHdpdGhvdXQgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheSwgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2VPYmplY3QoYXJyYXkpXG4gICAgICAgID8gYmFzZURpZmZlcmVuY2UoYXJyYXksIHZhbHVlcylcbiAgICAgICAgOiBbXTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdW5pcXVlIHZhbHVlcyB0aGF0IGlzIHRoZVxuICAgICAqIFtzeW1tZXRyaWMgZGlmZmVyZW5jZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvU3ltbWV0cmljX2RpZmZlcmVuY2UpXG4gICAgICogb2YgdGhlIGdpdmVuIGFycmF5cy4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZCBieSB0aGUgb3JkZXJcbiAgICAgKiB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgYXJyYXkgb2YgZmlsdGVyZWQgdmFsdWVzLlxuICAgICAqIEBzZWUgXy5kaWZmZXJlbmNlLCBfLndpdGhvdXRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3IoWzIsIDFdLCBbMiwgM10pO1xuICAgICAqIC8vID0+IFsxLCAzXVxuICAgICAqL1xuICAgIHZhciB4b3IgPSBiYXNlUmVzdChmdW5jdGlvbihhcnJheXMpIHtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ueG9yYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBpdGVyYXRlZWAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIGZvciBlYWNoIGVsZW1lbnQgb2YgZWFjaCBgYXJyYXlzYCB0byBnZW5lcmF0ZSB0aGUgY3JpdGVyaW9uIGJ5XG4gICAgICogd2hpY2ggYnkgd2hpY2ggdGhleSdyZSBjb21wYXJlZC4gVGhlIG9yZGVyIG9mIHJlc3VsdCB2YWx1ZXMgaXMgZGV0ZXJtaW5lZFxuICAgICAqIGJ5IHRoZSBvcmRlciB0aGV5IG9jY3VyIGluIHRoZSBhcnJheXMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lXG4gICAgICogYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGZpbHRlcmVkIHZhbHVlcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy54b3JCeShbMi4xLCAxLjJdLCBbMi4zLCAzLjRdLCBNYXRoLmZsb29yKTtcbiAgICAgKiAvLyA9PiBbMS4yLCAzLjRdXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnhvckJ5KFt7ICd4JzogMSB9XSwgW3sgJ3gnOiAyIH0sIHsgJ3gnOiAxIH1dLCAneCcpO1xuICAgICAqIC8vID0+IFt7ICd4JzogMiB9XVxuICAgICAqL1xuICAgIHZhciB4b3JCeSA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGl0ZXJhdGVlID0gbGFzdChhcnJheXMpO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlT2JqZWN0KGl0ZXJhdGVlKSkge1xuICAgICAgICBpdGVyYXRlZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy54b3JgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGNvbXBhcmF0b3JgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCB0byBjb21wYXJlIGVsZW1lbnRzIG9mIGBhcnJheXNgLiBUaGUgb3JkZXIgb2YgcmVzdWx0IHZhbHVlcyBpc1xuICAgICAqIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gdGhlIGFycmF5cy4gVGhlIGNvbXBhcmF0b3IgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdHdvIGFyZ3VtZW50czogKGFyclZhbCwgb3RoVmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBBcnJheVxuICAgICAqIEBwYXJhbSB7Li4uQXJyYXl9IFthcnJheXNdIFRoZSBhcnJheXMgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY29tcGFyYXRvcl0gVGhlIGNvbXBhcmF0b3IgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBhcnJheSBvZiBmaWx0ZXJlZCB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ3gnOiAxLCAneSc6IDIgfSwgeyAneCc6IDIsICd5JzogMSB9XTtcbiAgICAgKiB2YXIgb3RoZXJzID0gW3sgJ3gnOiAxLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMiB9XTtcbiAgICAgKlxuICAgICAqIF8ueG9yV2l0aChvYmplY3RzLCBvdGhlcnMsIF8uaXNFcXVhbCk7XG4gICAgICogLy8gPT4gW3sgJ3gnOiAyLCAneSc6IDEgfSwgeyAneCc6IDEsICd5JzogMSB9XVxuICAgICAqL1xuICAgIHZhciB4b3JXaXRoID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJyYXlzKSB7XG4gICAgICB2YXIgY29tcGFyYXRvciA9IGxhc3QoYXJyYXlzKTtcbiAgICAgIGNvbXBhcmF0b3IgPSB0eXBlb2YgY29tcGFyYXRvciA9PSAnZnVuY3Rpb24nID8gY29tcGFyYXRvciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlWG9yKGFycmF5RmlsdGVyKGFycmF5cywgaXNBcnJheUxpa2VPYmplY3QpLCB1bmRlZmluZWQsIGNvbXBhcmF0b3IpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBncm91cGVkIGVsZW1lbnRzLCB0aGUgZmlyc3Qgb2Ygd2hpY2ggY29udGFpbnMgdGhlXG4gICAgICogZmlyc3QgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgdGhlIHNlY29uZCBvZiB3aGljaCBjb250YWlucyB0aGVcbiAgICAgKiBzZWNvbmQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGFycmF5cywgYW5kIHNvIG9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEFycmF5XG4gICAgICogQHBhcmFtIHsuLi5BcnJheX0gW2FycmF5c10gVGhlIGFycmF5cyB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwKFsnYScsICdiJ10sIFsxLCAyXSwgW3RydWUsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gW1snYScsIDEsIHRydWVdLCBbJ2InLCAyLCBmYWxzZV1dXG4gICAgICovXG4gICAgdmFyIHppcCA9IGJhc2VSZXN0KHVuemlwKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZnJvbVBhaXJzYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIHR3byBhcnJheXMsXG4gICAgICogb25lIG9mIHByb3BlcnR5IGlkZW50aWZpZXJzIGFuZCBvbmUgb2YgY29ycmVzcG9uZGluZyB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC40LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0KFsnYScsICdiJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0KHByb3BzLCB2YWx1ZXMpIHtcbiAgICAgIHJldHVybiBiYXNlWmlwT2JqZWN0KHByb3BzIHx8IFtdLCB2YWx1ZXMgfHwgW10sIGFzc2lnblZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcE9iamVjdGAgZXhjZXB0IHRoYXQgaXQgc3VwcG9ydHMgcHJvcGVydHkgcGF0aHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbcHJvcHM9W11dIFRoZSBwcm9wZXJ0eSBpZGVudGlmaWVycy5cbiAgICAgKiBAcGFyYW0ge0FycmF5fSBbdmFsdWVzPVtdXSBUaGUgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwT2JqZWN0RGVlcChbJ2EuYlswXS5jJywgJ2EuYlsxXS5kJ10sIFsxLCAyXSk7XG4gICAgICogLy8gPT4geyAnYSc6IHsgJ2InOiBbeyAnYyc6IDEgfSwgeyAnZCc6IDIgfV0gfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gemlwT2JqZWN0RGVlcChwcm9wcywgdmFsdWVzKSB7XG4gICAgICByZXR1cm4gYmFzZVppcE9iamVjdChwcm9wcyB8fCBbXSwgdmFsdWVzIHx8IFtdLCBiYXNlU2V0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnppcGAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHRvIHNwZWNpZnlcbiAgICAgKiBob3cgZ3JvdXBlZCB2YWx1ZXMgc2hvdWxkIGJlIGNvbWJpbmVkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRoZVxuICAgICAqIGVsZW1lbnRzIG9mIGVhY2ggZ3JvdXA6ICguLi5ncm91cCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy44LjBcbiAgICAgKiBAY2F0ZWdvcnkgQXJyYXlcbiAgICAgKiBAcGFyYW0gey4uLkFycmF5fSBbYXJyYXlzXSBUaGUgYXJyYXlzIHRvIHByb2Nlc3MuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiB0byBjb21iaW5lXG4gICAgICogIGdyb3VwZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGFycmF5IG9mIGdyb3VwZWQgZWxlbWVudHMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uemlwV2l0aChbMSwgMl0sIFsxMCwgMjBdLCBbMTAwLCAyMDBdLCBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gYSArIGIgKyBjO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IFsxMTEsIDIyMl1cbiAgICAgKi9cbiAgICB2YXIgemlwV2l0aCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGFycmF5cykge1xuICAgICAgdmFyIGxlbmd0aCA9IGFycmF5cy5sZW5ndGgsXG4gICAgICAgICAgaXRlcmF0ZWUgPSBsZW5ndGggPiAxID8gYXJyYXlzW2xlbmd0aCAtIDFdIDogdW5kZWZpbmVkO1xuXG4gICAgICBpdGVyYXRlZSA9IHR5cGVvZiBpdGVyYXRlZSA9PSAnZnVuY3Rpb24nID8gKGFycmF5cy5wb3AoKSwgaXRlcmF0ZWUpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHVuemlwV2l0aChhcnJheXMsIGl0ZXJhdGVlKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHRoYXQgd3JhcHMgYHZhbHVlYCB3aXRoIGV4cGxpY2l0IG1ldGhvZFxuICAgICAqIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLiBUaGUgcmVzdWx0IG9mIHN1Y2ggc2VxdWVuY2VzIG11c3QgYmUgdW53cmFwcGVkXG4gICAgICogd2l0aCBgXyN2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICAnYWdlJzogNDAgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogdmFyIHlvdW5nZXN0ID0gX1xuICAgICAqICAgLmNoYWluKHVzZXJzKVxuICAgICAqICAgLnNvcnRCeSgnYWdlJylcbiAgICAgKiAgIC5tYXAoZnVuY3Rpb24obykge1xuICAgICAqICAgICByZXR1cm4gby51c2VyICsgJyBpcyAnICsgby5hZ2U7XG4gICAgICogICB9KVxuICAgICAqICAgLmhlYWQoKVxuICAgICAqICAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMgaXMgMSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjaGFpbih2YWx1ZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaCh2YWx1ZSk7XG4gICAgICByZXN1bHQuX19jaGFpbl9fID0gdHJ1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaW52b2tlcyBgaW50ZXJjZXB0b3JgIGFuZCByZXR1cm5zIGB2YWx1ZWAuIFRoZSBpbnRlcmNlcHRvclxuICAgICAqIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvXG4gICAgICogXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlIGluIG9yZGVyIHRvIG1vZGlmeSBpbnRlcm1lZGlhdGUgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm92aWRlIHRvIGBpbnRlcmNlcHRvcmAuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gaW50ZXJjZXB0b3IgVGhlIGZ1bmN0aW9uIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyBgdmFsdWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfKFsxLCAyLCAzXSlcbiAgICAgKiAgLnRhcChmdW5jdGlvbihhcnJheSkge1xuICAgICAqICAgIC8vIE11dGF0ZSBpbnB1dCBhcnJheS5cbiAgICAgKiAgICBhcnJheS5wb3AoKTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnJldmVyc2UoKVxuICAgICAqICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICBpbnRlcmNlcHRvcih2YWx1ZSk7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy50YXBgIGV4Y2VwdCB0aGF0IGl0IHJldHVybnMgdGhlIHJlc3VsdCBvZiBgaW50ZXJjZXB0b3JgLlxuICAgICAqIFRoZSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwicGFzcyB0aHJ1XCIgdmFsdWVzIHJlcGxhY2luZyBpbnRlcm1lZGlhdGVcbiAgICAgKiByZXN1bHRzIGluIGEgbWV0aG9kIGNoYWluIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHByb3ZpZGUgdG8gYGludGVyY2VwdG9yYC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgYGludGVyY2VwdG9yYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXygnICBhYmMgICcpXG4gICAgICogIC5jaGFpbigpXG4gICAgICogIC50cmltKClcbiAgICAgKiAgLnRocnUoZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgICByZXR1cm4gW3ZhbHVlXTtcbiAgICAgKiAgfSlcbiAgICAgKiAgLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWydhYmMnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRocnUodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgICByZXR1cm4gaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIHRoZSB3cmFwcGVyIHZlcnNpb24gb2YgYF8uYXRgLlxuICAgICAqXG4gICAgICogQG5hbWUgYXRcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBbcGF0aHNdIFRoZSBwcm9wZXJ0eSBwYXRocyB0byBwaWNrLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXyhvYmplY3QpLmF0KFsnYVswXS5iLmMnLCAnYVsxXSddKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqL1xuICAgIHZhciB3cmFwcGVyQXQgPSBmbGF0UmVzdChmdW5jdGlvbihwYXRocykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhdGhzLmxlbmd0aCxcbiAgICAgICAgICBzdGFydCA9IGxlbmd0aCA/IHBhdGhzWzBdIDogMCxcbiAgICAgICAgICB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgaW50ZXJjZXB0b3IgPSBmdW5jdGlvbihvYmplY3QpIHsgcmV0dXJuIGJhc2VBdChvYmplY3QsIHBhdGhzKTsgfTtcblxuICAgICAgaWYgKGxlbmd0aCA+IDEgfHwgdGhpcy5fX2FjdGlvbnNfXy5sZW5ndGggfHxcbiAgICAgICAgICAhKHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIpIHx8ICFpc0luZGV4KHN0YXJ0KSkge1xuICAgICAgICByZXR1cm4gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgIH1cbiAgICAgIHZhbHVlID0gdmFsdWUuc2xpY2Uoc3RhcnQsICtzdGFydCArIChsZW5ndGggPyAxIDogMCkpO1xuICAgICAgdmFsdWUuX19hY3Rpb25zX18ucHVzaCh7XG4gICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLFxuICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgfSk7XG4gICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIodmFsdWUsIHRoaXMuX19jaGFpbl9fKS50aHJ1KGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgICAgIGlmIChsZW5ndGggJiYgIWFycmF5Lmxlbmd0aCkge1xuICAgICAgICAgIGFycmF5LnB1c2godW5kZWZpbmVkKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlIHdpdGggZXhwbGljaXQgbWV0aG9kIGNoYWluIHNlcXVlbmNlcyBlbmFibGVkLlxuICAgICAqXG4gICAgICogQG5hbWUgY2hhaW5cbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTZXFcbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgYGxvZGFzaGAgd3JhcHBlciBpbnN0YW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDQwIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gQSBzZXF1ZW5jZSB3aXRob3V0IGV4cGxpY2l0IGNoYWluaW5nLlxuICAgICAqIF8odXNlcnMpLmhlYWQoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNiB9XG4gICAgICpcbiAgICAgKiAvLyBBIHNlcXVlbmNlIHdpdGggZXhwbGljaXQgY2hhaW5pbmcuXG4gICAgICogXyh1c2VycylcbiAgICAgKiAgIC5jaGFpbigpXG4gICAgICogICAuaGVhZCgpXG4gICAgICogICAucGljaygndXNlcicpXG4gICAgICogICAudmFsdWUoKTtcbiAgICAgKiAvLyA9PiB7ICd1c2VyJzogJ2Jhcm5leScgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJDaGFpbigpIHtcbiAgICAgIHJldHVybiBjaGFpbih0aGlzKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFeGVjdXRlcyB0aGUgY2hhaW4gc2VxdWVuY2UgYW5kIHJldHVybnMgdGhlIHdyYXBwZWQgcmVzdWx0LlxuICAgICAqXG4gICAgICogQG5hbWUgY29tbWl0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyXTtcbiAgICAgKiB2YXIgd3JhcHBlZCA9IF8oYXJyYXkpLnB1c2goMyk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkID0gd3JhcHBlZC5jb21taXQoKTtcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLmxhc3QoKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhhcnJheSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlckNvbW1pdCgpIHtcbiAgICAgIHJldHVybiBuZXcgTG9kYXNoV3JhcHBlcih0aGlzLnZhbHVlKCksIHRoaXMuX19jaGFpbl9fKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBuZXh0IHZhbHVlIG9uIGEgd3JhcHBlZCBvYmplY3QgZm9sbG93aW5nIHRoZVxuICAgICAqIFtpdGVyYXRvciBwcm90b2NvbF0oaHR0cHM6Ly9tZG4uaW8vaXRlcmF0aW9uX3Byb3RvY29scyNpdGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAbmFtZSBuZXh0XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV4dCBpdGVyYXRvciB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSk7XG4gICAgICpcbiAgICAgKiB3cmFwcGVkLm5leHQoKTtcbiAgICAgKiAvLyA9PiB7ICdkb25lJzogZmFsc2UsICd2YWx1ZSc6IDEgfVxuICAgICAqXG4gICAgICogd3JhcHBlZC5uZXh0KCk7XG4gICAgICogLy8gPT4geyAnZG9uZSc6IGZhbHNlLCAndmFsdWUnOiAyIH1cbiAgICAgKlxuICAgICAqIHdyYXBwZWQubmV4dCgpO1xuICAgICAqIC8vID0+IHsgJ2RvbmUnOiB0cnVlLCAndmFsdWUnOiB1bmRlZmluZWQgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJOZXh0KCkge1xuICAgICAgaWYgKHRoaXMuX192YWx1ZXNfXyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHRoaXMuX192YWx1ZXNfXyA9IHRvQXJyYXkodGhpcy52YWx1ZSgpKTtcbiAgICAgIH1cbiAgICAgIHZhciBkb25lID0gdGhpcy5fX2luZGV4X18gPj0gdGhpcy5fX3ZhbHVlc19fLmxlbmd0aCxcbiAgICAgICAgICB2YWx1ZSA9IGRvbmUgPyB1bmRlZmluZWQgOiB0aGlzLl9fdmFsdWVzX19bdGhpcy5fX2luZGV4X18rK107XG5cbiAgICAgIHJldHVybiB7ICdkb25lJzogZG9uZSwgJ3ZhbHVlJzogdmFsdWUgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFbmFibGVzIHRoZSB3cmFwcGVyIHRvIGJlIGl0ZXJhYmxlLlxuICAgICAqXG4gICAgICogQG5hbWUgU3ltYm9sLml0ZXJhdG9yXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB3cmFwcGVkID0gXyhbMSwgMl0pO1xuICAgICAqXG4gICAgICogd3JhcHBlZFtTeW1ib2wuaXRlcmF0b3JdKCkgPT09IHdyYXBwZWQ7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogQXJyYXkuZnJvbSh3cmFwcGVkKTtcbiAgICAgKiAvLyA9PiBbMSwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3cmFwcGVyVG9JdGVyYXRvcigpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjbG9uZSBvZiB0aGUgY2hhaW4gc2VxdWVuY2UgcGxhbnRpbmcgYHZhbHVlYCBhcyB0aGUgd3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHBsYW50XG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgU2VxXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGxhbnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGBsb2Rhc2hgIHdyYXBwZXIgaW5zdGFuY2UuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHdyYXBwZWQgPSBfKFsxLCAyXSkubWFwKHNxdWFyZSk7XG4gICAgICogdmFyIG90aGVyID0gd3JhcHBlZC5wbGFudChbMywgNF0pO1xuICAgICAqXG4gICAgICogb3RoZXIudmFsdWUoKTtcbiAgICAgKiAvLyA9PiBbOSwgMTZdXG4gICAgICpcbiAgICAgKiB3cmFwcGVkLnZhbHVlKCk7XG4gICAgICogLy8gPT4gWzEsIDRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gd3JhcHBlclBsYW50KHZhbHVlKSB7XG4gICAgICB2YXIgcmVzdWx0LFxuICAgICAgICAgIHBhcmVudCA9IHRoaXM7XG5cbiAgICAgIHdoaWxlIChwYXJlbnQgaW5zdGFuY2VvZiBiYXNlTG9kYXNoKSB7XG4gICAgICAgIHZhciBjbG9uZSA9IHdyYXBwZXJDbG9uZShwYXJlbnQpO1xuICAgICAgICBjbG9uZS5fX2luZGV4X18gPSAwO1xuICAgICAgICBjbG9uZS5fX3ZhbHVlc19fID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSBjbG9uZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQgPSBjbG9uZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcHJldmlvdXMgPSBjbG9uZTtcbiAgICAgICAgcGFyZW50ID0gcGFyZW50Ll9fd3JhcHBlZF9fO1xuICAgICAgfVxuICAgICAgcHJldmlvdXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgdGhlIHdyYXBwZXIgdmVyc2lvbiBvZiBgXy5yZXZlcnNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIHRoZSB3cmFwcGVkIGFycmF5LlxuICAgICAqXG4gICAgICogQG5hbWUgcmV2ZXJzZVxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBgbG9kYXNoYCB3cmFwcGVyIGluc3RhbmNlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbMSwgMiwgM107XG4gICAgICpcbiAgICAgKiBfKGFycmF5KS5yZXZlcnNlKCkudmFsdWUoKVxuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXkpO1xuICAgICAqIC8vID0+IFszLCAyLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJSZXZlcnNlKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIExhenlXcmFwcGVyKSB7XG4gICAgICAgIHZhciB3cmFwcGVkID0gdmFsdWU7XG4gICAgICAgIGlmICh0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCkge1xuICAgICAgICAgIHdyYXBwZWQgPSBuZXcgTGF6eVdyYXBwZXIodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgd3JhcHBlZCA9IHdyYXBwZWQucmV2ZXJzZSgpO1xuICAgICAgICB3cmFwcGVkLl9fYWN0aW9uc19fLnB1c2goe1xuICAgICAgICAgICdmdW5jJzogdGhydSxcbiAgICAgICAgICAnYXJncyc6IFtyZXZlcnNlXSxcbiAgICAgICAgICAndGhpc0FyZyc6IHVuZGVmaW5lZFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIG5ldyBMb2Rhc2hXcmFwcGVyKHdyYXBwZWQsIHRoaXMuX19jaGFpbl9fKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLnRocnUocmV2ZXJzZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogRXhlY3V0ZXMgdGhlIGNoYWluIHNlcXVlbmNlIHRvIHJlc29sdmUgdGhlIHVud3JhcHBlZCB2YWx1ZS5cbiAgICAgKlxuICAgICAqIEBuYW1lIHZhbHVlXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAYWxpYXMgdG9KU09OLCB2YWx1ZU9mXG4gICAgICogQGNhdGVnb3J5IFNlcVxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB1bndyYXBwZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8oWzEsIDIsIDNdKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXBwZXJWYWx1ZSgpIHtcbiAgICAgIHJldHVybiBiYXNlV3JhcHBlclZhbHVlKHRoaXMuX193cmFwcGVkX18sIHRoaXMuX19hY3Rpb25zX18pO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIGtleXMgZ2VuZXJhdGVkIGZyb20gdGhlIHJlc3VsdHMgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZlxuICAgICAqIGVhY2gga2V5IGlzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGtleSB3YXMgcmV0dXJuZWQgYnkgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjUuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgdG8gdHJhbnNmb3JtIGtleXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY29tcG9zZWQgYWdncmVnYXRlIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jb3VudEJ5KFs2LjEsIDQuMiwgNi4zXSwgTWF0aC5mbG9vcik7XG4gICAgICogLy8gPT4geyAnNCc6IDEsICc2JzogMiB9XG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICAgKiAvLyA9PiB7ICczJzogMiwgJzUnOiAxIH1cbiAgICAgKi9cbiAgICB2YXIgY291bnRCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkpIHtcbiAgICAgICAgKytyZXN1bHRba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgMSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkgZm9yICoqYWxsKiogZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyBmYWxzZXkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgcmV0dXJucyBgdHJ1ZWAgZm9yXG4gICAgICogW2VtcHR5IGNvbGxlY3Rpb25zXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9FbXB0eV9zZXQpIGJlY2F1c2VcbiAgICAgKiBbZXZlcnl0aGluZyBpcyB0cnVlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9WYWN1b3VzX3RydXRoKSBvZlxuICAgICAqIGVsZW1lbnRzIG9mIGVtcHR5IGNvbGxlY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGFsbCBlbGVtZW50cyBwYXNzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5ldmVyeShbdHJ1ZSwgMSwgbnVsbCwgJ3llcyddLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgeyAndXNlcic6ICdiYXJuZXknLCAnYWN0aXZlJzogZmFsc2UgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmV2ZXJ5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5ldmVyeSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgcHJlZGljYXRlLCBndWFyZCkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlFdmVyeSA6IGJhc2VFdmVyeTtcbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChjb2xsZWN0aW9uLCBwcmVkaWNhdGUsIGd1YXJkKSkge1xuICAgICAgICBwcmVkaWNhdGUgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uLCBnZXRJdGVyYXRlZShwcmVkaWNhdGUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgYF8ucmVtb3ZlYCwgdGhpcyBtZXRob2QgcmV0dXJucyBhIG5ldyBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtwcmVkaWNhdGU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICAgKiBAc2VlIF8ucmVqZWN0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiAhby5hY3RpdmU7IH0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFsnZnJlZCddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmlsdGVyKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydiYXJuZXknXVxuICAgICAqXG4gICAgICogLy8gQ29tYmluaW5nIHNldmVyYWwgcHJlZGljYXRlcyB1c2luZyBgXy5vdmVyRXZlcnlgIG9yIGBfLm92ZXJTb21lYC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5vdmVyU29tZShbeyAnYWdlJzogMzYgfSwgWydhZ2UnLCA0MF1dKSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJywgJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmlsdGVyKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZiBgY29sbGVjdGlvbmAsIHJldHVybmluZyB0aGUgZmlyc3QgZWxlbWVudFxuICAgICAqIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlIHByZWRpY2F0ZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ3BlYmJsZXMnLCAnYWdlJzogMSwgICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZCh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAncGViYmxlcydcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmQodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3QgZm9yICdmcmVkJ1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kKHVzZXJzLCAnYWN0aXZlJyk7XG4gICAgICogLy8gPT4gb2JqZWN0IGZvciAnYmFybmV5J1xuICAgICAqL1xuICAgIHZhciBmaW5kID0gY3JlYXRlRmluZChmaW5kSW5kZXgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9Y29sbGVjdGlvbi5sZW5ndGgtMV0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXRjaGVkIGVsZW1lbnQsIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmluZExhc3QoWzEsIDIsIDMsIDRdLCBmdW5jdGlvbihuKSB7XG4gICAgICogICByZXR1cm4gbiAlIDIgPT0gMTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgdmFyIGZpbmRMYXN0ID0gY3JlYXRlRmluZChmaW5kTGFzdEluZGV4KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmbGF0dGVuZWQgYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYFxuICAgICAqIHRocnUgYGl0ZXJhdGVlYCBhbmQgZmxhdHRlbmluZyB0aGUgbWFwcGVkIHJlc3VsdHMuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbbiwgbl07XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5mbGF0TWFwKFsxLCAyXSwgZHVwbGljYXRlKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMiwgMl1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGF0TWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgMSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mbGF0TWFwYCBleGNlcHQgdGhhdCBpdCByZWN1cnNpdmVseSBmbGF0dGVucyB0aGVcbiAgICAgKiBtYXBwZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlZXAoWzEsIDJdLCBkdXBsaWNhdGUpO1xuICAgICAqIC8vID0+IFsxLCAxLCAyLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZsYXRNYXBEZWVwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgSU5GSU5JVFkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxhdE1hcGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgZmxhdHRlbnMgdGhlXG4gICAgICogbWFwcGVkIHJlc3VsdHMgdXAgdG8gYGRlcHRoYCB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVwdGg9MV0gVGhlIG1heGltdW0gcmVjdXJzaW9uIGRlcHRoLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZsYXR0ZW5lZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZHVwbGljYXRlKG4pIHtcbiAgICAgKiAgIHJldHVybiBbW1tuLCBuXV1dO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmxhdE1hcERlcHRoKFsxLCAyXSwgZHVwbGljYXRlLCAyKTtcbiAgICAgKiAvLyA9PiBbWzEsIDFdLCBbMiwgMl1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gZmxhdE1hcERlcHRoKGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBkZXB0aCkge1xuICAgICAgZGVwdGggPSBkZXB0aCA9PT0gdW5kZWZpbmVkID8gMSA6IHRvSW50ZWdlcihkZXB0aCk7XG4gICAgICByZXR1cm4gYmFzZUZsYXR0ZW4obWFwKGNvbGxlY3Rpb24sIGl0ZXJhdGVlKSwgZGVwdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2YgYGNvbGxlY3Rpb25gIGFuZCBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggZWxlbWVudC5cbiAgICAgKiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdCBpdGVyYXRpb24gZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBBcyB3aXRoIG90aGVyIFwiQ29sbGVjdGlvbnNcIiBtZXRob2RzLCBvYmplY3RzIHdpdGggYSBcImxlbmd0aFwiXG4gICAgICogcHJvcGVydHkgYXJlIGl0ZXJhdGVkIGxpa2UgYXJyYXlzLiBUbyBhdm9pZCB0aGlzIGJlaGF2aW9yIHVzZSBgXy5mb3JJbmBcbiAgICAgKiBvciBgXy5mb3JPd25gIGZvciBvYmplY3QgaXRlcmF0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGFsaWFzIGVhY2hcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fSBSZXR1cm5zIGBjb2xsZWN0aW9uYC5cbiAgICAgKiBAc2VlIF8uZm9yRWFjaFJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaChbMSwgMl0sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICogICBjb25zb2xlLmxvZyh2YWx1ZSk7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4gTG9ncyBgMWAgdGhlbiBgMmAuXG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckVhY2goY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaCA6IGJhc2VFYWNoO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmZvckVhY2hgIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgZWxlbWVudHMgb2ZcbiAgICAgKiBgY29sbGVjdGlvbmAgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGFsaWFzIGVhY2hSaWdodFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheXxPYmplY3R9IFJldHVybnMgYGNvbGxlY3Rpb25gLlxuICAgICAqIEBzZWUgXy5mb3JFYWNoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZm9yRWFjaFJpZ2h0KFsxLCAyXSwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKHZhbHVlKTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzIGAyYCB0aGVuIGAxYC5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JFYWNoUmlnaHQoY29sbGVjdGlvbiwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5RWFjaFJpZ2h0IDogYmFzZUVhY2hSaWdodDtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2Yga2V5cyBnZW5lcmF0ZWQgZnJvbSB0aGUgcmVzdWx0cyBvZiBydW5uaW5nXG4gICAgICogZWFjaCBlbGVtZW50IG9mIGBjb2xsZWN0aW9uYCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBvcmRlciBvZiBncm91cGVkIHZhbHVlc1xuICAgICAqIGlzIGRldGVybWluZWQgYnkgdGhlIG9yZGVyIHRoZXkgb2NjdXIgaW4gYGNvbGxlY3Rpb25gLiBUaGUgY29ycmVzcG9uZGluZ1xuICAgICAqIHZhbHVlIG9mIGVhY2gga2V5IGlzIGFuIGFycmF5IG9mIGVsZW1lbnRzIHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZVxuICAgICAqIGtleS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3JvdXBCeShbNi4xLCA0LjIsIDYuM10sIE1hdGguZmxvb3IpO1xuICAgICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjNdIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgICAqIC8vID0+IHsgJzMnOiBbJ29uZScsICd0d28nXSwgJzUnOiBbJ3RocmVlJ10gfVxuICAgICAqL1xuICAgIHZhciBncm91cEJ5ID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSkge1xuICAgICAgICByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGtleSwgW3ZhbHVlXSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBpbiBgY29sbGVjdGlvbmAuIElmIGBjb2xsZWN0aW9uYCBpcyBhIHN0cmluZywgaXQnc1xuICAgICAqIGNoZWNrZWQgZm9yIGEgc3Vic3RyaW5nIG9mIGB2YWx1ZWAsIG90aGVyd2lzZVxuICAgICAqIFtgU2FtZVZhbHVlWmVyb2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzcuMC8jc2VjLXNhbWV2YWx1ZXplcm8pXG4gICAgICogaXMgdXNlZCBmb3IgZXF1YWxpdHkgY29tcGFyaXNvbnMuIElmIGBmcm9tSW5kZXhgIGlzIG5lZ2F0aXZlLCBpdCdzIHVzZWQgYXNcbiAgICAgKiB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fHN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLnJlZHVjZWAuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZm91bmQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyhbMSwgMiwgM10sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoWzEsIDIsIDNdLCAxLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pbmNsdWRlcyh7ICdhJzogMSwgJ2InOiAyIH0sIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5jbHVkZXMoJ2FiY2QnLCAnYmMnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5jbHVkZXMoY29sbGVjdGlvbiwgdmFsdWUsIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICAgIGNvbGxlY3Rpb24gPSBpc0FycmF5TGlrZShjb2xsZWN0aW9uKSA/IGNvbGxlY3Rpb24gOiB2YWx1ZXMoY29sbGVjdGlvbik7XG4gICAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4ICYmICFndWFyZCkgPyB0b0ludGVnZXIoZnJvbUluZGV4KSA6IDA7XG5cbiAgICAgIHZhciBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcbiAgICAgIGlmIChmcm9tSW5kZXggPCAwKSB7XG4gICAgICAgIGZyb21JbmRleCA9IG5hdGl2ZU1heChsZW5ndGggKyBmcm9tSW5kZXgsIDApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gKGZyb21JbmRleCA8PSBsZW5ndGggJiYgY29sbGVjdGlvbi5pbmRleE9mKHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpXG4gICAgICAgIDogKCEhbGVuZ3RoICYmIGJhc2VJbmRleE9mKGNvbGxlY3Rpb24sIHZhbHVlLCBmcm9tSW5kZXgpID4gLTEpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nXG4gICAgICogYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAgICogYXJlIHByb3ZpZGVkIHRvIGVhY2ggaW52b2tlZCBtZXRob2QuIElmIGBwYXRoYCBpcyBhIGZ1bmN0aW9uLCBpdCdzIGludm9rZWRcbiAgICAgKiBmb3IsIGFuZCBgdGhpc2AgYm91bmQgdG8sIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0FycmF5fEZ1bmN0aW9ufHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgbWV0aG9kIHRvIGludm9rZSBvclxuICAgICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIGVhY2ggbWV0aG9kIHdpdGguXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiByZXN1bHRzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmludm9rZU1hcChbWzUsIDEsIDddLCBbMywgMiwgMV1dLCAnc29ydCcpO1xuICAgICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICAgKlxuICAgICAqIF8uaW52b2tlTWFwKFsxMjMsIDQ1Nl0sIFN0cmluZy5wcm90b3R5cGUuc3BsaXQsICcnKTtcbiAgICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAgICovXG4gICAgdmFyIGludm9rZU1hcCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGNvbGxlY3Rpb24sIHBhdGgsIGFyZ3MpIHtcbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGlzRnVuYyA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbicsXG4gICAgICAgICAgcmVzdWx0ID0gaXNBcnJheUxpa2UoY29sbGVjdGlvbikgPyBBcnJheShjb2xsZWN0aW9uLmxlbmd0aCkgOiBbXTtcblxuICAgICAgYmFzZUVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gaXNGdW5jID8gYXBwbHkocGF0aCwgdmFsdWUsIGFyZ3MpIDogYmFzZUludm9rZSh2YWx1ZSwgcGF0aCwgYXJncyk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIGdlbmVyYXRlZCBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmdcbiAgICAgKiBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocnUgYGl0ZXJhdGVlYC4gVGhlIGNvcnJlc3BvbmRpbmcgdmFsdWUgb2ZcbiAgICAgKiBlYWNoIGtleSBpcyB0aGUgbGFzdCBlbGVtZW50IHJlc3BvbnNpYmxlIGZvciBnZW5lcmF0aW5nIHRoZSBrZXkuIFRoZVxuICAgICAqIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIHRvIHRyYW5zZm9ybSBrZXlzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNvbXBvc2VkIGFnZ3JlZ2F0ZSBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFtcbiAgICAgKiAgIHsgJ2Rpcic6ICdsZWZ0JywgJ2NvZGUnOiA5NyB9LFxuICAgICAqICAgeyAnZGlyJzogJ3JpZ2h0JywgJ2NvZGUnOiAxMDAgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiBfLmtleUJ5KGFycmF5LCBmdW5jdGlvbihvKSB7XG4gICAgICogICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShvLmNvZGUpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IHsgJ2EnOiB7ICdkaXInOiAnbGVmdCcsICdjb2RlJzogOTcgfSwgJ2QnOiB7ICdkaXInOiAncmlnaHQnLCAnY29kZSc6IDEwMCB9IH1cbiAgICAgKlxuICAgICAqIF8ua2V5QnkoYXJyYXksICdkaXInKTtcbiAgICAgKiAvLyA9PiB7ICdsZWZ0JzogeyAnZGlyJzogJ2xlZnQnLCAnY29kZSc6IDk3IH0sICdyaWdodCc6IHsgJ2Rpcic6ICdyaWdodCcsICdjb2RlJzogMTAwIH0gfVxuICAgICAqL1xuICAgIHZhciBrZXlCeSA9IGNyZWF0ZUFnZ3JlZ2F0b3IoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgICBiYXNlQXNzaWduVmFsdWUocmVzdWx0LCBrZXksIHZhbHVlKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGJ5IHJ1bm5pbmcgZWFjaCBlbGVtZW50IGluIGBjb2xsZWN0aW9uYCB0aHJ1XG4gICAgICogYGl0ZXJhdGVlYC4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM6XG4gICAgICogKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgICAqXG4gICAgICogTWFueSBsb2Rhc2ggbWV0aG9kcyBhcmUgZ3VhcmRlZCB0byB3b3JrIGFzIGl0ZXJhdGVlcyBmb3IgbWV0aG9kcyBsaWtlXG4gICAgICogYF8uZXZlcnlgLCBgXy5maWx0ZXJgLCBgXy5tYXBgLCBgXy5tYXBWYWx1ZXNgLCBgXy5yZWplY3RgLCBhbmQgYF8uc29tZWAuXG4gICAgICpcbiAgICAgKiBUaGUgZ3VhcmRlZCBtZXRob2RzIGFyZTpcbiAgICAgKiBgYXJ5YCwgYGNodW5rYCwgYGN1cnJ5YCwgYGN1cnJ5UmlnaHRgLCBgZHJvcGAsIGBkcm9wUmlnaHRgLCBgZXZlcnlgLFxuICAgICAqIGBmaWxsYCwgYGludmVydGAsIGBwYXJzZUludGAsIGByYW5kb21gLCBgcmFuZ2VgLCBgcmFuZ2VSaWdodGAsIGByZXBlYXRgLFxuICAgICAqIGBzYW1wbGVTaXplYCwgYHNsaWNlYCwgYHNvbWVgLCBgc29ydEJ5YCwgYHNwbGl0YCwgYHRha2VgLCBgdGFrZVJpZ2h0YCxcbiAgICAgKiBgdGVtcGxhdGVgLCBgdHJpbWAsIGB0cmltRW5kYCwgYHRyaW1TdGFydGAsIGFuZCBgd29yZHNgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogXy5tYXAoWzQsIDhdLCBzcXVhcmUpO1xuICAgICAqIC8vID0+IFsxNiwgNjRdXG4gICAgICpcbiAgICAgKiBfLm1hcCh7ICdhJzogNCwgJ2InOiA4IH0sIHNxdWFyZSk7XG4gICAgICogLy8gPT4gWzE2LCA2NF0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IFtcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JyB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJyB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCAndXNlcicpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1hcChjb2xsZWN0aW9uLCBpdGVyYXRlZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlNYXAgOiBiYXNlTWFwO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnNvcnRCeWAgZXhjZXB0IHRoYXQgaXQgYWxsb3dzIHNwZWNpZnlpbmcgdGhlIHNvcnRcbiAgICAgKiBvcmRlcnMgb2YgdGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LiBJZiBgb3JkZXJzYCBpcyB1bnNwZWNpZmllZCwgYWxsIHZhbHVlc1xuICAgICAqIGFyZSBzb3J0ZWQgaW4gYXNjZW5kaW5nIG9yZGVyLiBPdGhlcndpc2UsIHNwZWNpZnkgYW4gb3JkZXIgb2YgXCJkZXNjXCIgZm9yXG4gICAgICogZGVzY2VuZGluZyBvciBcImFzY1wiIGZvciBhc2NlbmRpbmcgc29ydCBvcmRlciBvZiBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7QXJyYXlbXXxGdW5jdGlvbltdfE9iamVjdFtdfHN0cmluZ1tdfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBzb3J0IGJ5LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nW119IFtvcmRlcnNdIFRoZSBzb3J0IG9yZGVycyBvZiBgaXRlcmF0ZWVzYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5yZWR1Y2VgLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IHNvcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDggfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnYmFybmV5JywgJ2FnZSc6IDM0IH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfVxuICAgICAqIF07XG4gICAgICpcbiAgICAgKiAvLyBTb3J0IGJ5IGB1c2VyYCBpbiBhc2NlbmRpbmcgb3JkZXIgYW5kIGJ5IGBhZ2VgIGluIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICogXy5vcmRlckJ5KHVzZXJzLCBbJ3VzZXInLCAnYWdlJ10sIFsnYXNjJywgJ2Rlc2MnXSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCA0MF1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gb3JkZXJCeShjb2xsZWN0aW9uLCBpdGVyYXRlZXMsIG9yZGVycywgZ3VhcmQpIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgaWYgKCFpc0FycmF5KGl0ZXJhdGVlcykpIHtcbiAgICAgICAgaXRlcmF0ZWVzID0gaXRlcmF0ZWVzID09IG51bGwgPyBbXSA6IFtpdGVyYXRlZXNdO1xuICAgICAgfVxuICAgICAgb3JkZXJzID0gZ3VhcmQgPyB1bmRlZmluZWQgOiBvcmRlcnM7XG4gICAgICBpZiAoIWlzQXJyYXkob3JkZXJzKSkge1xuICAgICAgICBvcmRlcnMgPSBvcmRlcnMgPT0gbnVsbCA/IFtdIDogW29yZGVyc107XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZU9yZGVyQnkoY29sbGVjdGlvbiwgaXRlcmF0ZWVzLCBvcmRlcnMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMgc3BsaXQgaW50byB0d28gZ3JvdXBzLCB0aGUgZmlyc3Qgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IsIHRoZSBzZWNvbmQgb2Ygd2hpY2hcbiAgICAgKiBjb250YWlucyBlbGVtZW50cyBgcHJlZGljYXRlYCByZXR1cm5zIGZhbHNleSBmb3IuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAgJ2FnZSc6IDM2LCAnYWN0aXZlJzogZmFsc2UgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWN0aXZlOyB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsIHsgJ2FnZSc6IDEsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydwZWJibGVzJ10sIFsnYmFybmV5JywgJ2ZyZWQnXV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzUHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLnBhcnRpdGlvbih1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IG9iamVjdHMgZm9yIFtbJ2Jhcm5leScsICdwZWJibGVzJ10sIFsnZnJlZCddXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5wYXJ0aXRpb24odXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydmcmVkJ10sIFsnYmFybmV5JywgJ3BlYmJsZXMnXV1cbiAgICAgKi9cbiAgICB2YXIgcGFydGl0aW9uID0gY3JlYXRlQWdncmVnYXRvcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIHJlc3VsdFtrZXkgPyAwIDogMV0ucHVzaCh2YWx1ZSk7XG4gICAgfSwgZnVuY3Rpb24oKSB7IHJldHVybiBbW10sIFtdXTsgfSk7XG5cbiAgICAvKipcbiAgICAgKiBSZWR1Y2VzIGBjb2xsZWN0aW9uYCB0byBhIHZhbHVlIHdoaWNoIGlzIHRoZSBhY2N1bXVsYXRlZCByZXN1bHQgb2YgcnVubmluZ1xuICAgICAqIGVhY2ggZWxlbWVudCBpbiBgY29sbGVjdGlvbmAgdGhydSBgaXRlcmF0ZWVgLCB3aGVyZSBlYWNoIHN1Y2Nlc3NpdmVcbiAgICAgKiBpbnZvY2F0aW9uIGlzIHN1cHBsaWVkIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHByZXZpb3VzLiBJZiBgYWNjdW11bGF0b3JgXG4gICAgICogaXMgbm90IGdpdmVuLCB0aGUgZmlyc3QgZWxlbWVudCBvZiBgY29sbGVjdGlvbmAgaXMgdXNlZCBhcyB0aGUgaW5pdGlhbFxuICAgICAqIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOlxuICAgICAqIChhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBNYW55IGxvZGFzaCBtZXRob2RzIGFyZSBndWFyZGVkIHRvIHdvcmsgYXMgaXRlcmF0ZWVzIGZvciBtZXRob2RzIGxpa2VcbiAgICAgKiBgXy5yZWR1Y2VgLCBgXy5yZWR1Y2VSaWdodGAsIGFuZCBgXy50cmFuc2Zvcm1gLlxuICAgICAqXG4gICAgICogVGhlIGd1YXJkZWQgbWV0aG9kcyBhcmU6XG4gICAgICogYGFzc2lnbmAsIGBkZWZhdWx0c2AsIGBkZWZhdWx0c0RlZXBgLCBgaW5jbHVkZXNgLCBgbWVyZ2VgLCBgb3JkZXJCeWAsXG4gICAgICogYW5kIGBzb3J0QnlgXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcGFyYW0geyp9IFthY2N1bXVsYXRvcl0gVGhlIGluaXRpYWwgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5yZWR1Y2VSaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlZHVjZShbMSwgMl0sIGZ1bmN0aW9uKHN1bSwgbikge1xuICAgICAqICAgcmV0dXJuIHN1bSArIG47XG4gICAgICogfSwgMCk7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy5yZWR1Y2UoeyAnYSc6IDEsICdiJzogMiwgJ2MnOiAxIH0sIGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAqICAgKHJlc3VsdFt2YWx1ZV0gfHwgKHJlc3VsdFt2YWx1ZV0gPSBbXSkpLnB1c2goa2V5KTtcbiAgICAgKiAgIHJldHVybiByZXN1bHQ7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZWR1Y2UoY29sbGVjdGlvbiwgaXRlcmF0ZWUsIGFjY3VtdWxhdG9yKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVJlZHVjZSA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2gpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ucmVkdWNlYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIGVsZW1lbnRzIG9mXG4gICAgICogYGNvbGxlY3Rpb25gIGZyb20gcmlnaHQgdG8gbGVmdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uXG4gICAgICogQHBhcmFtIHtBcnJheXxPYmplY3R9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEBwYXJhbSB7Kn0gW2FjY3VtdWxhdG9yXSBUaGUgaW5pdGlhbCB2YWx1ZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgYWNjdW11bGF0ZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLnJlZHVjZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYXJyYXkgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAgICpcbiAgICAgKiBfLnJlZHVjZVJpZ2h0KGFycmF5LCBmdW5jdGlvbihmbGF0dGVuZWQsIG90aGVyKSB7XG4gICAgICogICByZXR1cm4gZmxhdHRlbmVkLmNvbmNhdChvdGhlcik7XG4gICAgICogfSwgW10pO1xuICAgICAqIC8vID0+IFs0LCA1LCAyLCAzLCAwLCAxXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGl0ZXJhdGVlLCBhY2N1bXVsYXRvcikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlSZWR1Y2VSaWdodCA6IGJhc2VSZWR1Y2UsXG4gICAgICAgICAgaW5pdEFjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG5cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KSwgYWNjdW11bGF0b3IsIGluaXRBY2N1bSwgYmFzZUVhY2hSaWdodCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmA7IHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIGVsZW1lbnRzIG9mIGBjb2xsZWN0aW9uYFxuICAgICAqIHRoYXQgYHByZWRpY2F0ZWAgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgICAqIEBzZWUgXy5maWx0ZXJcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgeyAndXNlcic6ICdmcmVkJywgICAnYWdlJzogNDAsICdhY3RpdmUnOiB0cnVlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5yZWplY3QodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuICFvLmFjdGl2ZTsgfSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgWydmcmVkJ11cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIHsgJ2FnZSc6IDQwLCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5yZWplY3QodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbJ2Jhcm5leSddXG4gICAgICovXG4gICAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIHByZWRpY2F0ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlGaWx0ZXIgOiBiYXNlRmlsdGVyO1xuICAgICAgcmV0dXJuIGZ1bmMoY29sbGVjdGlvbiwgbmVnYXRlKGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmFuZG9tIGVsZW1lbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2FtcGxlKFsxLCAyLCAzLCA0XSk7XG4gICAgICogLy8gPT4gMlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNhbXBsZShjb2xsZWN0aW9uKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZSA6IGJhc2VTYW1wbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIGBuYCByYW5kb20gZWxlbWVudHMgYXQgdW5pcXVlIGtleXMgZnJvbSBgY29sbGVjdGlvbmAgdXAgdG8gdGhlXG4gICAgICogc2l6ZSBvZiBgY29sbGVjdGlvbmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNhbXBsZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBzYW1wbGUuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmRvbSBlbGVtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zYW1wbGVTaXplKFsxLCAyLCAzXSwgMik7XG4gICAgICogLy8gPT4gWzMsIDFdXG4gICAgICpcbiAgICAgKiBfLnNhbXBsZVNpemUoWzEsIDIsIDNdLCA0KTtcbiAgICAgKiAvLyA9PiBbMiwgMywgMV1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzYW1wbGVTaXplKGNvbGxlY3Rpb24sIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgbiwgZ3VhcmQpIDogbiA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICBuID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICB9XG4gICAgICB2YXIgZnVuYyA9IGlzQXJyYXkoY29sbGVjdGlvbikgPyBhcnJheVNhbXBsZVNpemUgOiBiYXNlU2FtcGxlU2l6ZTtcbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygc2h1ZmZsZWQgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAgICogW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc2h1ZmZsZWQgYXJyYXkuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2h1ZmZsZShbMSwgMiwgMywgNF0pO1xuICAgICAqIC8vID0+IFs0LCAxLCAzLCAyXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNodWZmbGUoY29sbGVjdGlvbikge1xuICAgICAgdmFyIGZ1bmMgPSBpc0FycmF5KGNvbGxlY3Rpb24pID8gYXJyYXlTaHVmZmxlIDogYmFzZVNodWZmbGU7XG4gICAgICByZXR1cm4gZnVuYyhjb2xsZWN0aW9uKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBzaXplIG9mIGBjb2xsZWN0aW9uYCBieSByZXR1cm5pbmcgaXRzIGxlbmd0aCBmb3IgYXJyYXktbGlrZVxuICAgICAqIHZhbHVlcyBvciB0aGUgbnVtYmVyIG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIGZvciBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxzdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaW5zcGVjdC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb2xsZWN0aW9uIHNpemUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc2l6ZShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uc2l6ZSh7ICdhJzogMSwgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8uc2l6ZSgncGViYmxlcycpO1xuICAgICAqIC8vID0+IDdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzaXplKGNvbGxlY3Rpb24pIHtcbiAgICAgIGlmIChjb2xsZWN0aW9uID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgICB9XG4gICAgICBpZiAoaXNBcnJheUxpa2UoY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKGNvbGxlY3Rpb24pID8gc3RyaW5nU2l6ZShjb2xsZWN0aW9uKSA6IGNvbGxlY3Rpb24ubGVuZ3RoO1xuICAgICAgfVxuICAgICAgdmFyIHRhZyA9IGdldFRhZyhjb2xsZWN0aW9uKTtcbiAgICAgIGlmICh0YWcgPT0gbWFwVGFnIHx8IHRhZyA9PSBzZXRUYWcpIHtcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb24uc2l6ZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlS2V5cyhjb2xsZWN0aW9uKS5sZW5ndGg7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwcmVkaWNhdGVgIHJldHVybnMgdHJ1dGh5IGZvciAqKmFueSoqIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gLlxuICAgICAqIEl0ZXJhdGlvbiBpcyBzdG9wcGVkIG9uY2UgYHByZWRpY2F0ZWAgcmV0dXJucyB0cnV0aHkuIFRoZSBwcmVkaWNhdGUgaXNcbiAgICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOiAodmFsdWUsIGluZGV4fGtleSwgY29sbGVjdGlvbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvblxuICAgICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYW55IGVsZW1lbnQgcGFzc2VzIHRoZSBwcmVkaWNhdGUgY2hlY2ssXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zb21lKFtudWxsLCAwLCAneWVzJywgZmFsc2VdLCBCb29sZWFuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhY3RpdmUnOiBmYWxzZSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5tYXRjaGVzYCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5zb21lKHVzZXJzLCB7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiBmYWxzZSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgWydhY3RpdmUnLCBmYWxzZV0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc29tZSh1c2VycywgJ2FjdGl2ZScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpIHtcbiAgICAgIHZhciBmdW5jID0gaXNBcnJheShjb2xsZWN0aW9uKSA/IGFycmF5U29tZSA6IGJhc2VTb21lO1xuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKGNvbGxlY3Rpb24sIHByZWRpY2F0ZSwgZ3VhcmQpKSB7XG4gICAgICAgIHByZWRpY2F0ZSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmdW5jKGNvbGxlY3Rpb24sIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgZWxlbWVudHMsIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24gdGhydSBlYWNoIGl0ZXJhdGVlLiBUaGlzIG1ldGhvZFxuICAgICAqIHBlcmZvcm1zIGEgc3RhYmxlIHNvcnQsIHRoYXQgaXMsIGl0IHByZXNlcnZlcyB0aGUgb3JpZ2luYWwgc29ydCBvcmRlciBvZlxuICAgICAqIGVxdWFsIGVsZW1lbnRzLiBUaGUgaXRlcmF0ZWVzIGFyZSBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25cbiAgICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdH0gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtpdGVyYXRlZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgaXRlcmF0ZWVzIHRvIHNvcnQgYnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgc29ydGVkIGFycmF5LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgdXNlcnMgPSBbXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0OCB9LFxuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYgfSxcbiAgICAgKiAgIHsgJ3VzZXInOiAnZnJlZCcsICAgJ2FnZSc6IDMwIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2Jhcm5leScsICdhZ2UnOiAzNCB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uc29ydEJ5KHVzZXJzLCBbZnVuY3Rpb24obykgeyByZXR1cm4gby51c2VyOyB9XSk7XG4gICAgICogLy8gPT4gb2JqZWN0cyBmb3IgW1snYmFybmV5JywgMzZdLCBbJ2Jhcm5leScsIDM0XSwgWydmcmVkJywgNDhdLCBbJ2ZyZWQnLCAzMF1dXG4gICAgICpcbiAgICAgKiBfLnNvcnRCeSh1c2VycywgWyd1c2VyJywgJ2FnZSddKTtcbiAgICAgKiAvLyA9PiBvYmplY3RzIGZvciBbWydiYXJuZXknLCAzNF0sIFsnYmFybmV5JywgMzZdLCBbJ2ZyZWQnLCAzMF0sIFsnZnJlZCcsIDQ4XV1cbiAgICAgKi9cbiAgICB2YXIgc29ydEJ5ID0gYmFzZVJlc3QoZnVuY3Rpb24oY29sbGVjdGlvbiwgaXRlcmF0ZWVzKSB7XG4gICAgICBpZiAoY29sbGVjdGlvbiA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBpdGVyYXRlZXMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA+IDEgJiYgaXNJdGVyYXRlZUNhbGwoY29sbGVjdGlvbiwgaXRlcmF0ZWVzWzBdLCBpdGVyYXRlZXNbMV0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtdO1xuICAgICAgfSBlbHNlIGlmIChsZW5ndGggPiAyICYmIGlzSXRlcmF0ZWVDYWxsKGl0ZXJhdGVlc1swXSwgaXRlcmF0ZWVzWzFdLCBpdGVyYXRlZXNbMl0pKSB7XG4gICAgICAgIGl0ZXJhdGVlcyA9IFtpdGVyYXRlZXNbMF1dO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VPcmRlckJ5KGNvbGxlY3Rpb24sIGJhc2VGbGF0dGVuKGl0ZXJhdGVlcywgMSksIFtdKTtcbiAgICB9KTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0aGF0IGhhdmUgZWxhcHNlZCBzaW5jZVxuICAgICAqIHRoZSBVbml4IGVwb2NoICgxIEphbnVhcnkgMTk3MCAwMDowMDowMCBVVEMpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IERhdGVcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lc3RhbXAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmZXIoZnVuY3Rpb24oc3RhbXApIHtcbiAgICAgKiAgIGNvbnNvbGUubG9nKF8ubm93KCkgLSBzdGFtcCk7XG4gICAgICogfSwgXy5ub3coKSk7XG4gICAgICogLy8gPT4gTG9ncyB0aGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyBpdCB0b29rIGZvciB0aGUgZGVmZXJyZWQgaW52b2NhdGlvbi5cbiAgICAgKi9cbiAgICB2YXIgbm93ID0gY3R4Tm93IHx8IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHJvb3QuRGF0ZS5ub3coKTtcbiAgICB9O1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmJlZm9yZWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXNcbiAgICAgKiBgZnVuY2Agb25jZSBpdCdzIGNhbGxlZCBgbmAgb3IgbW9yZSB0aW1lcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgY2FsbHMgYmVmb3JlIGBmdW5jYCBpcyBpbnZva2VkLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBzYXZlcyA9IFsncHJvZmlsZScsICdzZXR0aW5ncyddO1xuICAgICAqXG4gICAgICogdmFyIGRvbmUgPSBfLmFmdGVyKHNhdmVzLmxlbmd0aCwgZnVuY3Rpb24oKSB7XG4gICAgICogICBjb25zb2xlLmxvZygnZG9uZSBzYXZpbmchJyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZvckVhY2goc2F2ZXMsIGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgKiAgIGFzeW5jU2F2ZSh7ICd0eXBlJzogdHlwZSwgJ2NvbXBsZXRlJzogZG9uZSB9KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdkb25lIHNhdmluZyEnIGFmdGVyIHRoZSB0d28gYXN5bmMgc2F2ZXMgaGF2ZSBjb21wbGV0ZWQuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYWZ0ZXIobiwgZnVuYykge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKC0tbiA8IDEpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgLCB3aXRoIHVwIHRvIGBuYCBhcmd1bWVudHMsXG4gICAgICogaWdub3JpbmcgYW55IGFkZGl0aW9uYWwgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY2FwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtuPWZ1bmMubGVuZ3RoXSBUaGUgYXJpdHkgY2FwLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY2FwcGVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcChbJzYnLCAnOCcsICcxMCddLCBfLmFyeShwYXJzZUludCwgMSkpO1xuICAgICAqIC8vID0+IFs2LCA4LCAxMF1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBhcnkoZnVuYywgbiwgZ3VhcmQpIHtcbiAgICAgIG4gPSBndWFyZCA/IHVuZGVmaW5lZCA6IG47XG4gICAgICBuID0gKGZ1bmMgJiYgbiA9PSBudWxsKSA/IGZ1bmMubGVuZ3RoIDogbjtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfQVJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2AsIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHNcbiAgICAgKiBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hpbGUgaXQncyBjYWxsZWQgbGVzcyB0aGFuIGBuYCB0aW1lcy4gU3Vic2VxdWVudFxuICAgICAqIGNhbGxzIHRvIHRoZSBjcmVhdGVkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG4gVGhlIG51bWJlciBvZiBjYWxscyBhdCB3aGljaCBgZnVuY2AgaXMgbm8gbG9uZ2VyIGludm9rZWQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcmVzdHJpY3QuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcmVzdHJpY3RlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIF8uYmVmb3JlKDUsIGFkZENvbnRhY3RUb0xpc3QpKTtcbiAgICAgKiAvLyA9PiBBbGxvd3MgYWRkaW5nIHVwIHRvIDQgY29udGFjdHMgdG8gdGhlIGxpc3QuXG4gICAgICovXG4gICAgZnVuY3Rpb24gYmVmb3JlKG4sIGZ1bmMpIHtcbiAgICAgIHZhciByZXN1bHQ7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgICBpZiAoLS1uID4gMCkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobiA8PSAxKSB7XG4gICAgICAgICAgZnVuYyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiBgdGhpc0FyZ2BcbiAgICAgKiBhbmQgYHBhcnRpYWxzYCBwcmVwZW5kZWQgdG8gdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlcy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kLnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVbmxpa2UgbmF0aXZlIGBGdW5jdGlvbiNiaW5kYCwgdGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCJcbiAgICAgKiBwcm9wZXJ0eSBvZiBib3VuZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBiaW5kLlxuICAgICAqIEBwYXJhbSB7Kn0gdGhpc0FyZyBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMudXNlciArIHB1bmN0dWF0aW9uO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICd1c2VyJzogJ2ZyZWQnIH07XG4gICAgICpcbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmQoZ3JlZXQsIG9iamVjdCwgXywgJyEnKTtcbiAgICAgKiBib3VuZCgnaGknKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICovXG4gICAgdmFyIGJpbmQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB0aGlzQXJnLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGJpdG1hc2sgPSBXUkFQX0JJTkRfRkxBRztcbiAgICAgIGlmIChwYXJ0aWFscy5sZW5ndGgpIHtcbiAgICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKGJpbmQpKTtcbiAgICAgICAgYml0bWFzayB8PSBXUkFQX1BBUlRJQUxfRkxBRztcbiAgICAgIH1cbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIGJpdG1hc2ssIHRoaXNBcmcsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgb2JqZWN0W2tleV1gIHdpdGggYHBhcnRpYWxzYFxuICAgICAqIHByZXBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZGlmZmVycyBmcm9tIGBfLmJpbmRgIGJ5IGFsbG93aW5nIGJvdW5kIGZ1bmN0aW9ucyB0byByZWZlcmVuY2VcbiAgICAgKiBtZXRob2RzIHRoYXQgbWF5IGJlIHJlZGVmaW5lZCBvciBkb24ndCB5ZXQgZXhpc3QuIFNlZVxuICAgICAqIFtQZXRlciBNaWNoYXV4J3MgYXJ0aWNsZV0oaHR0cDovL3BldGVyLm1pY2hhdXguY2EvYXJ0aWNsZXMvbGF6eS1mdW5jdGlvbi1kZWZpbml0aW9uLXBhdHRlcm4pXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFRoZSBgXy5iaW5kS2V5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWNcbiAgICAgKiBidWlsZHMsIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW52b2tlIHRoZSBtZXRob2Qgb24uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IGtleSBUaGUga2V5IG9mIHRoZSBtZXRob2QuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbcGFydGlhbHNdIFRoZSBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7XG4gICAgICogICAndXNlcic6ICdmcmVkJyxcbiAgICAgKiAgICdncmVldCc6IGZ1bmN0aW9uKGdyZWV0aW5nLCBwdW5jdHVhdGlvbikge1xuICAgICAqICAgICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLnVzZXIgKyBwdW5jdHVhdGlvbjtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGJvdW5kID0gXy5iaW5kS2V5KG9iamVjdCwgJ2dyZWV0JywgJ2hpJyk7XG4gICAgICogYm91bmQoJyEnKTtcbiAgICAgKiAvLyA9PiAnaGkgZnJlZCEnXG4gICAgICpcbiAgICAgKiBvYmplY3QuZ3JlZXQgPSBmdW5jdGlvbihncmVldGluZywgcHVuY3R1YXRpb24pIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICd5YSAnICsgdGhpcy51c2VyICsgcHVuY3R1YXRpb247XG4gICAgICogfTtcbiAgICAgKlxuICAgICAqIGJvdW5kKCchJyk7XG4gICAgICogLy8gPT4gJ2hpeWEgZnJlZCEnXG4gICAgICpcbiAgICAgKiAvLyBCb3VuZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiB2YXIgYm91bmQgPSBfLmJpbmRLZXkob2JqZWN0LCAnZ3JlZXQnLCBfLCAnIScpO1xuICAgICAqIGJvdW5kKCdoaScpO1xuICAgICAqIC8vID0+ICdoaXlhIGZyZWQhJ1xuICAgICAqL1xuICAgIHZhciBiaW5kS2V5ID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBrZXksIHBhcnRpYWxzKSB7XG4gICAgICB2YXIgYml0bWFzayA9IFdSQVBfQklORF9GTEFHIHwgV1JBUF9CSU5EX0tFWV9GTEFHO1xuICAgICAgaWYgKHBhcnRpYWxzLmxlbmd0aCkge1xuICAgICAgICB2YXIgaG9sZGVycyA9IHJlcGxhY2VIb2xkZXJzKHBhcnRpYWxzLCBnZXRIb2xkZXIoYmluZEtleSkpO1xuICAgICAgICBiaXRtYXNrIHw9IFdSQVBfUEFSVElBTF9GTEFHO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoa2V5LCBiaXRtYXNrLCBvYmplY3QsIHBhcnRpYWxzLCBob2xkZXJzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGFjY2VwdHMgYXJndW1lbnRzIG9mIGBmdW5jYCBhbmQgZWl0aGVyIGludm9rZXNcbiAgICAgKiBgZnVuY2AgcmV0dXJuaW5nIGl0cyByZXN1bHQsIGlmIGF0IGxlYXN0IGBhcml0eWAgbnVtYmVyIG9mIGFyZ3VtZW50cyBoYXZlXG4gICAgICogYmVlbiBwcm92aWRlZCwgb3IgcmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgYWNjZXB0cyB0aGUgcmVtYWluaW5nIGBmdW5jYFxuICAgICAqIGFyZ3VtZW50cywgYW5kIHNvIG9uLiBUaGUgYXJpdHkgb2YgYGZ1bmNgIG1heSBiZSBzcGVjaWZpZWQgaWYgYGZ1bmMubGVuZ3RoYFxuICAgICAqIGlzIG5vdCBzdWZmaWNpZW50LlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5LnBsYWNlaG9sZGVyYCB2YWx1ZSwgd2hpY2ggZGVmYXVsdHMgdG8gYF9gIGluIG1vbm9saXRoaWMgYnVpbGRzLFxuICAgICAqIG1heSBiZSB1c2VkIGFzIGEgcGxhY2Vob2xkZXIgZm9yIHByb3ZpZGVkIGFyZ3VtZW50cy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBkb2Vzbid0IHNldCB0aGUgXCJsZW5ndGhcIiBwcm9wZXJ0eSBvZiBjdXJyaWVkIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjAuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGN1cnJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbYXJpdHk9ZnVuYy5sZW5ndGhdIFRoZSBhcml0eSBvZiBgZnVuY2AuXG4gICAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEVuYWJsZXMgdXNlIGFzIGFuIGl0ZXJhdGVlIGZvciBtZXRob2RzIGxpa2UgYF8ubWFwYC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjdXJyaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgYWJjID0gZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIGN1cnJpZWQgPSBfLmN1cnJ5KGFiYyk7XG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEpKDIpKDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogY3VycmllZCgxLCAyKSgzKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMSwgMiwgMyk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiAvLyBDdXJyaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIGN1cnJpZWQoMSkoXywgMykoMik7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICovXG4gICAgZnVuY3Rpb24gY3VycnkoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeS5wbGFjZWhvbGRlcjtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5jdXJyeWAgZXhjZXB0IHRoYXQgYXJndW1lbnRzIGFyZSBhcHBsaWVkIHRvIGBmdW5jYFxuICAgICAqIGluIHRoZSBtYW5uZXIgb2YgYF8ucGFydGlhbFJpZ2h0YCBpbnN0ZWFkIG9mIGBfLnBhcnRpYWxgLlxuICAgICAqXG4gICAgICogVGhlIGBfLmN1cnJ5UmlnaHQucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcHJvdmlkZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGN1cnJpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gY3VycnkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFthcml0eT1mdW5jLmxlbmd0aF0gVGhlIGFyaXR5IG9mIGBmdW5jYC5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGN1cnJpZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhYmMgPSBmdW5jdGlvbihhLCBiLCBjKSB7XG4gICAgICogICByZXR1cm4gW2EsIGIsIGNdO1xuICAgICAqIH07XG4gICAgICpcbiAgICAgKiB2YXIgY3VycmllZCA9IF8uY3VycnlSaWdodChhYmMpO1xuICAgICAqXG4gICAgICogY3VycmllZCgzKSgyKSgxKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICAgKlxuICAgICAqIGN1cnJpZWQoMiwgMykoMSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBjdXJyaWVkKDEsIDIsIDMpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqXG4gICAgICogLy8gQ3VycmllZCB3aXRoIHBsYWNlaG9sZGVycy5cbiAgICAgKiBjdXJyaWVkKDMpKDEsIF8pKDIpO1xuICAgICAqIC8vID0+IFsxLCAyLCAzXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGN1cnJ5UmlnaHQoZnVuYywgYXJpdHksIGd1YXJkKSB7XG4gICAgICBhcml0eSA9IGd1YXJkID8gdW5kZWZpbmVkIDogYXJpdHk7XG4gICAgICB2YXIgcmVzdWx0ID0gY3JlYXRlV3JhcChmdW5jLCBXUkFQX0NVUlJZX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBhcml0eSk7XG4gICAgICByZXN1bHQucGxhY2Vob2xkZXIgPSBjdXJyeVJpZ2h0LnBsYWNlaG9sZGVyO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZGVib3VuY2VkIGZ1bmN0aW9uIHRoYXQgZGVsYXlzIGludm9raW5nIGBmdW5jYCB1bnRpbCBhZnRlciBgd2FpdGBcbiAgICAgKiBtaWxsaXNlY29uZHMgaGF2ZSBlbGFwc2VkIHNpbmNlIHRoZSBsYXN0IHRpbWUgdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3YXNcbiAgICAgKiBpbnZva2VkLiBUaGUgZGVib3VuY2VkIGZ1bmN0aW9uIGNvbWVzIHdpdGggYSBgY2FuY2VsYCBtZXRob2QgdG8gY2FuY2VsXG4gICAgICogZGVsYXllZCBgZnVuY2AgaW52b2NhdGlvbnMgYW5kIGEgYGZsdXNoYCBtZXRob2QgdG8gaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uXG4gICAgICogUHJvdmlkZSBgb3B0aW9uc2AgdG8gaW5kaWNhdGUgd2hldGhlciBgZnVuY2Agc2hvdWxkIGJlIGludm9rZWQgb24gdGhlXG4gICAgICogbGVhZGluZyBhbmQvb3IgdHJhaWxpbmcgZWRnZSBvZiB0aGUgYHdhaXRgIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhlIGxhc3QgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnRcbiAgICAgKiBjYWxscyB0byB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYFxuICAgICAqIGludm9jYXRpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSWYgYGxlYWRpbmdgIGFuZCBgdHJhaWxpbmdgIG9wdGlvbnMgYXJlIGB0cnVlYCwgYGZ1bmNgIGlzXG4gICAgICogaW52b2tlZCBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb25cbiAgICAgKiBpcyBpbnZva2VkIG1vcmUgdGhhbiBvbmNlIGR1cmluZyB0aGUgYHdhaXRgIHRpbWVvdXQuXG4gICAgICpcbiAgICAgKiBJZiBgd2FpdGAgaXMgYDBgIGFuZCBgbGVhZGluZ2AgaXMgYGZhbHNlYCwgYGZ1bmNgIGludm9jYXRpb24gaXMgZGVmZXJyZWRcbiAgICAgKiB1bnRpbCB0byB0aGUgbmV4dCB0aWNrLCBzaW1pbGFyIHRvIGBzZXRUaW1lb3V0YCB3aXRoIGEgdGltZW91dCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBTZWUgW0RhdmlkIENvcmJhY2hvJ3MgYXJ0aWNsZV0oaHR0cHM6Ly9jc3MtdHJpY2tzLmNvbS9kZWJvdW5jaW5nLXRocm90dGxpbmctZXhwbGFpbmVkLWV4YW1wbGVzLylcbiAgICAgKiBmb3IgZGV0YWlscyBvdmVyIHRoZSBkaWZmZXJlbmNlcyBiZXR3ZWVuIGBfLmRlYm91bmNlYCBhbmQgYF8udGhyb3R0bGVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFt3YWl0PTBdIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMubGVhZGluZz1mYWxzZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5tYXhXYWl0XVxuICAgICAqICBUaGUgbWF4aW11bSB0aW1lIGBmdW5jYCBpcyBhbGxvd2VkIHRvIGJlIGRlbGF5ZWQgYmVmb3JlIGl0J3MgaW52b2tlZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLnRyYWlsaW5nPXRydWVdXG4gICAgICogIFNwZWNpZnkgaW52b2tpbmcgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZGVib3VuY2VkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCBjb3N0bHkgY2FsY3VsYXRpb25zIHdoaWxlIHRoZSB3aW5kb3cgc2l6ZSBpcyBpbiBmbHV4LlxuICAgICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdyZXNpemUnLCBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMTUwKSk7XG4gICAgICpcbiAgICAgKiAvLyBJbnZva2UgYHNlbmRNYWlsYCB3aGVuIGNsaWNrZWQsIGRlYm91bmNpbmcgc3Vic2VxdWVudCBjYWxscy5cbiAgICAgKiBqUXVlcnkoZWxlbWVudCkub24oJ2NsaWNrJywgXy5kZWJvdW5jZShzZW5kTWFpbCwgMzAwLCB7XG4gICAgICogICAnbGVhZGluZyc6IHRydWUsXG4gICAgICogICAndHJhaWxpbmcnOiBmYWxzZVxuICAgICAqIH0pKTtcbiAgICAgKlxuICAgICAqIC8vIEVuc3VyZSBgYmF0Y2hMb2dgIGlzIGludm9rZWQgb25jZSBhZnRlciAxIHNlY29uZCBvZiBkZWJvdW5jZWQgY2FsbHMuXG4gICAgICogdmFyIGRlYm91bmNlZCA9IF8uZGVib3VuY2UoYmF0Y2hMb2csIDI1MCwgeyAnbWF4V2FpdCc6IDEwMDAgfSk7XG4gICAgICogdmFyIHNvdXJjZSA9IG5ldyBFdmVudFNvdXJjZSgnL3N0cmVhbScpO1xuICAgICAqIGpRdWVyeShzb3VyY2UpLm9uKCdtZXNzYWdlJywgZGVib3VuY2VkKTtcbiAgICAgKlxuICAgICAqIC8vIENhbmNlbCB0aGUgdHJhaWxpbmcgZGVib3VuY2VkIGludm9jYXRpb24uXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3BvcHN0YXRlJywgZGVib3VuY2VkLmNhbmNlbCk7XG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgb3B0aW9ucykge1xuICAgICAgdmFyIGxhc3RBcmdzLFxuICAgICAgICAgIGxhc3RUaGlzLFxuICAgICAgICAgIG1heFdhaXQsXG4gICAgICAgICAgcmVzdWx0LFxuICAgICAgICAgIHRpbWVySWQsXG4gICAgICAgICAgbGFzdENhbGxUaW1lLFxuICAgICAgICAgIGxhc3RJbnZva2VUaW1lID0gMCxcbiAgICAgICAgICBsZWFkaW5nID0gZmFsc2UsXG4gICAgICAgICAgbWF4aW5nID0gZmFsc2UsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICB3YWl0ID0gdG9OdW1iZXIod2FpdCkgfHwgMDtcbiAgICAgIGlmIChpc09iamVjdChvcHRpb25zKSkge1xuICAgICAgICBsZWFkaW5nID0gISFvcHRpb25zLmxlYWRpbmc7XG4gICAgICAgIG1heGluZyA9ICdtYXhXYWl0JyBpbiBvcHRpb25zO1xuICAgICAgICBtYXhXYWl0ID0gbWF4aW5nID8gbmF0aXZlTWF4KHRvTnVtYmVyKG9wdGlvbnMubWF4V2FpdCkgfHwgMCwgd2FpdCkgOiBtYXhXYWl0O1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBpbnZva2VGdW5jKHRpbWUpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBsYXN0QXJncyxcbiAgICAgICAgICAgIHRoaXNBcmcgPSBsYXN0VGhpcztcblxuICAgICAgICBsYXN0QXJncyA9IGxhc3RUaGlzID0gdW5kZWZpbmVkO1xuICAgICAgICBsYXN0SW52b2tlVGltZSA9IHRpbWU7XG4gICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpc0FyZywgYXJncyk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGxlYWRpbmdFZGdlKHRpbWUpIHtcbiAgICAgICAgLy8gUmVzZXQgYW55IGBtYXhXYWl0YCB0aW1lci5cbiAgICAgICAgbGFzdEludm9rZVRpbWUgPSB0aW1lO1xuICAgICAgICAvLyBTdGFydCB0aGUgdGltZXIgZm9yIHRoZSB0cmFpbGluZyBlZGdlLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICAvLyBJbnZva2UgdGhlIGxlYWRpbmcgZWRnZS5cbiAgICAgICAgcmV0dXJuIGxlYWRpbmcgPyBpbnZva2VGdW5jKHRpbWUpIDogcmVzdWx0O1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiByZW1haW5pbmdXYWl0KHRpbWUpIHtcbiAgICAgICAgdmFyIHRpbWVTaW5jZUxhc3RDYWxsID0gdGltZSAtIGxhc3RDYWxsVGltZSxcbiAgICAgICAgICAgIHRpbWVTaW5jZUxhc3RJbnZva2UgPSB0aW1lIC0gbGFzdEludm9rZVRpbWUsXG4gICAgICAgICAgICB0aW1lV2FpdGluZyA9IHdhaXQgLSB0aW1lU2luY2VMYXN0Q2FsbDtcblxuICAgICAgICByZXR1cm4gbWF4aW5nXG4gICAgICAgICAgPyBuYXRpdmVNaW4odGltZVdhaXRpbmcsIG1heFdhaXQgLSB0aW1lU2luY2VMYXN0SW52b2tlKVxuICAgICAgICAgIDogdGltZVdhaXRpbmc7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHNob3VsZEludm9rZSh0aW1lKSB7XG4gICAgICAgIHZhciB0aW1lU2luY2VMYXN0Q2FsbCA9IHRpbWUgLSBsYXN0Q2FsbFRpbWUsXG4gICAgICAgICAgICB0aW1lU2luY2VMYXN0SW52b2tlID0gdGltZSAtIGxhc3RJbnZva2VUaW1lO1xuXG4gICAgICAgIC8vIEVpdGhlciB0aGlzIGlzIHRoZSBmaXJzdCBjYWxsLCBhY3Rpdml0eSBoYXMgc3RvcHBlZCBhbmQgd2UncmUgYXQgdGhlXG4gICAgICAgIC8vIHRyYWlsaW5nIGVkZ2UsIHRoZSBzeXN0ZW0gdGltZSBoYXMgZ29uZSBiYWNrd2FyZHMgYW5kIHdlJ3JlIHRyZWF0aW5nXG4gICAgICAgIC8vIGl0IGFzIHRoZSB0cmFpbGluZyBlZGdlLCBvciB3ZSd2ZSBoaXQgdGhlIGBtYXhXYWl0YCBsaW1pdC5cbiAgICAgICAgcmV0dXJuIChsYXN0Q2FsbFRpbWUgPT09IHVuZGVmaW5lZCB8fCAodGltZVNpbmNlTGFzdENhbGwgPj0gd2FpdCkgfHxcbiAgICAgICAgICAodGltZVNpbmNlTGFzdENhbGwgPCAwKSB8fCAobWF4aW5nICYmIHRpbWVTaW5jZUxhc3RJbnZva2UgPj0gbWF4V2FpdCkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0aW1lckV4cGlyZWQoKSB7XG4gICAgICAgIHZhciB0aW1lID0gbm93KCk7XG4gICAgICAgIGlmIChzaG91bGRJbnZva2UodGltZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJhaWxpbmdFZGdlKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyLlxuICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHJlbWFpbmluZ1dhaXQodGltZSkpO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiB0cmFpbGluZ0VkZ2UodGltZSkge1xuICAgICAgICB0aW1lcklkID0gdW5kZWZpbmVkO1xuXG4gICAgICAgIC8vIE9ubHkgaW52b2tlIGlmIHdlIGhhdmUgYGxhc3RBcmdzYCB3aGljaCBtZWFucyBgZnVuY2AgaGFzIGJlZW5cbiAgICAgICAgLy8gZGVib3VuY2VkIGF0IGxlYXN0IG9uY2UuXG4gICAgICAgIGlmICh0cmFpbGluZyAmJiBsYXN0QXJncykge1xuICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKHRpbWUpO1xuICAgICAgICB9XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdFRoaXMgPSB1bmRlZmluZWQ7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGNhbmNlbCgpIHtcbiAgICAgICAgaWYgKHRpbWVySWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcklkKTtcbiAgICAgICAgfVxuICAgICAgICBsYXN0SW52b2tlVGltZSA9IDA7XG4gICAgICAgIGxhc3RBcmdzID0gbGFzdENhbGxUaW1lID0gbGFzdFRoaXMgPSB0aW1lcklkID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgICBmdW5jdGlvbiBmbHVzaCgpIHtcbiAgICAgICAgcmV0dXJuIHRpbWVySWQgPT09IHVuZGVmaW5lZCA/IHJlc3VsdCA6IHRyYWlsaW5nRWRnZShub3coKSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIGRlYm91bmNlZCgpIHtcbiAgICAgICAgdmFyIHRpbWUgPSBub3coKSxcbiAgICAgICAgICAgIGlzSW52b2tpbmcgPSBzaG91bGRJbnZva2UodGltZSk7XG5cbiAgICAgICAgbGFzdEFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICAgIGxhc3RUaGlzID0gdGhpcztcbiAgICAgICAgbGFzdENhbGxUaW1lID0gdGltZTtcblxuICAgICAgICBpZiAoaXNJbnZva2luZykge1xuICAgICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBsZWFkaW5nRWRnZShsYXN0Q2FsbFRpbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWF4aW5nKSB7XG4gICAgICAgICAgICAvLyBIYW5kbGUgaW52b2NhdGlvbnMgaW4gYSB0aWdodCBsb29wLlxuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVySWQpO1xuICAgICAgICAgICAgdGltZXJJZCA9IHNldFRpbWVvdXQodGltZXJFeHBpcmVkLCB3YWl0KTtcbiAgICAgICAgICAgIHJldHVybiBpbnZva2VGdW5jKGxhc3RDYWxsVGltZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aW1lcklkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB0aW1lcklkID0gc2V0VGltZW91dCh0aW1lckV4cGlyZWQsIHdhaXQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICBkZWJvdW5jZWQuY2FuY2VsID0gY2FuY2VsO1xuICAgICAgZGVib3VuY2VkLmZsdXNoID0gZmx1c2g7XG4gICAgICByZXR1cm4gZGVib3VuY2VkO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIERlZmVycyBpbnZva2luZyB0aGUgYGZ1bmNgIHVudGlsIHRoZSBjdXJyZW50IGNhbGwgc3RhY2sgaGFzIGNsZWFyZWQuIEFueVxuICAgICAqIGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWZlci5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZlcihmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAnZGVmZXJyZWQnKTtcbiAgICAgKiAvLyA9PiBMb2dzICdkZWZlcnJlZCcgYWZ0ZXIgb25lIG1pbGxpc2Vjb25kLlxuICAgICAqL1xuICAgIHZhciBkZWZlciA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBiYXNlRGVsYXkoZnVuYywgMSwgYXJncyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBJbnZva2VzIGBmdW5jYCBhZnRlciBgd2FpdGAgbWlsbGlzZWNvbmRzLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gYGZ1bmNgIHdoZW4gaXQncyBpbnZva2VkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVsYXkuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgaW52b2NhdGlvbi5cbiAgICAgKiBAcGFyYW0gey4uLip9IFthcmdzXSBUaGUgYXJndW1lbnRzIHRvIGludm9rZSBgZnVuY2Agd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSB0aW1lciBpZC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWxheShmdW5jdGlvbih0ZXh0KSB7XG4gICAgICogICBjb25zb2xlLmxvZyh0ZXh0KTtcbiAgICAgKiB9LCAxMDAwLCAnbGF0ZXInKTtcbiAgICAgKiAvLyA9PiBMb2dzICdsYXRlcicgYWZ0ZXIgb25lIHNlY29uZC5cbiAgICAgKi9cbiAgICB2YXIgZGVsYXkgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCB3YWl0LCBhcmdzKSB7XG4gICAgICByZXR1cm4gYmFzZURlbGF5KGZ1bmMsIHRvTnVtYmVyKHdhaXQpIHx8IDAsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgcmV2ZXJzZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBmbGlwIGFyZ3VtZW50cyBmb3IuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZmxpcHBlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZsaXBwZWQgPSBfLmZsaXAoZnVuY3Rpb24oKSB7XG4gICAgICogICByZXR1cm4gXy50b0FycmF5KGFyZ3VtZW50cyk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBmbGlwcGVkKCdhJywgJ2InLCAnYycsICdkJyk7XG4gICAgICogLy8gPT4gWydkJywgJ2MnLCAnYicsICdhJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmbGlwKGZ1bmMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfRkxJUF9GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBtZW1vaXplcyB0aGUgcmVzdWx0IG9mIGBmdW5jYC4gSWYgYHJlc29sdmVyYCBpc1xuICAgICAqIHByb3ZpZGVkLCBpdCBkZXRlcm1pbmVzIHRoZSBjYWNoZSBrZXkgZm9yIHN0b3JpbmcgdGhlIHJlc3VsdCBiYXNlZCBvbiB0aGVcbiAgICAgKiBhcmd1bWVudHMgcHJvdmlkZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3QgYXJndW1lbnRcbiAgICAgKiBwcm92aWRlZCB0byB0aGUgbWVtb2l6ZWQgZnVuY3Rpb24gaXMgdXNlZCBhcyB0aGUgbWFwIGNhY2hlIGtleS4gVGhlIGBmdW5jYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjYWNoZSBpcyBleHBvc2VkIGFzIHRoZSBgY2FjaGVgIHByb3BlcnR5IG9uIHRoZSBtZW1vaXplZFxuICAgICAqIGZ1bmN0aW9uLiBJdHMgY3JlYXRpb24gbWF5IGJlIGN1c3RvbWl6ZWQgYnkgcmVwbGFjaW5nIHRoZSBgXy5tZW1vaXplLkNhY2hlYFxuICAgICAqIGNvbnN0cnVjdG9yIHdpdGggb25lIHdob3NlIGluc3RhbmNlcyBpbXBsZW1lbnQgdGhlXG4gICAgICogW2BNYXBgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1wcm9wZXJ0aWVzLW9mLXRoZS1tYXAtcHJvdG90eXBlLW9iamVjdClcbiAgICAgKiBtZXRob2QgaW50ZXJmYWNlIG9mIGBjbGVhcmAsIGBkZWxldGVgLCBgZ2V0YCwgYGhhc2AsIGFuZCBgc2V0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGhhdmUgaXRzIG91dHB1dCBtZW1vaXplZC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIFRoZSBmdW5jdGlvbiB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbWVtb2l6ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyIH07XG4gICAgICogdmFyIG90aGVyID0geyAnYyc6IDMsICdkJzogNCB9O1xuICAgICAqXG4gICAgICogdmFyIHZhbHVlcyA9IF8ubWVtb2l6ZShfLnZhbHVlcyk7XG4gICAgICogdmFsdWVzKG9iamVjdCk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiB2YWx1ZXMob3RoZXIpO1xuICAgICAqIC8vID0+IFszLCA0XVxuICAgICAqXG4gICAgICogb2JqZWN0LmEgPSAyO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsxLCAyXVxuICAgICAqXG4gICAgICogLy8gTW9kaWZ5IHRoZSByZXN1bHQgY2FjaGUuXG4gICAgICogdmFsdWVzLmNhY2hlLnNldChvYmplY3QsIFsnYScsICdiJ10pO1xuICAgICAqIHZhbHVlcyhvYmplY3QpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKlxuICAgICAqIC8vIFJlcGxhY2UgYF8ubWVtb2l6ZS5DYWNoZWAuXG4gICAgICogXy5tZW1vaXplLkNhY2hlID0gV2Vha01hcDtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtZW1vaXplKGZ1bmMsIHJlc29sdmVyKSB7XG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJyB8fCAocmVzb2x2ZXIgIT0gbnVsbCAmJiB0eXBlb2YgcmVzb2x2ZXIgIT0gJ2Z1bmN0aW9uJykpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgdmFyIG1lbW9pemVkID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgICAga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmdzKSA6IGFyZ3NbMF0sXG4gICAgICAgICAgICBjYWNoZSA9IG1lbW9pemVkLmNhY2hlO1xuXG4gICAgICAgIGlmIChjYWNoZS5oYXMoa2V5KSkge1xuICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICAgICAgbWVtb2l6ZWQuY2FjaGUgPSBjYWNoZS5zZXQoa2V5LCByZXN1bHQpIHx8IGNhY2hlO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIG1lbW9pemVkLmNhY2hlID0gbmV3IChtZW1vaXplLkNhY2hlIHx8IE1hcENhY2hlKTtcbiAgICAgIHJldHVybiBtZW1vaXplZDtcbiAgICB9XG5cbiAgICAvLyBFeHBvc2UgYE1hcENhY2hlYC5cbiAgICBtZW1vaXplLkNhY2hlID0gTWFwQ2FjaGU7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBuZWdhdGVzIHRoZSByZXN1bHQgb2YgdGhlIHByZWRpY2F0ZSBgZnVuY2AuIFRoZVxuICAgICAqIGBmdW5jYCBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBhbmQgYXJndW1lbnRzIG9mIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBwcmVkaWNhdGUgVGhlIHByZWRpY2F0ZSB0byBuZWdhdGUuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgbmVnYXRlZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNFdmVuKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgXy5uZWdhdGUoaXNFdmVuKSk7XG4gICAgICogLy8gPT4gWzEsIDMsIDVdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbmVnYXRlKHByZWRpY2F0ZSkge1xuICAgICAgaWYgKHR5cGVvZiBwcmVkaWNhdGUgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAwOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMpO1xuICAgICAgICAgIGNhc2UgMTogcmV0dXJuICFwcmVkaWNhdGUuY2FsbCh0aGlzLCBhcmdzWzBdKTtcbiAgICAgICAgICBjYXNlIDI6IHJldHVybiAhcHJlZGljYXRlLmNhbGwodGhpcywgYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgY2FzZSAzOiByZXR1cm4gIXByZWRpY2F0ZS5jYWxsKHRoaXMsIGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICAgICAgfTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpcyByZXN0cmljdGVkIHRvIGludm9raW5nIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHNcbiAgICAgKiB0byB0aGUgZnVuY3Rpb24gcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgaW52b2NhdGlvbi4gVGhlIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgYW5kIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHJlc3RyaWN0ZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBpbml0aWFsaXplID0gXy5vbmNlKGNyZWF0ZUFwcGxpY2F0aW9uKTtcbiAgICAgKiBpbml0aWFsaXplKCk7XG4gICAgICogaW5pdGlhbGl6ZSgpO1xuICAgICAqIC8vID0+IGBjcmVhdGVBcHBsaWNhdGlvbmAgaXMgaW52b2tlZCBvbmNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gb25jZShmdW5jKSB7XG4gICAgICByZXR1cm4gYmVmb3JlKDIsIGZ1bmMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggaXRzIGFyZ3VtZW50cyB0cmFuc2Zvcm1lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFt0cmFuc2Zvcm1zPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGFyZ3VtZW50IHRyYW5zZm9ybXMuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGRvdWJsZWQobikge1xuICAgICAqICAgcmV0dXJuIG4gKiAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHNxdWFyZShuKSB7XG4gICAgICogICByZXR1cm4gbiAqIG47XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJBcmdzKGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgKiAgIHJldHVybiBbeCwgeV07XG4gICAgICogfSwgW3NxdWFyZSwgZG91YmxlZF0pO1xuICAgICAqXG4gICAgICogZnVuYyg5LCAzKTtcbiAgICAgKiAvLyA9PiBbODEsIDZdXG4gICAgICpcbiAgICAgKiBmdW5jKDEwLCA1KTtcbiAgICAgKiAvLyA9PiBbMTAwLCAxMF1cbiAgICAgKi9cbiAgICB2YXIgb3ZlckFyZ3MgPSBjYXN0UmVzdChmdW5jdGlvbihmdW5jLCB0cmFuc2Zvcm1zKSB7XG4gICAgICB0cmFuc2Zvcm1zID0gKHRyYW5zZm9ybXMubGVuZ3RoID09IDEgJiYgaXNBcnJheSh0cmFuc2Zvcm1zWzBdKSlcbiAgICAgICAgPyBhcnJheU1hcCh0cmFuc2Zvcm1zWzBdLCBiYXNlVW5hcnkoZ2V0SXRlcmF0ZWUoKSkpXG4gICAgICAgIDogYXJyYXlNYXAoYmFzZUZsYXR0ZW4odHJhbnNmb3JtcywgMSksIGJhc2VVbmFyeShnZXRJdGVyYXRlZSgpKSk7XG5cbiAgICAgIHZhciBmdW5jc0xlbmd0aCA9IHRyYW5zZm9ybXMubGVuZ3RoO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4oYXJncy5sZW5ndGgsIGZ1bmNzTGVuZ3RoKTtcblxuICAgICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICAgIGFyZ3NbaW5kZXhdID0gdHJhbnNmb3Jtc1tpbmRleF0uY2FsbCh0aGlzLCBhcmdzW2luZGV4XSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIGFyZ3MpO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIGBwYXJ0aWFsc2AgcHJlcGVuZGVkIHRvIHRoZVxuICAgICAqIGFyZ3VtZW50cyBpdCByZWNlaXZlcy4gVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5iaW5kYCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqXG4gICAgICogYWx0ZXIgdGhlIGB0aGlzYCBiaW5kaW5nLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWwucGxhY2Vob2xkZXJgIHZhbHVlLCB3aGljaCBkZWZhdWx0cyB0byBgX2AgaW4gbW9ub2xpdGhpY1xuICAgICAqIGJ1aWxkcywgbWF5IGJlIHVzZWQgYXMgYSBwbGFjZWhvbGRlciBmb3IgcGFydGlhbGx5IGFwcGxpZWQgYXJndW1lbnRzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIHBhcnRpYWxseVxuICAgICAqIGFwcGxpZWQgZnVuY3Rpb25zLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMi4wXG4gICAgICogQGNhdGVnb3J5IEZ1bmN0aW9uXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gcGFydGlhbGx5IGFwcGx5IGFyZ3VtZW50cyB0by5cbiAgICAgKiBAcGFyYW0gey4uLip9IFtwYXJ0aWFsc10gVGhlIGFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXJ0aWFsbHkgYXBwbGllZCBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gZ3JlZXQoZ3JlZXRpbmcsIG5hbWUpIHtcbiAgICAgKiAgIHJldHVybiBncmVldGluZyArICcgJyArIG5hbWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWwoZ3JlZXQsICdoZWxsbycpO1xuICAgICAqIHNheUhlbGxvVG8oJ2ZyZWQnKTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFBhcnRpYWxseSBhcHBsaWVkIHdpdGggcGxhY2Vob2xkZXJzLlxuICAgICAqIHZhciBncmVldEZyZWQgPSBfLnBhcnRpYWwoZ3JlZXQsIF8sICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsID0gYmFzZVJlc3QoZnVuY3Rpb24oZnVuYywgcGFydGlhbHMpIHtcbiAgICAgIHZhciBob2xkZXJzID0gcmVwbGFjZUhvbGRlcnMocGFydGlhbHMsIGdldEhvbGRlcihwYXJ0aWFsKSk7XG4gICAgICByZXR1cm4gY3JlYXRlV3JhcChmdW5jLCBXUkFQX1BBUlRJQUxfRkxBRywgdW5kZWZpbmVkLCBwYXJ0aWFscywgaG9sZGVycyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnBhcnRpYWxgIGV4Y2VwdCB0aGF0IHBhcnRpYWxseSBhcHBsaWVkIGFyZ3VtZW50c1xuICAgICAqIGFyZSBhcHBlbmRlZCB0byB0aGUgYXJndW1lbnRzIGl0IHJlY2VpdmVzLlxuICAgICAqXG4gICAgICogVGhlIGBfLnBhcnRpYWxSaWdodC5wbGFjZWhvbGRlcmAgdmFsdWUsIHdoaWNoIGRlZmF1bHRzIHRvIGBfYCBpbiBtb25vbGl0aGljXG4gICAgICogYnVpbGRzLCBtYXkgYmUgdXNlZCBhcyBhIHBsYWNlaG9sZGVyIGZvciBwYXJ0aWFsbHkgYXBwbGllZCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgZG9lc24ndCBzZXQgdGhlIFwibGVuZ3RoXCIgcHJvcGVydHkgb2YgcGFydGlhbGx5XG4gICAgICogYXBwbGllZCBmdW5jdGlvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBwYXJ0aWFsbHkgYXBwbHkgYXJndW1lbnRzIHRvLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW3BhcnRpYWxzXSBUaGUgYXJndW1lbnRzIHRvIGJlIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHBhcnRpYWxseSBhcHBsaWVkIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBncmVldChncmVldGluZywgbmFtZSkge1xuICAgICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJyAnICsgbmFtZTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgZ3JlZXRGcmVkID0gXy5wYXJ0aWFsUmlnaHQoZ3JlZXQsICdmcmVkJyk7XG4gICAgICogZ3JlZXRGcmVkKCdoaScpO1xuICAgICAqIC8vID0+ICdoaSBmcmVkJ1xuICAgICAqXG4gICAgICogLy8gUGFydGlhbGx5IGFwcGxpZWQgd2l0aCBwbGFjZWhvbGRlcnMuXG4gICAgICogdmFyIHNheUhlbGxvVG8gPSBfLnBhcnRpYWxSaWdodChncmVldCwgJ2hlbGxvJywgXyk7XG4gICAgICogc2F5SGVsbG9UbygnZnJlZCcpO1xuICAgICAqIC8vID0+ICdoZWxsbyBmcmVkJ1xuICAgICAqL1xuICAgIHZhciBwYXJ0aWFsUmlnaHQgPSBiYXNlUmVzdChmdW5jdGlvbihmdW5jLCBwYXJ0aWFscykge1xuICAgICAgdmFyIGhvbGRlcnMgPSByZXBsYWNlSG9sZGVycyhwYXJ0aWFscywgZ2V0SG9sZGVyKHBhcnRpYWxSaWdodCkpO1xuICAgICAgcmV0dXJuIGNyZWF0ZVdyYXAoZnVuYywgV1JBUF9QQVJUSUFMX1JJR0hUX0ZMQUcsIHVuZGVmaW5lZCwgcGFydGlhbHMsIGhvbGRlcnMpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBhcmd1bWVudHMgYXJyYW5nZWQgYWNjb3JkaW5nXG4gICAgICogdG8gdGhlIHNwZWNpZmllZCBgaW5kZXhlc2Agd2hlcmUgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBmaXJzdCBpbmRleCBpc1xuICAgICAqIHByb3ZpZGVkIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgdGhlIGFyZ3VtZW50IHZhbHVlIGF0IHRoZSBzZWNvbmQgaW5kZXggaXNcbiAgICAgKiBwcm92aWRlZCBhcyB0aGUgc2Vjb25kIGFyZ3VtZW50LCBhbmQgc28gb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byByZWFycmFuZ2UgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcGFyYW0gey4uLihudW1iZXJ8bnVtYmVyW10pfSBpbmRleGVzIFRoZSBhcnJhbmdlZCBhcmd1bWVudCBpbmRleGVzLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgcmVhcmdlZCA9IF8ucmVhcmcoZnVuY3Rpb24oYSwgYiwgYykge1xuICAgICAqICAgcmV0dXJuIFthLCBiLCBjXTtcbiAgICAgKiB9LCBbMiwgMCwgMV0pO1xuICAgICAqXG4gICAgICogcmVhcmdlZCgnYicsICdjJywgJ2EnKVxuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIHZhciByZWFyZyA9IGZsYXRSZXN0KGZ1bmN0aW9uKGZ1bmMsIGluZGV4ZXMpIHtcbiAgICAgIHJldHVybiBjcmVhdGVXcmFwKGZ1bmMsIFdSQVBfUkVBUkdfRkxBRywgdW5kZWZpbmVkLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgaW5kZXhlcyk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBmdW5jYCB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGVcbiAgICAgKiBjcmVhdGVkIGZ1bmN0aW9uIGFuZCBhcmd1bWVudHMgZnJvbSBgc3RhcnRgIGFuZCBiZXlvbmQgcHJvdmlkZWQgYXNcbiAgICAgKiBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvbiB0aGVcbiAgICAgKiBbcmVzdCBwYXJhbWV0ZXJdKGh0dHBzOi8vbWRuLmlvL3Jlc3RfcGFyYW1ldGVycykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBhcHBseSBhIHJlc3QgcGFyYW1ldGVyIHRvLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9ZnVuYy5sZW5ndGgtMV0gVGhlIHN0YXJ0IHBvc2l0aW9uIG9mIHRoZSByZXN0IHBhcmFtZXRlci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8ucmVzdChmdW5jdGlvbih3aGF0LCBuYW1lcykge1xuICAgICAqICAgcmV0dXJuIHdoYXQgKyAnICcgKyBfLmluaXRpYWwobmFtZXMpLmpvaW4oJywgJykgK1xuICAgICAqICAgICAoXy5zaXplKG5hbWVzKSA+IDEgPyAnLCAmICcgOiAnJykgKyBfLmxhc3QobmFtZXMpO1xuICAgICAqIH0pO1xuICAgICAqXG4gICAgICogc2F5KCdoZWxsbycsICdmcmVkJywgJ2Jhcm5leScsICdwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQsIGJhcm5leSwgJiBwZWJibGVzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3QoZnVuYywgc3RhcnQpIHtcbiAgICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoRlVOQ19FUlJPUl9URVhUKTtcbiAgICAgIH1cbiAgICAgIHN0YXJ0ID0gc3RhcnQgPT09IHVuZGVmaW5lZCA/IHN0YXJ0IDogdG9JbnRlZ2VyKHN0YXJ0KTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jLCBzdGFydCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAgICogY3JlYXRlIGZ1bmN0aW9uIGFuZCBhbiBhcnJheSBvZiBhcmd1bWVudHMgbXVjaCBsaWtlXG4gICAgICogW2BGdW5jdGlvbiNhcHBseWBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1mdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uIHRoZVxuICAgICAqIFtzcHJlYWQgb3BlcmF0b3JdKGh0dHBzOi8vbWRuLmlvL3NwcmVhZF9vcGVyYXRvcikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4yLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBzcHJlYWQgYXJndW1lbnRzIG92ZXIuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgcG9zaXRpb24gb2YgdGhlIHNwcmVhZC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHNheSA9IF8uc3ByZWFkKGZ1bmN0aW9uKHdobywgd2hhdCkge1xuICAgICAqICAgcmV0dXJuIHdobyArICcgc2F5cyAnICsgd2hhdDtcbiAgICAgKiB9KTtcbiAgICAgKlxuICAgICAqIHNheShbJ2ZyZWQnLCAnaGVsbG8nXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQgc2F5cyBoZWxsbydcbiAgICAgKlxuICAgICAqIHZhciBudW1iZXJzID0gUHJvbWlzZS5hbGwoW1xuICAgICAqICAgUHJvbWlzZS5yZXNvbHZlKDQwKSxcbiAgICAgKiAgIFByb21pc2UucmVzb2x2ZSgzNilcbiAgICAgKiBdKTtcbiAgICAgKlxuICAgICAqIG51bWJlcnMudGhlbihfLnNwcmVhZChmdW5jdGlvbih4LCB5KSB7XG4gICAgICogICByZXR1cm4geCArIHk7XG4gICAgICogfSkpO1xuICAgICAqIC8vID0+IGEgUHJvbWlzZSBvZiA3NlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNwcmVhZChmdW5jLCBzdGFydCkge1xuICAgICAgaWYgKHR5cGVvZiBmdW5jICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgfVxuICAgICAgc3RhcnQgPSBzdGFydCA9PSBudWxsID8gMCA6IG5hdGl2ZU1heCh0b0ludGVnZXIoc3RhcnQpLCAwKTtcbiAgICAgIHJldHVybiBiYXNlUmVzdChmdW5jdGlvbihhcmdzKSB7XG4gICAgICAgIHZhciBhcnJheSA9IGFyZ3Nbc3RhcnRdLFxuICAgICAgICAgICAgb3RoZXJBcmdzID0gY2FzdFNsaWNlKGFyZ3MsIDAsIHN0YXJ0KTtcblxuICAgICAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgICBhcnJheVB1c2gob3RoZXJBcmdzLCBhcnJheSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGFwcGx5KGZ1bmMsIHRoaXMsIG90aGVyQXJncyk7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgdGhyb3R0bGVkIGZ1bmN0aW9uIHRoYXQgb25seSBpbnZva2VzIGBmdW5jYCBhdCBtb3N0IG9uY2UgcGVyXG4gICAgICogZXZlcnkgYHdhaXRgIG1pbGxpc2Vjb25kcy4gVGhlIHRocm90dGxlZCBmdW5jdGlvbiBjb21lcyB3aXRoIGEgYGNhbmNlbGBcbiAgICAgKiBtZXRob2QgdG8gY2FuY2VsIGRlbGF5ZWQgYGZ1bmNgIGludm9jYXRpb25zIGFuZCBhIGBmbHVzaGAgbWV0aG9kIHRvXG4gICAgICogaW1tZWRpYXRlbHkgaW52b2tlIHRoZW0uIFByb3ZpZGUgYG9wdGlvbnNgIHRvIGluZGljYXRlIHdoZXRoZXIgYGZ1bmNgXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIGB3YWl0YFxuICAgICAqIHRpbWVvdXQuIFRoZSBgZnVuY2AgaXMgaW52b2tlZCB3aXRoIHRoZSBsYXN0IGFyZ3VtZW50cyBwcm92aWRlZCB0byB0aGVcbiAgICAgKiB0aHJvdHRsZWQgZnVuY3Rpb24uIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZCBmdW5jdGlvbiByZXR1cm4gdGhlXG4gICAgICogcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBpbnZvY2F0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIElmIGBsZWFkaW5nYCBhbmQgYHRyYWlsaW5nYCBvcHRpb25zIGFyZSBgdHJ1ZWAsIGBmdW5jYCBpc1xuICAgICAqIGludm9rZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQgb25seSBpZiB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uXG4gICAgICogaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIGB3YWl0YCB0aW1lb3V0LlxuICAgICAqXG4gICAgICogSWYgYHdhaXRgIGlzIGAwYCBhbmQgYGxlYWRpbmdgIGlzIGBmYWxzZWAsIGBmdW5jYCBpbnZvY2F0aW9uIGlzIGRlZmVycmVkXG4gICAgICogdW50aWwgdG8gdGhlIG5leHQgdGljaywgc2ltaWxhciB0byBgc2V0VGltZW91dGAgd2l0aCBhIHRpbWVvdXQgb2YgYDBgLlxuICAgICAqXG4gICAgICogU2VlIFtEYXZpZCBDb3JiYWNobydzIGFydGljbGVdKGh0dHBzOi8vY3NzLXRyaWNrcy5jb20vZGVib3VuY2luZy10aHJvdHRsaW5nLWV4cGxhaW5lZC1leGFtcGxlcy8pXG4gICAgICogZm9yIGRldGFpbHMgb3ZlciB0aGUgZGlmZmVyZW5jZXMgYmV0d2VlbiBgXy50aHJvdHRsZWAgYW5kIGBfLmRlYm91bmNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBGdW5jdGlvblxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHRocm90dGxlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbd2FpdD0wXSBUaGUgbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB0aHJvdHRsZSBpbnZvY2F0aW9ucyB0by5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRpb25zLmxlYWRpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgbGVhZGluZyBlZGdlIG9mIHRoZSB0aW1lb3V0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMudHJhaWxpbmc9dHJ1ZV1cbiAgICAgKiAgU3BlY2lmeSBpbnZva2luZyBvbiB0aGUgdHJhaWxpbmcgZWRnZSBvZiB0aGUgdGltZW91dC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyB0aHJvdHRsZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIC8vIEF2b2lkIGV4Y2Vzc2l2ZWx5IHVwZGF0aW5nIHRoZSBwb3NpdGlvbiB3aGlsZSBzY3JvbGxpbmcuXG4gICAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Njcm9sbCcsIF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCkpO1xuICAgICAqXG4gICAgICogLy8gSW52b2tlIGByZW5ld1Rva2VuYCB3aGVuIHRoZSBjbGljayBldmVudCBpcyBmaXJlZCwgYnV0IG5vdCBtb3JlIHRoYW4gb25jZSBldmVyeSA1IG1pbnV0ZXMuXG4gICAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUocmVuZXdUb2tlbiwgMzAwMDAwLCB7ICd0cmFpbGluZyc6IGZhbHNlIH0pO1xuICAgICAqIGpRdWVyeShlbGVtZW50KS5vbignY2xpY2snLCB0aHJvdHRsZWQpO1xuICAgICAqXG4gICAgICogLy8gQ2FuY2VsIHRoZSB0cmFpbGluZyB0aHJvdHRsZWQgaW52b2NhdGlvbi5cbiAgICAgKiBqUXVlcnkod2luZG93KS5vbigncG9wc3RhdGUnLCB0aHJvdHRsZWQuY2FuY2VsKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0aHJvdHRsZShmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVhZGluZyA9IHRydWUsXG4gICAgICAgICAgdHJhaWxpbmcgPSB0cnVlO1xuXG4gICAgICBpZiAodHlwZW9mIGZ1bmMgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKEZVTkNfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgbGVhZGluZyA9ICdsZWFkaW5nJyBpbiBvcHRpb25zID8gISFvcHRpb25zLmxlYWRpbmcgOiBsZWFkaW5nO1xuICAgICAgICB0cmFpbGluZyA9ICd0cmFpbGluZycgaW4gb3B0aW9ucyA/ICEhb3B0aW9ucy50cmFpbGluZyA6IHRyYWlsaW5nO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGRlYm91bmNlKGZ1bmMsIHdhaXQsIHtcbiAgICAgICAgJ2xlYWRpbmcnOiBsZWFkaW5nLFxuICAgICAgICAnbWF4V2FpdCc6IHdhaXQsXG4gICAgICAgICd0cmFpbGluZyc6IHRyYWlsaW5nXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBhY2NlcHRzIHVwIHRvIG9uZSBhcmd1bWVudCwgaWdub3JpbmcgYW55XG4gICAgICogYWRkaXRpb25hbCBhcmd1bWVudHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBjYXAgYXJndW1lbnRzIGZvci5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjYXBwZWQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICc4JywgJzEwJ10sIF8udW5hcnkocGFyc2VJbnQpKTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdW5hcnkoZnVuYykge1xuICAgICAgcmV0dXJuIGFyeShmdW5jLCAxKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwcm92aWRlcyBgdmFsdWVgIHRvIGB3cmFwcGVyYCBhcyBpdHMgZmlyc3RcbiAgICAgKiBhcmd1bWVudC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIHByb3ZpZGVkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICAgKiB0byB0aG9zZSBwcm92aWRlZCB0byB0aGUgYHdyYXBwZXJgLiBUaGUgd3JhcHBlciBpcyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYFxuICAgICAqIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25cbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byB3cmFwLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFt3cmFwcGVyPWlkZW50aXR5XSBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHAgPSBfLndyYXAoXy5lc2NhcGUsIGZ1bmN0aW9uKGZ1bmMsIHRleHQpIHtcbiAgICAgKiAgIHJldHVybiAnPHA+JyArIGZ1bmModGV4dCkgKyAnPC9wPic7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBwKCdmcmVkLCBiYXJuZXksICYgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICc8cD5mcmVkLCBiYXJuZXksICZhbXA7IHBlYmJsZXM8L3A+J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICAgIHJldHVybiBwYXJ0aWFsKGNhc3RGdW5jdGlvbih3cmFwcGVyKSwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIENhc3RzIGB2YWx1ZWAgYXMgYW4gYXJyYXkgaWYgaXQncyBub3Qgb25lLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgY2FzdCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYXN0QXJyYXkoMSk7XG4gICAgICogLy8gPT4gWzFdXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheSh7ICdhJzogMSB9KTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEgfV1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBbJ2FiYyddXG4gICAgICpcbiAgICAgKiBfLmNhc3RBcnJheShudWxsKTtcbiAgICAgKiAvLyA9PiBbbnVsbF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gW3VuZGVmaW5lZF1cbiAgICAgKlxuICAgICAqIF8uY2FzdEFycmF5KCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsxLCAyLCAzXTtcbiAgICAgKiBjb25zb2xlLmxvZyhfLmNhc3RBcnJheShhcnJheSkgPT09IGFycmF5KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2FzdEFycmF5KCkge1xuICAgICAgaWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIHZhciB2YWx1ZSA9IGFyZ3VtZW50c1swXTtcbiAgICAgIHJldHVybiBpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgdmFsdWVgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb24gdGhlXG4gICAgICogW3N0cnVjdHVyZWQgY2xvbmUgYWxnb3JpdGhtXShodHRwczovL21kbi5pby9TdHJ1Y3R1cmVkX2Nsb25lX2FsZ29yaXRobSlcbiAgICAgKiBhbmQgc3VwcG9ydHMgY2xvbmluZyBhcnJheXMsIGFycmF5IGJ1ZmZlcnMsIGJvb2xlYW5zLCBkYXRlIG9iamVjdHMsIG1hcHMsXG4gICAgICogbnVtYmVycywgYE9iamVjdGAgb2JqZWN0cywgcmVnZXhlcywgc2V0cywgc3RyaW5ncywgc3ltYm9scywgYW5kIHR5cGVkXG4gICAgICogYXJyYXlzLiBUaGUgb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiBgYXJndW1lbnRzYCBvYmplY3RzIGFyZSBjbG9uZWRcbiAgICAgKiBhcyBwbGFpbiBvYmplY3RzLiBBbiBlbXB0eSBvYmplY3QgaXMgcmV0dXJuZWQgZm9yIHVuY2xvbmVhYmxlIHZhbHVlcyBzdWNoXG4gICAgICogYXMgZXJyb3Igb2JqZWN0cywgZnVuY3Rpb25zLCBET00gbm9kZXMsIGFuZCBXZWFrTWFwcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2xvbmUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIHNoYWxsb3cgPSBfLmNsb25lKG9iamVjdHMpO1xuICAgICAqIGNvbnNvbGUubG9nKHNoYWxsb3dbMF0gPT09IG9iamVjdHNbMF0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgY2xvbmVkIHZhbHVlLiBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYCxcbiAgICAgKiBjbG9uaW5nIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aFxuICAgICAqIHVwIHRvIGZvdXIgYXJndW1lbnRzOyAodmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIHN0YWNrXSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGNsb25lZCB2YWx1ZS5cbiAgICAgKiBAc2VlIF8uY2xvbmVEZWVwV2l0aFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKHZhbHVlKSB7XG4gICAgICogICBpZiAoXy5pc0VsZW1lbnQodmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB2YWx1ZS5jbG9uZU5vZGUoZmFsc2UpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVXaXRoKGRvY3VtZW50LmJvZHksIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coZWwgPT09IGRvY3VtZW50LmJvZHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICogY29uc29sZS5sb2coZWwubm9kZU5hbWUpO1xuICAgICAqIC8vID0+ICdCT0RZJ1xuICAgICAqIGNvbnNvbGUubG9nKGVsLmNoaWxkTm9kZXMubGVuZ3RoKTtcbiAgICAgKiAvLyA9PiAwXG4gICAgICovXG4gICAgZnVuY3Rpb24gY2xvbmVXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uY2xvbmVgIGV4Y2VwdCB0aGF0IGl0IHJlY3Vyc2l2ZWx5IGNsb25lcyBgdmFsdWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byByZWN1cnNpdmVseSBjbG9uZS5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgZGVlcCBjbG9uZWQgdmFsdWUuXG4gICAgICogQHNlZSBfLmNsb25lXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ2EnOiAxIH0sIHsgJ2InOiAyIH1dO1xuICAgICAqXG4gICAgICogdmFyIGRlZXAgPSBfLmNsb25lRGVlcChvYmplY3RzKTtcbiAgICAgKiBjb25zb2xlLmxvZyhkZWVwWzBdID09PSBvYmplY3RzWzBdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsb25lRGVlcCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIGJhc2VDbG9uZSh2YWx1ZSwgQ0xPTkVfREVFUF9GTEFHIHwgQ0xPTkVfU1lNQk9MU19GTEFHKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmNsb25lV2l0aGAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgY2xvbmVzIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJlY3Vyc2l2ZWx5IGNsb25lLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGNsb25pbmcuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGRlZXAgY2xvbmVkIHZhbHVlLlxuICAgICAqIEBzZWUgXy5jbG9uZVdpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcih2YWx1ZSkge1xuICAgICAqICAgaWYgKF8uaXNFbGVtZW50KHZhbHVlKSkge1xuICAgICAqICAgICByZXR1cm4gdmFsdWUuY2xvbmVOb2RlKHRydWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBlbCA9IF8uY2xvbmVEZWVwV2l0aChkb2N1bWVudC5ib2R5LCBjdXN0b21pemVyKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKGVsID09PSBkb2N1bWVudC5ib2R5KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqIGNvbnNvbGUubG9nKGVsLm5vZGVOYW1lKTtcbiAgICAgKiAvLyA9PiAnQk9EWSdcbiAgICAgKiBjb25zb2xlLmxvZyhlbC5jaGlsZE5vZGVzLmxlbmd0aCk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjbG9uZURlZXBXaXRoKHZhbHVlLCBjdXN0b21pemVyKSB7XG4gICAgICBjdXN0b21pemVyID0gdHlwZW9mIGN1c3RvbWl6ZXIgPT0gJ2Z1bmN0aW9uJyA/IGN1c3RvbWl6ZXIgOiB1bmRlZmluZWQ7XG4gICAgICByZXR1cm4gYmFzZUNsb25lKHZhbHVlLCBDTE9ORV9ERUVQX0ZMQUcgfCBDTE9ORV9TWU1CT0xTX0ZMQUcsIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgb2JqZWN0YCBjb25mb3JtcyB0byBgc291cmNlYCBieSBpbnZva2luZyB0aGUgcHJlZGljYXRlXG4gICAgICogcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHZhbHVlcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBlcXVpdmFsZW50IHRvIGBfLmNvbmZvcm1zYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xNC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgb2JqZWN0YCBjb25mb3JtcywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogMiB9O1xuICAgICAqXG4gICAgICogXy5jb25mb3Jtc1RvKG9iamVjdCwgeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uY29uZm9ybXNUbyhvYmplY3QsIHsgJ2InOiBmdW5jdGlvbihuKSB7IHJldHVybiBuID4gMjsgfSB9KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zVG8ob2JqZWN0LCBzb3VyY2UpIHtcbiAgICAgIHJldHVybiBzb3VyY2UgPT0gbnVsbCB8fCBiYXNlQ29uZm9ybXNUbyhvYmplY3QsIHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQZXJmb3JtcyBhXG4gICAgICogW2BTYW1lVmFsdWVaZXJvYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtc2FtZXZhbHVlemVybylcbiAgICAgKiBjb21wYXJpc29uIGJldHdlZW4gdHdvIHZhbHVlcyB0byBkZXRlcm1pbmUgaWYgdGhleSBhcmUgZXF1aXZhbGVudC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb2JqZWN0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKG9iamVjdCwgb3RoZXIpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmVxKCdhJywgT2JqZWN0KCdhJykpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmVxKE5hTiwgTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXEodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG90aGVyIHx8ICh2YWx1ZSAhPT0gdmFsdWUgJiYgb3RoZXIgIT09IG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBncmVhdGVyIHRoYW4gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBgb3RoZXJgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmx0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3QoMywgMSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5ndCgzLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5ndCgxLCAzKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBndCA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oYmFzZUd0KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byBgb3RoZXJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgZ3JlYXRlciB0aGFuIG9yIGVxdWFsIHRvXG4gICAgICogIGBvdGhlcmAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAc2VlIF8ubHRlXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDMsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uZ3RlKDEsIDMpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGd0ZSA9IGNyZWF0ZVJlbGF0aW9uYWxPcGVyYXRpb24oZnVuY3Rpb24odmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPj0gb3RoZXI7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsaWtlbHkgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QsXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FyZ3VtZW50cyhmdW5jdGlvbigpIHsgcmV0dXJuIGFyZ3VtZW50czsgfSgpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJndW1lbnRzKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcmd1bWVudHMgPSBiYXNlSXNBcmd1bWVudHMoZnVuY3Rpb24oKSB7IHJldHVybiBhcmd1bWVudHM7IH0oKSkgPyBiYXNlSXNBcmd1bWVudHMgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmV0dXJuIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwgJ2NhbGxlZScpICYmXG4gICAgICAgICFwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHZhbHVlLCAnY2FsbGVlJyk7XG4gICAgfTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGFycmF5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheShkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5KF8ubm9vcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGFuIGBBcnJheUJ1ZmZlcmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheSBidWZmZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheUJ1ZmZlcigyKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5QnVmZmVyKG5ldyBBcnJheSgyKSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNBcnJheUJ1ZmZlciA9IG5vZGVJc0FycmF5QnVmZmVyID8gYmFzZVVuYXJ5KG5vZGVJc0FycmF5QnVmZmVyKSA6IGJhc2VJc0FycmF5QnVmZmVyO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYXJyYXktbGlrZS4gQSB2YWx1ZSBpcyBjb25zaWRlcmVkIGFycmF5LWxpa2UgaWYgaXQnc1xuICAgICAqIG5vdCBhIGZ1bmN0aW9uIGFuZCBoYXMgYSBgdmFsdWUubGVuZ3RoYCB0aGF0J3MgYW4gaW50ZWdlciBncmVhdGVyIHRoYW4gb3JcbiAgICAgKiBlcXVhbCB0byBgMGAgYW5kIGxlc3MgdGhhbiBvciBlcXVhbCB0byBgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhcnJheS1saWtlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlKGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNBcnJheUxpa2UoXy5ub29wKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzQXJyYXlMaWtlKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiBpc0xlbmd0aCh2YWx1ZS5sZW5ndGgpICYmICFpc0Z1bmN0aW9uKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzQXJyYXlMaWtlYCBleGNlcHQgdGhhdCBpdCBhbHNvIGNoZWNrcyBpZiBgdmFsdWVgXG4gICAgICogaXMgYW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBhcnJheS1saWtlIG9iamVjdCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChkb2N1bWVudC5ib2R5LmNoaWxkcmVuKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzQXJyYXlMaWtlT2JqZWN0KCdhYmMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc0FycmF5TGlrZU9iamVjdChfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNBcnJheUxpa2VPYmplY3QodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGlzQXJyYXlMaWtlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYm9vbGVhbiBwcmltaXRpdmUgb3Igb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJvb2xlYW4sIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Jvb2xlYW4oZmFsc2UpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHRydWUgfHwgdmFsdWUgPT09IGZhbHNlIHx8XG4gICAgICAgIChpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IGJvb2xUYWcpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgYnVmZmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMy4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGJ1ZmZlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzQnVmZmVyKG5ldyBCdWZmZXIoMikpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNCdWZmZXIobmV3IFVpbnQ4QXJyYXkoMikpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzQnVmZmVyID0gbmF0aXZlSXNCdWZmZXIgfHwgc3R1YkZhbHNlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBEYXRlYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgZGF0ZSBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0RhdGUobmV3IERhdGUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNEYXRlKCdNb24gQXByaWwgMjMgMjAxMicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgdmFyIGlzRGF0ZSA9IG5vZGVJc0RhdGUgPyBiYXNlVW5hcnkobm9kZUlzRGF0ZSkgOiBiYXNlSXNEYXRlO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGlrZWx5IGEgRE9NIGVsZW1lbnQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgRE9NIGVsZW1lbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoZG9jdW1lbnQuYm9keSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VsZW1lbnQoJzxib2R5PicpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFbGVtZW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gaXNPYmplY3RMaWtlKHZhbHVlKSAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMSAmJiAhaXNQbGFpbk9iamVjdCh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gZW1wdHkgb2JqZWN0LCBjb2xsZWN0aW9uLCBtYXAsIG9yIHNldC5cbiAgICAgKlxuICAgICAqIE9iamVjdHMgYXJlIGNvbnNpZGVyZWQgZW1wdHkgaWYgdGhleSBoYXZlIG5vIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZFxuICAgICAqIHByb3BlcnRpZXMuXG4gICAgICpcbiAgICAgKiBBcnJheS1saWtlIHZhbHVlcyBzdWNoIGFzIGBhcmd1bWVudHNgIG9iamVjdHMsIGFycmF5cywgYnVmZmVycywgc3RyaW5ncywgb3JcbiAgICAgKiBqUXVlcnktbGlrZSBjb2xsZWN0aW9ucyBhcmUgY29uc2lkZXJlZCBlbXB0eSBpZiB0aGV5IGhhdmUgYSBgbGVuZ3RoYCBvZiBgMGAuXG4gICAgICogU2ltaWxhcmx5LCBtYXBzIGFuZCBzZXRzIGFyZSBjb25zaWRlcmVkIGVtcHR5IGlmIHRoZXkgaGF2ZSBhIGBzaXplYCBvZiBgMGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGVtcHR5LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkodHJ1ZSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc0VtcHR5KDEpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNFbXB0eShbMSwgMiwgM10pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRW1wdHkoeyAnYSc6IDEgfSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VtcHR5KHZhbHVlKSB7XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiZcbiAgICAgICAgICAoaXNBcnJheSh2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZS5zcGxpY2UgPT0gJ2Z1bmN0aW9uJyB8fFxuICAgICAgICAgICAgaXNCdWZmZXIodmFsdWUpIHx8IGlzVHlwZWRBcnJheSh2YWx1ZSkgfHwgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gIXZhbHVlLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBnZXRUYWcodmFsdWUpO1xuICAgICAgaWYgKHRhZyA9PSBtYXBUYWcgfHwgdGFnID09IHNldFRhZykge1xuICAgICAgICByZXR1cm4gIXZhbHVlLnNpemU7XG4gICAgICB9XG4gICAgICBpZiAoaXNQcm90b3R5cGUodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiAhYmFzZUtleXModmFsdWUpLmxlbmd0aDtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbCh2YWx1ZSwga2V5KSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUGVyZm9ybXMgYSBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiB0d28gdmFsdWVzIHRvIGRldGVybWluZSBpZiB0aGV5IGFyZVxuICAgICAqIGVxdWl2YWxlbnQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2Qgc3VwcG9ydHMgY29tcGFyaW5nIGFycmF5cywgYXJyYXkgYnVmZmVycywgYm9vbGVhbnMsXG4gICAgICogZGF0ZSBvYmplY3RzLCBlcnJvciBvYmplY3RzLCBtYXBzLCBudW1iZXJzLCBgT2JqZWN0YCBvYmplY3RzLCByZWdleGVzLFxuICAgICAqIHNldHMsIHN0cmluZ3MsIHN5bWJvbHMsIGFuZCB0eXBlZCBhcnJheXMuIGBPYmplY3RgIG9iamVjdHMgYXJlIGNvbXBhcmVkXG4gICAgICogYnkgdGhlaXIgb3duLCBub3QgaW5oZXJpdGVkLCBlbnVtZXJhYmxlIHByb3BlcnRpZXMuIEZ1bmN0aW9ucyBhbmQgRE9NXG4gICAgICogbm9kZXMgYXJlIGNvbXBhcmVkIGJ5IHN0cmljdCBlcXVhbGl0eSwgaS5lLiBgPT09YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgdmFsdWVzIGFyZSBlcXVpdmFsZW50LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiAxIH07XG4gICAgICpcbiAgICAgKiBfLmlzRXF1YWwob2JqZWN0LCBvdGhlcik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogb2JqZWN0ID09PSBvdGhlcjtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzRXF1YWwodmFsdWUsIG90aGVyKSB7XG4gICAgICByZXR1cm4gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmlzRXF1YWxgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBjb21wYXJlIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIGNvbXBhcmlzb25zXG4gICAgICogYXJlIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWQgd2l0aCB1cCB0b1xuICAgICAqIHNpeCBhcmd1bWVudHM6IChvYmpWYWx1ZSwgb3RoVmFsdWUgWywgaW5kZXh8a2V5LCBvYmplY3QsIG90aGVyLCBzdGFja10pLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEBwYXJhbSB7Kn0gb3RoZXIgVGhlIG90aGVyIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBvdGhWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcob3RoVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IFsnaGVsbG8nLCAnZ29vZGJ5ZSddO1xuICAgICAqIHZhciBvdGhlciA9IFsnaGknLCAnZ29vZGJ5ZSddO1xuICAgICAqXG4gICAgICogXy5pc0VxdWFsV2l0aChhcnJheSwgb3RoZXIsIGN1c3RvbWl6ZXIpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0VxdWFsV2l0aCh2YWx1ZSwgb3RoZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHZhciByZXN1bHQgPSBjdXN0b21pemVyID8gY3VzdG9taXplcih2YWx1ZSwgb3RoZXIpIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdW5kZWZpbmVkID8gYmFzZUlzRXF1YWwodmFsdWUsIG90aGVyLCB1bmRlZmluZWQsIGN1c3RvbWl6ZXIpIDogISFyZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYEVycm9yYCwgYEV2YWxFcnJvcmAsIGBSYW5nZUVycm9yYCwgYFJlZmVyZW5jZUVycm9yYCxcbiAgICAgKiBgU3ludGF4RXJyb3JgLCBgVHlwZUVycm9yYCwgb3IgYFVSSUVycm9yYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGFuIGVycm9yIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IobmV3IEVycm9yKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRXJyb3IoRXJyb3IpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNFcnJvcih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZXJyb3JUYWcgfHwgdGFnID09IGRvbUV4Y1RhZyB8fFxuICAgICAgICAodHlwZW9mIHZhbHVlLm1lc3NhZ2UgPT0gJ3N0cmluZycgJiYgdHlwZW9mIHZhbHVlLm5hbWUgPT0gJ3N0cmluZycgJiYgIWlzUGxhaW5PYmplY3QodmFsdWUpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBwcmltaXRpdmUgbnVtYmVyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNGaW5pdGVgXShodHRwczovL21kbi5pby9OdW1iZXIvaXNGaW5pdGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc0Zpbml0ZSgzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNGaW5pdGUoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzRmluaXRlKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0Zpbml0ZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJiBuYXRpdmVJc0Zpbml0ZSh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBGdW5jdGlvbmAgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIGZ1bmN0aW9uLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNGdW5jdGlvbihfKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzRnVuY3Rpb24oL2FiYy8pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNGdW5jdGlvbih2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdCh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgLy8gVGhlIHVzZSBvZiBgT2JqZWN0I3RvU3RyaW5nYCBhdm9pZHMgaXNzdWVzIHdpdGggdGhlIGB0eXBlb2ZgIG9wZXJhdG9yXG4gICAgICAvLyBpbiBTYWZhcmkgOSB3aGljaCByZXR1cm5zICdvYmplY3QnIGZvciB0eXBlZCBhcnJheXMgYW5kIG90aGVyIGNvbnN0cnVjdG9ycy5cbiAgICAgIHZhciB0YWcgPSBiYXNlR2V0VGFnKHZhbHVlKTtcbiAgICAgIHJldHVybiB0YWcgPT0gZnVuY1RhZyB8fCB0YWcgPT0gZ2VuVGFnIHx8IHRhZyA9PSBhc3luY1RhZyB8fCB0YWcgPT0gcHJveHlUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gaW50ZWdlci5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgTnVtYmVyLmlzSW50ZWdlcmBdKGh0dHBzOi8vbWRuLmlvL051bWJlci9pc0ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhbiBpbnRlZ2VyLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNJbnRlZ2VyKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgJiYgdmFsdWUgPT0gdG9JbnRlZ2VyKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGFycmF5LWxpa2UgbGVuZ3RoLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvTGVuZ3RoYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtdG9sZW5ndGgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHZhbGlkIGxlbmd0aCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNMZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzTGVuZ3RoKCczJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJyAmJlxuICAgICAgICB2YWx1ZSA+IC0xICYmIHZhbHVlICUgMSA9PSAwICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgdGhlXG4gICAgICogW2xhbmd1YWdlIHR5cGVdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy1lY21hc2NyaXB0LWxhbmd1YWdlLXR5cGVzKVxuICAgICAqIG9mIGBPYmplY3RgLiAoZS5nLiBhcnJheXMsIGZ1bmN0aW9ucywgb2JqZWN0cywgcmVnZXhlcywgYG5ldyBOdW1iZXIoMClgLCBhbmQgYG5ldyBTdHJpbmcoJycpYClcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3Qoe30pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNPYmplY3QoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0KF8ubm9vcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAgIHJldHVybiB2YWx1ZSAhPSBudWxsICYmICh0eXBlID09ICdvYmplY3QnIHx8IHR5cGUgPT0gJ2Z1bmN0aW9uJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgb2JqZWN0LWxpa2UuIEEgdmFsdWUgaXMgb2JqZWN0LWxpa2UgaWYgaXQncyBub3QgYG51bGxgXG4gICAgICogYW5kIGhhcyBhIGB0eXBlb2ZgIHJlc3VsdCBvZiBcIm9iamVjdFwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZSh7fSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYSBgTWFwYCBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4zLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgbWFwLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgaXNNYXAgPSBub2RlSXNNYXAgPyBiYXNlVW5hcnkobm9kZUlzTWFwKSA6IGJhc2VJc01hcDtcblxuICAgIC8qKlxuICAgICAqIFBlcmZvcm1zIGEgcGFydGlhbCBkZWVwIGNvbXBhcmlzb24gYmV0d2VlbiBgb2JqZWN0YCBhbmQgYHNvdXJjZWAgdG9cbiAgICAgKiBkZXRlcm1pbmUgaWYgYG9iamVjdGAgY29udGFpbnMgZXF1aXZhbGVudCBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byBgXy5tYXRjaGVzYCB3aGVuIGBzb3VyY2VgIGlzXG4gICAgICogcGFydGlhbGx5IGFwcGxpZWQuXG4gICAgICpcbiAgICAgKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdCBgc291cmNlYFxuICAgICAqIHZhbHVlcyBhZ2FpbnN0IGFueSBhcnJheSBvciBvYmplY3QgdmFsdWUsIHJlc3BlY3RpdmVseS4gU2VlIGBfLmlzRXF1YWxgXG4gICAgICogZm9yIGEgbGlzdCBvZiBzdXBwb3J0ZWQgdmFsdWUgY29tcGFyaXNvbnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIgfTtcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAyIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNNYXRjaChvYmplY3QsIHsgJ2InOiAxIH0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaChvYmplY3QsIHNvdXJjZSkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PT0gc291cmNlIHx8IGJhc2VJc01hdGNoKG9iamVjdCwgc291cmNlLCBnZXRNYXRjaERhdGEoc291cmNlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5pc01hdGNoYCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaFxuICAgICAqIGlzIGludm9rZWQgdG8gY29tcGFyZSB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zIGB1bmRlZmluZWRgLCBjb21wYXJpc29uc1xuICAgICAqIGFyZSBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggZml2ZVxuICAgICAqIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwgaW5kZXh8a2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gbWF0Y2guXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgY29tcGFyaXNvbnMuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBvYmplY3RgIGlzIGEgbWF0Y2gsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gaXNHcmVldGluZyh2YWx1ZSkge1xuICAgICAqICAgcmV0dXJuIC9eaCg/Oml8ZWxsbykkLy50ZXN0KHZhbHVlKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBjdXN0b21pemVyKG9ialZhbHVlLCBzcmNWYWx1ZSkge1xuICAgICAqICAgaWYgKGlzR3JlZXRpbmcob2JqVmFsdWUpICYmIGlzR3JlZXRpbmcoc3JjVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiB0cnVlO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdncmVldGluZyc6ICdoZWxsbycgfTtcbiAgICAgKiB2YXIgc291cmNlID0geyAnZ3JlZXRpbmcnOiAnaGknIH07XG4gICAgICpcbiAgICAgKiBfLmlzTWF0Y2hXaXRoKG9iamVjdCwgc291cmNlLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNNYXRjaFdpdGgob2JqZWN0LCBzb3VyY2UsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBiYXNlSXNNYXRjaChvYmplY3QsIHNvdXJjZSwgZ2V0TWF0Y2hEYXRhKHNvdXJjZSksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGBOYU5gLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGJhc2VkIG9uXG4gICAgICogW2BOdW1iZXIuaXNOYU5gXShodHRwczovL21kbi5pby9OdW1iZXIvaXNOYU4pIGFuZCBpcyBub3QgdGhlIHNhbWUgYXNcbiAgICAgKiBnbG9iYWwgW2Bpc05hTmBdKGh0dHBzOi8vbWRuLmlvL2lzTmFOKSB3aGljaCByZXR1cm5zIGB0cnVlYCBmb3JcbiAgICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgbm9uLW51bWJlciB2YWx1ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBOYU5gLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOYU4oTmFOKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKG5ldyBOdW1iZXIoTmFOKSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogaXNOYU4odW5kZWZpbmVkKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTmFOKHVuZGVmaW5lZCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc05hTih2YWx1ZSkge1xuICAgICAgLy8gQW4gYE5hTmAgcHJpbWl0aXZlIGlzIHRoZSBvbmx5IHZhbHVlIHRoYXQgaXMgbm90IGVxdWFsIHRvIGl0c2VsZi5cbiAgICAgIC8vIFBlcmZvcm0gdGhlIGB0b1N0cmluZ1RhZ2AgY2hlY2sgZmlyc3QgdG8gYXZvaWQgZXJyb3JzIHdpdGggc29tZVxuICAgICAgLy8gQWN0aXZlWCBvYmplY3RzIGluIElFLlxuICAgICAgcmV0dXJuIGlzTnVtYmVyKHZhbHVlKSAmJiB2YWx1ZSAhPSArdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBwcmlzdGluZSBuYXRpdmUgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgY2FuJ3QgcmVsaWFibHkgZGV0ZWN0IG5hdGl2ZSBmdW5jdGlvbnMgaW4gdGhlIHByZXNlbmNlXG4gICAgICogb2YgdGhlIGNvcmUtanMgcGFja2FnZSBiZWNhdXNlIGNvcmUtanMgY2lyY3VtdmVudHMgdGhpcyBraW5kIG9mIGRldGVjdGlvbi5cbiAgICAgKiBEZXNwaXRlIG11bHRpcGxlIHJlcXVlc3RzLCB0aGUgY29yZS1qcyBtYWludGFpbmVyIGhhcyBtYWRlIGl0IGNsZWFyOiBhbnlcbiAgICAgKiBhdHRlbXB0IHRvIGZpeCB0aGUgZGV0ZWN0aW9uIHdpbGwgYmUgb2JzdHJ1Y3RlZC4gQXMgYSByZXN1bHQsIHdlJ3JlIGxlZnRcbiAgICAgKiB3aXRoIGxpdHRsZSBjaG9pY2UgYnV0IHRvIHRocm93IGFuIGVycm9yLiBVbmZvcnR1bmF0ZWx5LCB0aGlzIGFsc28gYWZmZWN0c1xuICAgICAqIHBhY2thZ2VzLCBsaWtlIFtiYWJlbC1wb2x5ZmlsbF0oaHR0cHM6Ly93d3cubnBtanMuY29tL3BhY2thZ2UvYmFiZWwtcG9seWZpbGwpLFxuICAgICAqIHdoaWNoIHJlbHkgb24gY29yZS1qcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBuYXRpdmUgZnVuY3Rpb24sXG4gICAgICogIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShBcnJheS5wcm90b3R5cGUucHVzaCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05hdGl2ZShfKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmF0aXZlKHZhbHVlKSB7XG4gICAgICBpZiAoaXNNYXNrYWJsZSh2YWx1ZSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKENPUkVfRVJST1JfVEVYVCk7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmFzZUlzTmF0aXZlKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgbnVsbGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzTnVsbCh2b2lkIDApO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IG51bGw7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgIG9yIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBudWxsaXNoLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc05pbCh2b2lkIDApO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOaWwoTmFOKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzTmlsKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYE51bWJlcmAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUbyBleGNsdWRlIGBJbmZpbml0eWAsIGAtSW5maW5pdHlgLCBhbmQgYE5hTmAsIHdoaWNoIGFyZVxuICAgICAqIGNsYXNzaWZpZWQgYXMgbnVtYmVycywgdXNlIHRoZSBgXy5pc0Zpbml0ZWAgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIG51bWJlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzTnVtYmVyKDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNOdW1iZXIoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc051bWJlcignMycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNOdW1iZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ251bWJlcicgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gbnVtYmVyVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgdGhhdCBpcywgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlXG4gICAgICogYE9iamVjdGAgY29uc3RydWN0b3Igb3Igb25lIHdpdGggYSBgW1tQcm90b3R5cGVdXWAgb2YgYG51bGxgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuOC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHBsYWluIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pc1BsYWluT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdCh7ICd4JzogMCwgJ3knOiAwIH0pO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNQbGFpbk9iamVjdChPYmplY3QuY3JlYXRlKG51bGwpKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNQbGFpbk9iamVjdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc09iamVjdExpa2UodmFsdWUpIHx8IGJhc2VHZXRUYWcodmFsdWUpICE9IG9iamVjdFRhZykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xuICAgICAgaWYgKHByb3RvID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcbiAgICAgIHJldHVybiB0eXBlb2YgQ3RvciA9PSAnZnVuY3Rpb24nICYmIEN0b3IgaW5zdGFuY2VvZiBDdG9yICYmXG4gICAgICAgIGZ1bmNUb1N0cmluZy5jYWxsKEN0b3IpID09IG9iamVjdEN0b3JTdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBSZWdFeHBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSByZWdleHAsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgvYWJjLyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1JlZ0V4cCgnL2FiYy8nKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1JlZ0V4cCA9IG5vZGVJc1JlZ0V4cCA/IGJhc2VVbmFyeShub2RlSXNSZWdFeHApIDogYmFzZUlzUmVnRXhwO1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBzYWZlIGludGVnZXIuIEFuIGludGVnZXIgaXMgc2FmZSBpZiBpdCdzIGFuIElFRUUtNzU0XG4gICAgICogZG91YmxlIHByZWNpc2lvbiBudW1iZXIgd2hpY2ggaXNuJ3QgdGhlIHJlc3VsdCBvZiBhIHJvdW5kZWQgdW5zYWZlIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYE51bWJlci5pc1NhZmVJbnRlZ2VyYF0oaHR0cHM6Ly9tZG4uaW8vTnVtYmVyL2lzU2FmZUludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBhIHNhZmUgaW50ZWdlciwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoMyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBfLmlzU2FmZUludGVnZXIoJzMnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzU2FmZUludGVnZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc0ludGVnZXIodmFsdWUpICYmIHZhbHVlID49IC1NQVhfU0FGRV9JTlRFR0VSICYmIHZhbHVlIDw9IE1BWF9TQUZFX0lOVEVHRVI7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzZXQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1NldChuZXcgU2V0KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmlzU2V0KG5ldyBXZWFrU2V0KTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1NldCA9IG5vZGVJc1NldCA/IGJhc2VVbmFyeShub2RlSXNTZXQpIDogYmFzZUlzU2V0O1xuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgY2xhc3NpZmllZCBhcyBhIGBTdHJpbmdgIHByaW1pdGl2ZSBvciBvYmplY3QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoJ2FiYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTdHJpbmcoMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAoIWlzQXJyYXkodmFsdWUpICYmIGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3RyaW5nVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN5bWJvbGAgcHJpbWl0aXZlIG9yIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBzeW1ib2wsIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1N5bWJvbChTeW1ib2wuaXRlcmF0b3IpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNTeW1ib2woJ2FiYycpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaXNTeW1ib2wodmFsdWUpIHtcbiAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT0gJ3N5bWJvbCcgfHxcbiAgICAgICAgKGlzT2JqZWN0TGlrZSh2YWx1ZSkgJiYgYmFzZUdldFRhZyh2YWx1ZSkgPT0gc3ltYm9sVGFnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgdHlwZWQgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgdHlwZWQgYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pc1R5cGVkQXJyYXkobmV3IFVpbnQ4QXJyYXkpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaXNUeXBlZEFycmF5KFtdKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBpc1R5cGVkQXJyYXkgPSBub2RlSXNUeXBlZEFycmF5ID8gYmFzZVVuYXJ5KG5vZGVJc1R5cGVkQXJyYXkpIDogYmFzZUlzVHlwZWRBcnJheTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGB1bmRlZmluZWRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1VuZGVmaW5lZChudWxsKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtNYXBgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIG1hcCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha01hcChuZXcgV2Vha01hcCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtNYXAobmV3IE1hcCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtNYXAodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGdldFRhZyh2YWx1ZSkgPT0gd2Vha01hcFRhZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFdlYWtTZXRgIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjMuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSB3ZWFrIHNldCwgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmlzV2Vha1NldChuZXcgV2Vha1NldCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pc1dlYWtTZXQobmV3IFNldCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpc1dlYWtTZXQodmFsdWUpIHtcbiAgICAgIHJldHVybiBpc09iamVjdExpa2UodmFsdWUpICYmIGJhc2VHZXRUYWcodmFsdWUpID09IHdlYWtTZXRUYWc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgbGVzcyB0aGFuIGBvdGhlcmAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy45LjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbXBhcmUuXG4gICAgICogQHBhcmFtIHsqfSBvdGhlciBUaGUgb3RoZXIgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gYG90aGVyYCxcbiAgICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBzZWUgXy5ndFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0KDEsIDMpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8ubHQoMywgMSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgbHQgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGJhc2VMdCk7XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBsZXNzIHRoYW4gb3IgZXF1YWwgdG8gYG90aGVyYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjkuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29tcGFyZS5cbiAgICAgKiBAcGFyYW0geyp9IG90aGVyIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGxlc3MgdGhhbiBvciBlcXVhbCB0b1xuICAgICAqICBgb3RoZXJgLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLmd0ZVxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgxLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAzKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmx0ZSgzLCAxKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIHZhciBsdGUgPSBjcmVhdGVSZWxhdGlvbmFsT3BlcmF0aW9uKGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgcmV0dXJuIHZhbHVlIDw9IG90aGVyO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBhcnJheS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b0FycmF5KHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkoJ2FiYycpO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqXG4gICAgICogXy50b0FycmF5KDEpO1xuICAgICAqIC8vID0+IFtdXG4gICAgICpcbiAgICAgKiBfLnRvQXJyYXkobnVsbCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gICAgICBpZiAoIXZhbHVlKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICAgIH1cbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuIGlzU3RyaW5nKHZhbHVlKSA/IHN0cmluZ1RvQXJyYXkodmFsdWUpIDogY29weUFycmF5KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIGlmIChzeW1JdGVyYXRvciAmJiB2YWx1ZVtzeW1JdGVyYXRvcl0pIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yVG9BcnJheSh2YWx1ZVtzeW1JdGVyYXRvcl0oKSk7XG4gICAgICB9XG4gICAgICB2YXIgdGFnID0gZ2V0VGFnKHZhbHVlKSxcbiAgICAgICAgICBmdW5jID0gdGFnID09IG1hcFRhZyA/IG1hcFRvQXJyYXkgOiAodGFnID09IHNldFRhZyA/IHNldFRvQXJyYXkgOiB2YWx1ZXMpO1xuXG4gICAgICByZXR1cm4gZnVuYyh2YWx1ZSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIGZpbml0ZSBudW1iZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMi4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoMy4yKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKlxuICAgICAqIF8udG9GaW5pdGUoTnVtYmVyLk1JTl9WQUxVRSk7XG4gICAgICogLy8gPT4gNWUtMzI0XG4gICAgICpcbiAgICAgKiBfLnRvRmluaXRlKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0Zpbml0ZSgnMy4yJyk7XG4gICAgICogLy8gPT4gMy4yXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9GaW5pdGUodmFsdWUpIHtcbiAgICAgIGlmICghdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiAwO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSB0b051bWJlcih2YWx1ZSk7XG4gICAgICBpZiAodmFsdWUgPT09IElORklOSVRZIHx8IHZhbHVlID09PSAtSU5GSU5JVFkpIHtcbiAgICAgICAgdmFyIHNpZ24gPSAodmFsdWUgPCAwID8gLTEgOiAxKTtcbiAgICAgICAgcmV0dXJuIHNpZ24gKiBNQVhfSU5URUdFUjtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2YWx1ZSA9PT0gdmFsdWUgPyB2YWx1ZSA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhbiBpbnRlZ2VyLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGlzIGxvb3NlbHkgYmFzZWQgb25cbiAgICAgKiBbYFRvSW50ZWdlcmBdKGh0dHA6Ly93d3cuZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2ludGVnZXIpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvSW50ZWdlcigzLjIpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9JbnRlZ2VyKEluZmluaXR5KTtcbiAgICAgKiAvLyA9PiAxLjc5NzY5MzEzNDg2MjMxNTdlKzMwOFxuICAgICAqXG4gICAgICogXy50b0ludGVnZXIoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0ludGVnZXIodmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB0b0Zpbml0ZSh2YWx1ZSksXG4gICAgICAgICAgcmVtYWluZGVyID0gcmVzdWx0ICUgMTtcblxuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gcmVzdWx0ID8gKHJlbWFpbmRlciA/IHJlc3VsdCAtIHJlbWFpbmRlciA6IHJlc3VsdCkgOiAwO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYW4gaW50ZWdlciBzdWl0YWJsZSBmb3IgdXNlIGFzIHRoZSBsZW5ndGggb2YgYW5cbiAgICAgKiBhcnJheS1saWtlIG9iamVjdC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBpcyBiYXNlZCBvblxuICAgICAqIFtgVG9MZW5ndGhgXShodHRwOi8vZWNtYS1pbnRlcm5hdGlvbmFsLm9yZy9lY21hLTI2Mi83LjAvI3NlYy10b2xlbmd0aCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTGFuZ1xuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgY29udmVydGVkIGludGVnZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoMy4yKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICpcbiAgICAgKiBfLnRvTGVuZ3RoKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IDQyOTQ5NjcyOTVcbiAgICAgKlxuICAgICAqIF8udG9MZW5ndGgoJzMuMicpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b0xlbmd0aCh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIDAsIE1BWF9BUlJBWV9MRU5HVEgpIDogMDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgdmFsdWVgIHRvIGEgbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IExhbmdcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBwcm9jZXNzLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b051bWJlcigzLjIpO1xuICAgICAqIC8vID0+IDMuMlxuICAgICAqXG4gICAgICogXy50b051bWJlcihOdW1iZXIuTUlOX1ZBTFVFKTtcbiAgICAgKiAvLyA9PiA1ZS0zMjRcbiAgICAgKlxuICAgICAqIF8udG9OdW1iZXIoSW5maW5pdHkpO1xuICAgICAqIC8vID0+IEluZmluaXR5XG4gICAgICpcbiAgICAgKiBfLnRvTnVtYmVyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzLjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b051bWJlcih2YWx1ZSkge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PSAnbnVtYmVyJykge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoaXNTeW1ib2wodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBOQU47XG4gICAgICB9XG4gICAgICBpZiAoaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIHZhciBvdGhlciA9IHR5cGVvZiB2YWx1ZS52YWx1ZU9mID09ICdmdW5jdGlvbicgPyB2YWx1ZS52YWx1ZU9mKCkgOiB2YWx1ZTtcbiAgICAgICAgdmFsdWUgPSBpc09iamVjdChvdGhlcikgPyAob3RoZXIgKyAnJykgOiBvdGhlcjtcbiAgICAgIH1cbiAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSAwID8gdmFsdWUgOiArdmFsdWU7XG4gICAgICB9XG4gICAgICB2YWx1ZSA9IGJhc2VUcmltKHZhbHVlKTtcbiAgICAgIHZhciBpc0JpbmFyeSA9IHJlSXNCaW5hcnkudGVzdCh2YWx1ZSk7XG4gICAgICByZXR1cm4gKGlzQmluYXJ5IHx8IHJlSXNPY3RhbC50ZXN0KHZhbHVlKSlcbiAgICAgICAgPyBmcmVlUGFyc2VJbnQodmFsdWUuc2xpY2UoMiksIGlzQmluYXJ5ID8gMiA6IDgpXG4gICAgICAgIDogKHJlSXNCYWRIZXgudGVzdCh2YWx1ZSkgPyBOQU4gOiArdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIGB2YWx1ZWAgdG8gYSBwbGFpbiBvYmplY3QgZmxhdHRlbmluZyBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmdcbiAgICAgKiBrZXllZCBwcm9wZXJ0aWVzIG9mIGB2YWx1ZWAgdG8gb3duIHByb3BlcnRpZXMgb2YgdGhlIHBsYWluIG9iamVjdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgcGxhaW4gb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbih7ICdhJzogMSB9LCBuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKlxuICAgICAqIF8uYXNzaWduKHsgJ2EnOiAxIH0sIF8udG9QbGFpbk9iamVjdChuZXcgRm9vKSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiwgJ2MnOiAzIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0b1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgICByZXR1cm4gY29weU9iamVjdCh2YWx1ZSwga2V5c0luKHZhbHVlKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHNhZmUgaW50ZWdlci4gQSBzYWZlIGludGVnZXIgY2FuIGJlIGNvbXBhcmVkIGFuZFxuICAgICAqIHJlcHJlc2VudGVkIGNvcnJlY3RseS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgaW50ZWdlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKDMuMik7XG4gICAgICogLy8gPT4gM1xuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKE51bWJlci5NSU5fVkFMVUUpO1xuICAgICAqIC8vID0+IDBcbiAgICAgKlxuICAgICAqIF8udG9TYWZlSW50ZWdlcihJbmZpbml0eSk7XG4gICAgICogLy8gPT4gOTAwNzE5OTI1NDc0MDk5MVxuICAgICAqXG4gICAgICogXy50b1NhZmVJbnRlZ2VyKCczLjInKTtcbiAgICAgKiAvLyA9PiAzXG4gICAgICovXG4gICAgZnVuY3Rpb24gdG9TYWZlSW50ZWdlcih2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlXG4gICAgICAgID8gYmFzZUNsYW1wKHRvSW50ZWdlcih2YWx1ZSksIC1NQVhfU0FGRV9JTlRFR0VSLCBNQVhfU0FGRV9JTlRFR0VSKVxuICAgICAgICA6ICh2YWx1ZSA9PT0gMCA/IHZhbHVlIDogMCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHN0cmluZy4gQW4gZW1wdHkgc3RyaW5nIGlzIHJldHVybmVkIGZvciBgbnVsbGBcbiAgICAgKiBhbmQgYHVuZGVmaW5lZGAgdmFsdWVzLiBUaGUgc2lnbiBvZiBgLTBgIGlzIHByZXNlcnZlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBMYW5nXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBjb252ZXJ0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKG51bGwpO1xuICAgICAqIC8vID0+ICcnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKC0wKTtcbiAgICAgKiAvLyA9PiAnLTAnXG4gICAgICpcbiAgICAgKiBfLnRvU3RyaW5nKFsxLCAyLCAzXSk7XG4gICAgICogLy8gPT4gJzEsMiwzJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvU3RyaW5nKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPT0gbnVsbCA/ICcnIDogYmFzZVRvU3RyaW5nKHZhbHVlKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBc3NpZ25zIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIHNvdXJjZSBvYmplY3RzIHRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LlxuICAgICAqIFN1YnNlcXVlbnQgc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgIGFuZCBpcyBsb29zZWx5IGJhc2VkIG9uXG4gICAgICogW2BPYmplY3QuYXNzaWduYF0oaHR0cHM6Ly9tZG4uaW8vT2JqZWN0L2Fzc2lnbikuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMC4xMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5hc3NpZ25JblxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEJhcigpIHtcbiAgICAgKiAgIHRoaXMuYyA9IDM7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5iID0gMjtcbiAgICAgKiBCYXIucHJvdG90eXBlLmQgPSA0O1xuICAgICAqXG4gICAgICogXy5hc3NpZ24oeyAnYSc6IDAgfSwgbmV3IEZvbywgbmV3IEJhcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlKSB7XG4gICAgICBpZiAoaXNQcm90b3R5cGUoc291cmNlKSB8fCBpc0FycmF5TGlrZShzb3VyY2UpKSB7XG4gICAgICAgIGNvcHlPYmplY3Qoc291cmNlLCBrZXlzKHNvdXJjZSksIG9iamVjdCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBzb3VyY2UpIHtcbiAgICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgYXNzaWduVmFsdWUob2JqZWN0LCBrZXksIHNvdXJjZVtrZXldKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGl0ZXJhdGVzIG92ZXIgb3duIGFuZFxuICAgICAqIGluaGVyaXRlZCBzb3VyY2UgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGFsaWFzIGV4dGVuZFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogfVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gQmFyKCkge1xuICAgICAqICAgdGhpcy5jID0gMztcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmIgPSAyO1xuICAgICAqIEJhci5wcm90b3R5cGUuZCA9IDQ7XG4gICAgICpcbiAgICAgKiBfLmFzc2lnbkluKHsgJ2EnOiAwIH0sIG5ldyBGb28sIG5ldyBCYXIpO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMywgJ2QnOiA0IH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduSW4gPSBjcmVhdGVBc3NpZ25lcihmdW5jdGlvbihvYmplY3QsIHNvdXJjZSkge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25JbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmBcbiAgICAgKiB3aGljaCBpcyBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIGFzc2lnbmVkIHZhbHVlcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnNcbiAgICAgKiBgdW5kZWZpbmVkYCwgYXNzaWdubWVudCBpcyBoYW5kbGVkIGJ5IHRoZSBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYFxuICAgICAqIGlzIGludm9rZWQgd2l0aCBmaXZlIGFyZ3VtZW50czogKG9ialZhbHVlLCBzcmNWYWx1ZSwga2V5LCBvYmplY3QsIHNvdXJjZSkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBleHRlbmRXaXRoXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gc291cmNlcyBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmFzc2lnbldpdGhcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiBfLmlzVW5kZWZpbmVkKG9ialZhbHVlKSA/IHNyY1ZhbHVlIDogb2JqVmFsdWU7XG4gICAgICogfVxuICAgICAqXG4gICAgICogdmFyIGRlZmF1bHRzID0gXy5wYXJ0aWFsUmlnaHQoXy5hc3NpZ25JbldpdGgsIGN1c3RvbWl6ZXIpO1xuICAgICAqXG4gICAgICogZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGFzc2lnbkluV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXNJbihzb3VyY2UpLCBvYmplY3QsIGN1c3RvbWl6ZXIpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5hc3NpZ25gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgXG4gICAgICogd2hpY2ggaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBhc3NpZ25lZCB2YWx1ZXMuIElmIGBjdXN0b21pemVyYCByZXR1cm5zXG4gICAgICogYHVuZGVmaW5lZGAsIGFzc2lnbm1lbnQgaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggZml2ZSBhcmd1bWVudHM6IChvYmpWYWx1ZSwgc3JjVmFsdWUsIGtleSwgb2JqZWN0LCBzb3VyY2UpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Li4uT2JqZWN0fSBzb3VyY2VzIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY3VzdG9taXplcl0gVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uYXNzaWduSW5XaXRoXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIGN1c3RvbWl6ZXIob2JqVmFsdWUsIHNyY1ZhbHVlKSB7XG4gICAgICogICByZXR1cm4gXy5pc1VuZGVmaW5lZChvYmpWYWx1ZSkgPyBzcmNWYWx1ZSA6IG9ialZhbHVlO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBkZWZhdWx0cyA9IF8ucGFydGlhbFJpZ2h0KF8uYXNzaWduV2l0aCwgY3VzdG9taXplcik7XG4gICAgICpcbiAgICAgKiBkZWZhdWx0cyh7ICdhJzogMSB9LCB7ICdiJzogMiB9LCB7ICdhJzogMyB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogMSwgJ2InOiAyIH1cbiAgICAgKi9cbiAgICB2YXIgYXNzaWduV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgY29weU9iamVjdChzb3VyY2UsIGtleXMoc291cmNlKSwgb2JqZWN0LCBjdXN0b21pemVyKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdmFsdWVzIGNvcnJlc3BvbmRpbmcgdG8gYHBhdGhzYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAxLjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7Li4uKHN0cmluZ3xzdHJpbmdbXSl9IFtwYXRoc10gVGhlIHByb3BlcnR5IHBhdGhzIHRvIHBpY2suXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBwaWNrZWQgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9LCA0XSB9O1xuICAgICAqXG4gICAgICogXy5hdChvYmplY3QsIFsnYVswXS5iLmMnLCAnYVsxXSddKTtcbiAgICAgKiAvLyA9PiBbMywgNF1cbiAgICAgKi9cbiAgICB2YXIgYXQgPSBmbGF0UmVzdChiYXNlQXQpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBgcHJvdG90eXBlYCBvYmplY3QuIElmIGFcbiAgICAgKiBgcHJvcGVydGllc2Agb2JqZWN0IGlzIGdpdmVuLCBpdHMgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXNcbiAgICAgKiBhcmUgYXNzaWduZWQgdG8gdGhlIGNyZWF0ZWQgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBwcm90b3R5cGUgVGhlIG9iamVjdCB0byBpbmhlcml0IGZyb20uXG4gICAgICogQHBhcmFtIHtPYmplY3R9IFtwcm9wZXJ0aWVzXSBUaGUgcHJvcGVydGllcyB0byBhc3NpZ24gdG8gdGhlIG9iamVjdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBTaGFwZSgpIHtcbiAgICAgKiAgIHRoaXMueCA9IDA7XG4gICAgICogICB0aGlzLnkgPSAwO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIENpcmNsZSgpIHtcbiAgICAgKiAgIFNoYXBlLmNhbGwodGhpcyk7XG4gICAgICogfVxuICAgICAqXG4gICAgICogQ2lyY2xlLnByb3RvdHlwZSA9IF8uY3JlYXRlKFNoYXBlLnByb3RvdHlwZSwge1xuICAgICAqICAgJ2NvbnN0cnVjdG9yJzogQ2lyY2xlXG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiB2YXIgY2lyY2xlID0gbmV3IENpcmNsZTtcbiAgICAgKiBjaXJjbGUgaW5zdGFuY2VvZiBDaXJjbGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY2lyY2xlIGluc3RhbmNlb2YgU2hhcGU7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNyZWF0ZShwcm90b3R5cGUsIHByb3BlcnRpZXMpIHtcbiAgICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgICByZXR1cm4gcHJvcGVydGllcyA9PSBudWxsID8gcmVzdWx0IDogYmFzZUFzc2lnbihyZXN1bHQsIHByb3BlcnRpZXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEFzc2lnbnMgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2VcbiAgICAgKiBvYmplY3RzIHRvIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QgZm9yIGFsbCBkZXN0aW5hdGlvbiBwcm9wZXJ0aWVzIHRoYXRcbiAgICAgKiByZXNvbHZlIHRvIGB1bmRlZmluZWRgLiBTb3VyY2Ugb2JqZWN0cyBhcmUgYXBwbGllZCBmcm9tIGxlZnQgdG8gcmlnaHQuXG4gICAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCB2YWx1ZXMgb2YgdGhlIHNhbWUgcHJvcGVydHkgYXJlIGlnbm9yZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNEZWVwXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdHMoeyAnYSc6IDEgfSwgeyAnYic6IDIgfSwgeyAnYSc6IDMgfSk7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdiJzogMiB9XG4gICAgICovXG4gICAgdmFyIGRlZmF1bHRzID0gYmFzZVJlc3QoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2VzKSB7XG4gICAgICBvYmplY3QgPSBPYmplY3Qob2JqZWN0KTtcblxuICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICB2YXIgbGVuZ3RoID0gc291cmNlcy5sZW5ndGg7XG4gICAgICB2YXIgZ3VhcmQgPSBsZW5ndGggPiAyID8gc291cmNlc1syXSA6IHVuZGVmaW5lZDtcblxuICAgICAgaWYgKGd1YXJkICYmIGlzSXRlcmF0ZWVDYWxsKHNvdXJjZXNbMF0sIHNvdXJjZXNbMV0sIGd1YXJkKSkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgfVxuXG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgc291cmNlID0gc291cmNlc1tpbmRleF07XG4gICAgICAgIHZhciBwcm9wcyA9IGtleXNJbihzb3VyY2UpO1xuICAgICAgICB2YXIgcHJvcHNJbmRleCA9IC0xO1xuICAgICAgICB2YXIgcHJvcHNMZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cbiAgICAgICAgd2hpbGUgKCsrcHJvcHNJbmRleCA8IHByb3BzTGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIGtleSA9IHByb3BzW3Byb3BzSW5kZXhdO1xuICAgICAgICAgIHZhciB2YWx1ZSA9IG9iamVjdFtrZXldO1xuXG4gICAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQgfHxcbiAgICAgICAgICAgICAgKGVxKHZhbHVlLCBvYmplY3RQcm90b1trZXldKSAmJiAhaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIGtleSkpKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5kZWZhdWx0c2AgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgYXNzaWduc1xuICAgICAqIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IFtzb3VyY2VzXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZGVmYXVsdHNcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0c0RlZXAoeyAnYSc6IHsgJ2InOiAyIH0gfSwgeyAnYSc6IHsgJ2InOiAxLCAnYyc6IDMgfSB9KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogeyAnYic6IDIsICdjJzogMyB9IH1cbiAgICAgKi9cbiAgICB2YXIgZGVmYXVsdHNEZWVwID0gYmFzZVJlc3QoZnVuY3Rpb24oYXJncykge1xuICAgICAgYXJncy5wdXNoKHVuZGVmaW5lZCwgY3VzdG9tRGVmYXVsdHNNZXJnZSk7XG4gICAgICByZXR1cm4gYXBwbHkobWVyZ2VXaXRoLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5maW5kYCBleGNlcHQgdGhhdCBpdCByZXR1cm5zIHRoZSBrZXkgb2YgdGhlIGZpcnN0XG4gICAgICogZWxlbWVudCBgcHJlZGljYXRlYCByZXR1cm5zIHRydXRoeSBmb3IgaW5zdGVhZCBvZiB0aGUgZWxlbWVudCBpdHNlbGYuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMS4xLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlIDwgNDA7IH0pO1xuICAgICAqIC8vID0+ICdiYXJuZXknIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZEtleSh1c2VycywgeyAnYWdlJzogMSwgJ2FjdGl2ZSc6IHRydWUgfSk7XG4gICAgICogLy8gPT4gJ3BlYmJsZXMnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maW5kS2V5KHVzZXJzLCBbJ2FjdGl2ZScsIGZhbHNlXSk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbmRLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZpbmRLZXkob2JqZWN0LCBwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiBiYXNlRmluZEtleShvYmplY3QsIGdldEl0ZXJhdGVlKHByZWRpY2F0ZSwgMyksIGJhc2VGb3JPd24pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmluZEtleWAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBlbGVtZW50cyBvZlxuICAgICAqIGEgY29sbGVjdGlvbiBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd8dW5kZWZpbmVkfSBSZXR1cm5zIHRoZSBrZXkgb2YgdGhlIG1hdGNoZWQgZWxlbWVudCxcbiAgICAgKiAgZWxzZSBgdW5kZWZpbmVkYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0ge1xuICAgICAqICAgJ2Jhcm5leSc6ICB7ICdhZ2UnOiAzNiwgJ2FjdGl2ZSc6IHRydWUgfSxcbiAgICAgKiAgICdmcmVkJzogICAgeyAnYWdlJzogNDAsICdhY3RpdmUnOiBmYWxzZSB9LFxuICAgICAqICAgJ3BlYmJsZXMnOiB7ICdhZ2UnOiAxLCAgJ2FjdGl2ZSc6IHRydWUgfVxuICAgICAqIH07XG4gICAgICpcbiAgICAgKiBfLmZpbmRMYXN0S2V5KHVzZXJzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLmFnZSA8IDQwOyB9KTtcbiAgICAgKiAvLyA9PiByZXR1cm5zICdwZWJibGVzJyBhc3N1bWluZyBgXy5maW5kS2V5YCByZXR1cm5zICdiYXJuZXknXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc2AgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIHsgJ2FnZSc6IDM2LCAnYWN0aXZlJzogdHJ1ZSB9KTtcbiAgICAgKiAvLyA9PiAnYmFybmV5J1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNQcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsIFsnYWN0aXZlJywgZmFsc2VdKTtcbiAgICAgKiAvLyA9PiAnZnJlZCdcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uZmluZExhc3RLZXkodXNlcnMsICdhY3RpdmUnKTtcbiAgICAgKiAvLyA9PiAncGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmaW5kTGFzdEtleShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIGJhc2VGaW5kS2V5KG9iamVjdCwgZ2V0SXRlcmF0ZWUocHJlZGljYXRlLCAzKSwgYmFzZUZvck93blJpZ2h0KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYW5cbiAgICAgKiBvYmplY3QgYW5kIGludm9rZXMgYGl0ZXJhdGVlYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGl0ZXJhdGVlIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKHZhbHVlLCBrZXksIG9iamVjdCkuIEl0ZXJhdGVlIGZ1bmN0aW9ucyBtYXkgZXhpdFxuICAgICAqIGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5SaWdodFxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5mb3JJbihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnLCAnYicsIHRoZW4gJ2MnIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvckluKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3Iob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksIGtleXNJbik7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5mb3JJbmAgZXhjZXB0IHRoYXQgaXQgaXRlcmF0ZXMgb3ZlciBwcm9wZXJ0aWVzIG9mXG4gICAgICogYG9iamVjdGAgaW4gdGhlIG9wcG9zaXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAc2VlIF8uZm9ySW5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9ySW5SaWdodChuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2MnLCAnYicsIHRoZW4gJ2EnIGFzc3VtaW5nIGBfLmZvckluYCBsb2dzICdhJywgJ2InLCB0aGVuICdjJy5cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBmb3JJblJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbFxuICAgICAgICA/IG9iamVjdFxuICAgICAgICA6IGJhc2VGb3JSaWdodChvYmplY3QsIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAzKSwga2V5c0luKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBJdGVyYXRlcyBvdmVyIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0aWVzIG9mIGFuIG9iamVjdCBhbmRcbiAgICAgKiBpbnZva2VzIGBpdGVyYXRlZWAgZm9yIGVhY2ggcHJvcGVydHkuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggdGhyZWVcbiAgICAgKiBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBJdGVyYXRlZSBmdW5jdGlvbnMgbWF5IGV4aXQgaXRlcmF0aW9uXG4gICAgICogZWFybHkgYnkgZXhwbGljaXRseSByZXR1cm5pbmcgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjMuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQHNlZSBfLmZvck93blJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLmZvck93bihuZXcgRm9vLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICBjb25zb2xlLmxvZyhrZXkpO1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+IExvZ3MgJ2EnIHRoZW4gJ2InIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93bihvYmplY3QsIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ICYmIGJhc2VGb3JPd24ob2JqZWN0LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZm9yT3duYCBleGNlcHQgdGhhdCBpdCBpdGVyYXRlcyBvdmVyIHByb3BlcnRpZXMgb2ZcbiAgICAgKiBgb2JqZWN0YCBpbiB0aGUgb3Bwb3NpdGUgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGludm9rZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBzZWUgXy5mb3JPd25cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8uZm9yT3duUmlnaHQobmV3IEZvbywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAqICAgY29uc29sZS5sb2coa2V5KTtcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiBMb2dzICdiJyB0aGVuICdhJyBhc3N1bWluZyBgXy5mb3JPd25gIGxvZ3MgJ2EnIHRoZW4gJ2InLlxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZvck93blJpZ2h0KG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHJldHVybiBvYmplY3QgJiYgYmFzZUZvck93blJpZ2h0KG9iamVjdCwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGVudW1lcmFibGUgcHJvcGVydGllc1xuICAgICAqIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnNwZWN0LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgZnVuY3Rpb24gbmFtZXMuXG4gICAgICogQHNlZSBfLmZ1bmN0aW9uc0luXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9ucyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddXG4gICAgICovXG4gICAgZnVuY3Rpb24gZnVuY3Rpb25zKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5cyhvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIGZ1bmN0aW9uIHByb3BlcnR5IG5hbWVzIGZyb20gb3duIGFuZCBpbmhlcml0ZWRcbiAgICAgKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBmdW5jdGlvbiBuYW1lcy5cbiAgICAgKiBAc2VlIF8uZnVuY3Rpb25zXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IF8uY29uc3RhbnQoJ2EnKTtcbiAgICAgKiAgIHRoaXMuYiA9IF8uY29uc3RhbnQoJ2InKTtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSBfLmNvbnN0YW50KCdjJyk7XG4gICAgICpcbiAgICAgKiBfLmZ1bmN0aW9uc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFsnYScsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGZ1bmN0aW9uc0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gW10gOiBiYXNlRnVuY3Rpb25zKG9iamVjdCwga2V5c0luKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgdGhlIHJlc29sdmVkIHZhbHVlIGlzXG4gICAgICogYHVuZGVmaW5lZGAsIHRoZSBgZGVmYXVsdFZhbHVlYCBpcyByZXR1cm5lZCBpbiBpdHMgcGxhY2UuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBnZXQuXG4gICAgICogQHBhcmFtIHsqfSBbZGVmYXVsdFZhbHVlXSBUaGUgdmFsdWUgcmV0dXJuZWQgZm9yIGB1bmRlZmluZWRgIHJlc29sdmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7Kn0gUmV0dXJucyB0aGUgcmVzb2x2ZWQgdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogMyB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmdldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgWydhJywgJzAnLCAnYicsICdjJ10pO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8uZ2V0KG9iamVjdCwgJ2EuYi5jJywgJ2RlZmF1bHQnKTtcbiAgICAgKiAvLyA9PiAnZGVmYXVsdCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXQob2JqZWN0LCBwYXRoLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IGJhc2VHZXQob2JqZWN0LCBwYXRoKTtcbiAgICAgIHJldHVybiByZXN1bHQgPT09IHVuZGVmaW5lZCA/IGRlZmF1bHRWYWx1ZSA6IHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYHBhdGhgIGlzIGEgZGlyZWN0IHByb3BlcnR5IG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHBhdGhgIGV4aXN0cywgZWxzZSBgZmFsc2VgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IHsgJ2InOiAyIH0gfTtcbiAgICAgKiB2YXIgb3RoZXIgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhcyhvYmplY3QsICdhJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCAnYS5iJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5oYXMob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhcyhvdGhlciwgJ2EnKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhcyhvYmplY3QsIHBhdGgpIHtcbiAgICAgIHJldHVybiBvYmplY3QgIT0gbnVsbCAmJiBoYXNQYXRoKG9iamVjdCwgcGF0aCwgYmFzZUhhcyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGlmIGBwYXRoYCBpcyBhIGRpcmVjdCBvciBpbmhlcml0ZWQgcHJvcGVydHkgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIHRvIGNoZWNrLlxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgcGF0aGAgZXhpc3RzLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSBfLmNyZWF0ZSh7ICdhJzogXy5jcmVhdGUoeyAnYic6IDIgfSkgfSk7XG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2EuYicpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaGFzSW4ob2JqZWN0LCBbJ2EnLCAnYiddKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmhhc0luKG9iamVjdCwgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGhhc0luKG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIGhhc1BhdGgob2JqZWN0LCBwYXRoLCBiYXNlSGFzSW4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICogSWYgYG9iamVjdGAgY29udGFpbnMgZHVwbGljYXRlIHZhbHVlcywgc3Vic2VxdWVudCB2YWx1ZXMgb3ZlcndyaXRlXG4gICAgICogcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGludmVydGVkIG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9O1xuICAgICAqXG4gICAgICogXy5pbnZlcnQob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogJ2MnLCAnMic6ICdiJyB9XG4gICAgICovXG4gICAgdmFyIGludmVydCA9IGNyZWF0ZUludmVydGVyKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgICAgaWYgKHZhbHVlICE9IG51bGwgJiZcbiAgICAgICAgICB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICB2YWx1ZSA9IG5hdGl2ZU9iamVjdFRvU3RyaW5nLmNhbGwodmFsdWUpO1xuICAgICAgfVxuXG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0sIGNvbnN0YW50KGlkZW50aXR5KSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmludmVydGAgZXhjZXB0IHRoYXQgdGhlIGludmVydGVkIG9iamVjdCBpcyBnZW5lcmF0ZWRcbiAgICAgKiBmcm9tIHRoZSByZXN1bHRzIG9mIHJ1bm5pbmcgZWFjaCBlbGVtZW50IG9mIGBvYmplY3RgIHRocnUgYGl0ZXJhdGVlYC4gVGhlXG4gICAgICogY29ycmVzcG9uZGluZyBpbnZlcnRlZCB2YWx1ZSBvZiBlYWNoIGludmVydGVkIGtleSBpcyBhbiBhcnJheSBvZiBrZXlzXG4gICAgICogcmVzcG9uc2libGUgZm9yIGdlbmVyYXRpbmcgdGhlIGludmVydGVkIHZhbHVlLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZFxuICAgICAqIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBpbnZlcnRlZCBvYmplY3QuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDEgfTtcbiAgICAgKlxuICAgICAqIF8uaW52ZXJ0Qnkob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICcxJzogWydhJywgJ2MnXSwgJzInOiBbJ2InXSB9XG4gICAgICpcbiAgICAgKiBfLmludmVydEJ5KG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgKiAgIHJldHVybiAnZ3JvdXAnICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnZ3JvdXAxJzogWydhJywgJ2MnXSwgJ2dyb3VwMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICB2YXIgaW52ZXJ0QnkgPSBjcmVhdGVJbnZlcnRlcihmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgIGlmICh2YWx1ZSAhPSBudWxsICYmXG4gICAgICAgICAgdHlwZW9mIHZhbHVlLnRvU3RyaW5nICE9ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdmFsdWUgPSBuYXRpdmVPYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0W3ZhbHVlXS5wdXNoKGtleSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXN1bHRbdmFsdWVdID0gW2tleV07XG4gICAgICB9XG4gICAgfSwgZ2V0SXRlcmF0ZWUpO1xuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgbWV0aG9kIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIG1ldGhvZCB0byBpbnZva2UuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXN1bHQgb2YgdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IFsxLCAyLCAzLCA0XSB9IH1dIH07XG4gICAgICpcbiAgICAgKiBfLmludm9rZShvYmplY3QsICdhWzBdLmIuYy5zbGljZScsIDEsIDMpO1xuICAgICAqIC8vID0+IFsyLCAzXVxuICAgICAqL1xuICAgIHZhciBpbnZva2UgPSBiYXNlUmVzdChiYXNlSW52b2tlKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHByb3BlcnR5IG5hbWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuIFNlZSB0aGVcbiAgICAgKiBbRVMgc3BlY10oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LmtleXMpXG4gICAgICogZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8ua2V5cyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnYiddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiBfLmtleXMoJ2hpJyk7XG4gICAgICogLy8gPT4gWycwJywgJzEnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGtleXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gaXNBcnJheUxpa2Uob2JqZWN0KSA/IGFycmF5TGlrZUtleXMob2JqZWN0KSA6IGJhc2VLZXlzKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiB0aGUgb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcyBvZiBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBOb24tb2JqZWN0IHZhbHVlcyBhcmUgY29lcmNlZCB0byBvYmplY3RzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGFycmF5IG9mIHByb3BlcnR5IG5hbWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy5rZXlzSW4obmV3IEZvbyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddIChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICovXG4gICAgZnVuY3Rpb24ga2V5c0luKG9iamVjdCkge1xuICAgICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iamVjdCkgPyBhcnJheUxpa2VLZXlzKG9iamVjdCwgdHJ1ZSkgOiBiYXNlS2V5c0luKG9iamVjdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLm1hcFZhbHVlc2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IHdpdGggdGhlXG4gICAgICogc2FtZSB2YWx1ZXMgYXMgYG9iamVjdGAgYW5kIGtleXMgZ2VuZXJhdGVkIGJ5IHJ1bm5pbmcgZWFjaCBvd24gZW51bWVyYWJsZVxuICAgICAqIHN0cmluZyBrZXllZCBwcm9wZXJ0eSBvZiBgb2JqZWN0YCB0aHJ1IGBpdGVyYXRlZWAuIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkXG4gICAgICogd2l0aCB0aHJlZSBhcmd1bWVudHM6ICh2YWx1ZSwga2V5LCBvYmplY3QpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuOC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG1hcHBlZCBvYmplY3QuXG4gICAgICogQHNlZSBfLm1hcFZhbHVlc1xuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1hcEtleXMoeyAnYSc6IDEsICdiJzogMiB9LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICogICByZXR1cm4ga2V5ICsgdmFsdWU7XG4gICAgICogfSk7XG4gICAgICogLy8gPT4geyAnYTEnOiAxLCAnYjInOiAyIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBLZXlzKG9iamVjdCwgaXRlcmF0ZWUpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDMpO1xuXG4gICAgICBiYXNlRm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICAgIGJhc2VBc3NpZ25WYWx1ZShyZXN1bHQsIGl0ZXJhdGVlKHZhbHVlLCBrZXksIG9iamVjdCksIHZhbHVlKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lIGtleXMgYXMgYG9iamVjdGAgYW5kIHZhbHVlcyBnZW5lcmF0ZWRcbiAgICAgKiBieSBydW5uaW5nIGVhY2ggb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5IG9mIGBvYmplY3RgIHRocnVcbiAgICAgKiBgaXRlcmF0ZWVgLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czpcbiAgICAgKiAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjQuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIG5ldyBtYXBwZWQgb2JqZWN0LlxuICAgICAqIEBzZWUgXy5tYXBLZXlzXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB1c2VycyA9IHtcbiAgICAgKiAgICdmcmVkJzogICAgeyAndXNlcic6ICdmcmVkJywgICAgJ2FnZSc6IDQwIH0sXG4gICAgICogICAncGViYmxlcyc6IHsgJ3VzZXInOiAncGViYmxlcycsICdhZ2UnOiAxIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tYXBWYWx1ZXModXNlcnMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8uYWdlOyB9KTtcbiAgICAgKiAvLyA9PiB7ICdmcmVkJzogNDAsICdwZWJibGVzJzogMSB9IChpdGVyYXRpb24gb3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ucHJvcGVydHlgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLm1hcFZhbHVlcyh1c2VycywgJ2FnZScpO1xuICAgICAqIC8vID0+IHsgJ2ZyZWQnOiA0MCwgJ3BlYmJsZXMnOiAxIH0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXBWYWx1ZXMob2JqZWN0LCBpdGVyYXRlZSkge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaXRlcmF0ZWUgPSBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyk7XG5cbiAgICAgIGJhc2VGb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKHJlc3VsdCwga2V5LCBpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLmFzc2lnbmAgZXhjZXB0IHRoYXQgaXQgcmVjdXJzaXZlbHkgbWVyZ2VzIG93biBhbmRcbiAgICAgKiBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQgcHJvcGVydGllcyBvZiBzb3VyY2Ugb2JqZWN0cyBpbnRvIHRoZVxuICAgICAqIGRlc3RpbmF0aW9uIG9iamVjdC4gU291cmNlIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGB1bmRlZmluZWRgIGFyZVxuICAgICAqIHNraXBwZWQgaWYgYSBkZXN0aW5hdGlvbiB2YWx1ZSBleGlzdHMuIEFycmF5IGFuZCBwbGFpbiBvYmplY3QgcHJvcGVydGllc1xuICAgICAqIGFyZSBtZXJnZWQgcmVjdXJzaXZlbHkuIE90aGVyIG9iamVjdHMgYW5kIHZhbHVlIHR5cGVzIGFyZSBvdmVycmlkZGVuIGJ5XG4gICAgICogYXNzaWdubWVudC4gU291cmNlIG9iamVjdHMgYXJlIGFwcGxpZWQgZnJvbSBsZWZ0IHRvIHJpZ2h0LiBTdWJzZXF1ZW50XG4gICAgICogc291cmNlcyBvdmVyd3JpdGUgcHJvcGVydHkgYXNzaWdubWVudHMgb2YgcHJldmlvdXMgc291cmNlcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGlzIG1ldGhvZCBtdXRhdGVzIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNS4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICAgKiBAcGFyYW0gey4uLk9iamVjdH0gW3NvdXJjZXNdIFRoZSBzb3VyY2Ugb2JqZWN0cy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYic6IDIgfSwgeyAnZCc6IDQgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogdmFyIG90aGVyID0ge1xuICAgICAqICAgJ2EnOiBbeyAnYyc6IDMgfSwgeyAnZSc6IDUgfV1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5tZXJnZShvYmplY3QsIG90aGVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiAyLCAnYyc6IDMgfSwgeyAnZCc6IDQsICdlJzogNSB9XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlID0gY3JlYXRlQXNzaWduZXIoZnVuY3Rpb24ob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KSB7XG4gICAgICBiYXNlTWVyZ2Uob2JqZWN0LCBzb3VyY2UsIHNyY0luZGV4KTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVyZ2VgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGN1c3RvbWl6ZXJgIHdoaWNoXG4gICAgICogaXMgaW52b2tlZCB0byBwcm9kdWNlIHRoZSBtZXJnZWQgdmFsdWVzIG9mIHRoZSBkZXN0aW5hdGlvbiBhbmQgc291cmNlXG4gICAgICogcHJvcGVydGllcy4gSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGAsIG1lcmdpbmcgaXMgaGFuZGxlZCBieSB0aGVcbiAgICAgKiBtZXRob2QgaW5zdGVhZC4gVGhlIGBjdXN0b21pemVyYCBpcyBpbnZva2VkIHdpdGggc2l4IGFyZ3VtZW50czpcbiAgICAgKiAob2JqVmFsdWUsIHNyY1ZhbHVlLCBrZXksIG9iamVjdCwgc291cmNlLCBzdGFjaykuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi5PYmplY3R9IHNvdXJjZXMgVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGN1c3RvbWl6ZXIgVGhlIGZ1bmN0aW9uIHRvIGN1c3RvbWl6ZSBhc3NpZ25lZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gY3VzdG9taXplcihvYmpWYWx1ZSwgc3JjVmFsdWUpIHtcbiAgICAgKiAgIGlmIChfLmlzQXJyYXkob2JqVmFsdWUpKSB7XG4gICAgICogICAgIHJldHVybiBvYmpWYWx1ZS5jb25jYXQoc3JjVmFsdWUpO1xuICAgICAqICAgfVxuICAgICAqIH1cbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogWzFdLCAnYic6IFsyXSB9O1xuICAgICAqIHZhciBvdGhlciA9IHsgJ2EnOiBbM10sICdiJzogWzRdIH07XG4gICAgICpcbiAgICAgKiBfLm1lcmdlV2l0aChvYmplY3QsIG90aGVyLCBjdXN0b21pemVyKTtcbiAgICAgKiAvLyA9PiB7ICdhJzogWzEsIDNdLCAnYic6IFsyLCA0XSB9XG4gICAgICovXG4gICAgdmFyIG1lcmdlV2l0aCA9IGNyZWF0ZUFzc2lnbmVyKGZ1bmN0aW9uKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcikge1xuICAgICAgYmFzZU1lcmdlKG9iamVjdCwgc291cmNlLCBzcmNJbmRleCwgY3VzdG9taXplcik7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ucGlja2A7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZVxuICAgICAqIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydHkgcGF0aHMgb2YgYG9iamVjdGAgdGhhdCBhcmUgbm90IG9taXR0ZWQuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgY29uc2lkZXJhYmx5IHNsb3dlciB0aGFuIGBfLnBpY2tgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gb21pdC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ub21pdChvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIHZhciBvbWl0ID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgICAgaWYgKG9iamVjdCA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9XG4gICAgICB2YXIgaXNEZWVwID0gZmFsc2U7XG4gICAgICBwYXRocyA9IGFycmF5TWFwKHBhdGhzLCBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHBhdGggPSBjYXN0UGF0aChwYXRoLCBvYmplY3QpO1xuICAgICAgICBpc0RlZXAgfHwgKGlzRGVlcCA9IHBhdGgubGVuZ3RoID4gMSk7XG4gICAgICAgIHJldHVybiBwYXRoO1xuICAgICAgfSk7XG4gICAgICBjb3B5T2JqZWN0KG9iamVjdCwgZ2V0QWxsS2V5c0luKG9iamVjdCksIHJlc3VsdCk7XG4gICAgICBpZiAoaXNEZWVwKSB7XG4gICAgICAgIHJlc3VsdCA9IGJhc2VDbG9uZShyZXN1bHQsIENMT05FX0RFRVBfRkxBRyB8IENMT05FX0ZMQVRfRkxBRyB8IENMT05FX1NZTUJPTFNfRkxBRywgY3VzdG9tT21pdENsb25lKTtcbiAgICAgIH1cbiAgICAgIHZhciBsZW5ndGggPSBwYXRocy5sZW5ndGg7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgYmFzZVVuc2V0KHJlc3VsdCwgcGF0aHNbbGVuZ3RoXSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnBpY2tCeWA7IHRoaXMgbWV0aG9kIGNyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mXG4gICAgICogdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgb2YgYG9iamVjdGAgdGhhdFxuICAgICAqIGBwcmVkaWNhdGVgIGRvZXNuJ3QgcmV0dXJuIHRydXRoeSBmb3IuIFRoZSBwcmVkaWNhdGUgaXMgaW52b2tlZCB3aXRoIHR3b1xuICAgICAqIGFyZ3VtZW50czogKHZhbHVlLCBrZXkpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW3ByZWRpY2F0ZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgcHJvcGVydHkuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiAxLCAnYic6ICcyJywgJ2MnOiAzIH07XG4gICAgICpcbiAgICAgKiBfLm9taXRCeShvYmplY3QsIF8uaXNOdW1iZXIpO1xuICAgICAqIC8vID0+IHsgJ2InOiAnMicgfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9taXRCeShvYmplY3QsIHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHBpY2tCeShvYmplY3QsIG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBgb2JqZWN0YCBwcm9wZXJ0aWVzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIHNvdXJjZSBvYmplY3QuXG4gICAgICogQHBhcmFtIHsuLi4oc3RyaW5nfHN0cmluZ1tdKX0gW3BhdGhzXSBUaGUgcHJvcGVydHkgcGF0aHMgdG8gcGljay5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGljayhvYmplY3QsIFsnYScsICdjJ10pO1xuICAgICAqIC8vID0+IHsgJ2EnOiAxLCAnYyc6IDMgfVxuICAgICAqL1xuICAgIHZhciBwaWNrID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBwYXRocykge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8ge30gOiBiYXNlUGljayhvYmplY3QsIHBhdGhzKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBgb2JqZWN0YCBwcm9wZXJ0aWVzIGBwcmVkaWNhdGVgIHJldHVybnNcbiAgICAgKiB0cnV0aHkgZm9yLiBUaGUgcHJlZGljYXRlIGlzIGludm9rZWQgd2l0aCB0d28gYXJndW1lbnRzOiAodmFsdWUsIGtleSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgc291cmNlIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcHJlZGljYXRlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBwcm9wZXJ0eS5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBuZXcgb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IDEsICdiJzogJzInLCAnYyc6IDMgfTtcbiAgICAgKlxuICAgICAqIF8ucGlja0J5KG9iamVjdCwgXy5pc051bWJlcik7XG4gICAgICogLy8gPT4geyAnYSc6IDEsICdjJzogMyB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gcGlja0J5KG9iamVjdCwgcHJlZGljYXRlKSB7XG4gICAgICBpZiAob2JqZWN0ID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHt9O1xuICAgICAgfVxuICAgICAgdmFyIHByb3BzID0gYXJyYXlNYXAoZ2V0QWxsS2V5c0luKG9iamVjdCksIGZ1bmN0aW9uKHByb3ApIHtcbiAgICAgICAgcmV0dXJuIFtwcm9wXTtcbiAgICAgIH0pO1xuICAgICAgcHJlZGljYXRlID0gZ2V0SXRlcmF0ZWUocHJlZGljYXRlKTtcbiAgICAgIHJldHVybiBiYXNlUGlja0J5KG9iamVjdCwgcHJvcHMsIGZ1bmN0aW9uKHZhbHVlLCBwYXRoKSB7XG4gICAgICAgIHJldHVybiBwcmVkaWNhdGUodmFsdWUsIHBhdGhbMF0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5nZXRgIGV4Y2VwdCB0aGF0IGlmIHRoZSByZXNvbHZlZCB2YWx1ZSBpcyBhXG4gICAgICogZnVuY3Rpb24gaXQncyBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIG9mIGl0cyBwYXJlbnQgb2JqZWN0IGFuZFxuICAgICAqIGl0cyByZXN1bHQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byByZXNvbHZlLlxuICAgICAqIEBwYXJhbSB7Kn0gW2RlZmF1bHRWYWx1ZV0gVGhlIHZhbHVlIHJldHVybmVkIGZvciBgdW5kZWZpbmVkYCByZXNvbHZlZCB2YWx1ZXMuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYzEnOiAzLCAnYzInOiBfLmNvbnN0YW50KDQpIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMScpO1xuICAgICAqIC8vID0+IDNcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMicpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8ucmVzdWx0KG9iamVjdCwgJ2FbMF0uYi5jMycsICdkZWZhdWx0Jyk7XG4gICAgICogLy8gPT4gJ2RlZmF1bHQnXG4gICAgICpcbiAgICAgKiBfLnJlc3VsdChvYmplY3QsICdhWzBdLmIuYzMnLCBfLmNvbnN0YW50KCdkZWZhdWx0JykpO1xuICAgICAqIC8vID0+ICdkZWZhdWx0J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc3VsdChvYmplY3QsIHBhdGgsIGRlZmF1bHRWYWx1ZSkge1xuICAgICAgcGF0aCA9IGNhc3RQYXRoKHBhdGgsIG9iamVjdCk7XG5cbiAgICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICAgIGxlbmd0aCA9IHBhdGgubGVuZ3RoO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIGxvb3AgaXMgZW50ZXJlZCB3aGVuIHBhdGggaXMgZW1wdHkuXG4gICAgICBpZiAoIWxlbmd0aCkge1xuICAgICAgICBsZW5ndGggPSAxO1xuICAgICAgICBvYmplY3QgPSB1bmRlZmluZWQ7XG4gICAgICB9XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IG9iamVjdFt0b0tleShwYXRoW2luZGV4XSldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGluZGV4ID0gbGVuZ3RoO1xuICAgICAgICAgIHZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIG9iamVjdCA9IGlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNldHMgdGhlIHZhbHVlIGF0IGBwYXRoYCBvZiBgb2JqZWN0YC4gSWYgYSBwb3J0aW9uIG9mIGBwYXRoYCBkb2Vzbid0IGV4aXN0LFxuICAgICAqIGl0J3MgY3JlYXRlZC4gQXJyYXlzIGFyZSBjcmVhdGVkIGZvciBtaXNzaW5nIGluZGV4IHByb3BlcnRpZXMgd2hpbGUgb2JqZWN0c1xuICAgICAqIGFyZSBjcmVhdGVkIGZvciBhbGwgb3RoZXIgbWlzc2luZyBwcm9wZXJ0aWVzLiBVc2UgYF8uc2V0V2l0aGAgdG8gY3VzdG9taXplXG4gICAgICogYHBhdGhgIGNyZWF0aW9uLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHNldC5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0geyAnYSc6IFt7ICdiJzogeyAnYyc6IDMgfSB9XSB9O1xuICAgICAqXG4gICAgICogXy5zZXQob2JqZWN0LCAnYVswXS5iLmMnLCA0KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QuYVswXS5iLmMpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uc2V0KG9iamVjdCwgWyd4JywgJzAnLCAneScsICd6J10sIDUpO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC54WzBdLnkueik7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldChvYmplY3QsIHBhdGgsIHZhbHVlKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlU2V0KG9iamVjdCwgcGF0aCwgdmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBpdCBhY2NlcHRzIGBjdXN0b21pemVyYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgdG8gcHJvZHVjZSB0aGUgb2JqZWN0cyBvZiBgcGF0aGAuICBJZiBgY3VzdG9taXplcmAgcmV0dXJucyBgdW5kZWZpbmVkYFxuICAgICAqIHBhdGggY3JlYXRpb24gaXMgaGFuZGxlZCBieSB0aGUgbWV0aG9kIGluc3RlYWQuIFRoZSBgY3VzdG9taXplcmAgaXMgaW52b2tlZFxuICAgICAqIHdpdGggdGhyZWUgYXJndW1lbnRzOiAobnNWYWx1ZSwga2V5LCBuc09iamVjdCkuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgbXV0YXRlcyBgb2JqZWN0YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gbW9kaWZ5LlxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBwcm9wZXJ0eSB0byBzZXQuXG4gICAgICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjdXN0b21pemVyXSBUaGUgZnVuY3Rpb24gdG8gY3VzdG9taXplIGFzc2lnbmVkIHZhbHVlcy5cbiAgICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0ID0ge307XG4gICAgICpcbiAgICAgKiBfLnNldFdpdGgob2JqZWN0LCAnWzBdWzFdJywgJ2EnLCBPYmplY3QpO1xuICAgICAqIC8vID0+IHsgJzAnOiB7ICcxJzogJ2EnIH0gfVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHNldFdpdGgob2JqZWN0LCBwYXRoLCB2YWx1ZSwgY3VzdG9taXplcikge1xuICAgICAgY3VzdG9taXplciA9IHR5cGVvZiBjdXN0b21pemVyID09ICdmdW5jdGlvbicgPyBjdXN0b21pemVyIDogdW5kZWZpbmVkO1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gb2JqZWN0IDogYmFzZVNldChvYmplY3QsIHBhdGgsIHZhbHVlLCBjdXN0b21pemVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZC12YWx1ZSBwYWlycyBmb3IgYG9iamVjdGBcbiAgICAgKiB3aGljaCBjYW4gYmUgY29uc3VtZWQgYnkgYF8uZnJvbVBhaXJzYC4gSWYgYG9iamVjdGAgaXMgYSBtYXAgb3Igc2V0LCBpdHNcbiAgICAgKiBlbnRyaWVzIGFyZSByZXR1cm5lZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBhbGlhcyBlbnRyaWVzXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlycyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbWydhJywgMV0sIFsnYicsIDJdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzID0gY3JlYXRlVG9QYWlycyhrZXlzKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2Ygb3duIGFuZCBpbmhlcml0ZWQgZW51bWVyYWJsZSBzdHJpbmcga2V5ZWQtdmFsdWUgcGFpcnNcbiAgICAgKiBmb3IgYG9iamVjdGAgd2hpY2ggY2FuIGJlIGNvbnN1bWVkIGJ5IGBfLmZyb21QYWlyc2AuIElmIGBvYmplY3RgIGlzIGEgbWFwXG4gICAgICogb3Igc2V0LCBpdHMgZW50cmllcyBhcmUgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAYWxpYXMgZW50cmllc0luXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIGtleS12YWx1ZSBwYWlycy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gRm9vKCkge1xuICAgICAqICAgdGhpcy5hID0gMTtcbiAgICAgKiAgIHRoaXMuYiA9IDI7XG4gICAgICogfVxuICAgICAqXG4gICAgICogRm9vLnByb3RvdHlwZS5jID0gMztcbiAgICAgKlxuICAgICAqIF8udG9QYWlyc0luKG5ldyBGb28pO1xuICAgICAqIC8vID0+IFtbJ2EnLCAxXSwgWydiJywgMl0sIFsnYycsIDNdXSAoaXRlcmF0aW9uIG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgICAqL1xuICAgIHZhciB0b1BhaXJzSW4gPSBjcmVhdGVUb1BhaXJzKGtleXNJbik7XG5cbiAgICAvKipcbiAgICAgKiBBbiBhbHRlcm5hdGl2ZSB0byBgXy5yZWR1Y2VgOyB0aGlzIG1ldGhvZCB0cmFuc2Zvcm1zIGBvYmplY3RgIHRvIGEgbmV3XG4gICAgICogYGFjY3VtdWxhdG9yYCBvYmplY3Qgd2hpY2ggaXMgdGhlIHJlc3VsdCBvZiBydW5uaW5nIGVhY2ggb2YgaXRzIG93blxuICAgICAqIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnRpZXMgdGhydSBgaXRlcmF0ZWVgLCB3aXRoIGVhY2ggaW52b2NhdGlvblxuICAgICAqIHBvdGVudGlhbGx5IG11dGF0aW5nIHRoZSBgYWNjdW11bGF0b3JgIG9iamVjdC4gSWYgYGFjY3VtdWxhdG9yYCBpcyBub3RcbiAgICAgKiBwcm92aWRlZCwgYSBuZXcgb2JqZWN0IHdpdGggdGhlIHNhbWUgYFtbUHJvdG90eXBlXV1gIHdpbGwgYmUgdXNlZC4gVGhlXG4gICAgICogaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIGZvdXIgYXJndW1lbnRzOiAoYWNjdW11bGF0b3IsIHZhbHVlLCBrZXksIG9iamVjdCkuXG4gICAgICogSXRlcmF0ZWUgZnVuY3Rpb25zIG1heSBleGl0IGl0ZXJhdGlvbiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMy4wXG4gICAgICogQGNhdGVnb3J5IE9iamVjdFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBmdW5jdGlvbiBpbnZva2VkIHBlciBpdGVyYXRpb24uXG4gICAgICogQHBhcmFtIHsqfSBbYWNjdW11bGF0b3JdIFRoZSBjdXN0b20gYWNjdW11bGF0b3IgdmFsdWUuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGFjY3VtdWxhdGVkIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyYW5zZm9ybShbMiwgMywgNF0sIGZ1bmN0aW9uKHJlc3VsdCwgbikge1xuICAgICAqICAgcmVzdWx0LnB1c2gobiAqPSBuKTtcbiAgICAgKiAgIHJldHVybiBuICUgMiA9PSAwO1xuICAgICAqIH0sIFtdKTtcbiAgICAgKiAvLyA9PiBbNCwgOV1cbiAgICAgKlxuICAgICAqIF8udHJhbnNmb3JtKHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMSB9LCBmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICAgKiAgIChyZXN1bHRbdmFsdWVdIHx8IChyZXN1bHRbdmFsdWVdID0gW10pKS5wdXNoKGtleSk7XG4gICAgICogfSwge30pO1xuICAgICAqIC8vID0+IHsgJzEnOiBbJ2EnLCAnYyddLCAnMic6IFsnYiddIH1cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmFuc2Zvcm0ob2JqZWN0LCBpdGVyYXRlZSwgYWNjdW11bGF0b3IpIHtcbiAgICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqZWN0KSxcbiAgICAgICAgICBpc0Fyckxpa2UgPSBpc0FyciB8fCBpc0J1ZmZlcihvYmplY3QpIHx8IGlzVHlwZWRBcnJheShvYmplY3QpO1xuXG4gICAgICBpdGVyYXRlZSA9IGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCA0KTtcbiAgICAgIGlmIChhY2N1bXVsYXRvciA9PSBudWxsKSB7XG4gICAgICAgIHZhciBDdG9yID0gb2JqZWN0ICYmIG9iamVjdC5jb25zdHJ1Y3RvcjtcbiAgICAgICAgaWYgKGlzQXJyTGlrZSkge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0gaXNBcnIgPyBuZXcgQ3RvciA6IFtdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGlzT2JqZWN0KG9iamVjdCkpIHtcbiAgICAgICAgICBhY2N1bXVsYXRvciA9IGlzRnVuY3Rpb24oQ3RvcikgPyBiYXNlQ3JlYXRlKGdldFByb3RvdHlwZShvYmplY3QpKSA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGFjY3VtdWxhdG9yID0ge307XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIChpc0Fyckxpa2UgPyBhcnJheUVhY2ggOiBiYXNlRm9yT3duKShvYmplY3QsIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgb2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBpdGVyYXRlZShhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBvYmplY3QpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyB0aGUgcHJvcGVydHkgYXQgYHBhdGhgIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gdW5zZXQuXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBwcm9wZXJ0eSBpcyBkZWxldGVkLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogW3sgJ2InOiB7ICdjJzogNyB9IH1dIH07XG4gICAgICogXy51bnNldChvYmplY3QsICdhWzBdLmIuYycpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdCk7XG4gICAgICogLy8gPT4geyAnYSc6IFt7ICdiJzoge30gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udW5zZXQob2JqZWN0LCBbJ2EnLCAnMCcsICdiJywgJ2MnXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0KTtcbiAgICAgKiAvLyA9PiB7ICdhJzogW3sgJ2InOiB7fSB9XSB9O1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgICAgcmV0dXJuIG9iamVjdCA9PSBudWxsID8gdHJ1ZSA6IGJhc2VVbnNldChvYmplY3QsIHBhdGgpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uc2V0YCBleGNlcHQgdGhhdCBhY2NlcHRzIGB1cGRhdGVyYCB0byBwcm9kdWNlIHRoZVxuICAgICAqIHZhbHVlIHRvIHNldC4gVXNlIGBfLnVwZGF0ZVdpdGhgIHRvIGN1c3RvbWl6ZSBgcGF0aGAgY3JlYXRpb24uIFRoZSBgdXBkYXRlcmBcbiAgICAgKiBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdCA9IHsgJ2EnOiBbeyAnYic6IHsgJ2MnOiAzIH0gfV0gfTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlKG9iamVjdCwgJ2FbMF0uYi5jJywgZnVuY3Rpb24obikgeyByZXR1cm4gbiAqIG47IH0pO1xuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdC5hWzBdLmIuYyk7XG4gICAgICogLy8gPT4gOVxuICAgICAqXG4gICAgICogXy51cGRhdGUob2JqZWN0LCAneFswXS55LnonLCBmdW5jdGlvbihuKSB7IHJldHVybiBuID8gbiArIDEgOiAwOyB9KTtcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3QueFswXS55LnopO1xuICAgICAqIC8vID0+IDBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1cGRhdGUob2JqZWN0LCBwYXRoLCB1cGRhdGVyKSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBvYmplY3QgOiBiYXNlVXBkYXRlKG9iamVjdCwgcGF0aCwgY2FzdEZ1bmN0aW9uKHVwZGF0ZXIpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyBsaWtlIGBfLnVwZGF0ZWAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgY3VzdG9taXplcmAgd2hpY2ggaXNcbiAgICAgKiBpbnZva2VkIHRvIHByb2R1Y2UgdGhlIG9iamVjdHMgb2YgYHBhdGhgLiAgSWYgYGN1c3RvbWl6ZXJgIHJldHVybnMgYHVuZGVmaW5lZGBcbiAgICAgKiBwYXRoIGNyZWF0aW9uIGlzIGhhbmRsZWQgYnkgdGhlIG1ldGhvZCBpbnN0ZWFkLiBUaGUgYGN1c3RvbWl6ZXJgIGlzIGludm9rZWRcbiAgICAgKiB3aXRoIHRocmVlIGFyZ3VtZW50czogKG5zVmFsdWUsIGtleSwgbnNPYmplY3QpLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIG11dGF0ZXMgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC42LjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gc2V0LlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IHVwZGF0ZXIgVGhlIGZ1bmN0aW9uIHRvIHByb2R1Y2UgdGhlIHVwZGF0ZWQgdmFsdWUuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2N1c3RvbWl6ZXJdIFRoZSBmdW5jdGlvbiB0byBjdXN0b21pemUgYXNzaWduZWQgdmFsdWVzLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7fTtcbiAgICAgKlxuICAgICAqIF8udXBkYXRlV2l0aChvYmplY3QsICdbMF1bMV0nLCBfLmNvbnN0YW50KCdhJyksIE9iamVjdCk7XG4gICAgICogLy8gPT4geyAnMCc6IHsgJzEnOiAnYScgfSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gdXBkYXRlV2l0aChvYmplY3QsIHBhdGgsIHVwZGF0ZXIsIGN1c3RvbWl6ZXIpIHtcbiAgICAgIGN1c3RvbWl6ZXIgPSB0eXBlb2YgY3VzdG9taXplciA9PSAnZnVuY3Rpb24nID8gY3VzdG9taXplciA6IHVuZGVmaW5lZDtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IG9iamVjdCA6IGJhc2VVcGRhdGUob2JqZWN0LCBwYXRoLCBjYXN0RnVuY3Rpb24odXBkYXRlciksIGN1c3RvbWl6ZXIpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBlbnVtZXJhYmxlIHN0cmluZyBrZXllZCBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogTm9uLW9iamVjdCB2YWx1ZXMgYXJlIGNvZXJjZWQgdG8gb2JqZWN0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBPYmplY3RcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIEZvbygpIHtcbiAgICAgKiAgIHRoaXMuYSA9IDE7XG4gICAgICogICB0aGlzLmIgPSAyO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIEZvby5wcm90b3R5cGUuYyA9IDM7XG4gICAgICpcbiAgICAgKiBfLnZhbHVlcyhuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMl0gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKlxuICAgICAqIF8udmFsdWVzKCdoaScpO1xuICAgICAqIC8vID0+IFsnaCcsICdpJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXMob2JqZWN0KSB7XG4gICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyBbXSA6IGJhc2VWYWx1ZXMob2JqZWN0LCBrZXlzKG9iamVjdCkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgdGhlIG93biBhbmQgaW5oZXJpdGVkIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIHByb3BlcnR5XG4gICAgICogdmFsdWVzIG9mIGBvYmplY3RgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vbi1vYmplY3QgdmFsdWVzIGFyZSBjb2VyY2VkIHRvIG9iamVjdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgT2JqZWN0XG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIHF1ZXJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcHJvcGVydHkgdmFsdWVzLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBmdW5jdGlvbiBGb28oKSB7XG4gICAgICogICB0aGlzLmEgPSAxO1xuICAgICAqICAgdGhpcy5iID0gMjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiBGb28ucHJvdG90eXBlLmMgPSAzO1xuICAgICAqXG4gICAgICogXy52YWx1ZXNJbihuZXcgRm9vKTtcbiAgICAgKiAvLyA9PiBbMSwgMiwgM10gKGl0ZXJhdGlvbiBvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB2YWx1ZXNJbihvYmplY3QpIHtcbiAgICAgIHJldHVybiBvYmplY3QgPT0gbnVsbCA/IFtdIDogYmFzZVZhbHVlcyhvYmplY3QsIGtleXNJbihvYmplY3QpKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDbGFtcHMgYG51bWJlcmAgd2l0aGluIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTnVtYmVyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIGNsYW1wLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbG93ZXJdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gdXBwZXIgVGhlIHVwcGVyIGJvdW5kLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNsYW1wZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNsYW1wKC0xMCwgLTUsIDUpO1xuICAgICAqIC8vID0+IC01XG4gICAgICpcbiAgICAgKiBfLmNsYW1wKDEwLCAtNSwgNSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNsYW1wKG51bWJlciwgbG93ZXIsIHVwcGVyKSB7XG4gICAgICBpZiAodXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmICh1cHBlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHVwcGVyID0gdG9OdW1iZXIodXBwZXIpO1xuICAgICAgICB1cHBlciA9IHVwcGVyID09PSB1cHBlciA/IHVwcGVyIDogMDtcbiAgICAgIH1cbiAgICAgIGlmIChsb3dlciAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGxvd2VyID0gdG9OdW1iZXIobG93ZXIpO1xuICAgICAgICBsb3dlciA9IGxvd2VyID09PSBsb3dlciA/IGxvd2VyIDogMDtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlQ2xhbXAodG9OdW1iZXIobnVtYmVyKSwgbG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDaGVja3MgaWYgYG5gIGlzIGJldHdlZW4gYHN0YXJ0YCBhbmQgdXAgdG8sIGJ1dCBub3QgaW5jbHVkaW5nLCBgZW5kYC4gSWZcbiAgICAgKiBgZW5kYCBpcyBub3Qgc3BlY2lmaWVkLCBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICogSWYgYHN0YXJ0YCBpcyBncmVhdGVyIHRoYW4gYGVuZGAgdGhlIHBhcmFtcyBhcmUgc3dhcHBlZCB0byBzdXBwb3J0XG4gICAgICogbmVnYXRpdmUgcmFuZ2VzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMy4wXG4gICAgICogQGNhdGVnb3J5IE51bWJlclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byBjaGVjay5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGVuZCBUaGUgZW5kIG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYG51bWJlcmAgaXMgaW4gdGhlIHJhbmdlLCBlbHNlIGBmYWxzZWAuXG4gICAgICogQHNlZSBfLnJhbmdlLCBfLnJhbmdlUmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDMsIDIsIDQpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSg0LCA4KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLmluUmFuZ2UoNCwgMik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgyLCAyKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDEuMiwgMik7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5pblJhbmdlKDUuMiwgNCk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uaW5SYW5nZSgtMywgLTIsIC02KTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gaW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9GaW5pdGUoc3RhcnQpO1xuICAgICAgaWYgKGVuZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGVuZCA9IHN0YXJ0O1xuICAgICAgICBzdGFydCA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbmQgPSB0b0Zpbml0ZShlbmQpO1xuICAgICAgfVxuICAgICAgbnVtYmVyID0gdG9OdW1iZXIobnVtYmVyKTtcbiAgICAgIHJldHVybiBiYXNlSW5SYW5nZShudW1iZXIsIHN0YXJ0LCBlbmQpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VzIGEgcmFuZG9tIG51bWJlciBiZXR3ZWVuIHRoZSBpbmNsdXNpdmUgYGxvd2VyYCBhbmQgYHVwcGVyYCBib3VuZHMuXG4gICAgICogSWYgb25seSBvbmUgYXJndW1lbnQgaXMgcHJvdmlkZWQgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXJcbiAgICAgKiBpcyByZXR1cm5lZC4gSWYgYGZsb2F0aW5nYCBpcyBgdHJ1ZWAsIG9yIGVpdGhlciBgbG93ZXJgIG9yIGB1cHBlcmAgYXJlXG4gICAgICogZmxvYXRzLCBhIGZsb2F0aW5nLXBvaW50IG51bWJlciBpcyByZXR1cm5lZCBpbnN0ZWFkIG9mIGFuIGludGVnZXIuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAwLjcuMFxuICAgICAqIEBjYXRlZ29yeSBOdW1iZXJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xvd2VyPTBdIFRoZSBsb3dlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3VwcGVyPTFdIFRoZSB1cHBlciBib3VuZC5cbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmbG9hdGluZ10gU3BlY2lmeSByZXR1cm5pbmcgYSBmbG9hdGluZy1wb2ludCBudW1iZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcmFuZG9tIG51bWJlci5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMCwgNSk7XG4gICAgICogLy8gPT4gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUpO1xuICAgICAqIC8vID0+IGFsc28gYW4gaW50ZWdlciBiZXR3ZWVuIDAgYW5kIDVcbiAgICAgKlxuICAgICAqIF8ucmFuZG9tKDUsIHRydWUpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMCBhbmQgNVxuICAgICAqXG4gICAgICogXy5yYW5kb20oMS4yLCA1LjIpO1xuICAgICAqIC8vID0+IGEgZmxvYXRpbmctcG9pbnQgbnVtYmVyIGJldHdlZW4gMS4yIGFuZCA1LjJcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByYW5kb20obG93ZXIsIHVwcGVyLCBmbG9hdGluZykge1xuICAgICAgaWYgKGZsb2F0aW5nICYmIHR5cGVvZiBmbG9hdGluZyAhPSAnYm9vbGVhbicgJiYgaXNJdGVyYXRlZUNhbGwobG93ZXIsIHVwcGVyLCBmbG9hdGluZykpIHtcbiAgICAgICAgdXBwZXIgPSBmbG9hdGluZyA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGlmIChmbG9hdGluZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdXBwZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSB1cHBlcjtcbiAgICAgICAgICB1cHBlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgbG93ZXIgPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgICAgZmxvYXRpbmcgPSBsb3dlcjtcbiAgICAgICAgICBsb3dlciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID09PSB1bmRlZmluZWQgJiYgdXBwZXIgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBsb3dlciA9IDA7XG4gICAgICAgIHVwcGVyID0gMTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBsb3dlciA9IHRvRmluaXRlKGxvd2VyKTtcbiAgICAgICAgaWYgKHVwcGVyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICB1cHBlciA9IGxvd2VyO1xuICAgICAgICAgIGxvd2VyID0gMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB1cHBlciA9IHRvRmluaXRlKHVwcGVyKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGxvd2VyID4gdXBwZXIpIHtcbiAgICAgICAgdmFyIHRlbXAgPSBsb3dlcjtcbiAgICAgICAgbG93ZXIgPSB1cHBlcjtcbiAgICAgICAgdXBwZXIgPSB0ZW1wO1xuICAgICAgfVxuICAgICAgaWYgKGZsb2F0aW5nIHx8IGxvd2VyICUgMSB8fCB1cHBlciAlIDEpIHtcbiAgICAgICAgdmFyIHJhbmQgPSBuYXRpdmVSYW5kb20oKTtcbiAgICAgICAgcmV0dXJuIG5hdGl2ZU1pbihsb3dlciArIChyYW5kICogKHVwcGVyIC0gbG93ZXIgKyBmcmVlUGFyc2VGbG9hdCgnMWUtJyArICgocmFuZCArICcnKS5sZW5ndGggLSAxKSkpKSwgdXBwZXIpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGJhc2VSYW5kb20obG93ZXIsIHVwcGVyKTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0byBbY2FtZWwgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvQ2FtZWxDYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGNhbWVsIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vQmFyJ1xuICAgICAqXG4gICAgICogXy5jYW1lbENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ2Zvb0JhcidcbiAgICAgKlxuICAgICAqIF8uY2FtZWxDYXNlKCdfX0ZPT19CQVJfXycpO1xuICAgICAqIC8vID0+ICdmb29CYXInXG4gICAgICovXG4gICAgdmFyIGNhbWVsQ2FzZSA9IGNyZWF0ZUNvbXBvdW5kZXIoZnVuY3Rpb24ocmVzdWx0LCB3b3JkLCBpbmRleCkge1xuICAgICAgd29yZCA9IHdvcmQudG9Mb3dlckNhc2UoKTtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyBjYXBpdGFsaXplKHdvcmQpIDogd29yZCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyB0aGUgZmlyc3QgY2hhcmFjdGVyIG9mIGBzdHJpbmdgIHRvIHVwcGVyIGNhc2UgYW5kIHRoZSByZW1haW5pbmdcbiAgICAgKiB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNhcGl0YWxpemUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY2FwaXRhbGl6ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNhcGl0YWxpemUoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRnJlZCdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBjYXBpdGFsaXplKHN0cmluZykge1xuICAgICAgcmV0dXJuIHVwcGVyRmlyc3QodG9TdHJpbmcoc3RyaW5nKS50b0xvd2VyQ2FzZSgpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBEZWJ1cnJzIGBzdHJpbmdgIGJ5IGNvbnZlcnRpbmdcbiAgICAgKiBbTGF0aW4tMSBTdXBwbGVtZW50XShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9MYXRpbi0xX1N1cHBsZW1lbnRfKFVuaWNvZGVfYmxvY2spI0NoYXJhY3Rlcl90YWJsZSlcbiAgICAgKiBhbmQgW0xhdGluIEV4dGVuZGVkLUFdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0xhdGluX0V4dGVuZGVkLUEpXG4gICAgICogbGV0dGVycyB0byBiYXNpYyBMYXRpbiBsZXR0ZXJzIGFuZCByZW1vdmluZ1xuICAgICAqIFtjb21iaW5pbmcgZGlhY3JpdGljYWwgbWFya3NdKGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0NvbWJpbmluZ19EaWFjcml0aWNhbF9NYXJrcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gZGVidXJyLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGRlYnVycmVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWJ1cnIoJ2TDqWrDoCB2dScpO1xuICAgICAqIC8vID0+ICdkZWphIHZ1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIGRlYnVycihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gc3RyaW5nICYmIHN0cmluZy5yZXBsYWNlKHJlTGF0aW4sIGRlYnVyckxldHRlcikucmVwbGFjZShyZUNvbWJvTWFyaywgJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBlbmRzIHdpdGggdGhlIGdpdmVuIHRhcmdldCBzdHJpbmcuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gaW5zcGVjdC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3RhcmdldF0gVGhlIHN0cmluZyB0byBzZWFyY2ggZm9yLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcG9zaXRpb249c3RyaW5nLmxlbmd0aF0gVGhlIHBvc2l0aW9uIHRvIHNlYXJjaCB1cCB0by5cbiAgICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHN0cmluZ2AgZW5kcyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZW5kc1dpdGgoJ2FiYycsICdjJyk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InKTtcbiAgICAgKiAvLyA9PiBmYWxzZVxuICAgICAqXG4gICAgICogXy5lbmRzV2l0aCgnYWJjJywgJ2InLCAyKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gZW5kc1dpdGgoc3RyaW5nLCB0YXJnZXQsIHBvc2l0aW9uKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgdGFyZ2V0ID0gYmFzZVRvU3RyaW5nKHRhcmdldCk7XG5cbiAgICAgIHZhciBsZW5ndGggPSBzdHJpbmcubGVuZ3RoO1xuICAgICAgcG9zaXRpb24gPSBwb3NpdGlvbiA9PT0gdW5kZWZpbmVkXG4gICAgICAgID8gbGVuZ3RoXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIGxlbmd0aCk7XG5cbiAgICAgIHZhciBlbmQgPSBwb3NpdGlvbjtcbiAgICAgIHBvc2l0aW9uIC09IHRhcmdldC5sZW5ndGg7XG4gICAgICByZXR1cm4gcG9zaXRpb24gPj0gMCAmJiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIGVuZCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIFwiJlwiLCBcIjxcIiwgXCI+XCIsICdcIicsIGFuZCBcIidcIiBpbiBgc3RyaW5nYCB0byB0aGVpclxuICAgICAqIGNvcnJlc3BvbmRpbmcgSFRNTCBlbnRpdGllcy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBObyBvdGhlciBjaGFyYWN0ZXJzIGFyZSBlc2NhcGVkLiBUbyBlc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIGNoYXJhY3RlcnMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogVGhvdWdoIHRoZSBcIj5cIiBjaGFyYWN0ZXIgaXMgZXNjYXBlZCBmb3Igc3ltbWV0cnksIGNoYXJhY3RlcnMgbGlrZVxuICAgICAqIFwiPlwiIGFuZCBcIi9cIiBkb24ndCBuZWVkIGVzY2FwaW5nIGluIEhUTUwgYW5kIGhhdmUgbm8gc3BlY2lhbCBtZWFuaW5nXG4gICAgICogdW5sZXNzIHRoZXkncmUgcGFydCBvZiBhIHRhZyBvciB1bnF1b3RlZCBhdHRyaWJ1dGUgdmFsdWUuIFNlZVxuICAgICAqIFtNYXRoaWFzIEJ5bmVucydzIGFydGljbGVdKGh0dHBzOi8vbWF0aGlhc2J5bmVucy5iZS9ub3Rlcy9hbWJpZ3VvdXMtYW1wZXJzYW5kcylcbiAgICAgKiAodW5kZXIgXCJzZW1pLXJlbGF0ZWQgZnVuIGZhY3RcIikgZm9yIG1vcmUgZGV0YWlscy5cbiAgICAgKlxuICAgICAqIFdoZW4gd29ya2luZyB3aXRoIEhUTUwgeW91IHNob3VsZCBhbHdheXNcbiAgICAgKiBbcXVvdGUgYXR0cmlidXRlIHZhbHVlc10oaHR0cDovL3dvbmtvLmNvbS9wb3N0L2h0bWwtZXNjYXBpbmcpIHRvIHJlZHVjZVxuICAgICAqIFhTUyB2ZWN0b3JzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJiBwZWJibGVzJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBlc2NhcGUoc3RyaW5nKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcmV0dXJuIChzdHJpbmcgJiYgcmVIYXNVbmVzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBFc2NhcGVzIHRoZSBgUmVnRXhwYCBzcGVjaWFsIGNoYXJhY3RlcnMgXCJeXCIsIFwiJFwiLCBcIlxcXCIsIFwiLlwiLCBcIipcIiwgXCIrXCIsXG4gICAgICogXCI/XCIsIFwiKFwiLCBcIilcIiwgXCJbXCIsIFwiXVwiLCBcIntcIiwgXCJ9XCIsIGFuZCBcInxcIiBpbiBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBlc2NhcGUuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZXNjYXBlUmVnRXhwKCdbbG9kYXNoXShodHRwczovL2xvZGFzaC5jb20vKScpO1xuICAgICAqIC8vID0+ICdcXFtsb2Rhc2hcXF1cXChodHRwczovL2xvZGFzaFxcLmNvbS9cXCknXG4gICAgICovXG4gICAgZnVuY3Rpb24gZXNjYXBlUmVnRXhwKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIHJldHVybiAoc3RyaW5nICYmIHJlSGFzUmVnRXhwQ2hhci50ZXN0KHN0cmluZykpXG4gICAgICAgID8gc3RyaW5nLnJlcGxhY2UocmVSZWdFeHBDaGFyLCAnXFxcXCQmJylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBba2ViYWIgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3BlY2lhbF9jYXNlX3N0eWxlcykuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBrZWJhYiBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ua2ViYWJDYXNlKCdGb28gQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2Zvby1iYXInXG4gICAgICpcbiAgICAgKiBfLmtlYmFiQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vLWJhcidcbiAgICAgKi9cbiAgICB2YXIga2ViYWJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJy0nIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AsIGFzIHNwYWNlIHNlcGFyYXRlZCB3b3JkcywgdG8gbG93ZXIgY2FzZS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIGxvd2VyIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckNhc2UoJy0tRm9vLUJhci0tJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ2ZvbyBiYXInXG4gICAgICpcbiAgICAgKiBfLmxvd2VyQ2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnZm9vIGJhcidcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b0xvd2VyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byBsb3dlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5sb3dlckZpcnN0KCdGcmVkJyk7XG4gICAgICogLy8gPT4gJ2ZyZWQnXG4gICAgICpcbiAgICAgKiBfLmxvd2VyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnZlJFRCdcbiAgICAgKi9cbiAgICB2YXIgbG93ZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9Mb3dlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFBhZHMgYHN0cmluZ2Agb24gdGhlIGxlZnQgYW5kIHJpZ2h0IHNpZGVzIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLlxuICAgICAqIFBhZGRpbmcgY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgY2FuJ3QgYmUgZXZlbmx5IGRpdmlkZWQgYnkgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWQoJ2FiYycsIDgpO1xuICAgICAqIC8vID0+ICcgIGFiYyAgICdcbiAgICAgKlxuICAgICAqIF8ucGFkKCdhYmMnLCA4LCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnXy1hYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgaWYgKCFsZW5ndGggfHwgc3RyTGVuZ3RoID49IGxlbmd0aCkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIG1pZCA9IChsZW5ndGggLSBzdHJMZW5ndGgpIC8gMjtcbiAgICAgIHJldHVybiAoXG4gICAgICAgIGNyZWF0ZVBhZGRpbmcobmF0aXZlRmxvb3IobWlkKSwgY2hhcnMpICtcbiAgICAgICAgc3RyaW5nICtcbiAgICAgICAgY3JlYXRlUGFkZGluZyhuYXRpdmVDZWlsKG1pZCksIGNoYXJzKVxuICAgICAgKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSByaWdodCBzaWRlIGlmIGl0J3Mgc2hvcnRlciB0aGFuIGBsZW5ndGhgLiBQYWRkaW5nXG4gICAgICogY2hhcmFjdGVycyBhcmUgdHJ1bmNhdGVkIGlmIHRoZXkgZXhjZWVkIGBsZW5ndGhgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHBhZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2xlbmd0aD0wXSBUaGUgcGFkZGluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz0nICddIFRoZSBzdHJpbmcgdXNlZCBhcyBwYWRkaW5nLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHBhZGRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucGFkRW5kKCdhYmMnLCA2KTtcbiAgICAgKiAvLyA9PiAnYWJjICAgJ1xuICAgICAqXG4gICAgICogXy5wYWRFbmQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmNfLV8nXG4gICAgICpcbiAgICAgKiBfLnBhZEVuZCgnYWJjJywgMyk7XG4gICAgICogLy8gPT4gJ2FiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBwYWRFbmQoc3RyaW5nLCBsZW5ndGgsIGNoYXJzKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgbGVuZ3RoID0gdG9JbnRlZ2VyKGxlbmd0aCk7XG5cbiAgICAgIHZhciBzdHJMZW5ndGggPSBsZW5ndGggPyBzdHJpbmdTaXplKHN0cmluZykgOiAwO1xuICAgICAgcmV0dXJuIChsZW5ndGggJiYgc3RyTGVuZ3RoIDwgbGVuZ3RoKVxuICAgICAgICA/IChzdHJpbmcgKyBjcmVhdGVQYWRkaW5nKGxlbmd0aCAtIHN0ckxlbmd0aCwgY2hhcnMpKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBQYWRzIGBzdHJpbmdgIG9uIHRoZSBsZWZ0IHNpZGUgaWYgaXQncyBzaG9ydGVyIHRoYW4gYGxlbmd0aGAuIFBhZGRpbmdcbiAgICAgKiBjaGFyYWN0ZXJzIGFyZSB0cnVuY2F0ZWQgaWYgdGhleSBleGNlZWQgYGxlbmd0aGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcGFkLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGVuZ3RoPTBdIFRoZSBwYWRkaW5nIGxlbmd0aC5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW2NoYXJzPScgJ10gVGhlIHN0cmluZyB1c2VkIGFzIHBhZGRpbmcuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcGFkZGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5wYWRTdGFydCgnYWJjJywgNik7XG4gICAgICogLy8gPT4gJyAgIGFiYydcbiAgICAgKlxuICAgICAqIF8ucGFkU3RhcnQoJ2FiYycsIDYsICdfLScpO1xuICAgICAqIC8vID0+ICdfLV9hYmMnXG4gICAgICpcbiAgICAgKiBfLnBhZFN0YXJ0KCdhYmMnLCAzKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHBhZFN0YXJ0KHN0cmluZywgbGVuZ3RoLCBjaGFycykge1xuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGxlbmd0aCA9IHRvSW50ZWdlcihsZW5ndGgpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gbGVuZ3RoID8gc3RyaW5nU2l6ZShzdHJpbmcpIDogMDtcbiAgICAgIHJldHVybiAobGVuZ3RoICYmIHN0ckxlbmd0aCA8IGxlbmd0aClcbiAgICAgICAgPyAoY3JlYXRlUGFkZGluZyhsZW5ndGggLSBzdHJMZW5ndGgsIGNoYXJzKSArIHN0cmluZylcbiAgICAgICAgOiBzdHJpbmc7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG8gYW4gaW50ZWdlciBvZiB0aGUgc3BlY2lmaWVkIHJhZGl4LiBJZiBgcmFkaXhgIGlzXG4gICAgICogYHVuZGVmaW5lZGAgb3IgYDBgLCBhIGByYWRpeGAgb2YgYDEwYCBpcyB1c2VkIHVubGVzcyBgdmFsdWVgIGlzIGFcbiAgICAgKiBoZXhhZGVjaW1hbCwgaW4gd2hpY2ggY2FzZSBhIGByYWRpeGAgb2YgYDE2YCBpcyB1c2VkLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGFsaWducyB3aXRoIHRoZVxuICAgICAqIFtFUzUgaW1wbGVtZW50YXRpb25dKGh0dHBzOi8vZXM1LmdpdGh1Yi5pby8jeDE1LjEuMi4yKSBvZiBgcGFyc2VJbnRgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDEuMS4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBzdHJpbmcgVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbcmFkaXg9MTBdIFRoZSByYWRpeCB0byBpbnRlcnByZXQgYHZhbHVlYCBieS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIGNvbnZlcnRlZCBpbnRlZ2VyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnBhcnNlSW50KCcwOCcpO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnNicsICcwOCcsICcxMCddLCBfLnBhcnNlSW50KTtcbiAgICAgKiAvLyA9PiBbNiwgOCwgMTBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcGFyc2VJbnQoc3RyaW5nLCByYWRpeCwgZ3VhcmQpIHtcbiAgICAgIGlmIChndWFyZCB8fCByYWRpeCA9PSBudWxsKSB7XG4gICAgICAgIHJhZGl4ID0gMDtcbiAgICAgIH0gZWxzZSBpZiAocmFkaXgpIHtcbiAgICAgICAgcmFkaXggPSArcmFkaXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmF0aXZlUGFyc2VJbnQodG9TdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyksIHJhZGl4IHx8IDApO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGVhdHMgdGhlIGdpdmVuIHN0cmluZyBgbmAgdGltZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gcmVwZWF0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIHJlcGVhdCB0aGUgc3RyaW5nLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgcmVwZWF0ZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnKicsIDMpO1xuICAgICAqIC8vID0+ICcqKionXG4gICAgICpcbiAgICAgKiBfLnJlcGVhdCgnYWJjJywgMik7XG4gICAgICogLy8gPT4gJ2FiY2FiYydcbiAgICAgKlxuICAgICAqIF8ucmVwZWF0KCdhYmMnLCAwKTtcbiAgICAgKiAvLyA9PiAnJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHJlcGVhdChzdHJpbmcsIG4sIGd1YXJkKSB7XG4gICAgICBpZiAoKGd1YXJkID8gaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBuLCBndWFyZCkgOiBuID09PSB1bmRlZmluZWQpKSB7XG4gICAgICAgIG4gPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbiA9IHRvSW50ZWdlcihuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBiYXNlUmVwZWF0KHRvU3RyaW5nKHN0cmluZyksIG4pO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlcGxhY2VzIG1hdGNoZXMgZm9yIGBwYXR0ZXJuYCBpbiBgc3RyaW5nYCB3aXRoIGByZXBsYWNlbWVudGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNyZXBsYWNlYF0oaHR0cHM6Ly9tZG4uaW8vU3RyaW5nL3JlcGxhY2UpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIG1vZGlmeS5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IHBhdHRlcm4gVGhlIHBhdHRlcm4gdG8gcmVwbGFjZS5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufHN0cmluZ30gcmVwbGFjZW1lbnQgVGhlIG1hdGNoIHJlcGxhY2VtZW50LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIG1vZGlmaWVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yZXBsYWNlKCdIaSBGcmVkJywgJ0ZyZWQnLCAnQmFybmV5Jyk7XG4gICAgICogLy8gPT4gJ0hpIEJhcm5leSdcbiAgICAgKi9cbiAgICBmdW5jdGlvbiByZXBsYWNlKCkge1xuICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHMsXG4gICAgICAgICAgc3RyaW5nID0gdG9TdHJpbmcoYXJnc1swXSk7XG5cbiAgICAgIHJldHVybiBhcmdzLmxlbmd0aCA8IDMgPyBzdHJpbmcgOiBzdHJpbmcucmVwbGFjZShhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCB0b1xuICAgICAqIFtzbmFrZSBjYXNlXShodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9TbmFrZV9jYXNlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHNuYWtlIGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zbmFrZUNhc2UoJ0ZvbyBCYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCdmb29CYXInKTtcbiAgICAgKiAvLyA9PiAnZm9vX2JhcidcbiAgICAgKlxuICAgICAqIF8uc25ha2VDYXNlKCctLUZPTy1CQVItLScpO1xuICAgICAqIC8vID0+ICdmb29fYmFyJ1xuICAgICAqL1xuICAgIHZhciBzbmFrZUNhc2UgPSBjcmVhdGVDb21wb3VuZGVyKGZ1bmN0aW9uKHJlc3VsdCwgd29yZCwgaW5kZXgpIHtcbiAgICAgIHJldHVybiByZXN1bHQgKyAoaW5kZXggPyAnXycgOiAnJykgKyB3b3JkLnRvTG93ZXJDYXNlKCk7XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBTcGxpdHMgYHN0cmluZ2AgYnkgYHNlcGFyYXRvcmAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogVGhpcyBtZXRob2QgaXMgYmFzZWQgb25cbiAgICAgKiBbYFN0cmluZyNzcGxpdGBdKGh0dHBzOi8vbWRuLmlvL1N0cmluZy9zcGxpdCkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gc3BsaXQuXG4gICAgICogQHBhcmFtIHtSZWdFeHB8c3RyaW5nfSBzZXBhcmF0b3IgVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHNwbGl0IGJ5LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbGltaXRdIFRoZSBsZW5ndGggdG8gdHJ1bmNhdGUgcmVzdWx0cyB0by5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHN0cmluZyBzZWdtZW50cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zcGxpdCgnYS1iLWMnLCAnLScsIDIpO1xuICAgICAqIC8vID0+IFsnYScsICdiJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzcGxpdChzdHJpbmcsIHNlcGFyYXRvciwgbGltaXQpIHtcbiAgICAgIGlmIChsaW1pdCAmJiB0eXBlb2YgbGltaXQgIT0gJ251bWJlcicgJiYgaXNJdGVyYXRlZUNhbGwoc3RyaW5nLCBzZXBhcmF0b3IsIGxpbWl0KSkge1xuICAgICAgICBzZXBhcmF0b3IgPSBsaW1pdCA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICAgIGxpbWl0ID0gbGltaXQgPT09IHVuZGVmaW5lZCA/IE1BWF9BUlJBWV9MRU5HVEggOiBsaW1pdCA+Pj4gMDtcbiAgICAgIGlmICghbGltaXQpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIGlmIChzdHJpbmcgJiYgKFxuICAgICAgICAgICAgdHlwZW9mIHNlcGFyYXRvciA9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgKHNlcGFyYXRvciAhPSBudWxsICYmICFpc1JlZ0V4cChzZXBhcmF0b3IpKVxuICAgICAgICAgICkpIHtcbiAgICAgICAgc2VwYXJhdG9yID0gYmFzZVRvU3RyaW5nKHNlcGFyYXRvcik7XG4gICAgICAgIGlmICghc2VwYXJhdG9yICYmIGhhc1VuaWNvZGUoc3RyaW5nKSkge1xuICAgICAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyaW5nVG9BcnJheShzdHJpbmcpLCAwLCBsaW1pdCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBzdHJpbmcuc3BsaXQoc2VwYXJhdG9yLCBsaW1pdCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHN0cmluZ2AgdG9cbiAgICAgKiBbc3RhcnQgY2FzZV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGV0dGVyX2Nhc2UjU3R5bGlzdGljX29yX3NwZWNpYWxpc2VkX3VzYWdlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBjb252ZXJ0LlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHN0YXJ0IGNhc2VkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdGFydENhc2UoJy0tZm9vLWJhci0tJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZvbyBCYXInXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0Q2FzZSgnX19GT09fQkFSX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgc3RhcnRDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgdXBwZXJGaXJzdCh3b3JkKTtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENoZWNrcyBpZiBgc3RyaW5nYCBzdGFydHMgd2l0aCB0aGUgZ2l2ZW4gdGFyZ2V0IHN0cmluZy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbdGFyZ2V0XSBUaGUgc3RyaW5nIHRvIHNlYXJjaCBmb3IuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwb3NpdGlvbj0wXSBUaGUgcG9zaXRpb24gdG8gc2VhcmNoIGZyb20uXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGBzdHJpbmdgIHN0YXJ0cyB3aXRoIGB0YXJnZXRgLFxuICAgICAqICBlbHNlIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2EnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBfLnN0YXJ0c1dpdGgoJ2FiYycsICdiJyk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKlxuICAgICAqIF8uc3RhcnRzV2l0aCgnYWJjJywgJ2InLCAxKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3RhcnRzV2l0aChzdHJpbmcsIHRhcmdldCwgcG9zaXRpb24pIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBwb3NpdGlvbiA9IHBvc2l0aW9uID09IG51bGxcbiAgICAgICAgPyAwXG4gICAgICAgIDogYmFzZUNsYW1wKHRvSW50ZWdlcihwb3NpdGlvbiksIDAsIHN0cmluZy5sZW5ndGgpO1xuXG4gICAgICB0YXJnZXQgPSBiYXNlVG9TdHJpbmcodGFyZ2V0KTtcbiAgICAgIHJldHVybiBzdHJpbmcuc2xpY2UocG9zaXRpb24sIHBvc2l0aW9uICsgdGFyZ2V0Lmxlbmd0aCkgPT0gdGFyZ2V0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbiB0aGF0IGNhbiBpbnRlcnBvbGF0ZSBkYXRhIHByb3BlcnRpZXNcbiAgICAgKiBpbiBcImludGVycG9sYXRlXCIgZGVsaW1pdGVycywgSFRNTC1lc2NhcGUgaW50ZXJwb2xhdGVkIGRhdGEgcHJvcGVydGllcyBpblxuICAgICAqIFwiZXNjYXBlXCIgZGVsaW1pdGVycywgYW5kIGV4ZWN1dGUgSmF2YVNjcmlwdCBpbiBcImV2YWx1YXRlXCIgZGVsaW1pdGVycy4gRGF0YVxuICAgICAqIHByb3BlcnRpZXMgbWF5IGJlIGFjY2Vzc2VkIGFzIGZyZWUgdmFyaWFibGVzIGluIHRoZSB0ZW1wbGF0ZS4gSWYgYSBzZXR0aW5nXG4gICAgICogb2JqZWN0IGlzIGdpdmVuLCBpdCB0YWtlcyBwcmVjZWRlbmNlIG92ZXIgYF8udGVtcGxhdGVTZXR0aW5nc2AgdmFsdWVzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIEluIHRoZSBkZXZlbG9wbWVudCBidWlsZCBgXy50ZW1wbGF0ZWAgdXRpbGl6ZXNcbiAgICAgKiBbc291cmNlVVJMc10oaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybClcbiAgICAgKiBmb3IgZWFzaWVyIGRlYnVnZ2luZy5cbiAgICAgKlxuICAgICAqIEZvciBtb3JlIGluZm9ybWF0aW9uIG9uIHByZWNvbXBpbGluZyB0ZW1wbGF0ZXMgc2VlXG4gICAgICogW2xvZGFzaCdzIGN1c3RvbSBidWlsZHMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9sb2Rhc2guY29tL2N1c3RvbS1idWlsZHMpLlxuICAgICAqXG4gICAgICogRm9yIG1vcmUgaW5mb3JtYXRpb24gb24gQ2hyb21lIGV4dGVuc2lvbiBzYW5kYm94ZXMgc2VlXG4gICAgICogW0Nocm9tZSdzIGV4dGVuc2lvbnMgZG9jdW1lbnRhdGlvbl0oaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9leHRlbnNpb25zL3NhbmRib3hpbmdFdmFsKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHRlbXBsYXRlIHN0cmluZy5cbiAgICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIFRoZSBvcHRpb25zIG9iamVjdC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cH0gW29wdGlvbnMuZXNjYXBlPV8udGVtcGxhdGVTZXR0aW5ncy5lc2NhcGVdXG4gICAgICogIFRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5ldmFsdWF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuZXZhbHVhdGVdXG4gICAgICogIFRoZSBcImV2YWx1YXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy5pbXBvcnRzPV8udGVtcGxhdGVTZXR0aW5ncy5pbXBvcnRzXVxuICAgICAqICBBbiBvYmplY3QgdG8gaW1wb3J0IGludG8gdGhlIHRlbXBsYXRlIGFzIGZyZWUgdmFyaWFibGVzLlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfSBbb3B0aW9ucy5pbnRlcnBvbGF0ZT1fLnRlbXBsYXRlU2V0dGluZ3MuaW50ZXJwb2xhdGVdXG4gICAgICogIFRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5zb3VyY2VVUkw9J2xvZGFzaC50ZW1wbGF0ZVNvdXJjZXNbbl0nXVxuICAgICAqICBUaGUgc291cmNlVVJMIG9mIHRoZSBjb21waWxlZCB0ZW1wbGF0ZS5cbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMudmFyaWFibGU9J29iaiddXG4gICAgICogIFRoZSBkYXRhIG9iamVjdCB2YXJpYWJsZSBuYW1lLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjb21waWxlZCB0ZW1wbGF0ZSBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBcImludGVycG9sYXRlXCIgZGVsaW1pdGVyIHRvIGNyZWF0ZSBhIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSB1c2VyICU+IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnZnJlZCcgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGZyZWQhJ1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBIVE1MIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBkYXRhIHByb3BlcnR5IHZhbHVlcy5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCc8Yj48JS0gdmFsdWUgJT48L2I+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndmFsdWUnOiAnPHNjcmlwdD4nIH0pO1xuICAgICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgdG8gZXhlY3V0ZSBKYXZhU2NyaXB0IGFuZCBnZW5lcmF0ZSBIVE1MLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlIF8uZm9yRWFjaCh1c2VycywgZnVuY3Rpb24odXNlcikgeyAlPjxsaT48JS0gdXNlciAlPjwvbGk+PCUgfSk7ICU+Jyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcnMnOiBbJ2ZyZWQnLCAnYmFybmV5J10gfSk7XG4gICAgICogLy8gPT4gJzxsaT5mcmVkPC9saT48bGk+YmFybmV5PC9saT4nXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnMuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIHVzZXIpOyAlPiEnKTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2VyJzogJ2Jhcm5leScgfSk7XG4gICAgICogLy8gPT4gJ2hlbGxvIGJhcm5leSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIEVTIHRlbXBsYXRlIGxpdGVyYWwgZGVsaW1pdGVyIGFzIGFuIFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXIuXG4gICAgICogLy8gRGlzYWJsZSBzdXBwb3J0IGJ5IHJlcGxhY2luZyB0aGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlci5cbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyAkeyB1c2VyIH0hJyk7XG4gICAgICogY29tcGlsZWQoeyAndXNlcic6ICdwZWJibGVzJyB9KTtcbiAgICAgKiAvLyA9PiAnaGVsbG8gcGViYmxlcyEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgYmFja3NsYXNoZXMgdG8gdHJlYXQgZGVsaW1pdGVycyBhcyBwbGFpbiB0ZXh0LlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJzwlPSBcIlxcXFw8JS0gdmFsdWUgJVxcXFw+XCIgJT4nKTtcbiAgICAgKiBjb21waWxlZCh7ICd2YWx1ZSc6ICdpZ25vcmVkJyB9KTtcbiAgICAgKiAvLyA9PiAnPCUtIHZhbHVlICU+J1xuICAgICAqXG4gICAgICogLy8gVXNlIHRoZSBgaW1wb3J0c2Agb3B0aW9uIHRvIGltcG9ydCBgalF1ZXJ5YCBhcyBganFgLlxuICAgICAqIHZhciB0ZXh0ID0gJzwlIGpxLmVhY2godXNlcnMsIGZ1bmN0aW9uKHVzZXIpIHsgJT48bGk+PCUtIHVzZXIgJT48L2xpPjwlIH0pOyAlPic7XG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSh0ZXh0LCB7ICdpbXBvcnRzJzogeyAnanEnOiBqUXVlcnkgfSB9KTtcbiAgICAgKiBjb21waWxlZCh7ICd1c2Vycyc6IFsnZnJlZCcsICdiYXJuZXknXSB9KTtcbiAgICAgKiAvLyA9PiAnPGxpPmZyZWQ8L2xpPjxsaT5iYXJuZXk8L2xpPidcbiAgICAgKlxuICAgICAqIC8vIFVzZSB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGUuXG4gICAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IHVzZXIgJT4hJywgeyAnc291cmNlVVJMJzogJy9iYXNpYy9ncmVldGluZy5qc3QnIH0pO1xuICAgICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgICAqIC8vID0+IEZpbmQgdGhlIHNvdXJjZSBvZiBcImdyZWV0aW5nLmpzdFwiIHVuZGVyIHRoZSBTb3VyY2VzIHRhYiBvciBSZXNvdXJjZXMgcGFuZWwgb2YgdGhlIHdlYiBpbnNwZWN0b3IuXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGB2YXJpYWJsZWAgb3B0aW9uIHRvIGVuc3VyZSBhIHdpdGgtc3RhdGVtZW50IGlzbid0IHVzZWQgaW4gdGhlIGNvbXBpbGVkIHRlbXBsYXRlLlxuICAgICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hpIDwlPSBkYXRhLnVzZXIgJT4hJywgeyAndmFyaWFibGUnOiAnZGF0YScgfSk7XG4gICAgICogY29tcGlsZWQuc291cmNlO1xuICAgICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgKiAvLyAgIHZhciBfX3QsIF9fcCA9ICcnO1xuICAgICAqIC8vICAgX19wICs9ICdoaSAnICsgKChfX3QgPSAoIGRhdGEudXNlciApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgICAqIC8vICAgcmV0dXJuIF9fcDtcbiAgICAgKiAvLyB9XG4gICAgICpcbiAgICAgKiAvLyBVc2UgY3VzdG9tIHRlbXBsYXRlIGRlbGltaXRlcnMuXG4gICAgICogXy50ZW1wbGF0ZVNldHRpbmdzLmludGVycG9sYXRlID0gL3t7KFtcXHNcXFNdKz8pfX0vZztcbiAgICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyB7eyB1c2VyIH19IScpO1xuICAgICAqIGNvbXBpbGVkKHsgJ3VzZXInOiAnbXVzdGFjaGUnIH0pO1xuICAgICAqIC8vID0+ICdoZWxsbyBtdXN0YWNoZSEnXG4gICAgICpcbiAgICAgKiAvLyBVc2UgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICAgKiAvLyBsaW5lIG51bWJlcnMgaW4gZXJyb3IgbWVzc2FnZXMgYW5kIHN0YWNrIHRyYWNlcy5cbiAgICAgKiBmcy53cml0ZUZpbGVTeW5jKHBhdGguam9pbihwcm9jZXNzLmN3ZCgpLCAnanN0LmpzJyksICdcXFxuICAgICAqICAgdmFyIEpTVCA9IHtcXFxuICAgICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgICAqICAgfTtcXFxuICAgICAqICcpO1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRlbXBsYXRlKHN0cmluZywgb3B0aW9ucywgZ3VhcmQpIHtcbiAgICAgIC8vIEJhc2VkIG9uIEpvaG4gUmVzaWcncyBgdG1wbGAgaW1wbGVtZW50YXRpb25cbiAgICAgIC8vIChodHRwOi8vZWpvaG4ub3JnL2Jsb2cvamF2YXNjcmlwdC1taWNyby10ZW1wbGF0aW5nLylcbiAgICAgIC8vIGFuZCBMYXVyYSBEb2t0b3JvdmEncyBkb1QuanMgKGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1QpLlxuICAgICAgdmFyIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3M7XG5cbiAgICAgIGlmIChndWFyZCAmJiBpc0l0ZXJhdGVlQ2FsbChzdHJpbmcsIG9wdGlvbnMsIGd1YXJkKSkge1xuICAgICAgICBvcHRpb25zID0gdW5kZWZpbmVkO1xuICAgICAgfVxuICAgICAgc3RyaW5nID0gdG9TdHJpbmcoc3RyaW5nKTtcbiAgICAgIG9wdGlvbnMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMsIHNldHRpbmdzLCBjdXN0b21EZWZhdWx0c0Fzc2lnbkluKTtcblxuICAgICAgdmFyIGltcG9ydHMgPSBhc3NpZ25JbldpdGgoe30sIG9wdGlvbnMuaW1wb3J0cywgc2V0dGluZ3MuaW1wb3J0cywgY3VzdG9tRGVmYXVsdHNBc3NpZ25JbiksXG4gICAgICAgICAgaW1wb3J0c0tleXMgPSBrZXlzKGltcG9ydHMpLFxuICAgICAgICAgIGltcG9ydHNWYWx1ZXMgPSBiYXNlVmFsdWVzKGltcG9ydHMsIGltcG9ydHNLZXlzKTtcblxuICAgICAgdmFyIGlzRXNjYXBpbmcsXG4gICAgICAgICAgaXNFdmFsdWF0aW5nLFxuICAgICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgICBpbnRlcnBvbGF0ZSA9IG9wdGlvbnMuaW50ZXJwb2xhdGUgfHwgcmVOb01hdGNoLFxuICAgICAgICAgIHNvdXJjZSA9IFwiX19wICs9ICdcIjtcblxuICAgICAgLy8gQ29tcGlsZSB0aGUgcmVnZXhwIHRvIG1hdGNoIGVhY2ggZGVsaW1pdGVyLlxuICAgICAgdmFyIHJlRGVsaW1pdGVycyA9IFJlZ0V4cChcbiAgICAgICAgKG9wdGlvbnMuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgICAgaW50ZXJwb2xhdGUuc291cmNlICsgJ3wnICtcbiAgICAgICAgKGludGVycG9sYXRlID09PSByZUludGVycG9sYXRlID8gcmVFc1RlbXBsYXRlIDogcmVOb01hdGNoKS5zb3VyY2UgKyAnfCcgK1xuICAgICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAgICwgJ2cnKTtcblxuICAgICAgLy8gVXNlIGEgc291cmNlVVJMIGZvciBlYXNpZXIgZGVidWdnaW5nLlxuICAgICAgLy8gVGhlIHNvdXJjZVVSTCBnZXRzIGluamVjdGVkIGludG8gdGhlIHNvdXJjZSB0aGF0J3MgZXZhbC1lZCwgc28gYmUgY2FyZWZ1bFxuICAgICAgLy8gdG8gbm9ybWFsaXplIGFsbCBraW5kcyBvZiB3aGl0ZXNwYWNlLCBzbyBlLmcuIG5ld2xpbmVzIChhbmQgdW5pY29kZSB2ZXJzaW9ucyBvZiBpdCkgY2FuJ3Qgc25lYWsgaW5cbiAgICAgIC8vIGFuZCBlc2NhcGUgdGhlIGNvbW1lbnQsIHRodXMgaW5qZWN0aW5nIGNvZGUgdGhhdCBnZXRzIGV2YWxlZC5cbiAgICAgIHZhciBzb3VyY2VVUkwgPSAnLy8jIHNvdXJjZVVSTD0nICtcbiAgICAgICAgKGhhc093blByb3BlcnR5LmNhbGwob3B0aW9ucywgJ3NvdXJjZVVSTCcpXG4gICAgICAgICAgPyAob3B0aW9ucy5zb3VyY2VVUkwgKyAnJykucmVwbGFjZSgvXFxzL2csICcgJylcbiAgICAgICAgICA6ICgnbG9kYXNoLnRlbXBsYXRlU291cmNlc1snICsgKCsrdGVtcGxhdGVDb3VudGVyKSArICddJylcbiAgICAgICAgKSArICdcXG4nO1xuXG4gICAgICBzdHJpbmcucmVwbGFjZShyZURlbGltaXRlcnMsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGVWYWx1ZSwgaW50ZXJwb2xhdGVWYWx1ZSwgZXNUZW1wbGF0ZVZhbHVlLCBldmFsdWF0ZVZhbHVlLCBvZmZzZXQpIHtcbiAgICAgICAgaW50ZXJwb2xhdGVWYWx1ZSB8fCAoaW50ZXJwb2xhdGVWYWx1ZSA9IGVzVGVtcGxhdGVWYWx1ZSk7XG5cbiAgICAgICAgLy8gRXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW4ndCBiZSBpbmNsdWRlZCBpbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAgICAgIHNvdXJjZSArPSBzdHJpbmcuc2xpY2UoaW5kZXgsIG9mZnNldCkucmVwbGFjZShyZVVuZXNjYXBlZFN0cmluZywgZXNjYXBlU3RyaW5nQ2hhcik7XG5cbiAgICAgICAgLy8gUmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHMuXG4gICAgICAgIGlmIChlc2NhcGVWYWx1ZSkge1xuICAgICAgICAgIGlzRXNjYXBpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbl9fZShcIiArIGVzY2FwZVZhbHVlICsgXCIpICtcXG4nXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV2YWx1YXRlVmFsdWUpIHtcbiAgICAgICAgICBpc0V2YWx1YXRpbmcgPSB0cnVlO1xuICAgICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaW50ZXJwb2xhdGVWYWx1ZSkge1xuICAgICAgICAgIHNvdXJjZSArPSBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiO1xuICAgICAgICB9XG4gICAgICAgIGluZGV4ID0gb2Zmc2V0ICsgbWF0Y2gubGVuZ3RoO1xuXG4gICAgICAgIC8vIFRoZSBKUyBlbmdpbmUgZW1iZWRkZWQgaW4gQWRvYmUgcHJvZHVjdHMgbmVlZHMgYG1hdGNoYCByZXR1cm5lZCBpblxuICAgICAgICAvLyBvcmRlciB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IGBvZmZzZXRgIHZhbHVlLlxuICAgICAgICByZXR1cm4gbWF0Y2g7XG4gICAgICB9KTtcblxuICAgICAgc291cmNlICs9IFwiJztcXG5cIjtcblxuICAgICAgLy8gSWYgYHZhcmlhYmxlYCBpcyBub3Qgc3BlY2lmaWVkIHdyYXAgYSB3aXRoLXN0YXRlbWVudCBhcm91bmQgdGhlIGdlbmVyYXRlZFxuICAgICAgLy8gY29kZSB0byBhZGQgdGhlIGRhdGEgb2JqZWN0IHRvIHRoZSB0b3Agb2YgdGhlIHNjb3BlIGNoYWluLlxuICAgICAgdmFyIHZhcmlhYmxlID0gaGFzT3duUHJvcGVydHkuY2FsbChvcHRpb25zLCAndmFyaWFibGUnKSAmJiBvcHRpb25zLnZhcmlhYmxlO1xuICAgICAgaWYgKCF2YXJpYWJsZSkge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAob2JqKSB7XFxuJyArIHNvdXJjZSArICdcXG59XFxuJztcbiAgICAgIH1cbiAgICAgIC8vIFRocm93IGFuIGVycm9yIGlmIGEgZm9yYmlkZGVuIGNoYXJhY3RlciB3YXMgZm91bmQgaW4gYHZhcmlhYmxlYCwgdG8gcHJldmVudFxuICAgICAgLy8gcG90ZW50aWFsIGNvbW1hbmQgaW5qZWN0aW9uIGF0dGFja3MuXG4gICAgICBlbHNlIGlmIChyZUZvcmJpZGRlbklkZW50aWZpZXJDaGFycy50ZXN0KHZhcmlhYmxlKSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoSU5WQUxJRF9URU1QTF9WQVJfRVJST1JfVEVYVCk7XG4gICAgICB9XG5cbiAgICAgIC8vIENsZWFudXAgY29kZSBieSBzdHJpcHBpbmcgZW1wdHkgc3RyaW5ncy5cbiAgICAgIHNvdXJjZSA9IChpc0V2YWx1YXRpbmcgPyBzb3VyY2UucmVwbGFjZShyZUVtcHR5U3RyaW5nTGVhZGluZywgJycpIDogc291cmNlKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nVHJhaWxpbmcsICckMTsnKTtcblxuICAgICAgLy8gRnJhbWUgY29kZSBhcyB0aGUgZnVuY3Rpb24gYm9keS5cbiAgICAgIHNvdXJjZSA9ICdmdW5jdGlvbignICsgKHZhcmlhYmxlIHx8ICdvYmonKSArICcpIHtcXG4nICtcbiAgICAgICAgKHZhcmlhYmxlXG4gICAgICAgICAgPyAnJ1xuICAgICAgICAgIDogJ29iaiB8fCAob2JqID0ge30pO1xcbidcbiAgICAgICAgKSArXG4gICAgICAgIFwidmFyIF9fdCwgX19wID0gJydcIiArXG4gICAgICAgIChpc0VzY2FwaW5nXG4gICAgICAgICAgID8gJywgX19lID0gXy5lc2NhcGUnXG4gICAgICAgICAgIDogJydcbiAgICAgICAgKSArXG4gICAgICAgIChpc0V2YWx1YXRpbmdcbiAgICAgICAgICA/ICcsIF9faiA9IEFycmF5LnByb3RvdHlwZS5qb2luO1xcbicgK1xuICAgICAgICAgICAgXCJmdW5jdGlvbiBwcmludCgpIHsgX19wICs9IF9fai5jYWxsKGFyZ3VtZW50cywgJycpIH1cXG5cIlxuICAgICAgICAgIDogJztcXG4nXG4gICAgICAgICkgK1xuICAgICAgICBzb3VyY2UgK1xuICAgICAgICAncmV0dXJuIF9fcFxcbn0nO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYXR0ZW1wdChmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIEZ1bmN0aW9uKGltcG9ydHNLZXlzLCBzb3VyY2VVUkwgKyAncmV0dXJuICcgKyBzb3VyY2UpXG4gICAgICAgICAgLmFwcGx5KHVuZGVmaW5lZCwgaW1wb3J0c1ZhbHVlcyk7XG4gICAgICB9KTtcblxuICAgICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgYnkgaXRzIGB0b1N0cmluZ2AgbWV0aG9kIG9yXG4gICAgICAvLyB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3IgaW5saW5pbmcgY29tcGlsZWQgdGVtcGxhdGVzLlxuICAgICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICAgIGlmIChpc0Vycm9yKHJlc3VsdCkpIHtcbiAgICAgICAgdGhyb3cgcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gbG93ZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvTG93ZXJDYXNlXShodHRwczovL21kbi5pby90b0xvd2VyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSBsb3dlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9Mb3dlcignLS1Gb28tQmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1mb28tYmFyLS0nXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdmb29iYXInXG4gICAgICpcbiAgICAgKiBfLnRvTG93ZXIoJ19fRk9PX0JBUl9fJyk7XG4gICAgICogLy8gPT4gJ19fZm9vX2Jhcl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvTG93ZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9Mb3dlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgYSB3aG9sZSwgdG8gdXBwZXIgY2FzZSBqdXN0IGxpa2VcbiAgICAgKiBbU3RyaW5nI3RvVXBwZXJDYXNlXShodHRwczovL21kbi5pby90b1VwcGVyQ2FzZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgU3RyaW5nXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtzdHJpbmc9JyddIFRoZSBzdHJpbmcgdG8gY29udmVydC5cbiAgICAgKiBAcmV0dXJucyB7c3RyaW5nfSBSZXR1cm5zIHRoZSB1cHBlciBjYXNlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udG9VcHBlcignLS1mb28tYmFyLS0nKTtcbiAgICAgKiAvLyA9PiAnLS1GT08tQkFSLS0nXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ2Zvb0JhcicpO1xuICAgICAqIC8vID0+ICdGT09CQVInXG4gICAgICpcbiAgICAgKiBfLnRvVXBwZXIoJ19fZm9vX2Jhcl9fJyk7XG4gICAgICogLy8gPT4gJ19fRk9PX0JBUl9fJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvVXBwZXIodmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZyh2YWx1ZSkudG9VcHBlckNhc2UoKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2Ugb3Igc3BlY2lmaWVkIGNoYXJhY3RlcnMgZnJvbSBgc3RyaW5nYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byB0cmltLlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbY2hhcnM9d2hpdGVzcGFjZV0gVGhlIGNoYXJhY3RlcnMgdG8gdHJpbS5cbiAgICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gRW5hYmxlcyB1c2UgYXMgYW4gaXRlcmF0ZWUgZm9yIG1ldGhvZHMgbGlrZSBgXy5tYXBgLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRyaW1tZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRyaW0oJyAgYWJjICAnKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy50cmltKCctXy1hYmMtXy0nLCAnXy0nKTtcbiAgICAgKiAvLyA9PiAnYWJjJ1xuICAgICAqXG4gICAgICogXy5tYXAoWycgIGZvbyAgJywgJyAgYmFyICAnXSwgXy50cmltKTtcbiAgICAgKiAvLyA9PiBbJ2ZvbycsICdiYXInXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRyaW0oc3RyaW5nLCBjaGFycywgZ3VhcmQpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICBpZiAoc3RyaW5nICYmIChndWFyZCB8fCBjaGFycyA9PT0gdW5kZWZpbmVkKSkge1xuICAgICAgICByZXR1cm4gYmFzZVRyaW0oc3RyaW5nKTtcbiAgICAgIH1cbiAgICAgIGlmICghc3RyaW5nIHx8ICEoY2hhcnMgPSBiYXNlVG9TdHJpbmcoY2hhcnMpKSkge1xuICAgICAgICByZXR1cm4gc3RyaW5nO1xuICAgICAgfVxuICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyksXG4gICAgICAgICAgY2hyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoY2hhcnMpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIGNoclN5bWJvbHMpLFxuICAgICAgICAgIGVuZCA9IGNoYXJzRW5kSW5kZXgoc3RyU3ltYm9scywgY2hyU3ltYm9scykgKyAxO1xuXG4gICAgICByZXR1cm4gY2FzdFNsaWNlKHN0clN5bWJvbHMsIHN0YXJ0LCBlbmQpLmpvaW4oJycpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZXMgdHJhaWxpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnICBhYmMgICcpO1xuICAgICAqIC8vID0+ICcgIGFiYydcbiAgICAgKlxuICAgICAqIF8udHJpbUVuZCgnLV8tYWJjLV8tJywgJ18tJyk7XG4gICAgICogLy8gPT4gJy1fLWFiYydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB0cmltRW5kKHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5zbGljZSgwLCB0cmltbWVkRW5kSW5kZXgoc3RyaW5nKSArIDEpO1xuICAgICAgfVxuICAgICAgaWYgKCFzdHJpbmcgfHwgIShjaGFycyA9IGJhc2VUb1N0cmluZyhjaGFycykpKSB7XG4gICAgICAgIHJldHVybiBzdHJpbmc7XG4gICAgICB9XG4gICAgICB2YXIgc3RyU3ltYm9scyA9IHN0cmluZ1RvQXJyYXkoc3RyaW5nKSxcbiAgICAgICAgICBlbmQgPSBjaGFyc0VuZEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKSArIDE7XG5cbiAgICAgIHJldHVybiBjYXN0U2xpY2Uoc3RyU3ltYm9scywgMCwgZW5kKS5qb2luKCcnKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGxlYWRpbmcgd2hpdGVzcGFjZSBvciBzcGVjaWZpZWQgY2hhcmFjdGVycyBmcm9tIGBzdHJpbmdgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRyaW0uXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtjaGFycz13aGl0ZXNwYWNlXSBUaGUgY2hhcmFjdGVycyB0byB0cmltLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdHJpbW1lZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJpbVN0YXJ0KCcgIGFiYyAgJyk7XG4gICAgICogLy8gPT4gJ2FiYyAgJ1xuICAgICAqXG4gICAgICogXy50cmltU3RhcnQoJy1fLWFiYy1fLScsICdfLScpO1xuICAgICAqIC8vID0+ICdhYmMtXy0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJpbVN0YXJ0KHN0cmluZywgY2hhcnMsIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgaWYgKHN0cmluZyAmJiAoZ3VhcmQgfHwgY2hhcnMgPT09IHVuZGVmaW5lZCkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZy5yZXBsYWNlKHJlVHJpbVN0YXJ0LCAnJyk7XG4gICAgICB9XG4gICAgICBpZiAoIXN0cmluZyB8fCAhKGNoYXJzID0gYmFzZVRvU3RyaW5nKGNoYXJzKSkpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBzdHJTeW1ib2xzID0gc3RyaW5nVG9BcnJheShzdHJpbmcpLFxuICAgICAgICAgIHN0YXJ0ID0gY2hhcnNTdGFydEluZGV4KHN0clN5bWJvbHMsIHN0cmluZ1RvQXJyYXkoY2hhcnMpKTtcblxuICAgICAgcmV0dXJuIGNhc3RTbGljZShzdHJTeW1ib2xzLCBzdGFydCkuam9pbignJyk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVHJ1bmNhdGVzIGBzdHJpbmdgIGlmIGl0J3MgbG9uZ2VyIHRoYW4gdGhlIGdpdmVuIG1heGltdW0gc3RyaW5nIGxlbmd0aC5cbiAgICAgKiBUaGUgbGFzdCBjaGFyYWN0ZXJzIG9mIHRoZSB0cnVuY2F0ZWQgc3RyaW5nIGFyZSByZXBsYWNlZCB3aXRoIHRoZSBvbWlzc2lvblxuICAgICAqIHN0cmluZyB3aGljaCBkZWZhdWx0cyB0byBcIi4uLlwiLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHRydW5jYXRlLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sZW5ndGg9MzBdIFRoZSBtYXhpbXVtIHN0cmluZyBsZW5ndGguXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLm9taXNzaW9uPScuLi4nXSBUaGUgc3RyaW5nIHRvIGluZGljYXRlIHRleHQgaXMgb21pdHRlZC5cbiAgICAgKiBAcGFyYW0ge1JlZ0V4cHxzdHJpbmd9IFtvcHRpb25zLnNlcGFyYXRvcl0gVGhlIHNlcGFyYXRvciBwYXR0ZXJuIHRvIHRydW5jYXRlIHRvLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHRydW5jYXRlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nKTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvLi4uJ1xuICAgICAqXG4gICAgICogXy50cnVuY2F0ZSgnaGktZGlkZGx5LWhvIHRoZXJlLCBuZWlnaGJvcmlubycsIHtcbiAgICAgKiAgICdsZW5ndGgnOiAyNCxcbiAgICAgKiAgICdzZXBhcmF0b3InOiAnICdcbiAgICAgKiB9KTtcbiAgICAgKiAvLyA9PiAnaGktZGlkZGx5LWhvIHRoZXJlLC4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnbGVuZ3RoJzogMjQsXG4gICAgICogICAnc2VwYXJhdG9yJzogLyw/ICsvXG4gICAgICogfSk7XG4gICAgICogLy8gPT4gJ2hpLWRpZGRseS1obyB0aGVyZS4uLidcbiAgICAgKlxuICAgICAqIF8udHJ1bmNhdGUoJ2hpLWRpZGRseS1obyB0aGVyZSwgbmVpZ2hib3Jpbm8nLCB7XG4gICAgICogICAnb21pc3Npb24nOiAnIFsuLi5dJ1xuICAgICAqIH0pO1xuICAgICAqIC8vID0+ICdoaS1kaWRkbHktaG8gdGhlcmUsIG5laWcgWy4uLl0nXG4gICAgICovXG4gICAgZnVuY3Rpb24gdHJ1bmNhdGUoc3RyaW5nLCBvcHRpb25zKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gREVGQVVMVF9UUlVOQ19MRU5HVEgsXG4gICAgICAgICAgb21pc3Npb24gPSBERUZBVUxUX1RSVU5DX09NSVNTSU9OO1xuXG4gICAgICBpZiAoaXNPYmplY3Qob3B0aW9ucykpIHtcbiAgICAgICAgdmFyIHNlcGFyYXRvciA9ICdzZXBhcmF0b3InIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlcGFyYXRvciA6IHNlcGFyYXRvcjtcbiAgICAgICAgbGVuZ3RoID0gJ2xlbmd0aCcgaW4gb3B0aW9ucyA/IHRvSW50ZWdlcihvcHRpb25zLmxlbmd0aCkgOiBsZW5ndGg7XG4gICAgICAgIG9taXNzaW9uID0gJ29taXNzaW9uJyBpbiBvcHRpb25zID8gYmFzZVRvU3RyaW5nKG9wdGlvbnMub21pc3Npb24pIDogb21pc3Npb247XG4gICAgICB9XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuXG4gICAgICB2YXIgc3RyTGVuZ3RoID0gc3RyaW5nLmxlbmd0aDtcbiAgICAgIGlmIChoYXNVbmljb2RlKHN0cmluZykpIHtcbiAgICAgICAgdmFyIHN0clN5bWJvbHMgPSBzdHJpbmdUb0FycmF5KHN0cmluZyk7XG4gICAgICAgIHN0ckxlbmd0aCA9IHN0clN5bWJvbHMubGVuZ3RoO1xuICAgICAgfVxuICAgICAgaWYgKGxlbmd0aCA+PSBzdHJMZW5ndGgpIHtcbiAgICAgICAgcmV0dXJuIHN0cmluZztcbiAgICAgIH1cbiAgICAgIHZhciBlbmQgPSBsZW5ndGggLSBzdHJpbmdTaXplKG9taXNzaW9uKTtcbiAgICAgIGlmIChlbmQgPCAxKSB7XG4gICAgICAgIHJldHVybiBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIHZhciByZXN1bHQgPSBzdHJTeW1ib2xzXG4gICAgICAgID8gY2FzdFNsaWNlKHN0clN5bWJvbHMsIDAsIGVuZCkuam9pbignJylcbiAgICAgICAgOiBzdHJpbmcuc2xpY2UoMCwgZW5kKTtcblxuICAgICAgaWYgKHNlcGFyYXRvciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHJldHVybiByZXN1bHQgKyBvbWlzc2lvbjtcbiAgICAgIH1cbiAgICAgIGlmIChzdHJTeW1ib2xzKSB7XG4gICAgICAgIGVuZCArPSAocmVzdWx0Lmxlbmd0aCAtIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAoaXNSZWdFeHAoc2VwYXJhdG9yKSkge1xuICAgICAgICBpZiAoc3RyaW5nLnNsaWNlKGVuZCkuc2VhcmNoKHNlcGFyYXRvcikpIHtcbiAgICAgICAgICB2YXIgbWF0Y2gsXG4gICAgICAgICAgICAgIHN1YnN0cmluZyA9IHJlc3VsdDtcblxuICAgICAgICAgIGlmICghc2VwYXJhdG9yLmdsb2JhbCkge1xuICAgICAgICAgICAgc2VwYXJhdG9yID0gUmVnRXhwKHNlcGFyYXRvci5zb3VyY2UsIHRvU3RyaW5nKHJlRmxhZ3MuZXhlYyhzZXBhcmF0b3IpKSArICdnJyk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHNlcGFyYXRvci5sYXN0SW5kZXggPSAwO1xuICAgICAgICAgIHdoaWxlICgobWF0Y2ggPSBzZXBhcmF0b3IuZXhlYyhzdWJzdHJpbmcpKSkge1xuICAgICAgICAgICAgdmFyIG5ld0VuZCA9IG1hdGNoLmluZGV4O1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgbmV3RW5kID09PSB1bmRlZmluZWQgPyBlbmQgOiBuZXdFbmQpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHN0cmluZy5pbmRleE9mKGJhc2VUb1N0cmluZyhzZXBhcmF0b3IpLCBlbmQpICE9IGVuZCkge1xuICAgICAgICB2YXIgaW5kZXggPSByZXN1bHQubGFzdEluZGV4T2Yoc2VwYXJhdG9yKTtcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgICAgICByZXN1bHQgPSByZXN1bHQuc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0ICsgb21pc3Npb247XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIGludmVyc2Ugb2YgYF8uZXNjYXBlYDsgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICAgKiBgJmFtcDtgLCBgJmx0O2AsIGAmZ3Q7YCwgYCZxdW90O2AsIGFuZCBgJiMzOTtgIGluIGBzdHJpbmdgIHRvXG4gICAgICogdGhlaXIgY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIE5vIG90aGVyIEhUTUwgZW50aXRpZXMgYXJlIHVuZXNjYXBlZC4gVG8gdW5lc2NhcGUgYWRkaXRpb25hbFxuICAgICAqIEhUTUwgZW50aXRpZXMgdXNlIGEgdGhpcmQtcGFydHkgbGlicmFyeSBsaWtlIFtfaGVfXShodHRwczovL210aHMuYmUvaGUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDAuNi4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgICAqIEByZXR1cm5zIHtzdHJpbmd9IFJldHVybnMgdGhlIHVuZXNjYXBlZCBzdHJpbmcuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udW5lc2NhcGUoJ2ZyZWQsIGJhcm5leSwgJmFtcDsgcGViYmxlcycpO1xuICAgICAqIC8vID0+ICdmcmVkLCBiYXJuZXksICYgcGViYmxlcydcbiAgICAgKi9cbiAgICBmdW5jdGlvbiB1bmVzY2FwZShzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHRvU3RyaW5nKHN0cmluZyk7XG4gICAgICByZXR1cm4gKHN0cmluZyAmJiByZUhhc0VzY2FwZWRIdG1sLnRlc3Qoc3RyaW5nKSlcbiAgICAgICAgPyBzdHJpbmcucmVwbGFjZShyZUVzY2FwZWRIdG1sLCB1bmVzY2FwZUh0bWxDaGFyKVxuICAgICAgICA6IHN0cmluZztcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb252ZXJ0cyBgc3RyaW5nYCwgYXMgc3BhY2Ugc2VwYXJhdGVkIHdvcmRzLCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdXBwZXIgY2FzZWQgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnLS1mb28tYmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnZm9vQmFyJyk7XG4gICAgICogLy8gPT4gJ0ZPTyBCQVInXG4gICAgICpcbiAgICAgKiBfLnVwcGVyQ2FzZSgnX19mb29fYmFyX18nKTtcbiAgICAgKiAvLyA9PiAnRk9PIEJBUidcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJDYXNlID0gY3JlYXRlQ29tcG91bmRlcihmdW5jdGlvbihyZXN1bHQsIHdvcmQsIGluZGV4KSB7XG4gICAgICByZXR1cm4gcmVzdWx0ICsgKGluZGV4ID8gJyAnIDogJycpICsgd29yZC50b1VwcGVyQ2FzZSgpO1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgdGhlIGZpcnN0IGNoYXJhY3RlciBvZiBgc3RyaW5nYCB0byB1cHBlciBjYXNlLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFN0cmluZ1xuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBbc3RyaW5nPScnXSBUaGUgc3RyaW5nIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgY29udmVydGVkIHN0cmluZy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy51cHBlckZpcnN0KCdmcmVkJyk7XG4gICAgICogLy8gPT4gJ0ZyZWQnXG4gICAgICpcbiAgICAgKiBfLnVwcGVyRmlyc3QoJ0ZSRUQnKTtcbiAgICAgKiAvLyA9PiAnRlJFRCdcbiAgICAgKi9cbiAgICB2YXIgdXBwZXJGaXJzdCA9IGNyZWF0ZUNhc2VGaXJzdCgndG9VcHBlckNhc2UnKTtcblxuICAgIC8qKlxuICAgICAqIFNwbGl0cyBgc3RyaW5nYCBpbnRvIGFuIGFycmF5IG9mIGl0cyB3b3Jkcy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBTdHJpbmdcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gW3N0cmluZz0nJ10gVGhlIHN0cmluZyB0byBpbnNwZWN0LlxuICAgICAqIEBwYXJhbSB7UmVnRXhwfHN0cmluZ30gW3BhdHRlcm5dIFRoZSBwYXR0ZXJuIHRvIG1hdGNoIHdvcmRzLlxuICAgICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBFbmFibGVzIHVzZSBhcyBhbiBpdGVyYXRlZSBmb3IgbWV0aG9kcyBsaWtlIGBfLm1hcGAuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSB3b3JkcyBvZiBgc3RyaW5nYC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnKTtcbiAgICAgKiAvLyA9PiBbJ2ZyZWQnLCAnYmFybmV5JywgJ3BlYmJsZXMnXVxuICAgICAqXG4gICAgICogXy53b3JkcygnZnJlZCwgYmFybmV5LCAmIHBlYmJsZXMnLCAvW14sIF0rL2cpO1xuICAgICAqIC8vID0+IFsnZnJlZCcsICdiYXJuZXknLCAnJicsICdwZWJibGVzJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiB3b3JkcyhzdHJpbmcsIHBhdHRlcm4sIGd1YXJkKSB7XG4gICAgICBzdHJpbmcgPSB0b1N0cmluZyhzdHJpbmcpO1xuICAgICAgcGF0dGVybiA9IGd1YXJkID8gdW5kZWZpbmVkIDogcGF0dGVybjtcblxuICAgICAgaWYgKHBhdHRlcm4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gaGFzVW5pY29kZVdvcmQoc3RyaW5nKSA/IHVuaWNvZGVXb3JkcyhzdHJpbmcpIDogYXNjaWlXb3JkcyhzdHJpbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHN0cmluZy5tYXRjaChwYXR0ZXJuKSB8fCBbXTtcbiAgICB9XG5cbiAgICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgICAvKipcbiAgICAgKiBBdHRlbXB0cyB0byBpbnZva2UgYGZ1bmNgLCByZXR1cm5pbmcgZWl0aGVyIHRoZSByZXN1bHQgb3IgdGhlIGNhdWdodCBlcnJvclxuICAgICAqIG9iamVjdC4gQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byBgZnVuY2Agd2hlbiBpdCdzIGludm9rZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIGF0dGVtcHQuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgYGZ1bmNgIHdpdGguXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIGBmdW5jYCByZXN1bHQgb3IgZXJyb3Igb2JqZWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiAvLyBBdm9pZCB0aHJvd2luZyBlcnJvcnMgZm9yIGludmFsaWQgc2VsZWN0b3JzLlxuICAgICAqIHZhciBlbGVtZW50cyA9IF8uYXR0ZW1wdChmdW5jdGlvbihzZWxlY3Rvcikge1xuICAgICAqICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoc2VsZWN0b3IpO1xuICAgICAqIH0sICc+Xz4nKTtcbiAgICAgKlxuICAgICAqIGlmIChfLmlzRXJyb3IoZWxlbWVudHMpKSB7XG4gICAgICogICBlbGVtZW50cyA9IFtdO1xuICAgICAqIH1cbiAgICAgKi9cbiAgICB2YXIgYXR0ZW1wdCA9IGJhc2VSZXN0KGZ1bmN0aW9uKGZ1bmMsIGFyZ3MpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHJldHVybiBhcHBseShmdW5jLCB1bmRlZmluZWQsIGFyZ3MpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICByZXR1cm4gaXNFcnJvcihlKSA/IGUgOiBuZXcgRXJyb3IoZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBCaW5kcyBtZXRob2RzIG9mIGFuIG9iamVjdCB0byB0aGUgb2JqZWN0IGl0c2VsZiwgb3ZlcndyaXRpbmcgdGhlIGV4aXN0aW5nXG4gICAgICogbWV0aG9kLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoaXMgbWV0aG9kIGRvZXNuJ3Qgc2V0IHRoZSBcImxlbmd0aFwiIHByb3BlcnR5IG9mIGJvdW5kIGZ1bmN0aW9ucy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICAgKiBAcGFyYW0gey4uLihzdHJpbmd8c3RyaW5nW10pfSBtZXRob2ROYW1lcyBUaGUgb2JqZWN0IG1ldGhvZCBuYW1lcyB0byBiaW5kLlxuICAgICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciB2aWV3ID0ge1xuICAgICAqICAgJ2xhYmVsJzogJ2RvY3MnLFxuICAgICAqICAgJ2NsaWNrJzogZnVuY3Rpb24oKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKCdjbGlja2VkICcgKyB0aGlzLmxhYmVsKTtcbiAgICAgKiAgIH1cbiAgICAgKiB9O1xuICAgICAqXG4gICAgICogXy5iaW5kQWxsKHZpZXcsIFsnY2xpY2snXSk7XG4gICAgICogalF1ZXJ5KGVsZW1lbnQpLm9uKCdjbGljaycsIHZpZXcuY2xpY2spO1xuICAgICAqIC8vID0+IExvZ3MgJ2NsaWNrZWQgZG9jcycgd2hlbiBjbGlja2VkLlxuICAgICAqL1xuICAgIHZhciBiaW5kQWxsID0gZmxhdFJlc3QoZnVuY3Rpb24ob2JqZWN0LCBtZXRob2ROYW1lcykge1xuICAgICAgYXJyYXlFYWNoKG1ldGhvZE5hbWVzLCBmdW5jdGlvbihrZXkpIHtcbiAgICAgICAga2V5ID0gdG9LZXkoa2V5KTtcbiAgICAgICAgYmFzZUFzc2lnblZhbHVlKG9iamVjdCwga2V5LCBiaW5kKG9iamVjdFtrZXldLCBvYmplY3QpKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG9iamVjdDtcbiAgICB9KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGl0ZXJhdGVzIG92ZXIgYHBhaXJzYCBhbmQgaW52b2tlcyB0aGUgY29ycmVzcG9uZGluZ1xuICAgICAqIGZ1bmN0aW9uIG9mIHRoZSBmaXJzdCBwcmVkaWNhdGUgdG8gcmV0dXJuIHRydXRoeS4gVGhlIHByZWRpY2F0ZS1mdW5jdGlvblxuICAgICAqIHBhaXJzIGFyZSBpbnZva2VkIHdpdGggdGhlIGB0aGlzYCBiaW5kaW5nIGFuZCBhcmd1bWVudHMgb2YgdGhlIGNyZWF0ZWRcbiAgICAgKiBmdW5jdGlvbi5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheX0gcGFpcnMgVGhlIHByZWRpY2F0ZS1mdW5jdGlvbiBwYWlycy5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5jb25kKFtcbiAgICAgKiAgIFtfLm1hdGNoZXMoeyAnYSc6IDEgfSksICAgICAgICAgICBfLmNvbnN0YW50KCdtYXRjaGVzIEEnKV0sXG4gICAgICogICBbXy5jb25mb3Jtcyh7ICdiJzogXy5pc051bWJlciB9KSwgXy5jb25zdGFudCgnbWF0Y2hlcyBCJyldLFxuICAgICAqICAgW18uc3R1YlRydWUsICAgICAgICAgICAgICAgICAgICAgIF8uY29uc3RhbnQoJ25vIG1hdGNoJyldXG4gICAgICogXSk7XG4gICAgICpcbiAgICAgKiBmdW5jKHsgJ2EnOiAxLCAnYic6IDIgfSk7XG4gICAgICogLy8gPT4gJ21hdGNoZXMgQSdcbiAgICAgKlxuICAgICAqIGZ1bmMoeyAnYSc6IDAsICdiJzogMSB9KTtcbiAgICAgKiAvLyA9PiAnbWF0Y2hlcyBCJ1xuICAgICAqXG4gICAgICogZnVuYyh7ICdhJzogJzEnLCAnYic6ICcyJyB9KTtcbiAgICAgKiAvLyA9PiAnbm8gbWF0Y2gnXG4gICAgICovXG4gICAgZnVuY3Rpb24gY29uZChwYWlycykge1xuICAgICAgdmFyIGxlbmd0aCA9IHBhaXJzID09IG51bGwgPyAwIDogcGFpcnMubGVuZ3RoLFxuICAgICAgICAgIHRvSXRlcmF0ZWUgPSBnZXRJdGVyYXRlZSgpO1xuXG4gICAgICBwYWlycyA9ICFsZW5ndGggPyBbXSA6IGFycmF5TWFwKHBhaXJzLCBmdW5jdGlvbihwYWlyKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcGFpclsxXSAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihGVU5DX0VSUk9SX1RFWFQpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbdG9JdGVyYXRlZShwYWlyWzBdKSwgcGFpclsxXV07XG4gICAgICB9KTtcblxuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgdmFyIGluZGV4ID0gLTE7XG4gICAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgICAgdmFyIHBhaXIgPSBwYWlyc1tpbmRleF07XG4gICAgICAgICAgaWYgKGFwcGx5KHBhaXJbMF0sIHRoaXMsIGFyZ3MpKSB7XG4gICAgICAgICAgICByZXR1cm4gYXBwbHkocGFpclsxXSwgdGhpcywgYXJncyk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIHRoZSBwcmVkaWNhdGUgcHJvcGVydGllcyBvZiBgc291cmNlYCB3aXRoXG4gICAgICogdGhlIGNvcnJlc3BvbmRpbmcgcHJvcGVydHkgdmFsdWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCByZXR1cm5pbmcgYHRydWVgIGlmXG4gICAgICogYWxsIHByZWRpY2F0ZXMgcmV0dXJuIHRydXRoeSwgZWxzZSBgZmFsc2VgLlxuICAgICAqXG4gICAgICogKipOb3RlOioqIFRoZSBjcmVhdGVkIGZ1bmN0aW9uIGlzIGVxdWl2YWxlbnQgdG8gYF8uY29uZm9ybXNUb2Agd2l0aFxuICAgICAqIGBzb3VyY2VgIHBhcnRpYWxseSBhcHBsaWVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gc291cmNlIFRoZSBvYmplY3Qgb2YgcHJvcGVydHkgcHJlZGljYXRlcyB0byBjb25mb3JtIHRvLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHNwZWMgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW1xuICAgICAqICAgeyAnYSc6IDIsICdiJzogMSB9LFxuICAgICAqICAgeyAnYSc6IDEsICdiJzogMiB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8uY29uZm9ybXMoeyAnYic6IGZ1bmN0aW9uKG4pIHsgcmV0dXJuIG4gPiAxOyB9IH0pKTtcbiAgICAgKiAvLyA9PiBbeyAnYSc6IDEsICdiJzogMiB9XVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbmZvcm1zKHNvdXJjZSkge1xuICAgICAgcmV0dXJuIGJhc2VDb25mb3JtcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGB2YWx1ZWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMi40LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIHJldHVybiBmcm9tIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29uc3RhbnQgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gXy50aW1lcygyLCBfLmNvbnN0YW50KHsgJ2EnOiAxIH0pKTtcbiAgICAgKlxuICAgICAqIGNvbnNvbGUubG9nKG9iamVjdHMpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSB9LCB7ICdhJzogMSB9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGNvbnN0YW50KHZhbHVlKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH07XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ2hlY2tzIGB2YWx1ZWAgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgYSBkZWZhdWx0IHZhbHVlIHNob3VsZCBiZSByZXR1cm5lZCBpblxuICAgICAqIGl0cyBwbGFjZS4gVGhlIGBkZWZhdWx0VmFsdWVgIGlzIHJldHVybmVkIGlmIGB2YWx1ZWAgaXMgYE5hTmAsIGBudWxsYCxcbiAgICAgKiBvciBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjE0LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgICAqIEBwYXJhbSB7Kn0gZGVmYXVsdFZhbHVlIFRoZSBkZWZhdWx0IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSByZXNvbHZlZCB2YWx1ZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5kZWZhdWx0VG8oMSwgMTApO1xuICAgICAqIC8vID0+IDFcbiAgICAgKlxuICAgICAqIF8uZGVmYXVsdFRvKHVuZGVmaW5lZCwgMTApO1xuICAgICAqIC8vID0+IDEwXG4gICAgICovXG4gICAgZnVuY3Rpb24gZGVmYXVsdFRvKHZhbHVlLCBkZWZhdWx0VmFsdWUpIHtcbiAgICAgIHJldHVybiAodmFsdWUgPT0gbnVsbCB8fCB2YWx1ZSAhPT0gdmFsdWUpID8gZGVmYXVsdFZhbHVlIDogdmFsdWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgcmVzdWx0IG9mIGludm9raW5nIHRoZSBnaXZlbiBmdW5jdGlvbnNcbiAgICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbiwgd2hlcmUgZWFjaCBzdWNjZXNzaXZlXG4gICAgICogaW52b2NhdGlvbiBpcyBzdXBwbGllZCB0aGUgcmV0dXJuIHZhbHVlIG9mIHRoZSBwcmV2aW91cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHsuLi4oRnVuY3Rpb258RnVuY3Rpb25bXSl9IFtmdW5jc10gVGhlIGZ1bmN0aW9ucyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zaXRlIGZ1bmN0aW9uLlxuICAgICAqIEBzZWUgXy5mbG93UmlnaHRcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93KFtfLmFkZCwgc3F1YXJlXSk7XG4gICAgICogYWRkU3F1YXJlKDEsIDIpO1xuICAgICAqIC8vID0+IDlcbiAgICAgKi9cbiAgICB2YXIgZmxvdyA9IGNyZWF0ZUZsb3coKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8uZmxvd2AgZXhjZXB0IHRoYXQgaXQgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXRcbiAgICAgKiBpbnZva2VzIHRoZSBnaXZlbiBmdW5jdGlvbnMgZnJvbSByaWdodCB0byBsZWZ0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW2Z1bmNzXSBUaGUgZnVuY3Rpb25zIHRvIGludm9rZS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBjb21wb3NpdGUgZnVuY3Rpb24uXG4gICAgICogQHNlZSBfLmZsb3dcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogZnVuY3Rpb24gc3F1YXJlKG4pIHtcbiAgICAgKiAgIHJldHVybiBuICogbjtcbiAgICAgKiB9XG4gICAgICpcbiAgICAgKiB2YXIgYWRkU3F1YXJlID0gXy5mbG93UmlnaHQoW3NxdWFyZSwgXy5hZGRdKTtcbiAgICAgKiBhZGRTcXVhcmUoMSwgMik7XG4gICAgICogLy8gPT4gOVxuICAgICAqL1xuICAgIHZhciBmbG93UmlnaHQgPSBjcmVhdGVGbG93KHRydWUpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyB0aGUgZmlyc3QgYXJndW1lbnQgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgQW55IHZhbHVlLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIGB2YWx1ZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3QgPSB7ICdhJzogMSB9O1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coXy5pZGVudGl0eShvYmplY3QpID09PSBvYmplY3QpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBpZGVudGl0eSh2YWx1ZSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGFyZ3VtZW50cyBvZiB0aGUgY3JlYXRlZFxuICAgICAqIGZ1bmN0aW9uLiBJZiBgZnVuY2AgaXMgYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY3JlYXRlZCBmdW5jdGlvbiByZXR1cm5zIHRoZVxuICAgICAqIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuIElmIGBmdW5jYCBpcyBhbiBhcnJheSBvciBvYmplY3QsIHRoZVxuICAgICAqIGNyZWF0ZWQgZnVuY3Rpb24gcmV0dXJucyBgdHJ1ZWAgZm9yIGVsZW1lbnRzIHRoYXQgY29udGFpbiB0aGUgZXF1aXZhbGVudFxuICAgICAqIHNvdXJjZSBwcm9wZXJ0aWVzLCBvdGhlcndpc2UgaXQgcmV0dXJucyBgZmFsc2VgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0geyp9IFtmdW5jPV8uaWRlbnRpdHldIFRoZSB2YWx1ZSB0byBjb252ZXJ0IHRvIGEgY2FsbGJhY2suXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBjYWxsYmFjay5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIHVzZXJzID0gW1xuICAgICAqICAgeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH0sXG4gICAgICogICB7ICd1c2VyJzogJ2ZyZWQnLCAgICdhZ2UnOiA0MCwgJ2FjdGl2ZSc6IGZhbHNlIH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogLy8gVGhlIGBfLm1hdGNoZXNgIGl0ZXJhdGVlIHNob3J0aGFuZC5cbiAgICAgKiBfLmZpbHRlcih1c2VycywgXy5pdGVyYXRlZSh7ICd1c2VyJzogJ2Jhcm5leScsICdhY3RpdmUnOiB0cnVlIH0pKTtcbiAgICAgKiAvLyA9PiBbeyAndXNlcic6ICdiYXJuZXknLCAnYWdlJzogMzYsICdhY3RpdmUnOiB0cnVlIH1dXG4gICAgICpcbiAgICAgKiAvLyBUaGUgYF8ubWF0Y2hlc1Byb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5maWx0ZXIodXNlcnMsIF8uaXRlcmF0ZWUoWyd1c2VyJywgJ2ZyZWQnXSkpO1xuICAgICAqIC8vID0+IFt7ICd1c2VyJzogJ2ZyZWQnLCAnYWdlJzogNDAgfV1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWFwKHVzZXJzLCBfLml0ZXJhdGVlKCd1c2VyJykpO1xuICAgICAqIC8vID0+IFsnYmFybmV5JywgJ2ZyZWQnXVxuICAgICAqXG4gICAgICogLy8gQ3JlYXRlIGN1c3RvbSBpdGVyYXRlZSBzaG9ydGhhbmRzLlxuICAgICAqIF8uaXRlcmF0ZWUgPSBfLndyYXAoXy5pdGVyYXRlZSwgZnVuY3Rpb24oaXRlcmF0ZWUsIGZ1bmMpIHtcbiAgICAgKiAgIHJldHVybiAhXy5pc1JlZ0V4cChmdW5jKSA/IGl0ZXJhdGVlKGZ1bmMpIDogZnVuY3Rpb24oc3RyaW5nKSB7XG4gICAgICogICAgIHJldHVybiBmdW5jLnRlc3Qoc3RyaW5nKTtcbiAgICAgKiAgIH07XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiBfLmZpbHRlcihbJ2FiYycsICdkZWYnXSwgL2VmLyk7XG4gICAgICogLy8gPT4gWydkZWYnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIGl0ZXJhdGVlKGZ1bmMpIHtcbiAgICAgIHJldHVybiBiYXNlSXRlcmF0ZWUodHlwZW9mIGZ1bmMgPT0gJ2Z1bmN0aW9uJyA/IGZ1bmMgOiBiYXNlQ2xvbmUoZnVuYywgQ0xPTkVfREVFUF9GTEFHKSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcGVyZm9ybXMgYSBwYXJ0aWFsIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIGEgZ2l2ZW5cbiAgICAgKiBvYmplY3QgYW5kIGBzb3VyY2VgLCByZXR1cm5pbmcgYHRydWVgIGlmIHRoZSBnaXZlbiBvYmplY3QgaGFzIGVxdWl2YWxlbnRcbiAgICAgKiBwcm9wZXJ0eSB2YWx1ZXMsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBUaGUgY3JlYXRlZCBmdW5jdGlvbiBpcyBlcXVpdmFsZW50IHRvIGBfLmlzTWF0Y2hgIHdpdGggYHNvdXJjZWBcbiAgICAgKiBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICAgKlxuICAgICAqIFBhcnRpYWwgY29tcGFyaXNvbnMgd2lsbCBtYXRjaCBlbXB0eSBhcnJheSBhbmQgZW1wdHkgb2JqZWN0IGBzb3VyY2VgXG4gICAgICogdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWUgYF8uaXNFcXVhbGBcbiAgICAgKiBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjAuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtPYmplY3R9IHNvdXJjZSBUaGUgb2JqZWN0IG9mIHByb3BlcnR5IHZhbHVlcyB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maWx0ZXIob2JqZWN0cywgXy5tYXRjaGVzKHsgJ2EnOiA0LCAnYyc6IDYgfSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogNCwgJ2InOiA1LCAnYyc6IDYgfV1cbiAgICAgKlxuICAgICAqIC8vIENoZWNraW5nIGZvciBzZXZlcmFsIHBvc3NpYmxlIHZhbHVlc1xuICAgICAqIF8uZmlsdGVyKG9iamVjdHMsIF8ub3ZlclNvbWUoW18ubWF0Y2hlcyh7ICdhJzogMSB9KSwgXy5tYXRjaGVzKHsgJ2EnOiA0IH0pXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlcyhzb3VyY2UpIHtcbiAgICAgIHJldHVybiBiYXNlTWF0Y2hlcyhiYXNlQ2xvbmUoc291cmNlLCBDTE9ORV9ERUVQX0ZMQUcpKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwZXJmb3JtcyBhIHBhcnRpYWwgZGVlcCBjb21wYXJpc29uIGJldHdlZW4gdGhlXG4gICAgICogdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0IHRvIGBzcmNWYWx1ZWAsIHJldHVybmluZyBgdHJ1ZWAgaWYgdGhlXG4gICAgICogb2JqZWN0IHZhbHVlIGlzIGVxdWl2YWxlbnQsIGVsc2UgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBQYXJ0aWFsIGNvbXBhcmlzb25zIHdpbGwgbWF0Y2ggZW1wdHkgYXJyYXkgYW5kIGVtcHR5IG9iamVjdFxuICAgICAqIGBzcmNWYWx1ZWAgdmFsdWVzIGFnYWluc3QgYW55IGFycmF5IG9yIG9iamVjdCB2YWx1ZSwgcmVzcGVjdGl2ZWx5LiBTZWVcbiAgICAgKiBgXy5pc0VxdWFsYCBmb3IgYSBsaXN0IG9mIHN1cHBvcnRlZCB2YWx1ZSBjb21wYXJpc29ucy5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBNdWx0aXBsZSB2YWx1ZXMgY2FuIGJlIGNoZWNrZWQgYnkgY29tYmluaW5nIHNldmVyYWwgbWF0Y2hlcnNcbiAgICAgKiB1c2luZyBgXy5vdmVyU29tZWBcbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjIuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtBcnJheXxzdHJpbmd9IHBhdGggVGhlIHBhdGggb2YgdGhlIHByb3BlcnR5IHRvIGdldC5cbiAgICAgKiBAcGFyYW0geyp9IHNyY1ZhbHVlIFRoZSB2YWx1ZSB0byBtYXRjaC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBzcGVjIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiAxLCAnYic6IDIsICdjJzogMyB9LFxuICAgICAqICAgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1cbiAgICAgKiBdO1xuICAgICAqXG4gICAgICogXy5maW5kKG9iamVjdHMsIF8ubWF0Y2hlc1Byb3BlcnR5KCdhJywgNCkpO1xuICAgICAqIC8vID0+IHsgJ2EnOiA0LCAnYic6IDUsICdjJzogNiB9XG4gICAgICpcbiAgICAgKiAvLyBDaGVja2luZyBmb3Igc2V2ZXJhbCBwb3NzaWJsZSB2YWx1ZXNcbiAgICAgKiBfLmZpbHRlcihvYmplY3RzLCBfLm92ZXJTb21lKFtfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDEpLCBfLm1hdGNoZXNQcm9wZXJ0eSgnYScsIDQpXSkpO1xuICAgICAqIC8vID0+IFt7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgeyAnYSc6IDQsICdiJzogNSwgJ2MnOiA2IH1dXG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF0Y2hlc1Byb3BlcnR5KHBhdGgsIHNyY1ZhbHVlKSB7XG4gICAgICByZXR1cm4gYmFzZU1hdGNoZXNQcm9wZXJ0eShwYXRoLCBiYXNlQ2xvbmUoc3JjVmFsdWUsIENMT05FX0RFRVBfRkxBRykpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGludm9rZXMgdGhlIG1ldGhvZCBhdCBgcGF0aGAgb2YgYSBnaXZlbiBvYmplY3QuXG4gICAgICogQW55IGFkZGl0aW9uYWwgYXJndW1lbnRzIGFyZSBwcm92aWRlZCB0byB0aGUgaW52b2tlZCBtZXRob2QuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy43LjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7QXJyYXl8c3RyaW5nfSBwYXRoIFRoZSBwYXRoIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlLlxuICAgICAqIEBwYXJhbSB7Li4uKn0gW2FyZ3NdIFRoZSBhcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBpbnZva2VyIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogXy5jb25zdGFudCgyKSB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IF8uY29uc3RhbnQoMSkgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ubWV0aG9kKCdhLmInKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICpcbiAgICAgKiBfLm1hcChvYmplY3RzLCBfLm1ldGhvZChbJ2EnLCAnYiddKSk7XG4gICAgICogLy8gPT4gWzIsIDFdXG4gICAgICovXG4gICAgdmFyIG1ldGhvZCA9IGJhc2VSZXN0KGZ1bmN0aW9uKHBhdGgsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VJbnZva2Uob2JqZWN0LCBwYXRoLCBhcmdzKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvKipcbiAgICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8ubWV0aG9kYDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaW52b2tlc1xuICAgICAqIHRoZSBtZXRob2QgYXQgYSBnaXZlbiBwYXRoIG9mIGBvYmplY3RgLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYXJlXG4gICAgICogcHJvdmlkZWQgdG8gdGhlIGludm9rZWQgbWV0aG9kLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuNy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gcXVlcnkuXG4gICAgICogQHBhcmFtIHsuLi4qfSBbYXJnc10gVGhlIGFyZ3VtZW50cyB0byBpbnZva2UgdGhlIG1ldGhvZCB3aXRoLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGludm9rZXIgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBhcnJheSA9IF8udGltZXMoMywgXy5jb25zdGFudCksXG4gICAgICogICAgIG9iamVjdCA9IHsgJ2EnOiBhcnJheSwgJ2InOiBhcnJheSwgJ2MnOiBhcnJheSB9O1xuICAgICAqXG4gICAgICogXy5tYXAoWydhWzJdJywgJ2NbMF0nXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5tZXRob2RPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKi9cbiAgICB2YXIgbWV0aG9kT2YgPSBiYXNlUmVzdChmdW5jdGlvbihvYmplY3QsIGFyZ3MpIHtcbiAgICAgIHJldHVybiBmdW5jdGlvbihwYXRoKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKG9iamVjdCwgcGF0aCwgYXJncyk7XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLyoqXG4gICAgICogQWRkcyBhbGwgb3duIGVudW1lcmFibGUgc3RyaW5nIGtleWVkIGZ1bmN0aW9uIHByb3BlcnRpZXMgb2YgYSBzb3VyY2VcbiAgICAgKiBvYmplY3QgdG8gdGhlIGRlc3RpbmF0aW9uIG9iamVjdC4gSWYgYG9iamVjdGAgaXMgYSBmdW5jdGlvbiwgdGhlbiBtZXRob2RzXG4gICAgICogYXJlIGFkZGVkIHRvIGl0cyBwcm90b3R5cGUgYXMgd2VsbC5cbiAgICAgKlxuICAgICAqICoqTm90ZToqKiBVc2UgYF8ucnVuSW5Db250ZXh0YCB0byBjcmVhdGUgYSBwcmlzdGluZSBgbG9kYXNoYCBmdW5jdGlvbiB0b1xuICAgICAqIGF2b2lkIGNvbmZsaWN0cyBjYXVzZWQgYnkgbW9kaWZ5aW5nIHRoZSBvcmlnaW5hbC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbnxPYmplY3R9IFtvYmplY3Q9bG9kYXNoXSBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBzb3VyY2UgVGhlIG9iamVjdCBvZiBmdW5jdGlvbnMgdG8gYWRkLlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucz17fV0gVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuY2hhaW49dHJ1ZV0gU3BlY2lmeSB3aGV0aGVyIG1peGlucyBhcmUgY2hhaW5hYmxlLlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbnxPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIGZ1bmN0aW9uIHZvd2VscyhzdHJpbmcpIHtcbiAgICAgKiAgIHJldHVybiBfLmZpbHRlcihzdHJpbmcsIGZ1bmN0aW9uKHYpIHtcbiAgICAgKiAgICAgcmV0dXJuIC9bYWVpb3VdL2kudGVzdCh2KTtcbiAgICAgKiAgIH0pO1xuICAgICAqIH1cbiAgICAgKlxuICAgICAqIF8ubWl4aW4oeyAndm93ZWxzJzogdm93ZWxzIH0pO1xuICAgICAqIF8udm93ZWxzKCdmcmVkJyk7XG4gICAgICogLy8gPT4gWydlJ11cbiAgICAgKlxuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKS52YWx1ZSgpO1xuICAgICAqIC8vID0+IFsnZSddXG4gICAgICpcbiAgICAgKiBfLm1peGluKHsgJ3Zvd2Vscyc6IHZvd2VscyB9LCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuICAgICAqIF8oJ2ZyZWQnKS52b3dlbHMoKTtcbiAgICAgKiAvLyA9PiBbJ2UnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1peGluKG9iamVjdCwgc291cmNlLCBvcHRpb25zKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKHNvdXJjZSksXG4gICAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwgcHJvcHMpO1xuXG4gICAgICBpZiAob3B0aW9ucyA9PSBudWxsICYmXG4gICAgICAgICAgIShpc09iamVjdChzb3VyY2UpICYmIChtZXRob2ROYW1lcy5sZW5ndGggfHwgIXByb3BzLmxlbmd0aCkpKSB7XG4gICAgICAgIG9wdGlvbnMgPSBzb3VyY2U7XG4gICAgICAgIHNvdXJjZSA9IG9iamVjdDtcbiAgICAgICAgb2JqZWN0ID0gdGhpcztcbiAgICAgICAgbWV0aG9kTmFtZXMgPSBiYXNlRnVuY3Rpb25zKHNvdXJjZSwga2V5cyhzb3VyY2UpKTtcbiAgICAgIH1cbiAgICAgIHZhciBjaGFpbiA9ICEoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NoYWluJyBpbiBvcHRpb25zKSB8fCAhIW9wdGlvbnMuY2hhaW4sXG4gICAgICAgICAgaXNGdW5jID0gaXNGdW5jdGlvbihvYmplY3QpO1xuXG4gICAgICBhcnJheUVhY2gobWV0aG9kTmFtZXMsIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgICAgdmFyIGZ1bmMgPSBzb3VyY2VbbWV0aG9kTmFtZV07XG4gICAgICAgIG9iamVjdFttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgICAgICBvYmplY3QucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXztcbiAgICAgICAgICAgIGlmIChjaGFpbiB8fCBjaGFpbkFsbCkge1xuICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0KHRoaXMuX193cmFwcGVkX18pLFxuICAgICAgICAgICAgICAgICAgYWN0aW9ucyA9IHJlc3VsdC5fX2FjdGlvbnNfXyA9IGNvcHlBcnJheSh0aGlzLl9fYWN0aW9uc19fKTtcblxuICAgICAgICAgICAgICBhY3Rpb25zLnB1c2goeyAnZnVuYyc6IGZ1bmMsICdhcmdzJzogYXJndW1lbnRzLCAndGhpc0FyZyc6IG9iamVjdCB9KTtcbiAgICAgICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IGNoYWluQWxsO1xuICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkob2JqZWN0LCBhcnJheVB1c2goW3RoaXMudmFsdWUoKV0sIGFyZ3VtZW50cykpO1xuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gb2JqZWN0O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJldmVydHMgdGhlIGBfYCB2YXJpYWJsZSB0byBpdHMgcHJldmlvdXMgdmFsdWUgYW5kIHJldHVybnMgYSByZWZlcmVuY2UgdG9cbiAgICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQHNpbmNlIDAuMS4wXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBsb2Rhc2ggPSBfLm5vQ29uZmxpY3QoKTtcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgICAgaWYgKHJvb3QuXyA9PT0gdGhpcykge1xuICAgICAgICByb290Ll8gPSBvbGREYXNoO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBgdW5kZWZpbmVkYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAyLjMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5ub29wKTtcbiAgICAgKiAvLyA9PiBbdW5kZWZpbmVkLCB1bmRlZmluZWRdXG4gICAgICovXG4gICAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAgIC8vIE5vIG9wZXJhdGlvbiBwZXJmb3JtZWQuXG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgZ2V0cyB0aGUgYXJndW1lbnQgYXQgaW5kZXggYG5gLiBJZiBgbmAgaXMgbmVnYXRpdmUsXG4gICAgICogdGhlIG50aCBhcmd1bWVudCBmcm9tIHRoZSBlbmQgaXMgcmV0dXJuZWQuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbbj0wXSBUaGUgaW5kZXggb2YgdGhlIGFyZ3VtZW50IHRvIHJldHVybi5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBwYXNzLXRocnUgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5udGhBcmcoMSk7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdiJ1xuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm50aEFyZygtMik7XG4gICAgICogZnVuYygnYScsICdiJywgJ2MnLCAnZCcpO1xuICAgICAqIC8vID0+ICdjJ1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIG50aEFyZyhuKSB7XG4gICAgICBuID0gdG9JbnRlZ2VyKG4pO1xuICAgICAgcmV0dXJuIGJhc2VSZXN0KGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIGJhc2VOdGgoYXJncywgbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBpbnZva2VzIGBpdGVyYXRlZXNgIHdpdGggdGhlIGFyZ3VtZW50cyBpdCByZWNlaXZlc1xuICAgICAqIGFuZCByZXR1cm5zIHRoZWlyIHJlc3VsdHMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Li4uKEZ1bmN0aW9ufEZ1bmN0aW9uW10pfSBbaXRlcmF0ZWVzPVtfLmlkZW50aXR5XV1cbiAgICAgKiAgVGhlIGl0ZXJhdGVlcyB0byBpbnZva2UuXG4gICAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBmdW5jID0gXy5vdmVyKFtNYXRoLm1heCwgTWF0aC5taW5dKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoMSwgMiwgMywgNCk7XG4gICAgICogLy8gPT4gWzQsIDFdXG4gICAgICovXG4gICAgdmFyIG92ZXIgPSBjcmVhdGVPdmVyKGFycmF5TWFwKTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFsbCoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJFdmVyeShbQm9vbGVhbiwgaXNGaW5pdGVdKTtcbiAgICAgKlxuICAgICAqIGZ1bmMoJzEnKTtcbiAgICAgKiAvLyA9PiB0cnVlXG4gICAgICpcbiAgICAgKiBmdW5jKG51bGwpO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiBmdW5jKE5hTik7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICB2YXIgb3ZlckV2ZXJ5ID0gY3JlYXRlT3ZlcihhcnJheUV2ZXJ5KTtcblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGNoZWNrcyBpZiAqKmFueSoqIG9mIHRoZSBgcHJlZGljYXRlc2AgcmV0dXJuXG4gICAgICogdHJ1dGh5IHdoZW4gaW52b2tlZCB3aXRoIHRoZSBhcmd1bWVudHMgaXQgcmVjZWl2ZXMuXG4gICAgICpcbiAgICAgKiBGb2xsb3dpbmcgc2hvcnRoYW5kcyBhcmUgcG9zc2libGUgZm9yIHByb3ZpZGluZyBwcmVkaWNhdGVzLlxuICAgICAqIFBhc3MgYW4gYE9iamVjdGAgYW5kIGl0IHdpbGwgYmUgdXNlZCBhcyBhbiBwYXJhbWV0ZXIgZm9yIGBfLm1hdGNoZXNgIHRvIGNyZWF0ZSB0aGUgcHJlZGljYXRlLlxuICAgICAqIFBhc3MgYW4gYEFycmF5YCBvZiBwYXJhbWV0ZXJzIGZvciBgXy5tYXRjaGVzUHJvcGVydHlgIGFuZCB0aGUgcHJlZGljYXRlIHdpbGwgYmUgY3JlYXRlZCB1c2luZyB0aGVtLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0gey4uLihGdW5jdGlvbnxGdW5jdGlvbltdKX0gW3ByZWRpY2F0ZXM9W18uaWRlbnRpdHldXVxuICAgICAqICBUaGUgcHJlZGljYXRlcyB0byBjaGVjay5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGZ1bmMgPSBfLm92ZXJTb21lKFtCb29sZWFuLCBpc0Zpbml0ZV0pO1xuICAgICAqXG4gICAgICogZnVuYygnMScpO1xuICAgICAqIC8vID0+IHRydWVcbiAgICAgKlxuICAgICAqIGZ1bmMobnVsbCk7XG4gICAgICogLy8gPT4gdHJ1ZVxuICAgICAqXG4gICAgICogZnVuYyhOYU4pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICpcbiAgICAgKiB2YXIgbWF0Y2hlc0Z1bmMgPSBfLm92ZXJTb21lKFt7ICdhJzogMSB9LCB7ICdhJzogMiB9XSlcbiAgICAgKiB2YXIgbWF0Y2hlc1Byb3BlcnR5RnVuYyA9IF8ub3ZlclNvbWUoW1snYScsIDFdLCBbJ2EnLCAyXV0pXG4gICAgICovXG4gICAgdmFyIG92ZXJTb21lID0gY3JlYXRlT3ZlcihhcnJheVNvbWUpO1xuXG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgdmFsdWUgYXQgYHBhdGhgIG9mIGEgZ2l2ZW4gb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDIuNC4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge0FycmF5fHN0cmluZ30gcGF0aCBUaGUgcGF0aCBvZiB0aGUgcHJvcGVydHkgdG8gZ2V0LlxuICAgICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGFjY2Vzc29yIGZ1bmN0aW9uLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFtcbiAgICAgKiAgIHsgJ2EnOiB7ICdiJzogMiB9IH0sXG4gICAgICogICB7ICdhJzogeyAnYic6IDEgfSB9XG4gICAgICogXTtcbiAgICAgKlxuICAgICAqIF8ubWFwKG9iamVjdHMsIF8ucHJvcGVydHkoJ2EuYicpKTtcbiAgICAgKiAvLyA9PiBbMiwgMV1cbiAgICAgKlxuICAgICAqIF8ubWFwKF8uc29ydEJ5KG9iamVjdHMsIF8ucHJvcGVydHkoWydhJywgJ2InXSkpLCAnYS5iJyk7XG4gICAgICogLy8gPT4gWzEsIDJdXG4gICAgICovXG4gICAgZnVuY3Rpb24gcHJvcGVydHkocGF0aCkge1xuICAgICAgcmV0dXJuIGlzS2V5KHBhdGgpID8gYmFzZVByb3BlcnR5KHRvS2V5KHBhdGgpKSA6IGJhc2VQcm9wZXJ0eURlZXAocGF0aCk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhlIG9wcG9zaXRlIG9mIGBfLnByb3BlcnR5YDsgdGhpcyBtZXRob2QgY3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJuc1xuICAgICAqIHRoZSB2YWx1ZSBhdCBhIGdpdmVuIHBhdGggb2YgYG9iamVjdGAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBxdWVyeS5cbiAgICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyBhY2Nlc3NvciBmdW5jdGlvbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5ID0gWzAsIDEsIDJdLFxuICAgICAqICAgICBvYmplY3QgPSB7ICdhJzogYXJyYXksICdiJzogYXJyYXksICdjJzogYXJyYXkgfTtcbiAgICAgKlxuICAgICAqIF8ubWFwKFsnYVsyXScsICdjWzBdJ10sIF8ucHJvcGVydHlPZihvYmplY3QpKTtcbiAgICAgKiAvLyA9PiBbMiwgMF1cbiAgICAgKlxuICAgICAqIF8ubWFwKFtbJ2EnLCAnMiddLCBbJ2MnLCAnMCddXSwgXy5wcm9wZXJ0eU9mKG9iamVjdCkpO1xuICAgICAqIC8vID0+IFsyLCAwXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHByb3BlcnR5T2Yob2JqZWN0KSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ocGF0aCkge1xuICAgICAgICByZXR1cm4gb2JqZWN0ID09IG51bGwgPyB1bmRlZmluZWQgOiBiYXNlR2V0KG9iamVjdCwgcGF0aCk7XG4gICAgICB9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgbnVtYmVycyAocG9zaXRpdmUgYW5kL29yIG5lZ2F0aXZlKSBwcm9ncmVzc2luZyBmcm9tXG4gICAgICogYHN0YXJ0YCB1cCB0bywgYnV0IG5vdCBpbmNsdWRpbmcsIGBlbmRgLiBBIHN0ZXAgb2YgYC0xYCBpcyB1c2VkIGlmIGEgbmVnYXRpdmVcbiAgICAgKiBgc3RhcnRgIGlzIHNwZWNpZmllZCB3aXRob3V0IGFuIGBlbmRgIG9yIGBzdGVwYC4gSWYgYGVuZGAgaXMgbm90IHNwZWNpZmllZCxcbiAgICAgKiBpdCdzIHNldCB0byBgc3RhcnRgIHdpdGggYHN0YXJ0YCB0aGVuIHNldCB0byBgMGAuXG4gICAgICpcbiAgICAgKiAqKk5vdGU6KiogSmF2YVNjcmlwdCBmb2xsb3dzIHRoZSBJRUVFLTc1NCBzdGFuZGFyZCBmb3IgcmVzb2x2aW5nXG4gICAgICogZmxvYXRpbmctcG9pbnQgdmFsdWVzIHdoaWNoIGNhbiBwcm9kdWNlIHVuZXhwZWN0ZWQgcmVzdWx0cy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGFydD0wXSBUaGUgc3RhcnQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtzdGVwPTFdIFRoZSB2YWx1ZSB0byBpbmNyZW1lbnQgb3IgZGVjcmVtZW50IGJ5LlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgcmFuZ2Ugb2YgbnVtYmVycy5cbiAgICAgKiBAc2VlIF8uaW5SYW5nZSwgXy5yYW5nZVJpZ2h0XG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoNCk7XG4gICAgICogLy8gPT4gWzAsIDEsIDIsIDNdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKC00KTtcbiAgICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtM11cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMSwgNSk7XG4gICAgICogLy8gPT4gWzEsIDIsIDMsIDRdXG4gICAgICpcbiAgICAgKiBfLnJhbmdlKDAsIDIwLCA1KTtcbiAgICAgKiAvLyA9PiBbMCwgNSwgMTAsIDE1XVxuICAgICAqXG4gICAgICogXy5yYW5nZSgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFswLCAtMSwgLTIsIC0zXVxuICAgICAqXG4gICAgICogXy5yYW5nZSgxLCA0LCAwKTtcbiAgICAgKiAvLyA9PiBbMSwgMSwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2UoMCk7XG4gICAgICogLy8gPT4gW11cbiAgICAgKi9cbiAgICB2YXIgcmFuZ2UgPSBjcmVhdGVSYW5nZSgpO1xuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5yYW5nZWAgZXhjZXB0IHRoYXQgaXQgcG9wdWxhdGVzIHZhbHVlcyBpblxuICAgICAqIGRlc2NlbmRpbmcgb3JkZXIuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RhcnQ9MF0gVGhlIHN0YXJ0IG9mIHRoZSByYW5nZS5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZW5kIFRoZSBlbmQgb2YgdGhlIHJhbmdlLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlY3JlbWVudCBieS5cbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIHJhbmdlIG9mIG51bWJlcnMuXG4gICAgICogQHNlZSBfLmluUmFuZ2UsIF8ucmFuZ2VcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDQpO1xuICAgICAqIC8vID0+IFszLCAyLCAxLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KC00KTtcbiAgICAgKiAvLyA9PiBbLTMsIC0yLCAtMSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgxLCA1KTtcbiAgICAgKiAvLyA9PiBbNCwgMywgMiwgMV1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAyMCwgNSk7XG4gICAgICogLy8gPT4gWzE1LCAxMCwgNSwgMF1cbiAgICAgKlxuICAgICAqIF8ucmFuZ2VSaWdodCgwLCAtNCwgLTEpO1xuICAgICAqIC8vID0+IFstMywgLTIsIC0xLCAwXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDEsIDQsIDApO1xuICAgICAqIC8vID0+IFsxLCAxLCAxXVxuICAgICAqXG4gICAgICogXy5yYW5nZVJpZ2h0KDApO1xuICAgICAqIC8vID0+IFtdXG4gICAgICovXG4gICAgdmFyIHJhbmdlUmlnaHQgPSBjcmVhdGVSYW5nZSh0cnVlKTtcblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4xMy4wXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgdGhlIG5ldyBlbXB0eSBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIGFycmF5cyA9IF8udGltZXMoMiwgXy5zdHViQXJyYXkpO1xuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzKTtcbiAgICAgKiAvLyA9PiBbW10sIFtdXVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2coYXJyYXlzWzBdID09PSBhcnJheXNbMV0pO1xuICAgICAqIC8vID0+IGZhbHNlXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkFycmF5KCkge1xuICAgICAgcmV0dXJuIFtdO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYGZhbHNlYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjEzLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGBmYWxzZWAuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8udGltZXMoMiwgXy5zdHViRmFsc2UpO1xuICAgICAqIC8vID0+IFtmYWxzZSwgZmFsc2VdXG4gICAgICovXG4gICAgZnVuY3Rpb24gc3R1YkZhbHNlKCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYSBuZXcgZW1wdHkgb2JqZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgbmV3IGVtcHR5IG9iamVjdC5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBfLnRpbWVzKDIsIF8uc3R1Yk9iamVjdCk7XG4gICAgICpcbiAgICAgKiBjb25zb2xlLmxvZyhvYmplY3RzKTtcbiAgICAgKiAvLyA9PiBbe30sIHt9XVxuICAgICAqXG4gICAgICogY29uc29sZS5sb2cob2JqZWN0c1swXSA9PT0gb2JqZWN0c1sxXSk7XG4gICAgICogLy8gPT4gZmFsc2VcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViT2JqZWN0KCkge1xuICAgICAgcmV0dXJuIHt9O1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYW4gZW1wdHkgc3RyaW5nLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgZW1wdHkgc3RyaW5nLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlN0cmluZyk7XG4gICAgICogLy8gPT4gWycnLCAnJ11cbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdHViU3RyaW5nKCkge1xuICAgICAgcmV0dXJuICcnO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIHJldHVybnMgYHRydWVgLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuMTMuMFxuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnRpbWVzKDIsIF8uc3R1YlRydWUpO1xuICAgICAqIC8vID0+IFt0cnVlLCB0cnVlXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN0dWJUcnVlKCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogSW52b2tlcyB0aGUgaXRlcmF0ZWUgYG5gIHRpbWVzLCByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2ZcbiAgICAgKiBlYWNoIGludm9jYXRpb24uIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OyAoaW5kZXgpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IFV0aWxcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRvIGludm9rZSBgaXRlcmF0ZWVgLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyB0aGUgYXJyYXkgb2YgcmVzdWx0cy5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50aW1lcygzLCBTdHJpbmcpO1xuICAgICAqIC8vID0+IFsnMCcsICcxJywgJzInXVxuICAgICAqXG4gICAgICogIF8udGltZXMoNCwgXy5jb25zdGFudCgwKSk7XG4gICAgICogLy8gPT4gWzAsIDAsIDAsIDBdXG4gICAgICovXG4gICAgZnVuY3Rpb24gdGltZXMobiwgaXRlcmF0ZWUpIHtcbiAgICAgIG4gPSB0b0ludGVnZXIobik7XG4gICAgICBpZiAobiA8IDEgfHwgbiA+IE1BWF9TQUZFX0lOVEVHRVIpIHtcbiAgICAgICAgcmV0dXJuIFtdO1xuICAgICAgfVxuICAgICAgdmFyIGluZGV4ID0gTUFYX0FSUkFZX0xFTkdUSCxcbiAgICAgICAgICBsZW5ndGggPSBuYXRpdmVNaW4obiwgTUFYX0FSUkFZX0xFTkdUSCk7XG5cbiAgICAgIGl0ZXJhdGVlID0gZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUpO1xuICAgICAgbiAtPSBNQVhfQVJSQVlfTEVOR1RIO1xuXG4gICAgICB2YXIgcmVzdWx0ID0gYmFzZVRpbWVzKGxlbmd0aCwgaXRlcmF0ZWUpO1xuICAgICAgd2hpbGUgKCsraW5kZXggPCBuKSB7XG4gICAgICAgIGl0ZXJhdGVlKGluZGV4KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQ29udmVydHMgYHZhbHVlYCB0byBhIHByb3BlcnR5IHBhdGggYXJyYXkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgVXRpbFxuICAgICAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNvbnZlcnQuXG4gICAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgcHJvcGVydHkgcGF0aCBhcnJheS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy50b1BhdGgoJ2EuYi5jJyk7XG4gICAgICogLy8gPT4gWydhJywgJ2InLCAnYyddXG4gICAgICpcbiAgICAgKiBfLnRvUGF0aCgnYVswXS5iLmMnKTtcbiAgICAgKiAvLyA9PiBbJ2EnLCAnMCcsICdiJywgJ2MnXVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHRvUGF0aCh2YWx1ZSkge1xuICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBhcnJheU1hcCh2YWx1ZSwgdG9LZXkpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGlzU3ltYm9sKHZhbHVlKSA/IFt2YWx1ZV0gOiBjb3B5QXJyYXkoc3RyaW5nVG9QYXRoKHRvU3RyaW5nKHZhbHVlKSkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBJRC4gSWYgYHByZWZpeGAgaXMgZ2l2ZW4sIHRoZSBJRCBpcyBhcHBlbmRlZCB0byBpdC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAc2luY2UgMC4xLjBcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBjYXRlZ29yeSBVdGlsXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IFtwcmVmaXg9JyddIFRoZSB2YWx1ZSB0byBwcmVmaXggdGhlIElEIHdpdGguXG4gICAgICogQHJldHVybnMge3N0cmluZ30gUmV0dXJucyB0aGUgdW5pcXVlIElELlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgICAqIC8vID0+ICdjb250YWN0XzEwNCdcbiAgICAgKlxuICAgICAqIF8udW5pcXVlSWQoKTtcbiAgICAgKiAvLyA9PiAnMTA1J1xuICAgICAqL1xuICAgIGZ1bmN0aW9uIHVuaXF1ZUlkKHByZWZpeCkge1xuICAgICAgdmFyIGlkID0gKytpZENvdW50ZXI7XG4gICAgICByZXR1cm4gdG9TdHJpbmcocHJlZml4KSArIGlkO1xuICAgIH1cblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8qKlxuICAgICAqIEFkZHMgdHdvIG51bWJlcnMuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgMy40LjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBhdWdlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhbiBhZGRpdGlvbi5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gYWRkZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGFuIGFkZGl0aW9uLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHRvdGFsLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmFkZCg2LCA0KTtcbiAgICAgKiAvLyA9PiAxMFxuICAgICAqL1xuICAgIHZhciBhZGQgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGF1Z2VuZCwgYWRkZW5kKSB7XG4gICAgICByZXR1cm4gYXVnZW5kICsgYWRkZW5kO1xuICAgIH0sIDApO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB1cCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZCB1cC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHVwIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgdXAgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLmNlaWwoNC4wMDYpO1xuICAgICAqIC8vID0+IDVcbiAgICAgKlxuICAgICAqIF8uY2VpbCg2LjAwNCwgMik7XG4gICAgICogLy8gPT4gNi4wMVxuICAgICAqXG4gICAgICogXy5jZWlsKDYwNDAsIC0yKTtcbiAgICAgKiAvLyA9PiA2MTAwXG4gICAgICovXG4gICAgdmFyIGNlaWwgPSBjcmVhdGVSb3VuZCgnY2VpbCcpO1xuXG4gICAgLyoqXG4gICAgICogRGl2aWRlIHR3byBudW1iZXJzLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gZGl2aWRlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIGRpdmlzaW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBkaXZpc29yIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgZGl2aXNpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgcXVvdGllbnQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZGl2aWRlKDYsIDQpO1xuICAgICAqIC8vID0+IDEuNVxuICAgICAqL1xuICAgIHZhciBkaXZpZGUgPSBjcmVhdGVNYXRoT3BlcmF0aW9uKGZ1bmN0aW9uKGRpdmlkZW5kLCBkaXZpc29yKSB7XG4gICAgICByZXR1cm4gZGl2aWRlbmQgLyBkaXZpc29yO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCBkb3duIHRvIGBwcmVjaXNpb25gLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDMuMTAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG51bWJlciBUaGUgbnVtYmVyIHRvIHJvdW5kIGRvd24uXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtwcmVjaXNpb249MF0gVGhlIHByZWNpc2lvbiB0byByb3VuZCBkb3duIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgZG93biBudW1iZXIuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNC4wMDYpO1xuICAgICAqIC8vID0+IDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoMC4wNDYsIDIpO1xuICAgICAqIC8vID0+IDAuMDRcbiAgICAgKlxuICAgICAqIF8uZmxvb3IoNDA2MCwgLTIpO1xuICAgICAqIC8vID0+IDQwMDBcbiAgICAgKi9cbiAgICB2YXIgZmxvb3IgPSBjcmVhdGVSb3VuZCgnZmxvb3InKTtcblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtYXhpbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtYXhpbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1heChbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDhcbiAgICAgKlxuICAgICAqIF8ubWF4KFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtYXgoYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VHdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5tYXhgIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5tYXhCeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAyIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWF4Qnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMiB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWF4QnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUd0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgbWVhbiBvZiB0aGUgdmFsdWVzIGluIGBhcnJheWAuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgbWVhbi5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5tZWFuKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG1lYW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiBiYXNlTWVhbihhcnJheSwgaWRlbnRpdHkpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGxpa2UgYF8ubWVhbmAgZXhjZXB0IHRoYXQgaXQgYWNjZXB0cyBgaXRlcmF0ZWVgIHdoaWNoIGlzXG4gICAgICogaW52b2tlZCBmb3IgZWFjaCBlbGVtZW50IGluIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlIHZhbHVlIHRvIGJlIGF2ZXJhZ2VkLlxuICAgICAqIFRoZSBpdGVyYXRlZSBpcyBpbnZva2VkIHdpdGggb25lIGFyZ3VtZW50OiAodmFsdWUpLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHNpbmNlIDQuNy4wXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IFtpdGVyYXRlZT1fLmlkZW50aXR5XSBUaGUgaXRlcmF0ZWUgaW52b2tlZCBwZXIgZWxlbWVudC5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBtZWFuLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiB2YXIgb2JqZWN0cyA9IFt7ICduJzogNCB9LCB7ICduJzogMiB9LCB7ICduJzogOCB9LCB7ICduJzogNiB9XTtcbiAgICAgKlxuICAgICAqIF8ubWVhbkJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gNVxuICAgICAqXG4gICAgICogLy8gVGhlIGBfLnByb3BlcnR5YCBpdGVyYXRlZSBzaG9ydGhhbmQuXG4gICAgICogXy5tZWFuQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiA1XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWVhbkJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIGJhc2VNZWFuKGFycmF5LCBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMikpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIENvbXB1dGVzIHRoZSBtaW5pbXVtIHZhbHVlIG9mIGBhcnJheWAuIElmIGBhcnJheWAgaXMgZW1wdHkgb3IgZmFsc2V5LFxuICAgICAqIGB1bmRlZmluZWRgIGlzIHJldHVybmVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBzaW5jZSAwLjEuMFxuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQGNhdGVnb3J5IE1hdGhcbiAgICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgICAqIEByZXR1cm5zIHsqfSBSZXR1cm5zIHRoZSBtaW5pbXVtIHZhbHVlLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm1pbihbNCwgMiwgOCwgNl0pO1xuICAgICAqIC8vID0+IDJcbiAgICAgKlxuICAgICAqIF8ubWluKFtdKTtcbiAgICAgKiAvLyA9PiB1bmRlZmluZWRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBtaW4oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VFeHRyZW11bShhcnJheSwgaWRlbnRpdHksIGJhc2VMdClcbiAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5taW5gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSBjcml0ZXJpb24gYnkgd2hpY2hcbiAgICAgKiB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgaXRlcmF0ZWUgaXMgaW52b2tlZCB3aXRoIG9uZSBhcmd1bWVudDogKHZhbHVlKS5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbaXRlcmF0ZWU9Xy5pZGVudGl0eV0gVGhlIGl0ZXJhdGVlIGludm9rZWQgcGVyIGVsZW1lbnQuXG4gICAgICogQHJldHVybnMgeyp9IFJldHVybnMgdGhlIG1pbmltdW0gdmFsdWUuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIHZhciBvYmplY3RzID0gW3sgJ24nOiAxIH0sIHsgJ24nOiAyIH1dO1xuICAgICAqXG4gICAgICogXy5taW5CeShvYmplY3RzLCBmdW5jdGlvbihvKSB7IHJldHVybiBvLm47IH0pO1xuICAgICAqIC8vID0+IHsgJ24nOiAxIH1cbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8ubWluQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiB7ICduJzogMSB9XG4gICAgICovXG4gICAgZnVuY3Rpb24gbWluQnkoYXJyYXksIGl0ZXJhdGVlKSB7XG4gICAgICByZXR1cm4gKGFycmF5ICYmIGFycmF5Lmxlbmd0aClcbiAgICAgICAgPyBiYXNlRXh0cmVtdW0oYXJyYXksIGdldEl0ZXJhdGVlKGl0ZXJhdGVlLCAyKSwgYmFzZUx0KVxuICAgICAgICA6IHVuZGVmaW5lZDtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBNdWx0aXBseSB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjcuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG11bHRpcGxpZXIgVGhlIGZpcnN0IG51bWJlciBpbiBhIG11bHRpcGxpY2F0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBtdWx0aXBsaWNhbmQgVGhlIHNlY29uZCBudW1iZXIgaW4gYSBtdWx0aXBsaWNhdGlvbi5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBwcm9kdWN0LlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLm11bHRpcGx5KDYsIDQpO1xuICAgICAqIC8vID0+IDI0XG4gICAgICovXG4gICAgdmFyIG11bHRpcGx5ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtdWx0aXBsaWVyLCBtdWx0aXBsaWNhbmQpIHtcbiAgICAgIHJldHVybiBtdWx0aXBsaWVyICogbXVsdGlwbGljYW5kO1xuICAgIH0sIDEpO1xuXG4gICAgLyoqXG4gICAgICogQ29tcHV0ZXMgYG51bWJlcmAgcm91bmRlZCB0byBgcHJlY2lzaW9uYC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjEwLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBudW1iZXIgVGhlIG51bWJlciB0byByb3VuZC5cbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW3ByZWNpc2lvbj0wXSBUaGUgcHJlY2lzaW9uIHRvIHJvdW5kIHRvLlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHJvdW5kZWQgbnVtYmVyLlxuICAgICAqIEBleGFtcGxlXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2KTtcbiAgICAgKiAvLyA9PiA0XG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQuMDA2LCAyKTtcbiAgICAgKiAvLyA9PiA0LjAxXG4gICAgICpcbiAgICAgKiBfLnJvdW5kKDQwNjAsIC0yKTtcbiAgICAgKiAvLyA9PiA0MTAwXG4gICAgICovXG4gICAgdmFyIHJvdW5kID0gY3JlYXRlUm91bmQoJ3JvdW5kJyk7XG5cbiAgICAvKipcbiAgICAgKiBTdWJ0cmFjdCB0d28gbnVtYmVycy5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSA0LjAuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbnVlbmQgVGhlIGZpcnN0IG51bWJlciBpbiBhIHN1YnRyYWN0aW9uLlxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBzdWJ0cmFoZW5kIFRoZSBzZWNvbmQgbnVtYmVyIGluIGEgc3VidHJhY3Rpb24uXG4gICAgICogQHJldHVybnMge251bWJlcn0gUmV0dXJucyB0aGUgZGlmZmVyZW5jZS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogXy5zdWJ0cmFjdCg2LCA0KTtcbiAgICAgKiAvLyA9PiAyXG4gICAgICovXG4gICAgdmFyIHN1YnRyYWN0ID0gY3JlYXRlTWF0aE9wZXJhdGlvbihmdW5jdGlvbihtaW51ZW5kLCBzdWJ0cmFoZW5kKSB7XG4gICAgICByZXR1cm4gbWludWVuZCAtIHN1YnRyYWhlbmQ7XG4gICAgfSwgMCk7XG5cbiAgICAvKipcbiAgICAgKiBDb21wdXRlcyB0aGUgc3VtIG9mIHRoZSB2YWx1ZXMgaW4gYGFycmF5YC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgX1xuICAgICAqIEBzaW5jZSAzLjQuMFxuICAgICAqIEBjYXRlZ29yeSBNYXRoXG4gICAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfSBSZXR1cm5zIHRoZSBzdW0uXG4gICAgICogQGV4YW1wbGVcbiAgICAgKlxuICAgICAqIF8uc3VtKFs0LCAyLCA4LCA2XSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBzdW0oYXJyYXkpIHtcbiAgICAgIHJldHVybiAoYXJyYXkgJiYgYXJyYXkubGVuZ3RoKVxuICAgICAgICA/IGJhc2VTdW0oYXJyYXksIGlkZW50aXR5KVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogVGhpcyBtZXRob2QgaXMgbGlrZSBgXy5zdW1gIGV4Y2VwdCB0aGF0IGl0IGFjY2VwdHMgYGl0ZXJhdGVlYCB3aGljaCBpc1xuICAgICAqIGludm9rZWQgZm9yIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGdlbmVyYXRlIHRoZSB2YWx1ZSB0byBiZSBzdW1tZWQuXG4gICAgICogVGhlIGl0ZXJhdGVlIGlzIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ6ICh2YWx1ZSkuXG4gICAgICpcbiAgICAgKiBAc3RhdGljXG4gICAgICogQG1lbWJlck9mIF9cbiAgICAgKiBAc2luY2UgNC4wLjBcbiAgICAgKiBAY2F0ZWdvcnkgTWF0aFxuICAgICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBpdGVyYXRlIG92ZXIuXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2l0ZXJhdGVlPV8uaWRlbnRpdHldIFRoZSBpdGVyYXRlZSBpbnZva2VkIHBlciBlbGVtZW50LlxuICAgICAqIEByZXR1cm5zIHtudW1iZXJ9IFJldHVybnMgdGhlIHN1bS5cbiAgICAgKiBAZXhhbXBsZVxuICAgICAqXG4gICAgICogdmFyIG9iamVjdHMgPSBbeyAnbic6IDQgfSwgeyAnbic6IDIgfSwgeyAnbic6IDggfSwgeyAnbic6IDYgfV07XG4gICAgICpcbiAgICAgKiBfLnN1bUJ5KG9iamVjdHMsIGZ1bmN0aW9uKG8pIHsgcmV0dXJuIG8ubjsgfSk7XG4gICAgICogLy8gPT4gMjBcbiAgICAgKlxuICAgICAqIC8vIFRoZSBgXy5wcm9wZXJ0eWAgaXRlcmF0ZWUgc2hvcnRoYW5kLlxuICAgICAqIF8uc3VtQnkob2JqZWN0cywgJ24nKTtcbiAgICAgKiAvLyA9PiAyMFxuICAgICAqL1xuICAgIGZ1bmN0aW9uIHN1bUJ5KGFycmF5LCBpdGVyYXRlZSkge1xuICAgICAgcmV0dXJuIChhcnJheSAmJiBhcnJheS5sZW5ndGgpXG4gICAgICAgID8gYmFzZVN1bShhcnJheSwgZ2V0SXRlcmF0ZWUoaXRlcmF0ZWUsIDIpKVxuICAgICAgICA6IDA7XG4gICAgfVxuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdGhhdCByZXR1cm4gd3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZnRlciA9IGFmdGVyO1xuICAgIGxvZGFzaC5hcnkgPSBhcnk7XG4gICAgbG9kYXNoLmFzc2lnbiA9IGFzc2lnbjtcbiAgICBsb2Rhc2guYXNzaWduSW4gPSBhc3NpZ25JbjtcbiAgICBsb2Rhc2guYXNzaWduSW5XaXRoID0gYXNzaWduSW5XaXRoO1xuICAgIGxvZGFzaC5hc3NpZ25XaXRoID0gYXNzaWduV2l0aDtcbiAgICBsb2Rhc2guYXQgPSBhdDtcbiAgICBsb2Rhc2guYmVmb3JlID0gYmVmb3JlO1xuICAgIGxvZGFzaC5iaW5kID0gYmluZDtcbiAgICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gICAgbG9kYXNoLmJpbmRLZXkgPSBiaW5kS2V5O1xuICAgIGxvZGFzaC5jYXN0QXJyYXkgPSBjYXN0QXJyYXk7XG4gICAgbG9kYXNoLmNoYWluID0gY2hhaW47XG4gICAgbG9kYXNoLmNodW5rID0gY2h1bms7XG4gICAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICAgIGxvZGFzaC5jb25jYXQgPSBjb25jYXQ7XG4gICAgbG9kYXNoLmNvbmQgPSBjb25kO1xuICAgIGxvZGFzaC5jb25mb3JtcyA9IGNvbmZvcm1zO1xuICAgIGxvZGFzaC5jb25zdGFudCA9IGNvbnN0YW50O1xuICAgIGxvZGFzaC5jb3VudEJ5ID0gY291bnRCeTtcbiAgICBsb2Rhc2guY3JlYXRlID0gY3JlYXRlO1xuICAgIGxvZGFzaC5jdXJyeSA9IGN1cnJ5O1xuICAgIGxvZGFzaC5jdXJyeVJpZ2h0ID0gY3VycnlSaWdodDtcbiAgICBsb2Rhc2guZGVib3VuY2UgPSBkZWJvdW5jZTtcbiAgICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgICBsb2Rhc2guZGVmYXVsdHNEZWVwID0gZGVmYXVsdHNEZWVwO1xuICAgIGxvZGFzaC5kZWZlciA9IGRlZmVyO1xuICAgIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlID0gZGlmZmVyZW5jZTtcbiAgICBsb2Rhc2guZGlmZmVyZW5jZUJ5ID0gZGlmZmVyZW5jZUJ5O1xuICAgIGxvZGFzaC5kaWZmZXJlbmNlV2l0aCA9IGRpZmZlcmVuY2VXaXRoO1xuICAgIGxvZGFzaC5kcm9wID0gZHJvcDtcbiAgICBsb2Rhc2guZHJvcFJpZ2h0ID0gZHJvcFJpZ2h0O1xuICAgIGxvZGFzaC5kcm9wUmlnaHRXaGlsZSA9IGRyb3BSaWdodFdoaWxlO1xuICAgIGxvZGFzaC5kcm9wV2hpbGUgPSBkcm9wV2hpbGU7XG4gICAgbG9kYXNoLmZpbGwgPSBmaWxsO1xuICAgIGxvZGFzaC5maWx0ZXIgPSBmaWx0ZXI7XG4gICAgbG9kYXNoLmZsYXRNYXAgPSBmbGF0TWFwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVlcCA9IGZsYXRNYXBEZWVwO1xuICAgIGxvZGFzaC5mbGF0TWFwRGVwdGggPSBmbGF0TWFwRGVwdGg7XG4gICAgbG9kYXNoLmZsYXR0ZW4gPSBmbGF0dGVuO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVlcCA9IGZsYXR0ZW5EZWVwO1xuICAgIGxvZGFzaC5mbGF0dGVuRGVwdGggPSBmbGF0dGVuRGVwdGg7XG4gICAgbG9kYXNoLmZsaXAgPSBmbGlwO1xuICAgIGxvZGFzaC5mbG93ID0gZmxvdztcbiAgICBsb2Rhc2guZmxvd1JpZ2h0ID0gZmxvd1JpZ2h0O1xuICAgIGxvZGFzaC5mcm9tUGFpcnMgPSBmcm9tUGFpcnM7XG4gICAgbG9kYXNoLmZ1bmN0aW9ucyA9IGZ1bmN0aW9ucztcbiAgICBsb2Rhc2guZnVuY3Rpb25zSW4gPSBmdW5jdGlvbnNJbjtcbiAgICBsb2Rhc2guZ3JvdXBCeSA9IGdyb3VwQnk7XG4gICAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICAgIGxvZGFzaC5pbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3Rpb247XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbkJ5ID0gaW50ZXJzZWN0aW9uQnk7XG4gICAgbG9kYXNoLmludGVyc2VjdGlvbldpdGggPSBpbnRlcnNlY3Rpb25XaXRoO1xuICAgIGxvZGFzaC5pbnZlcnQgPSBpbnZlcnQ7XG4gICAgbG9kYXNoLmludmVydEJ5ID0gaW52ZXJ0Qnk7XG4gICAgbG9kYXNoLmludm9rZU1hcCA9IGludm9rZU1hcDtcbiAgICBsb2Rhc2guaXRlcmF0ZWUgPSBpdGVyYXRlZTtcbiAgICBsb2Rhc2gua2V5QnkgPSBrZXlCeTtcbiAgICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gICAgbG9kYXNoLmtleXNJbiA9IGtleXNJbjtcbiAgICBsb2Rhc2gubWFwID0gbWFwO1xuICAgIGxvZGFzaC5tYXBLZXlzID0gbWFwS2V5cztcbiAgICBsb2Rhc2gubWFwVmFsdWVzID0gbWFwVmFsdWVzO1xuICAgIGxvZGFzaC5tYXRjaGVzID0gbWF0Y2hlcztcbiAgICBsb2Rhc2gubWF0Y2hlc1Byb3BlcnR5ID0gbWF0Y2hlc1Byb3BlcnR5O1xuICAgIGxvZGFzaC5tZW1vaXplID0gbWVtb2l6ZTtcbiAgICBsb2Rhc2gubWVyZ2UgPSBtZXJnZTtcbiAgICBsb2Rhc2gubWVyZ2VXaXRoID0gbWVyZ2VXaXRoO1xuICAgIGxvZGFzaC5tZXRob2QgPSBtZXRob2Q7XG4gICAgbG9kYXNoLm1ldGhvZE9mID0gbWV0aG9kT2Y7XG4gICAgbG9kYXNoLm1peGluID0gbWl4aW47XG4gICAgbG9kYXNoLm5lZ2F0ZSA9IG5lZ2F0ZTtcbiAgICBsb2Rhc2gubnRoQXJnID0gbnRoQXJnO1xuICAgIGxvZGFzaC5vbWl0ID0gb21pdDtcbiAgICBsb2Rhc2gub21pdEJ5ID0gb21pdEJ5O1xuICAgIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgICBsb2Rhc2gub3JkZXJCeSA9IG9yZGVyQnk7XG4gICAgbG9kYXNoLm92ZXIgPSBvdmVyO1xuICAgIGxvZGFzaC5vdmVyQXJncyA9IG92ZXJBcmdzO1xuICAgIGxvZGFzaC5vdmVyRXZlcnkgPSBvdmVyRXZlcnk7XG4gICAgbG9kYXNoLm92ZXJTb21lID0gb3ZlclNvbWU7XG4gICAgbG9kYXNoLnBhcnRpYWwgPSBwYXJ0aWFsO1xuICAgIGxvZGFzaC5wYXJ0aWFsUmlnaHQgPSBwYXJ0aWFsUmlnaHQ7XG4gICAgbG9kYXNoLnBhcnRpdGlvbiA9IHBhcnRpdGlvbjtcbiAgICBsb2Rhc2gucGljayA9IHBpY2s7XG4gICAgbG9kYXNoLnBpY2tCeSA9IHBpY2tCeTtcbiAgICBsb2Rhc2gucHJvcGVydHkgPSBwcm9wZXJ0eTtcbiAgICBsb2Rhc2gucHJvcGVydHlPZiA9IHByb3BlcnR5T2Y7XG4gICAgbG9kYXNoLnB1bGwgPSBwdWxsO1xuICAgIGxvZGFzaC5wdWxsQWxsID0gcHVsbEFsbDtcbiAgICBsb2Rhc2gucHVsbEFsbEJ5ID0gcHVsbEFsbEJ5O1xuICAgIGxvZGFzaC5wdWxsQWxsV2l0aCA9IHB1bGxBbGxXaXRoO1xuICAgIGxvZGFzaC5wdWxsQXQgPSBwdWxsQXQ7XG4gICAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gICAgbG9kYXNoLnJhbmdlUmlnaHQgPSByYW5nZVJpZ2h0O1xuICAgIGxvZGFzaC5yZWFyZyA9IHJlYXJnO1xuICAgIGxvZGFzaC5yZWplY3QgPSByZWplY3Q7XG4gICAgbG9kYXNoLnJlbW92ZSA9IHJlbW92ZTtcbiAgICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gICAgbG9kYXNoLnJldmVyc2UgPSByZXZlcnNlO1xuICAgIGxvZGFzaC5zYW1wbGVTaXplID0gc2FtcGxlU2l6ZTtcbiAgICBsb2Rhc2guc2V0ID0gc2V0O1xuICAgIGxvZGFzaC5zZXRXaXRoID0gc2V0V2l0aDtcbiAgICBsb2Rhc2guc2h1ZmZsZSA9IHNodWZmbGU7XG4gICAgbG9kYXNoLnNsaWNlID0gc2xpY2U7XG4gICAgbG9kYXNoLnNvcnRCeSA9IHNvcnRCeTtcbiAgICBsb2Rhc2guc29ydGVkVW5pcSA9IHNvcnRlZFVuaXE7XG4gICAgbG9kYXNoLnNvcnRlZFVuaXFCeSA9IHNvcnRlZFVuaXFCeTtcbiAgICBsb2Rhc2guc3BsaXQgPSBzcGxpdDtcbiAgICBsb2Rhc2guc3ByZWFkID0gc3ByZWFkO1xuICAgIGxvZGFzaC50YWlsID0gdGFpbDtcbiAgICBsb2Rhc2gudGFrZSA9IHRha2U7XG4gICAgbG9kYXNoLnRha2VSaWdodCA9IHRha2VSaWdodDtcbiAgICBsb2Rhc2gudGFrZVJpZ2h0V2hpbGUgPSB0YWtlUmlnaHRXaGlsZTtcbiAgICBsb2Rhc2gudGFrZVdoaWxlID0gdGFrZVdoaWxlO1xuICAgIGxvZGFzaC50YXAgPSB0YXA7XG4gICAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gICAgbG9kYXNoLnRocnUgPSB0aHJ1O1xuICAgIGxvZGFzaC50b0FycmF5ID0gdG9BcnJheTtcbiAgICBsb2Rhc2gudG9QYWlycyA9IHRvUGFpcnM7XG4gICAgbG9kYXNoLnRvUGFpcnNJbiA9IHRvUGFpcnNJbjtcbiAgICBsb2Rhc2gudG9QYXRoID0gdG9QYXRoO1xuICAgIGxvZGFzaC50b1BsYWluT2JqZWN0ID0gdG9QbGFpbk9iamVjdDtcbiAgICBsb2Rhc2gudHJhbnNmb3JtID0gdHJhbnNmb3JtO1xuICAgIGxvZGFzaC51bmFyeSA9IHVuYXJ5O1xuICAgIGxvZGFzaC51bmlvbiA9IHVuaW9uO1xuICAgIGxvZGFzaC51bmlvbkJ5ID0gdW5pb25CeTtcbiAgICBsb2Rhc2gudW5pb25XaXRoID0gdW5pb25XaXRoO1xuICAgIGxvZGFzaC51bmlxID0gdW5pcTtcbiAgICBsb2Rhc2gudW5pcUJ5ID0gdW5pcUJ5O1xuICAgIGxvZGFzaC51bmlxV2l0aCA9IHVuaXFXaXRoO1xuICAgIGxvZGFzaC51bnNldCA9IHVuc2V0O1xuICAgIGxvZGFzaC51bnppcCA9IHVuemlwO1xuICAgIGxvZGFzaC51bnppcFdpdGggPSB1bnppcFdpdGg7XG4gICAgbG9kYXNoLnVwZGF0ZSA9IHVwZGF0ZTtcbiAgICBsb2Rhc2gudXBkYXRlV2l0aCA9IHVwZGF0ZVdpdGg7XG4gICAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgICBsb2Rhc2gudmFsdWVzSW4gPSB2YWx1ZXNJbjtcbiAgICBsb2Rhc2gud2l0aG91dCA9IHdpdGhvdXQ7XG4gICAgbG9kYXNoLndvcmRzID0gd29yZHM7XG4gICAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICAgIGxvZGFzaC54b3IgPSB4b3I7XG4gICAgbG9kYXNoLnhvckJ5ID0geG9yQnk7XG4gICAgbG9kYXNoLnhvcldpdGggPSB4b3JXaXRoO1xuICAgIGxvZGFzaC56aXAgPSB6aXA7XG4gICAgbG9kYXNoLnppcE9iamVjdCA9IHppcE9iamVjdDtcbiAgICBsb2Rhc2guemlwT2JqZWN0RGVlcCA9IHppcE9iamVjdERlZXA7XG4gICAgbG9kYXNoLnppcFdpdGggPSB6aXBXaXRoO1xuXG4gICAgLy8gQWRkIGFsaWFzZXMuXG4gICAgbG9kYXNoLmVudHJpZXMgPSB0b1BhaXJzO1xuICAgIGxvZGFzaC5lbnRyaWVzSW4gPSB0b1BhaXJzSW47XG4gICAgbG9kYXNoLmV4dGVuZCA9IGFzc2lnbkluO1xuICAgIGxvZGFzaC5leHRlbmRXaXRoID0gYXNzaWduSW5XaXRoO1xuXG4gICAgLy8gQWRkIG1ldGhvZHMgdG8gYGxvZGFzaC5wcm90b3R5cGVgLlxuICAgIG1peGluKGxvZGFzaCwgbG9kYXNoKTtcblxuICAgIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAgIC8vIEFkZCBtZXRob2RzIHRoYXQgcmV0dXJuIHVud3JhcHBlZCB2YWx1ZXMgaW4gY2hhaW4gc2VxdWVuY2VzLlxuICAgIGxvZGFzaC5hZGQgPSBhZGQ7XG4gICAgbG9kYXNoLmF0dGVtcHQgPSBhdHRlbXB0O1xuICAgIGxvZGFzaC5jYW1lbENhc2UgPSBjYW1lbENhc2U7XG4gICAgbG9kYXNoLmNhcGl0YWxpemUgPSBjYXBpdGFsaXplO1xuICAgIGxvZGFzaC5jZWlsID0gY2VpbDtcbiAgICBsb2Rhc2guY2xhbXAgPSBjbGFtcDtcbiAgICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgICBsb2Rhc2guY2xvbmVEZWVwID0gY2xvbmVEZWVwO1xuICAgIGxvZGFzaC5jbG9uZURlZXBXaXRoID0gY2xvbmVEZWVwV2l0aDtcbiAgICBsb2Rhc2guY2xvbmVXaXRoID0gY2xvbmVXaXRoO1xuICAgIGxvZGFzaC5jb25mb3Jtc1RvID0gY29uZm9ybXNUbztcbiAgICBsb2Rhc2guZGVidXJyID0gZGVidXJyO1xuICAgIGxvZGFzaC5kZWZhdWx0VG8gPSBkZWZhdWx0VG87XG4gICAgbG9kYXNoLmRpdmlkZSA9IGRpdmlkZTtcbiAgICBsb2Rhc2guZW5kc1dpdGggPSBlbmRzV2l0aDtcbiAgICBsb2Rhc2guZXEgPSBlcTtcbiAgICBsb2Rhc2guZXNjYXBlID0gZXNjYXBlO1xuICAgIGxvZGFzaC5lc2NhcGVSZWdFeHAgPSBlc2NhcGVSZWdFeHA7XG4gICAgbG9kYXNoLmV2ZXJ5ID0gZXZlcnk7XG4gICAgbG9kYXNoLmZpbmQgPSBmaW5kO1xuICAgIGxvZGFzaC5maW5kSW5kZXggPSBmaW5kSW5kZXg7XG4gICAgbG9kYXNoLmZpbmRLZXkgPSBmaW5kS2V5O1xuICAgIGxvZGFzaC5maW5kTGFzdCA9IGZpbmRMYXN0O1xuICAgIGxvZGFzaC5maW5kTGFzdEluZGV4ID0gZmluZExhc3RJbmRleDtcbiAgICBsb2Rhc2guZmluZExhc3RLZXkgPSBmaW5kTGFzdEtleTtcbiAgICBsb2Rhc2guZmxvb3IgPSBmbG9vcjtcbiAgICBsb2Rhc2guZm9yRWFjaCA9IGZvckVhY2g7XG4gICAgbG9kYXNoLmZvckVhY2hSaWdodCA9IGZvckVhY2hSaWdodDtcbiAgICBsb2Rhc2guZm9ySW4gPSBmb3JJbjtcbiAgICBsb2Rhc2guZm9ySW5SaWdodCA9IGZvckluUmlnaHQ7XG4gICAgbG9kYXNoLmZvck93biA9IGZvck93bjtcbiAgICBsb2Rhc2guZm9yT3duUmlnaHQgPSBmb3JPd25SaWdodDtcbiAgICBsb2Rhc2guZ2V0ID0gZ2V0O1xuICAgIGxvZGFzaC5ndCA9IGd0O1xuICAgIGxvZGFzaC5ndGUgPSBndGU7XG4gICAgbG9kYXNoLmhhcyA9IGhhcztcbiAgICBsb2Rhc2guaGFzSW4gPSBoYXNJbjtcbiAgICBsb2Rhc2guaGVhZCA9IGhlYWQ7XG4gICAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gICAgbG9kYXNoLmluY2x1ZGVzID0gaW5jbHVkZXM7XG4gICAgbG9kYXNoLmluZGV4T2YgPSBpbmRleE9mO1xuICAgIGxvZGFzaC5pblJhbmdlID0gaW5SYW5nZTtcbiAgICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICAgIGxvZGFzaC5pc0FyZ3VtZW50cyA9IGlzQXJndW1lbnRzO1xuICAgIGxvZGFzaC5pc0FycmF5ID0gaXNBcnJheTtcbiAgICBsb2Rhc2guaXNBcnJheUJ1ZmZlciA9IGlzQXJyYXlCdWZmZXI7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlID0gaXNBcnJheUxpa2U7XG4gICAgbG9kYXNoLmlzQXJyYXlMaWtlT2JqZWN0ID0gaXNBcnJheUxpa2VPYmplY3Q7XG4gICAgbG9kYXNoLmlzQm9vbGVhbiA9IGlzQm9vbGVhbjtcbiAgICBsb2Rhc2guaXNCdWZmZXIgPSBpc0J1ZmZlcjtcbiAgICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICAgIGxvZGFzaC5pc0VsZW1lbnQgPSBpc0VsZW1lbnQ7XG4gICAgbG9kYXNoLmlzRW1wdHkgPSBpc0VtcHR5O1xuICAgIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgICBsb2Rhc2guaXNFcXVhbFdpdGggPSBpc0VxdWFsV2l0aDtcbiAgICBsb2Rhc2guaXNFcnJvciA9IGlzRXJyb3I7XG4gICAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gICAgbG9kYXNoLmlzRnVuY3Rpb24gPSBpc0Z1bmN0aW9uO1xuICAgIGxvZGFzaC5pc0ludGVnZXIgPSBpc0ludGVnZXI7XG4gICAgbG9kYXNoLmlzTGVuZ3RoID0gaXNMZW5ndGg7XG4gICAgbG9kYXNoLmlzTWFwID0gaXNNYXA7XG4gICAgbG9kYXNoLmlzTWF0Y2ggPSBpc01hdGNoO1xuICAgIGxvZGFzaC5pc01hdGNoV2l0aCA9IGlzTWF0Y2hXaXRoO1xuICAgIGxvZGFzaC5pc05hTiA9IGlzTmFOO1xuICAgIGxvZGFzaC5pc05hdGl2ZSA9IGlzTmF0aXZlO1xuICAgIGxvZGFzaC5pc05pbCA9IGlzTmlsO1xuICAgIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gICAgbG9kYXNoLmlzTnVtYmVyID0gaXNOdW1iZXI7XG4gICAgbG9kYXNoLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4gICAgbG9kYXNoLmlzT2JqZWN0TGlrZSA9IGlzT2JqZWN0TGlrZTtcbiAgICBsb2Rhc2guaXNQbGFpbk9iamVjdCA9IGlzUGxhaW5PYmplY3Q7XG4gICAgbG9kYXNoLmlzUmVnRXhwID0gaXNSZWdFeHA7XG4gICAgbG9kYXNoLmlzU2FmZUludGVnZXIgPSBpc1NhZmVJbnRlZ2VyO1xuICAgIGxvZGFzaC5pc1NldCA9IGlzU2V0O1xuICAgIGxvZGFzaC5pc1N0cmluZyA9IGlzU3RyaW5nO1xuICAgIGxvZGFzaC5pc1N5bWJvbCA9IGlzU3ltYm9sO1xuICAgIGxvZGFzaC5pc1R5cGVkQXJyYXkgPSBpc1R5cGVkQXJyYXk7XG4gICAgbG9kYXNoLmlzVW5kZWZpbmVkID0gaXNVbmRlZmluZWQ7XG4gICAgbG9kYXNoLmlzV2Vha01hcCA9IGlzV2Vha01hcDtcbiAgICBsb2Rhc2guaXNXZWFrU2V0ID0gaXNXZWFrU2V0O1xuICAgIGxvZGFzaC5qb2luID0gam9pbjtcbiAgICBsb2Rhc2gua2ViYWJDYXNlID0ga2ViYWJDYXNlO1xuICAgIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgICBsb2Rhc2gubGFzdEluZGV4T2YgPSBsYXN0SW5kZXhPZjtcbiAgICBsb2Rhc2gubG93ZXJDYXNlID0gbG93ZXJDYXNlO1xuICAgIGxvZGFzaC5sb3dlckZpcnN0ID0gbG93ZXJGaXJzdDtcbiAgICBsb2Rhc2gubHQgPSBsdDtcbiAgICBsb2Rhc2gubHRlID0gbHRlO1xuICAgIGxvZGFzaC5tYXggPSBtYXg7XG4gICAgbG9kYXNoLm1heEJ5ID0gbWF4Qnk7XG4gICAgbG9kYXNoLm1lYW4gPSBtZWFuO1xuICAgIGxvZGFzaC5tZWFuQnkgPSBtZWFuQnk7XG4gICAgbG9kYXNoLm1pbiA9IG1pbjtcbiAgICBsb2Rhc2gubWluQnkgPSBtaW5CeTtcbiAgICBsb2Rhc2guc3R1YkFycmF5ID0gc3R1YkFycmF5O1xuICAgIGxvZGFzaC5zdHViRmFsc2UgPSBzdHViRmFsc2U7XG4gICAgbG9kYXNoLnN0dWJPYmplY3QgPSBzdHViT2JqZWN0O1xuICAgIGxvZGFzaC5zdHViU3RyaW5nID0gc3R1YlN0cmluZztcbiAgICBsb2Rhc2guc3R1YlRydWUgPSBzdHViVHJ1ZTtcbiAgICBsb2Rhc2gubXVsdGlwbHkgPSBtdWx0aXBseTtcbiAgICBsb2Rhc2gubnRoID0gbnRoO1xuICAgIGxvZGFzaC5ub0NvbmZsaWN0ID0gbm9Db25mbGljdDtcbiAgICBsb2Rhc2gubm9vcCA9IG5vb3A7XG4gICAgbG9kYXNoLm5vdyA9IG5vdztcbiAgICBsb2Rhc2gucGFkID0gcGFkO1xuICAgIGxvZGFzaC5wYWRFbmQgPSBwYWRFbmQ7XG4gICAgbG9kYXNoLnBhZFN0YXJ0ID0gcGFkU3RhcnQ7XG4gICAgbG9kYXNoLnBhcnNlSW50ID0gcGFyc2VJbnQ7XG4gICAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgICBsb2Rhc2gucmVkdWNlID0gcmVkdWNlO1xuICAgIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICAgIGxvZGFzaC5yZXBlYXQgPSByZXBlYXQ7XG4gICAgbG9kYXNoLnJlcGxhY2UgPSByZXBsYWNlO1xuICAgIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gICAgbG9kYXNoLnJvdW5kID0gcm91bmQ7XG4gICAgbG9kYXNoLnJ1bkluQ29udGV4dCA9IHJ1bkluQ29udGV4dDtcbiAgICBsb2Rhc2guc2FtcGxlID0gc2FtcGxlO1xuICAgIGxvZGFzaC5zaXplID0gc2l6ZTtcbiAgICBsb2Rhc2guc25ha2VDYXNlID0gc25ha2VDYXNlO1xuICAgIGxvZGFzaC5zb21lID0gc29tZTtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXggPSBzb3J0ZWRJbmRleDtcbiAgICBsb2Rhc2guc29ydGVkSW5kZXhCeSA9IHNvcnRlZEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZEluZGV4T2YgPSBzb3J0ZWRJbmRleE9mO1xuICAgIGxvZGFzaC5zb3J0ZWRMYXN0SW5kZXggPSBzb3J0ZWRMYXN0SW5kZXg7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleEJ5ID0gc29ydGVkTGFzdEluZGV4Qnk7XG4gICAgbG9kYXNoLnNvcnRlZExhc3RJbmRleE9mID0gc29ydGVkTGFzdEluZGV4T2Y7XG4gICAgbG9kYXNoLnN0YXJ0Q2FzZSA9IHN0YXJ0Q2FzZTtcbiAgICBsb2Rhc2guc3RhcnRzV2l0aCA9IHN0YXJ0c1dpdGg7XG4gICAgbG9kYXNoLnN1YnRyYWN0ID0gc3VidHJhY3Q7XG4gICAgbG9kYXNoLnN1bSA9IHN1bTtcbiAgICBsb2Rhc2guc3VtQnkgPSBzdW1CeTtcbiAgICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgICBsb2Rhc2gudGltZXMgPSB0aW1lcztcbiAgICBsb2Rhc2gudG9GaW5pdGUgPSB0b0Zpbml0ZTtcbiAgICBsb2Rhc2gudG9JbnRlZ2VyID0gdG9JbnRlZ2VyO1xuICAgIGxvZGFzaC50b0xlbmd0aCA9IHRvTGVuZ3RoO1xuICAgIGxvZGFzaC50b0xvd2VyID0gdG9Mb3dlcjtcbiAgICBsb2Rhc2gudG9OdW1iZXIgPSB0b051bWJlcjtcbiAgICBsb2Rhc2gudG9TYWZlSW50ZWdlciA9IHRvU2FmZUludGVnZXI7XG4gICAgbG9kYXNoLnRvU3RyaW5nID0gdG9TdHJpbmc7XG4gICAgbG9kYXNoLnRvVXBwZXIgPSB0b1VwcGVyO1xuICAgIGxvZGFzaC50cmltID0gdHJpbTtcbiAgICBsb2Rhc2gudHJpbUVuZCA9IHRyaW1FbmQ7XG4gICAgbG9kYXNoLnRyaW1TdGFydCA9IHRyaW1TdGFydDtcbiAgICBsb2Rhc2gudHJ1bmNhdGUgPSB0cnVuY2F0ZTtcbiAgICBsb2Rhc2gudW5lc2NhcGUgPSB1bmVzY2FwZTtcbiAgICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgICBsb2Rhc2gudXBwZXJDYXNlID0gdXBwZXJDYXNlO1xuICAgIGxvZGFzaC51cHBlckZpcnN0ID0gdXBwZXJGaXJzdDtcblxuICAgIC8vIEFkZCBhbGlhc2VzLlxuICAgIGxvZGFzaC5lYWNoID0gZm9yRWFjaDtcbiAgICBsb2Rhc2guZWFjaFJpZ2h0ID0gZm9yRWFjaFJpZ2h0O1xuICAgIGxvZGFzaC5maXJzdCA9IGhlYWQ7XG5cbiAgICBtaXhpbihsb2Rhc2gsIChmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzb3VyY2UgPSB7fTtcbiAgICAgIGJhc2VGb3JPd24obG9kYXNoLCBmdW5jdGlvbihmdW5jLCBtZXRob2ROYW1lKSB7XG4gICAgICAgIGlmICghaGFzT3duUHJvcGVydHkuY2FsbChsb2Rhc2gucHJvdG90eXBlLCBtZXRob2ROYW1lKSkge1xuICAgICAgICAgIHNvdXJjZVttZXRob2ROYW1lXSA9IGZ1bmM7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHNvdXJjZTtcbiAgICB9KCkpLCB7ICdjaGFpbic6IGZhbHNlIH0pO1xuXG4gICAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gICAgLyoqXG4gICAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfXG4gICAgICogQHR5cGUge3N0cmluZ31cbiAgICAgKi9cbiAgICBsb2Rhc2guVkVSU0lPTiA9IFZFUlNJT047XG5cbiAgICAvLyBBc3NpZ24gZGVmYXVsdCBwbGFjZWhvbGRlcnMuXG4gICAgYXJyYXlFYWNoKFsnYmluZCcsICdiaW5kS2V5JywgJ2N1cnJ5JywgJ2N1cnJ5UmlnaHQnLCAncGFydGlhbCcsICdwYXJ0aWFsUmlnaHQnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgbG9kYXNoW21ldGhvZE5hbWVdLnBsYWNlaG9sZGVyID0gbG9kYXNoO1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uZHJvcGAgYW5kIGBfLnRha2VgIHZhcmlhbnRzLlxuICAgIGFycmF5RWFjaChbJ2Ryb3AnLCAndGFrZSddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24obikge1xuICAgICAgICBuID0gbiA9PT0gdW5kZWZpbmVkID8gMSA6IG5hdGl2ZU1heCh0b0ludGVnZXIobiksIDApO1xuXG4gICAgICAgIHZhciByZXN1bHQgPSAodGhpcy5fX2ZpbHRlcmVkX18gJiYgIWluZGV4KVxuICAgICAgICAgID8gbmV3IExhenlXcmFwcGVyKHRoaXMpXG4gICAgICAgICAgOiB0aGlzLmNsb25lKCk7XG5cbiAgICAgICAgaWYgKHJlc3VsdC5fX2ZpbHRlcmVkX18pIHtcbiAgICAgICAgICByZXN1bHQuX190YWtlQ291bnRfXyA9IG5hdGl2ZU1pbihuLCByZXN1bHQuX190YWtlQ291bnRfXyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0Ll9fdmlld3NfXy5wdXNoKHtcbiAgICAgICAgICAgICdzaXplJzogbmF0aXZlTWluKG4sIE1BWF9BUlJBWV9MRU5HVEgpLFxuICAgICAgICAgICAgJ3R5cGUnOiBtZXRob2ROYW1lICsgKHJlc3VsdC5fX2Rpcl9fIDwgMCA/ICdSaWdodCcgOiAnJylcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWUgKyAnUmlnaHQnXSA9IGZ1bmN0aW9uKG4pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMucmV2ZXJzZSgpW21ldGhvZE5hbWVdKG4pLnJldmVyc2UoKTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIHRoYXQgYWNjZXB0IGFuIGBpdGVyYXRlZWAgdmFsdWUuXG4gICAgYXJyYXlFYWNoKFsnZmlsdGVyJywgJ21hcCcsICd0YWtlV2hpbGUnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSwgaW5kZXgpIHtcbiAgICAgIHZhciB0eXBlID0gaW5kZXggKyAxLFxuICAgICAgICAgIGlzRmlsdGVyID0gdHlwZSA9PSBMQVpZX0ZJTFRFUl9GTEFHIHx8IHR5cGUgPT0gTEFaWV9XSElMRV9GTEFHO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbihpdGVyYXRlZSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gdGhpcy5jbG9uZSgpO1xuICAgICAgICByZXN1bHQuX19pdGVyYXRlZXNfXy5wdXNoKHtcbiAgICAgICAgICAnaXRlcmF0ZWUnOiBnZXRJdGVyYXRlZShpdGVyYXRlZSwgMyksXG4gICAgICAgICAgJ3R5cGUnOiB0eXBlXG4gICAgICAgIH0pO1xuICAgICAgICByZXN1bHQuX19maWx0ZXJlZF9fID0gcmVzdWx0Ll9fZmlsdGVyZWRfXyB8fCBpc0ZpbHRlcjtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYExhenlXcmFwcGVyYCBtZXRob2RzIGZvciBgXy5oZWFkYCBhbmQgYF8ubGFzdGAuXG4gICAgYXJyYXlFYWNoKFsnaGVhZCcsICdsYXN0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUsIGluZGV4KSB7XG4gICAgICB2YXIgdGFrZU5hbWUgPSAndGFrZScgKyAoaW5kZXggPyAnUmlnaHQnIDogJycpO1xuXG4gICAgICBMYXp5V3JhcHBlci5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXNbdGFrZU5hbWVdKDEpLnZhbHVlKClbMF07XG4gICAgICB9O1xuICAgIH0pO1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyBmb3IgYF8uaW5pdGlhbGAgYW5kIGBfLnRhaWxgLlxuICAgIGFycmF5RWFjaChbJ2luaXRpYWwnLCAndGFpbCddLCBmdW5jdGlvbihtZXRob2ROYW1lLCBpbmRleCkge1xuICAgICAgdmFyIGRyb3BOYW1lID0gJ2Ryb3AnICsgKGluZGV4ID8gJycgOiAnUmlnaHQnKTtcblxuICAgICAgTGF6eVdyYXBwZXIucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9fZmlsdGVyZWRfXyA/IG5ldyBMYXp5V3JhcHBlcih0aGlzKSA6IHRoaXNbZHJvcE5hbWVdKDEpO1xuICAgICAgfTtcbiAgICB9KTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jb21wYWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5maWx0ZXIoaWRlbnRpdHkpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKHByZWRpY2F0ZSkuaGVhZCgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUuZmluZExhc3QgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICAgIHJldHVybiB0aGlzLnJldmVyc2UoKS5maW5kKHByZWRpY2F0ZSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5pbnZva2VNYXAgPSBiYXNlUmVzdChmdW5jdGlvbihwYXRoLCBhcmdzKSB7XG4gICAgICBpZiAodHlwZW9mIHBhdGggPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBiYXNlSW52b2tlKHZhbHVlLCBwYXRoLCBhcmdzKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnJlamVjdCA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgICAgcmV0dXJuIHRoaXMuZmlsdGVyKG5lZ2F0ZShnZXRJdGVyYXRlZShwcmVkaWNhdGUpKSk7XG4gICAgfTtcblxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5zbGljZSA9IGZ1bmN0aW9uKHN0YXJ0LCBlbmQpIHtcbiAgICAgIHN0YXJ0ID0gdG9JbnRlZ2VyKHN0YXJ0KTtcblxuICAgICAgdmFyIHJlc3VsdCA9IHRoaXM7XG4gICAgICBpZiAocmVzdWx0Ll9fZmlsdGVyZWRfXyAmJiAoc3RhcnQgPiAwIHx8IGVuZCA8IDApKSB7XG4gICAgICAgIHJldHVybiBuZXcgTGF6eVdyYXBwZXIocmVzdWx0KTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGFydCA8IDApIHtcbiAgICAgICAgcmVzdWx0ID0gcmVzdWx0LnRha2VSaWdodCgtc3RhcnQpO1xuICAgICAgfSBlbHNlIGlmIChzdGFydCkge1xuICAgICAgICByZXN1bHQgPSByZXN1bHQuZHJvcChzdGFydCk7XG4gICAgICB9XG4gICAgICBpZiAoZW5kICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgZW5kID0gdG9JbnRlZ2VyKGVuZCk7XG4gICAgICAgIHJlc3VsdCA9IGVuZCA8IDAgPyByZXN1bHQuZHJvcFJpZ2h0KC1lbmQpIDogcmVzdWx0LnRha2UoZW5kIC0gc3RhcnQpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuXG4gICAgTGF6eVdyYXBwZXIucHJvdG90eXBlLnRha2VSaWdodFdoaWxlID0gZnVuY3Rpb24ocHJlZGljYXRlKSB7XG4gICAgICByZXR1cm4gdGhpcy5yZXZlcnNlKCkudGFrZVdoaWxlKHByZWRpY2F0ZSkucmV2ZXJzZSgpO1xuICAgIH07XG5cbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUudG9BcnJheSA9IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGFrZShNQVhfQVJSQVlfTEVOR1RIKTtcbiAgICB9O1xuXG4gICAgLy8gQWRkIGBMYXp5V3JhcHBlcmAgbWV0aG9kcyB0byBgbG9kYXNoLnByb3RvdHlwZWAuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBjaGVja0l0ZXJhdGVlID0gL14oPzpmaWx0ZXJ8ZmluZHxtYXB8cmVqZWN0KXxXaGlsZSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgaXNUYWtlciA9IC9eKD86aGVhZHxsYXN0KSQvLnRlc3QobWV0aG9kTmFtZSksXG4gICAgICAgICAgbG9kYXNoRnVuYyA9IGxvZGFzaFtpc1Rha2VyID8gKCd0YWtlJyArIChtZXRob2ROYW1lID09ICdsYXN0JyA/ICdSaWdodCcgOiAnJykpIDogbWV0aG9kTmFtZV0sXG4gICAgICAgICAgcmV0VW53cmFwcGVkID0gaXNUYWtlciB8fCAvXmZpbmQvLnRlc3QobWV0aG9kTmFtZSk7XG5cbiAgICAgIGlmICghbG9kYXNoRnVuYykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IHRoaXMuX193cmFwcGVkX18sXG4gICAgICAgICAgICBhcmdzID0gaXNUYWtlciA/IFsxXSA6IGFyZ3VtZW50cyxcbiAgICAgICAgICAgIGlzTGF6eSA9IHZhbHVlIGluc3RhbmNlb2YgTGF6eVdyYXBwZXIsXG4gICAgICAgICAgICBpdGVyYXRlZSA9IGFyZ3NbMF0sXG4gICAgICAgICAgICB1c2VMYXp5ID0gaXNMYXp5IHx8IGlzQXJyYXkodmFsdWUpO1xuXG4gICAgICAgIHZhciBpbnRlcmNlcHRvciA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgICAgdmFyIHJlc3VsdCA9IGxvZGFzaEZ1bmMuYXBwbHkobG9kYXNoLCBhcnJheVB1c2goW3ZhbHVlXSwgYXJncykpO1xuICAgICAgICAgIHJldHVybiAoaXNUYWtlciAmJiBjaGFpbkFsbCkgPyByZXN1bHRbMF0gOiByZXN1bHQ7XG4gICAgICAgIH07XG5cbiAgICAgICAgaWYgKHVzZUxhenkgJiYgY2hlY2tJdGVyYXRlZSAmJiB0eXBlb2YgaXRlcmF0ZWUgPT0gJ2Z1bmN0aW9uJyAmJiBpdGVyYXRlZS5sZW5ndGggIT0gMSkge1xuICAgICAgICAgIC8vIEF2b2lkIGxhenkgdXNlIGlmIHRoZSBpdGVyYXRlZSBoYXMgYSBcImxlbmd0aFwiIHZhbHVlIG90aGVyIHRoYW4gYDFgLlxuICAgICAgICAgIGlzTGF6eSA9IHVzZUxhenkgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhaW5BbGwgPSB0aGlzLl9fY2hhaW5fXyxcbiAgICAgICAgICAgIGlzSHlicmlkID0gISF0aGlzLl9fYWN0aW9uc19fLmxlbmd0aCxcbiAgICAgICAgICAgIGlzVW53cmFwcGVkID0gcmV0VW53cmFwcGVkICYmICFjaGFpbkFsbCxcbiAgICAgICAgICAgIG9ubHlMYXp5ID0gaXNMYXp5ICYmICFpc0h5YnJpZDtcblxuICAgICAgICBpZiAoIXJldFVud3JhcHBlZCAmJiB1c2VMYXp5KSB7XG4gICAgICAgICAgdmFsdWUgPSBvbmx5TGF6eSA/IHZhbHVlIDogbmV3IExhenlXcmFwcGVyKHRoaXMpO1xuICAgICAgICAgIHZhciByZXN1bHQgPSBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICAgICAgICByZXN1bHQuX19hY3Rpb25zX18ucHVzaCh7ICdmdW5jJzogdGhydSwgJ2FyZ3MnOiBbaW50ZXJjZXB0b3JdLCAndGhpc0FyZyc6IHVuZGVmaW5lZCB9KTtcbiAgICAgICAgICByZXR1cm4gbmV3IExvZGFzaFdyYXBwZXIocmVzdWx0LCBjaGFpbkFsbCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVW53cmFwcGVkICYmIG9ubHlMYXp5KSB7XG4gICAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0ID0gdGhpcy50aHJ1KGludGVyY2VwdG9yKTtcbiAgICAgICAgcmV0dXJuIGlzVW53cmFwcGVkID8gKGlzVGFrZXIgPyByZXN1bHQudmFsdWUoKVswXSA6IHJlc3VsdC52YWx1ZSgpKSA6IHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYEFycmF5YCBtZXRob2RzIHRvIGBsb2Rhc2gucHJvdG90eXBlYC5cbiAgICBhcnJheUVhY2goWydwb3AnLCAncHVzaCcsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBmdW5jID0gYXJyYXlQcm90b1ttZXRob2ROYW1lXSxcbiAgICAgICAgICBjaGFpbk5hbWUgPSAvXig/OnB1c2h8c29ydHx1bnNoaWZ0KSQvLnRlc3QobWV0aG9kTmFtZSkgPyAndGFwJyA6ICd0aHJ1JyxcbiAgICAgICAgICByZXRVbndyYXBwZWQgPSAvXig/OnBvcHxzaGlmdCkkLy50ZXN0KG1ldGhvZE5hbWUpO1xuXG4gICAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgICBpZiAocmV0VW53cmFwcGVkICYmICF0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICAgIHZhciB2YWx1ZSA9IHRoaXMudmFsdWUoKTtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzW2NoYWluTmFtZV0oZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgICAgICByZXR1cm4gZnVuYy5hcHBseShpc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW10sIGFyZ3MpO1xuICAgICAgICB9KTtcbiAgICAgIH07XG4gICAgfSk7XG5cbiAgICAvLyBNYXAgbWluaWZpZWQgbWV0aG9kIG5hbWVzIHRvIHRoZWlyIHJlYWwgbmFtZXMuXG4gICAgYmFzZUZvck93bihMYXp5V3JhcHBlci5wcm90b3R5cGUsIGZ1bmN0aW9uKGZ1bmMsIG1ldGhvZE5hbWUpIHtcbiAgICAgIHZhciBsb2Rhc2hGdW5jID0gbG9kYXNoW21ldGhvZE5hbWVdO1xuICAgICAgaWYgKGxvZGFzaEZ1bmMpIHtcbiAgICAgICAgdmFyIGtleSA9IGxvZGFzaEZ1bmMubmFtZSArICcnO1xuICAgICAgICBpZiAoIWhhc093blByb3BlcnR5LmNhbGwocmVhbE5hbWVzLCBrZXkpKSB7XG4gICAgICAgICAgcmVhbE5hbWVzW2tleV0gPSBbXTtcbiAgICAgICAgfVxuICAgICAgICByZWFsTmFtZXNba2V5XS5wdXNoKHsgJ25hbWUnOiBtZXRob2ROYW1lLCAnZnVuYyc6IGxvZGFzaEZ1bmMgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICByZWFsTmFtZXNbY3JlYXRlSHlicmlkKHVuZGVmaW5lZCwgV1JBUF9CSU5EX0tFWV9GTEFHKS5uYW1lXSA9IFt7XG4gICAgICAnbmFtZSc6ICd3cmFwcGVyJyxcbiAgICAgICdmdW5jJzogdW5kZWZpbmVkXG4gICAgfV07XG5cbiAgICAvLyBBZGQgbWV0aG9kcyB0byBgTGF6eVdyYXBwZXJgLlxuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS5jbG9uZSA9IGxhenlDbG9uZTtcbiAgICBMYXp5V3JhcHBlci5wcm90b3R5cGUucmV2ZXJzZSA9IGxhenlSZXZlcnNlO1xuICAgIExhenlXcmFwcGVyLnByb3RvdHlwZS52YWx1ZSA9IGxhenlWYWx1ZTtcblxuICAgIC8vIEFkZCBjaGFpbiBzZXF1ZW5jZSBtZXRob2RzIHRvIHRoZSBgbG9kYXNoYCB3cmFwcGVyLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuYXQgPSB3cmFwcGVyQXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgICBsb2Rhc2gucHJvdG90eXBlLmNvbW1pdCA9IHdyYXBwZXJDb21taXQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5uZXh0ID0gd3JhcHBlck5leHQ7XG4gICAgbG9kYXNoLnByb3RvdHlwZS5wbGFudCA9IHdyYXBwZXJQbGFudDtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnJldmVyc2UgPSB3cmFwcGVyUmV2ZXJzZTtcbiAgICBsb2Rhc2gucHJvdG90eXBlLnRvSlNPTiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWVPZiA9IGxvZGFzaC5wcm90b3R5cGUudmFsdWUgPSB3cmFwcGVyVmFsdWU7XG5cbiAgICAvLyBBZGQgbGF6eSBhbGlhc2VzLlxuICAgIGxvZGFzaC5wcm90b3R5cGUuZmlyc3QgPSBsb2Rhc2gucHJvdG90eXBlLmhlYWQ7XG5cbiAgICBpZiAoc3ltSXRlcmF0b3IpIHtcbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbc3ltSXRlcmF0b3JdID0gd3JhcHBlclRvSXRlcmF0b3I7XG4gICAgfVxuICAgIHJldHVybiBsb2Rhc2g7XG4gIH0pO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIEV4cG9ydCBsb2Rhc2guXG4gIHZhciBfID0gcnVuSW5Db250ZXh0KCk7XG5cbiAgLy8gU29tZSBBTUQgYnVpbGQgb3B0aW1pemVycywgbGlrZSByLmpzLCBjaGVjayBmb3IgY29uZGl0aW9uIHBhdHRlcm5zIGxpa2U6XG4gIGlmICh0eXBlb2YgZGVmaW5lID09ICdmdW5jdGlvbicgJiYgdHlwZW9mIGRlZmluZS5hbWQgPT0gJ29iamVjdCcgJiYgZGVmaW5lLmFtZCkge1xuICAgIC8vIEV4cG9zZSBMb2Rhc2ggb24gdGhlIGdsb2JhbCBvYmplY3QgdG8gcHJldmVudCBlcnJvcnMgd2hlbiBMb2Rhc2ggaXNcbiAgICAvLyBsb2FkZWQgYnkgYSBzY3JpcHQgdGFnIGluIHRoZSBwcmVzZW5jZSBvZiBhbiBBTUQgbG9hZGVyLlxuICAgIC8vIFNlZSBodHRwOi8vcmVxdWlyZWpzLm9yZy9kb2NzL2Vycm9ycy5odG1sI21pc21hdGNoIGZvciBtb3JlIGRldGFpbHMuXG4gICAgLy8gVXNlIGBfLm5vQ29uZmxpY3RgIHRvIHJlbW92ZSBMb2Rhc2ggZnJvbSB0aGUgZ2xvYmFsIG9iamVjdC5cbiAgICByb290Ll8gPSBfO1xuXG4gICAgLy8gRGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGUuXG4gICAgZGVmaW5lKGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbiAgLy8gQ2hlY2sgZm9yIGBleHBvcnRzYCBhZnRlciBgZGVmaW5lYCBpbiBjYXNlIGEgYnVpbGQgb3B0aW1pemVyIGFkZHMgaXQuXG4gIGVsc2UgaWYgKGZyZWVNb2R1bGUpIHtcbiAgICAvLyBFeHBvcnQgZm9yIE5vZGUuanMuXG4gICAgKGZyZWVNb2R1bGUuZXhwb3J0cyA9IF8pLl8gPSBfO1xuICAgIC8vIEV4cG9ydCBmb3IgQ29tbW9uSlMgc3VwcG9ydC5cbiAgICBmcmVlRXhwb3J0cy5fID0gXztcbiAgfVxuICBlbHNlIHtcbiAgICAvLyBFeHBvcnQgdG8gdGhlIGdsb2JhbCBvYmplY3QuXG4gICAgcm9vdC5fID0gXztcbiAgfVxufS5jYWxsKHRoaXMpKTtcbiIsIihmdW5jdGlvbihlKXtpZih0eXBlb2YgZXhwb3J0cz09XCJvYmplY3RcIiYmdHlwZW9mIG1vZHVsZT09XCJvYmplY3RcIiltb2R1bGUuZXhwb3J0cz1lKCk7ZWxzZSBpZih0eXBlb2YgZGVmaW5lPT1cImZ1bmN0aW9uXCImJmRlZmluZS5hbWQpZGVmaW5lKGUpO2Vsc2V7dmFyIGY9dHlwZW9mIGdsb2JhbFRoaXM8XCJ1XCI/Z2xvYmFsVGhpczp0eXBlb2YgZ2xvYmFsPFwidVwiP2dsb2JhbDp0eXBlb2Ygc2VsZjxcInVcIj9zZWxmOnRoaXN8fHt9O2YucHJldHRpZXI9ZSgpfX0pKGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHhlPShlLHIpPT4oKT0+KHJ8fGUoKHI9e2V4cG9ydHM6e319KS5leHBvcnRzLHIpLHIuZXhwb3J0cyk7dmFyIHB0PXhlKCh0MCxwdSk9Pnt2YXIgaXI9ZnVuY3Rpb24oZSl7cmV0dXJuIGUmJmUuTWF0aD09TWF0aCYmZX07cHUuZXhwb3J0cz1pcih0eXBlb2YgZ2xvYmFsVGhpcz09XCJvYmplY3RcIiYmZ2xvYmFsVGhpcyl8fGlyKHR5cGVvZiB3aW5kb3c9PVwib2JqZWN0XCImJndpbmRvdyl8fGlyKHR5cGVvZiBzZWxmPT1cIm9iamVjdFwiJiZzZWxmKXx8aXIodHlwZW9mIGdsb2JhbD09XCJvYmplY3RcIiYmZ2xvYmFsKXx8ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30oKXx8RnVuY3Rpb24oXCJyZXR1cm4gdGhpc1wiKSgpfSk7dmFyIER0PXhlKChyMCxmdSk9PntmdS5leHBvcnRzPWZ1bmN0aW9uKGUpe3RyeXtyZXR1cm4hIWUoKX1jYXRjaHtyZXR1cm4hMH19fSk7dmFyIHl0PXhlKChuMCxEdSk9Pnt2YXIgTW89RHQoKTtEdS5leHBvcnRzPSFNbyhmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sMSx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSlbMV0hPTd9KX0pO3ZhciBhcj14ZSgodTAsbXUpPT57dmFyIFJvPUR0KCk7bXUuZXhwb3J0cz0hUm8oZnVuY3Rpb24oKXt2YXIgZT1mdW5jdGlvbigpe30uYmluZCgpO3JldHVybiB0eXBlb2YgZSE9XCJmdW5jdGlvblwifHxlLmhhc093blByb3BlcnR5KFwicHJvdG90eXBlXCIpfSl9KTt2YXIgQXQ9eGUoKHMwLGR1KT0+e3ZhciAkbz1hcigpLG9yPUZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO2R1LmV4cG9ydHM9JG8/b3IuYmluZChvcik6ZnVuY3Rpb24oKXtyZXR1cm4gb3IuYXBwbHkob3IsYXJndW1lbnRzKX19KTt2YXIgdnU9eGUoaHU9PntcInVzZSBzdHJpY3RcIjt2YXIgZ3U9e30ucHJvcGVydHlJc0VudW1lcmFibGUseXU9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixWbz15dSYmIWd1LmNhbGwoezE6Mn0sMSk7aHUuZj1Wbz9mdW5jdGlvbihyKXt2YXIgdD15dSh0aGlzLHIpO3JldHVybiEhdCYmdC5lbnVtZXJhYmxlfTpndX0pO3ZhciBscj14ZSgoYTAsQ3UpPT57Q3UuZXhwb3J0cz1mdW5jdGlvbihlLHIpe3JldHVybntlbnVtZXJhYmxlOiEoZSYxKSxjb25maWd1cmFibGU6IShlJjIpLHdyaXRhYmxlOiEoZSY0KSx2YWx1ZTpyfX19KTt2YXIgbXQ9eGUoKG8wLEF1KT0+e3ZhciBFdT1hcigpLEZ1PUZ1bmN0aW9uLnByb3RvdHlwZSxXcj1GdS5jYWxsLFdvPUV1JiZGdS5iaW5kLmJpbmQoV3IsV3IpO0F1LmV4cG9ydHM9RXU/V286ZnVuY3Rpb24oZSl7cmV0dXJuIGZ1bmN0aW9uKCl7cmV0dXJuIFdyLmFwcGx5KGUsYXJndW1lbnRzKX19fSk7dmFyIFZ0PXhlKChsMCx4dSk9Pnt2YXIgU3U9bXQoKSxIbz1TdSh7fS50b1N0cmluZyksR289U3UoXCJcIi5zbGljZSk7eHUuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gR28oSG8oZSksOCwtMSl9fSk7dmFyIFR1PXhlKChjMCxidSk9Pnt2YXIgVW89bXQoKSxKbz1EdCgpLHpvPVZ0KCksSHI9T2JqZWN0LFhvPVVvKFwiXCIuc3BsaXQpO2J1LmV4cG9ydHM9Sm8oZnVuY3Rpb24oKXtyZXR1cm4hSHIoXCJ6XCIpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApfSk/ZnVuY3Rpb24oZSl7cmV0dXJuIHpvKGUpPT1cIlN0cmluZ1wiP1hvKGUsXCJcIik6SHIoZSl9OkhyfSk7dmFyIGNyPXhlKChwMCxCdSk9PntCdS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlPT1udWxsfX0pO3ZhciBHcj14ZSgoZjAsTnUpPT57dmFyIEtvPWNyKCksWW89VHlwZUVycm9yO051LmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoS28oZSkpdGhyb3cgWW8oXCJDYW4ndCBjYWxsIG1ldGhvZCBvbiBcIitlKTtyZXR1cm4gZX19KTt2YXIgcHI9eGUoKEQwLHd1KT0+e3ZhciBRbz1UdSgpLFpvPUdyKCk7d3UuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gUW8oWm8oZSkpfX0pO3ZhciBKcj14ZSgobTAsX3UpPT57dmFyIFVyPXR5cGVvZiBkb2N1bWVudD09XCJvYmplY3RcIiYmZG9jdW1lbnQuYWxsLGVsPXR5cGVvZiBVcj5cInVcIiYmVXIhPT12b2lkIDA7X3UuZXhwb3J0cz17YWxsOlVyLElTX0hUTUxEREE6ZWx9fSk7dmFyIG90PXhlKChkMCxJdSk9Pnt2YXIgUHU9SnIoKSx0bD1QdS5hbGw7SXUuZXhwb3J0cz1QdS5JU19IVE1MRERBP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09XCJmdW5jdGlvblwifHxlPT09dGx9OmZ1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09XCJmdW5jdGlvblwifX0pO3ZhciBTdD14ZSgoZzAsT3UpPT57dmFyIGt1PW90KCksTHU9SnIoKSxybD1MdS5hbGw7T3UuZXhwb3J0cz1MdS5JU19IVE1MRERBP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09XCJvYmplY3RcIj9lIT09bnVsbDprdShlKXx8ZT09PXJsfTpmdW5jdGlvbihlKXtyZXR1cm4gdHlwZW9mIGU9PVwib2JqZWN0XCI/ZSE9PW51bGw6a3UoZSl9fSk7dmFyIFd0PXhlKCh5MCxqdSk9Pnt2YXIgenI9cHQoKSxubD1vdCgpLHVsPWZ1bmN0aW9uKGUpe3JldHVybiBubChlKT9lOnZvaWQgMH07anUuZXhwb3J0cz1mdW5jdGlvbihlLHIpe3JldHVybiBhcmd1bWVudHMubGVuZ3RoPDI/dWwoenJbZV0pOnpyW2VdJiZ6cltlXVtyXX19KTt2YXIgWHI9eGUoKGgwLHF1KT0+e3ZhciBzbD1tdCgpO3F1LmV4cG9ydHM9c2woe30uaXNQcm90b3R5cGVPZil9KTt2YXIgUnU9eGUoKHYwLE11KT0+e3ZhciBpbD1XdCgpO011LmV4cG9ydHM9aWwoXCJuYXZpZ2F0b3JcIixcInVzZXJBZ2VudFwiKXx8XCJcIn0pO3ZhciBKdT14ZSgoQzAsVXUpPT57dmFyIEd1PXB0KCksS3I9UnUoKSwkdT1HdS5wcm9jZXNzLFZ1PUd1LkRlbm8sV3U9JHUmJiR1LnZlcnNpb25zfHxWdSYmVnUudmVyc2lvbixIdT1XdSYmV3UudjgsZHQsZnI7SHUmJihkdD1IdS5zcGxpdChcIi5cIiksZnI9ZHRbMF0+MCYmZHRbMF08ND8xOisoZHRbMF0rZHRbMV0pKTshZnImJktyJiYoZHQ9S3IubWF0Y2goL0VkZ2VcXC8oXFxkKykvKSwoIWR0fHxkdFsxXT49NzQpJiYoZHQ9S3IubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pLGR0JiYoZnI9K2R0WzFdKSkpO1V1LmV4cG9ydHM9ZnJ9KTt2YXIgWXI9eGUoKEUwLFh1KT0+e3ZhciB6dT1KdSgpLGFsPUR0KCk7WHUuZXhwb3J0cz0hIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMmJiFhbChmdW5jdGlvbigpe3ZhciBlPVN5bWJvbCgpO3JldHVybiFTdHJpbmcoZSl8fCEoT2JqZWN0KGUpaW5zdGFuY2VvZiBTeW1ib2wpfHwhU3ltYm9sLnNoYW0mJnp1JiZ6dTw0MX0pfSk7dmFyIFFyPXhlKChGMCxLdSk9Pnt2YXIgb2w9WXIoKTtLdS5leHBvcnRzPW9sJiYhU3ltYm9sLnNoYW0mJnR5cGVvZiBTeW1ib2wuaXRlcmF0b3I9PVwic3ltYm9sXCJ9KTt2YXIgWnI9eGUoKEEwLFl1KT0+e3ZhciBsbD1XdCgpLGNsPW90KCkscGw9WHIoKSxmbD1RcigpLERsPU9iamVjdDtZdS5leHBvcnRzPWZsP2Z1bmN0aW9uKGUpe3JldHVybiB0eXBlb2YgZT09XCJzeW1ib2xcIn06ZnVuY3Rpb24oZSl7dmFyIHI9bGwoXCJTeW1ib2xcIik7cmV0dXJuIGNsKHIpJiZwbChyLnByb3RvdHlwZSxEbChlKSl9fSk7dmFyIERyPXhlKChTMCxRdSk9Pnt2YXIgbWw9U3RyaW5nO1F1LmV4cG9ydHM9ZnVuY3Rpb24oZSl7dHJ5e3JldHVybiBtbChlKX1jYXRjaHtyZXR1cm5cIk9iamVjdFwifX19KTt2YXIgSHQ9eGUoKHgwLFp1KT0+e3ZhciBkbD1vdCgpLGdsPURyKCkseWw9VHlwZUVycm9yO1p1LmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoZGwoZSkpcmV0dXJuIGU7dGhyb3cgeWwoZ2woZSkrXCIgaXMgbm90IGEgZnVuY3Rpb25cIil9fSk7dmFyIG1yPXhlKChiMCxlcyk9Pnt2YXIgaGw9SHQoKSx2bD1jcigpO2VzLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXt2YXIgdD1lW3JdO3JldHVybiB2bCh0KT92b2lkIDA6aGwodCl9fSk7dmFyIHJzPXhlKChUMCx0cyk9Pnt2YXIgZW49QXQoKSx0bj1vdCgpLHJuPVN0KCksQ2w9VHlwZUVycm9yO3RzLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXt2YXIgdCxzO2lmKHI9PT1cInN0cmluZ1wiJiZ0bih0PWUudG9TdHJpbmcpJiYhcm4ocz1lbih0LGUpKXx8dG4odD1lLnZhbHVlT2YpJiYhcm4ocz1lbih0LGUpKXx8ciE9PVwic3RyaW5nXCImJnRuKHQ9ZS50b1N0cmluZykmJiFybihzPWVuKHQsZSkpKXJldHVybiBzO3Rocm93IENsKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpfX0pO3ZhciB1cz14ZSgoQjAsbnMpPT57bnMuZXhwb3J0cz0hMX0pO3ZhciBkcj14ZSgoTjAsaXMpPT57dmFyIHNzPXB0KCksRWw9T2JqZWN0LmRlZmluZVByb3BlcnR5O2lzLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXt0cnl7RWwoc3MsZSx7dmFsdWU6cixjb25maWd1cmFibGU6ITAsd3JpdGFibGU6ITB9KX1jYXRjaHtzc1tlXT1yfXJldHVybiByfX0pO3ZhciBncj14ZSgodzAsb3MpPT57dmFyIEZsPXB0KCksQWw9ZHIoKSxhcz1cIl9fY29yZS1qc19zaGFyZWRfX1wiLFNsPUZsW2FzXXx8QWwoYXMse30pO29zLmV4cG9ydHM9U2x9KTt2YXIgbm49eGUoKF8wLGNzKT0+e3ZhciB4bD11cygpLGxzPWdyKCk7KGNzLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtyZXR1cm4gbHNbZV18fChsc1tlXT1yIT09dm9pZCAwP3I6e30pfSkoXCJ2ZXJzaW9uc1wiLFtdKS5wdXNoKHt2ZXJzaW9uOlwiMy4yNi4xXCIsbW9kZTp4bD9cInB1cmVcIjpcImdsb2JhbFwiLGNvcHlyaWdodDpcIlxceEE5IDIwMTQtMjAyMiBEZW5pcyBQdXNoa2FyZXYgKHpsb2lyb2NrLnJ1KVwiLGxpY2Vuc2U6XCJodHRwczovL2dpdGh1Yi5jb20vemxvaXJvY2svY29yZS1qcy9ibG9iL3YzLjI2LjEvTElDRU5TRVwiLHNvdXJjZTpcImh0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzXCJ9KX0pO3ZhciB5cj14ZSgoUDAscHMpPT57dmFyIGJsPUdyKCksVGw9T2JqZWN0O3BzLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIFRsKGJsKGUpKX19KTt2YXIgQ3Q9eGUoKEkwLGZzKT0+e3ZhciBCbD1tdCgpLE5sPXlyKCksd2w9Qmwoe30uaGFzT3duUHJvcGVydHkpO2ZzLmV4cG9ydHM9T2JqZWN0Lmhhc093bnx8ZnVuY3Rpb24ocix0KXtyZXR1cm4gd2woTmwociksdCl9fSk7dmFyIHVuPXhlKChrMCxEcyk9Pnt2YXIgX2w9bXQoKSxQbD0wLElsPU1hdGgucmFuZG9tKCksa2w9X2woMSAudG9TdHJpbmcpO0RzLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuXCJTeW1ib2woXCIrKGU9PT12b2lkIDA/XCJcIjplKStcIilfXCIra2woKytQbCtJbCwzNil9fSk7dmFyIGJ0PXhlKChMMCxocyk9Pnt2YXIgTGw9cHQoKSxPbD1ubigpLG1zPUN0KCksamw9dW4oKSxkcz1ZcigpLHlzPVFyKCksUHQ9T2woXCJ3a3NcIikseHQ9TGwuU3ltYm9sLGdzPXh0JiZ4dC5mb3IscWw9eXM/eHQ6eHQmJnh0LndpdGhvdXRTZXR0ZXJ8fGpsO2hzLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoIW1zKFB0LGUpfHwhKGRzfHx0eXBlb2YgUHRbZV09PVwic3RyaW5nXCIpKXt2YXIgcj1cIlN5bWJvbC5cIitlO2RzJiZtcyh4dCxlKT9QdFtlXT14dFtlXTp5cyYmZ3M/UHRbZV09Z3Mocik6UHRbZV09cWwocil9cmV0dXJuIFB0W2VdfX0pO3ZhciBGcz14ZSgoTzAsRXMpPT57dmFyIE1sPUF0KCksdnM9U3QoKSxDcz1acigpLFJsPW1yKCksJGw9cnMoKSxWbD1idCgpLFdsPVR5cGVFcnJvcixIbD1WbChcInRvUHJpbWl0aXZlXCIpO0VzLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXtpZighdnMoZSl8fENzKGUpKXJldHVybiBlO3ZhciB0PVJsKGUsSGwpLHM7aWYodCl7aWYocj09PXZvaWQgMCYmKHI9XCJkZWZhdWx0XCIpLHM9TWwodCxlLHIpLCF2cyhzKXx8Q3MocykpcmV0dXJuIHM7dGhyb3cgV2woXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIil9cmV0dXJuIHI9PT12b2lkIDAmJihyPVwibnVtYmVyXCIpLCRsKGUscil9fSk7dmFyIGhyPXhlKChqMCxBcyk9Pnt2YXIgR2w9RnMoKSxVbD1acigpO0FzLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHI9R2woZSxcInN0cmluZ1wiKTtyZXR1cm4gVWwocik/cjpyK1wiXCJ9fSk7dmFyIGJzPXhlKChxMCx4cyk9Pnt2YXIgSmw9cHQoKSxTcz1TdCgpLHNuPUpsLmRvY3VtZW50LHpsPVNzKHNuKSYmU3Moc24uY3JlYXRlRWxlbWVudCk7eHMuZXhwb3J0cz1mdW5jdGlvbihlKXtyZXR1cm4gemw/c24uY3JlYXRlRWxlbWVudChlKTp7fX19KTt2YXIgYW49eGUoKE0wLFRzKT0+e3ZhciBYbD15dCgpLEtsPUR0KCksWWw9YnMoKTtUcy5leHBvcnRzPSFYbCYmIUtsKGZ1bmN0aW9uKCl7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShZbChcImRpdlwiKSxcImFcIix7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIDd9fSkuYSE9N30pfSk7dmFyIG9uPXhlKE5zPT57dmFyIFFsPXl0KCksWmw9QXQoKSxlYz12dSgpLHRjPWxyKCkscmM9cHIoKSxuYz1ocigpLHVjPUN0KCksc2M9YW4oKSxCcz1PYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO05zLmY9UWw/QnM6ZnVuY3Rpb24ocix0KXtpZihyPXJjKHIpLHQ9bmModCksc2MpdHJ5e3JldHVybiBCcyhyLHQpfWNhdGNoe31pZih1YyhyLHQpKXJldHVybiB0YyghWmwoZWMuZixyLHQpLHJbdF0pfX0pO3ZhciBfcz14ZSgoJDAsd3MpPT57dmFyIGljPXl0KCksYWM9RHQoKTt3cy5leHBvcnRzPWljJiZhYyhmdW5jdGlvbigpe3JldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24oKXt9LFwicHJvdG90eXBlXCIse3ZhbHVlOjQyLHdyaXRhYmxlOiExfSkucHJvdG90eXBlIT00Mn0pfSk7dmFyIFR0PXhlKChWMCxQcyk9Pnt2YXIgb2M9U3QoKSxsYz1TdHJpbmcsY2M9VHlwZUVycm9yO1BzLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYob2MoZSkpcmV0dXJuIGU7dGhyb3cgY2MobGMoZSkrXCIgaXMgbm90IGFuIG9iamVjdFwiKX19KTt2YXIgSXQ9eGUoa3M9Pnt2YXIgcGM9eXQoKSxmYz1hbigpLERjPV9zKCksdnI9VHQoKSxJcz1ocigpLG1jPVR5cGVFcnJvcixsbj1PYmplY3QuZGVmaW5lUHJvcGVydHksZGM9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixjbj1cImVudW1lcmFibGVcIixwbj1cImNvbmZpZ3VyYWJsZVwiLGZuPVwid3JpdGFibGVcIjtrcy5mPXBjP0RjP2Z1bmN0aW9uKHIsdCxzKXtpZih2cihyKSx0PUlzKHQpLHZyKHMpLHR5cGVvZiByPT1cImZ1bmN0aW9uXCImJnQ9PT1cInByb3RvdHlwZVwiJiZcInZhbHVlXCJpbiBzJiZmbiBpbiBzJiYhc1tmbl0pe3ZhciBhPWRjKHIsdCk7YSYmYVtmbl0mJihyW3RdPXMudmFsdWUscz17Y29uZmlndXJhYmxlOnBuIGluIHM/c1twbl06YVtwbl0sZW51bWVyYWJsZTpjbiBpbiBzP3NbY25dOmFbY25dLHdyaXRhYmxlOiExfSl9cmV0dXJuIGxuKHIsdCxzKX06bG46ZnVuY3Rpb24ocix0LHMpe2lmKHZyKHIpLHQ9SXModCksdnIocyksZmMpdHJ5e3JldHVybiBsbihyLHQscyl9Y2F0Y2h7fWlmKFwiZ2V0XCJpbiBzfHxcInNldFwiaW4gcyl0aHJvdyBtYyhcIkFjY2Vzc29ycyBub3Qgc3VwcG9ydGVkXCIpO3JldHVyblwidmFsdWVcImluIHMmJihyW3RdPXMudmFsdWUpLHJ9fSk7dmFyIERuPXhlKChIMCxMcyk9Pnt2YXIgZ2M9eXQoKSx5Yz1JdCgpLGhjPWxyKCk7THMuZXhwb3J0cz1nYz9mdW5jdGlvbihlLHIsdCl7cmV0dXJuIHljLmYoZSxyLGhjKDEsdCkpfTpmdW5jdGlvbihlLHIsdCl7cmV0dXJuIGVbcl09dCxlfX0pO3ZhciBxcz14ZSgoRzAsanMpPT57dmFyIG1uPXl0KCksdmM9Q3QoKSxPcz1GdW5jdGlvbi5wcm90b3R5cGUsQ2M9bW4mJk9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IsZG49dmMoT3MsXCJuYW1lXCIpLEVjPWRuJiZmdW5jdGlvbigpe30ubmFtZT09PVwic29tZXRoaW5nXCIsRmM9ZG4mJighbW58fG1uJiZDYyhPcyxcIm5hbWVcIikuY29uZmlndXJhYmxlKTtqcy5leHBvcnRzPXtFWElTVFM6ZG4sUFJPUEVSOkVjLENPTkZJR1VSQUJMRTpGY319KTt2YXIgeW49eGUoKFUwLE1zKT0+e3ZhciBBYz1tdCgpLFNjPW90KCksZ249Z3IoKSx4Yz1BYyhGdW5jdGlvbi50b1N0cmluZyk7U2MoZ24uaW5zcGVjdFNvdXJjZSl8fChnbi5pbnNwZWN0U291cmNlPWZ1bmN0aW9uKGUpe3JldHVybiB4YyhlKX0pO01zLmV4cG9ydHM9Z24uaW5zcGVjdFNvdXJjZX0pO3ZhciBWcz14ZSgoSjAsJHMpPT57dmFyIGJjPXB0KCksVGM9b3QoKSxScz1iYy5XZWFrTWFwOyRzLmV4cG9ydHM9VGMoUnMpJiYvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKFJzKSl9KTt2YXIgR3M9eGUoKHowLEhzKT0+e3ZhciBCYz1ubigpLE5jPXVuKCksV3M9QmMoXCJrZXlzXCIpO0hzLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIFdzW2VdfHwoV3NbZV09TmMoZSkpfX0pO3ZhciBobj14ZSgoWDAsVXMpPT57VXMuZXhwb3J0cz17fX0pO3ZhciBLcz14ZSgoSzAsWHMpPT57dmFyIHdjPVZzKCksenM9cHQoKSxfYz1TdCgpLFBjPURuKCksdm49Q3QoKSxDbj1ncigpLEljPUdzKCksa2M9aG4oKSxKcz1cIk9iamVjdCBhbHJlYWR5IGluaXRpYWxpemVkXCIsRW49enMuVHlwZUVycm9yLExjPXpzLldlYWtNYXAsQ3IsR3QsRXIsT2M9ZnVuY3Rpb24oZSl7cmV0dXJuIEVyKGUpP0d0KGUpOkNyKGUse30pfSxqYz1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24ocil7dmFyIHQ7aWYoIV9jKHIpfHwodD1HdChyKSkudHlwZSE9PWUpdGhyb3cgRW4oXCJJbmNvbXBhdGlibGUgcmVjZWl2ZXIsIFwiK2UrXCIgcmVxdWlyZWRcIik7cmV0dXJuIHR9fTt3Y3x8Q24uc3RhdGU/KGd0PUNuLnN0YXRlfHwoQ24uc3RhdGU9bmV3IExjKSxndC5nZXQ9Z3QuZ2V0LGd0Lmhhcz1ndC5oYXMsZ3Quc2V0PWd0LnNldCxDcj1mdW5jdGlvbihlLHIpe2lmKGd0LmhhcyhlKSl0aHJvdyBFbihKcyk7cmV0dXJuIHIuZmFjYWRlPWUsZ3Quc2V0KGUscikscn0sR3Q9ZnVuY3Rpb24oZSl7cmV0dXJuIGd0LmdldChlKXx8e319LEVyPWZ1bmN0aW9uKGUpe3JldHVybiBndC5oYXMoZSl9KTooQnQ9SWMoXCJzdGF0ZVwiKSxrY1tCdF09ITAsQ3I9ZnVuY3Rpb24oZSxyKXtpZih2bihlLEJ0KSl0aHJvdyBFbihKcyk7cmV0dXJuIHIuZmFjYWRlPWUsUGMoZSxCdCxyKSxyfSxHdD1mdW5jdGlvbihlKXtyZXR1cm4gdm4oZSxCdCk/ZVtCdF06e319LEVyPWZ1bmN0aW9uKGUpe3JldHVybiB2bihlLEJ0KX0pO3ZhciBndCxCdDtYcy5leHBvcnRzPXtzZXQ6Q3IsZ2V0Okd0LGhhczpFcixlbmZvcmNlOk9jLGdldHRlckZvcjpqY319KTt2YXIgQW49eGUoKFkwLFFzKT0+e3ZhciBxYz1EdCgpLE1jPW90KCksRnI9Q3QoKSxGbj15dCgpLFJjPXFzKCkuQ09ORklHVVJBQkxFLCRjPXluKCksWXM9S3MoKSxWYz1Zcy5lbmZvcmNlLFdjPVlzLmdldCxBcj1PYmplY3QuZGVmaW5lUHJvcGVydHksSGM9Rm4mJiFxYyhmdW5jdGlvbigpe3JldHVybiBBcihmdW5jdGlvbigpe30sXCJsZW5ndGhcIix7dmFsdWU6OH0pLmxlbmd0aCE9PTh9KSxHYz1TdHJpbmcoU3RyaW5nKS5zcGxpdChcIlN0cmluZ1wiKSxVYz1Rcy5leHBvcnRzPWZ1bmN0aW9uKGUscix0KXtTdHJpbmcocikuc2xpY2UoMCw3KT09PVwiU3ltYm9sKFwiJiYocj1cIltcIitTdHJpbmcocikucmVwbGFjZSgvXlN5bWJvbFxcKChbXildKilcXCkvLFwiJDFcIikrXCJdXCIpLHQmJnQuZ2V0dGVyJiYocj1cImdldCBcIityKSx0JiZ0LnNldHRlciYmKHI9XCJzZXQgXCIrciksKCFGcihlLFwibmFtZVwiKXx8UmMmJmUubmFtZSE9PXIpJiYoRm4/QXIoZSxcIm5hbWVcIix7dmFsdWU6cixjb25maWd1cmFibGU6ITB9KTplLm5hbWU9ciksSGMmJnQmJkZyKHQsXCJhcml0eVwiKSYmZS5sZW5ndGghPT10LmFyaXR5JiZBcihlLFwibGVuZ3RoXCIse3ZhbHVlOnQuYXJpdHl9KTt0cnl7dCYmRnIodCxcImNvbnN0cnVjdG9yXCIpJiZ0LmNvbnN0cnVjdG9yP0ZuJiZBcihlLFwicHJvdG90eXBlXCIse3dyaXRhYmxlOiExfSk6ZS5wcm90b3R5cGUmJihlLnByb3RvdHlwZT12b2lkIDApfWNhdGNoe312YXIgcz1WYyhlKTtyZXR1cm4gRnIocyxcInNvdXJjZVwiKXx8KHMuc291cmNlPUdjLmpvaW4odHlwZW9mIHI9PVwic3RyaW5nXCI/cjpcIlwiKSksZX07RnVuY3Rpb24ucHJvdG90eXBlLnRvU3RyaW5nPVVjKGZ1bmN0aW9uKCl7cmV0dXJuIE1jKHRoaXMpJiZXYyh0aGlzKS5zb3VyY2V8fCRjKHRoaXMpfSxcInRvU3RyaW5nXCIpfSk7dmFyIGVpPXhlKChRMCxacyk9Pnt2YXIgSmM9b3QoKSx6Yz1JdCgpLFhjPUFuKCksS2M9ZHIoKTtacy5leHBvcnRzPWZ1bmN0aW9uKGUscix0LHMpe3N8fChzPXt9KTt2YXIgYT1zLmVudW1lcmFibGUsbj1zLm5hbWUhPT12b2lkIDA/cy5uYW1lOnI7aWYoSmModCkmJlhjKHQsbixzKSxzLmdsb2JhbClhP2Vbcl09dDpLYyhyLHQpO2Vsc2V7dHJ5e3MudW5zYWZlP2Vbcl0mJihhPSEwKTpkZWxldGUgZVtyXX1jYXRjaHt9YT9lW3JdPXQ6emMuZihlLHIse3ZhbHVlOnQsZW51bWVyYWJsZTohMSxjb25maWd1cmFibGU6IXMubm9uQ29uZmlndXJhYmxlLHdyaXRhYmxlOiFzLm5vbldyaXRhYmxlfSl9cmV0dXJuIGV9fSk7dmFyIHJpPXhlKChaMCx0aSk9Pnt2YXIgWWM9TWF0aC5jZWlsLFFjPU1hdGguZmxvb3I7dGkuZXhwb3J0cz1NYXRoLnRydW5jfHxmdW5jdGlvbihyKXt2YXIgdD0rcjtyZXR1cm4odD4wP1FjOlljKSh0KX19KTt2YXIgU3I9eGUoKGV5LG5pKT0+e3ZhciBaYz1yaSgpO25pLmV4cG9ydHM9ZnVuY3Rpb24oZSl7dmFyIHI9K2U7cmV0dXJuIHIhPT1yfHxyPT09MD8wOlpjKHIpfX0pO3ZhciBzaT14ZSgodHksdWkpPT57dmFyIGVwPVNyKCksdHA9TWF0aC5tYXgscnA9TWF0aC5taW47dWkuZXhwb3J0cz1mdW5jdGlvbihlLHIpe3ZhciB0PWVwKGUpO3JldHVybiB0PDA/dHAodCtyLDApOnJwKHQscil9fSk7dmFyIGFpPXhlKChyeSxpaSk9Pnt2YXIgbnA9U3IoKSx1cD1NYXRoLm1pbjtpaS5leHBvcnRzPWZ1bmN0aW9uKGUpe3JldHVybiBlPjA/dXAobnAoZSksOTAwNzE5OTI1NDc0MDk5MSk6MH19KTt2YXIga3Q9eGUoKG55LG9pKT0+e3ZhciBzcD1haSgpO29pLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIHNwKGUubGVuZ3RoKX19KTt2YXIgcGk9eGUoKHV5LGNpKT0+e3ZhciBpcD1wcigpLGFwPXNpKCksb3A9a3QoKSxsaT1mdW5jdGlvbihlKXtyZXR1cm4gZnVuY3Rpb24ocix0LHMpe3ZhciBhPWlwKHIpLG49b3AoYSksdT1hcChzLG4pLGk7aWYoZSYmdCE9dCl7Zm9yKDtuPnU7KWlmKGk9YVt1KytdLGkhPWkpcmV0dXJuITB9ZWxzZSBmb3IoO24+dTt1KyspaWYoKGV8fHUgaW4gYSkmJmFbdV09PT10KXJldHVybiBlfHx1fHwwO3JldHVybiFlJiYtMX19O2NpLmV4cG9ydHM9e2luY2x1ZGVzOmxpKCEwKSxpbmRleE9mOmxpKCExKX19KTt2YXIgbWk9eGUoKHN5LERpKT0+e3ZhciBscD1tdCgpLFNuPUN0KCksY3A9cHIoKSxwcD1waSgpLmluZGV4T2YsZnA9aG4oKSxmaT1scChbXS5wdXNoKTtEaS5leHBvcnRzPWZ1bmN0aW9uKGUscil7dmFyIHQ9Y3AoZSkscz0wLGE9W10sbjtmb3IobiBpbiB0KSFTbihmcCxuKSYmU24odCxuKSYmZmkoYSxuKTtmb3IoO3IubGVuZ3RoPnM7KVNuKHQsbj1yW3MrK10pJiYofnBwKGEsbil8fGZpKGEsbikpO3JldHVybiBhfX0pO3ZhciBnaT14ZSgoaXksZGkpPT57ZGkuZXhwb3J0cz1bXCJjb25zdHJ1Y3RvclwiLFwiaGFzT3duUHJvcGVydHlcIixcImlzUHJvdG90eXBlT2ZcIixcInByb3BlcnR5SXNFbnVtZXJhYmxlXCIsXCJ0b0xvY2FsZVN0cmluZ1wiLFwidG9TdHJpbmdcIixcInZhbHVlT2ZcIl19KTt2YXIgaGk9eGUoeWk9Pnt2YXIgRHA9bWkoKSxtcD1naSgpLGRwPW1wLmNvbmNhdChcImxlbmd0aFwiLFwicHJvdG90eXBlXCIpO3lpLmY9T2JqZWN0LmdldE93blByb3BlcnR5TmFtZXN8fGZ1bmN0aW9uKHIpe3JldHVybiBEcChyLGRwKX19KTt2YXIgQ2k9eGUodmk9Pnt2aS5mPU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHN9KTt2YXIgRmk9eGUoKGx5LEVpKT0+e3ZhciBncD1XdCgpLHlwPW10KCksaHA9aGkoKSx2cD1DaSgpLENwPVR0KCksRXA9eXAoW10uY29uY2F0KTtFaS5leHBvcnRzPWdwKFwiUmVmbGVjdFwiLFwib3duS2V5c1wiKXx8ZnVuY3Rpb24ocil7dmFyIHQ9aHAuZihDcChyKSkscz12cC5mO3JldHVybiBzP0VwKHQscyhyKSk6dH19KTt2YXIgeGk9eGUoKGN5LFNpKT0+e3ZhciBBaT1DdCgpLEZwPUZpKCksQXA9b24oKSxTcD1JdCgpO1NpLmV4cG9ydHM9ZnVuY3Rpb24oZSxyLHQpe2Zvcih2YXIgcz1GcChyKSxhPVNwLmYsbj1BcC5mLHU9MDt1PHMubGVuZ3RoO3UrKyl7dmFyIGk9c1t1XTshQWkoZSxpKSYmISh0JiZBaSh0LGkpKSYmYShlLGksbihyLGkpKX19fSk7dmFyIFRpPXhlKChweSxiaSk9Pnt2YXIgeHA9RHQoKSxicD1vdCgpLFRwPS8jfFxcLnByb3RvdHlwZVxcLi8sVXQ9ZnVuY3Rpb24oZSxyKXt2YXIgdD1OcFtCcChlKV07cmV0dXJuIHQ9PV9wPyEwOnQ9PXdwPyExOmJwKHIpP3hwKHIpOiEhcn0sQnA9VXQubm9ybWFsaXplPWZ1bmN0aW9uKGUpe3JldHVybiBTdHJpbmcoZSkucmVwbGFjZShUcCxcIi5cIikudG9Mb3dlckNhc2UoKX0sTnA9VXQuZGF0YT17fSx3cD1VdC5OQVRJVkU9XCJOXCIsX3A9VXQuUE9MWUZJTEw9XCJQXCI7YmkuZXhwb3J0cz1VdH0pO3ZhciBKdD14ZSgoZnksQmkpPT57dmFyIHhuPXB0KCksUHA9b24oKS5mLElwPURuKCksa3A9ZWkoKSxMcD1kcigpLE9wPXhpKCksanA9VGkoKTtCaS5leHBvcnRzPWZ1bmN0aW9uKGUscil7dmFyIHQ9ZS50YXJnZXQscz1lLmdsb2JhbCxhPWUuc3RhdCxuLHUsaSxsLHAsZDtpZihzP3U9eG46YT91PXhuW3RdfHxMcCh0LHt9KTp1PSh4blt0XXx8e30pLnByb3RvdHlwZSx1KWZvcihpIGluIHIpe2lmKHA9cltpXSxlLmRvbnRDYWxsR2V0U2V0PyhkPVBwKHUsaSksbD1kJiZkLnZhbHVlKTpsPXVbaV0sbj1qcChzP2k6dCsoYT9cIi5cIjpcIiNcIikraSxlLmZvcmNlZCksIW4mJmwhPT12b2lkIDApe2lmKHR5cGVvZiBwPT10eXBlb2YgbCljb250aW51ZTtPcChwLGwpfShlLnNoYW18fGwmJmwuc2hhbSkmJklwKHAsXCJzaGFtXCIsITApLGtwKHUsaSxwLGUpfX19KTt2YXIgYm49eGUoKER5LE5pKT0+e3ZhciBxcD1WdCgpO05pLmV4cG9ydHM9QXJyYXkuaXNBcnJheXx8ZnVuY3Rpb24ocil7cmV0dXJuIHFwKHIpPT1cIkFycmF5XCJ9fSk7dmFyIF9pPXhlKChteSx3aSk9Pnt2YXIgTXA9VHlwZUVycm9yLFJwPTkwMDcxOTkyNTQ3NDA5OTE7d2kuZXhwb3J0cz1mdW5jdGlvbihlKXtpZihlPlJwKXRocm93IE1wKFwiTWF4aW11bSBhbGxvd2VkIGluZGV4IGV4Y2VlZGVkXCIpO3JldHVybiBlfX0pO3ZhciBJaT14ZSgoZHksUGkpPT57dmFyICRwPVZ0KCksVnA9bXQoKTtQaS5leHBvcnRzPWZ1bmN0aW9uKGUpe2lmKCRwKGUpPT09XCJGdW5jdGlvblwiKXJldHVybiBWcChlKX19KTt2YXIgVG49eGUoKGd5LExpKT0+e3ZhciBraT1JaSgpLFdwPUh0KCksSHA9YXIoKSxHcD1raShraS5iaW5kKTtMaS5leHBvcnRzPWZ1bmN0aW9uKGUscil7cmV0dXJuIFdwKGUpLHI9PT12b2lkIDA/ZTpIcD9HcChlLHIpOmZ1bmN0aW9uKCl7cmV0dXJuIGUuYXBwbHkocixhcmd1bWVudHMpfX19KTt2YXIgQm49eGUoKHl5LGppKT0+e1widXNlIHN0cmljdFwiO3ZhciBVcD1ibigpLEpwPWt0KCksenA9X2koKSxYcD1UbigpLE9pPWZ1bmN0aW9uKGUscix0LHMsYSxuLHUsaSl7Zm9yKHZhciBsPWEscD0wLGQ9dT9YcCh1LGkpOiExLHksZztwPHM7KXAgaW4gdCYmKHk9ZD9kKHRbcF0scCxyKTp0W3BdLG4+MCYmVXAoeSk/KGc9SnAoeSksbD1PaShlLHIseSxnLGwsbi0xKS0xKTooenAobCsxKSxlW2xdPXkpLGwrKykscCsrO3JldHVybiBsfTtqaS5leHBvcnRzPU9pfSk7dmFyIFJpPXhlKChoeSxNaSk9Pnt2YXIgS3A9YnQoKSxZcD1LcChcInRvU3RyaW5nVGFnXCIpLHFpPXt9O3FpW1lwXT1cInpcIjtNaS5leHBvcnRzPVN0cmluZyhxaSk9PT1cIltvYmplY3Qgel1cIn0pO3ZhciBObj14ZSgodnksJGkpPT57dmFyIFFwPVJpKCksWnA9b3QoKSx4cj1WdCgpLGVmPWJ0KCksdGY9ZWYoXCJ0b1N0cmluZ1RhZ1wiKSxyZj1PYmplY3QsbmY9eHIoZnVuY3Rpb24oKXtyZXR1cm4gYXJndW1lbnRzfSgpKT09XCJBcmd1bWVudHNcIix1Zj1mdW5jdGlvbihlLHIpe3RyeXtyZXR1cm4gZVtyXX1jYXRjaHt9fTskaS5leHBvcnRzPVFwP3hyOmZ1bmN0aW9uKGUpe3ZhciByLHQscztyZXR1cm4gZT09PXZvaWQgMD9cIlVuZGVmaW5lZFwiOmU9PT1udWxsP1wiTnVsbFwiOnR5cGVvZih0PXVmKHI9cmYoZSksdGYpKT09XCJzdHJpbmdcIj90Om5mP3hyKHIpOihzPXhyKHIpKT09XCJPYmplY3RcIiYmWnAoci5jYWxsZWUpP1wiQXJndW1lbnRzXCI6c319KTt2YXIgSmk9eGUoKEN5LFVpKT0+e3ZhciBzZj1tdCgpLGFmPUR0KCksVmk9b3QoKSxvZj1ObigpLGxmPVd0KCksY2Y9eW4oKSxXaT1mdW5jdGlvbigpe30scGY9W10sSGk9bGYoXCJSZWZsZWN0XCIsXCJjb25zdHJ1Y3RcIiksd249L15cXHMqKD86Y2xhc3N8ZnVuY3Rpb24pXFxiLyxmZj1zZih3bi5leGVjKSxEZj0hd24uZXhlYyhXaSksenQ9ZnVuY3Rpb24ocil7aWYoIVZpKHIpKXJldHVybiExO3RyeXtyZXR1cm4gSGkoV2kscGYsciksITB9Y2F0Y2h7cmV0dXJuITF9fSxHaT1mdW5jdGlvbihyKXtpZighVmkocikpcmV0dXJuITE7c3dpdGNoKG9mKHIpKXtjYXNlXCJBc3luY0Z1bmN0aW9uXCI6Y2FzZVwiR2VuZXJhdG9yRnVuY3Rpb25cIjpjYXNlXCJBc3luY0dlbmVyYXRvckZ1bmN0aW9uXCI6cmV0dXJuITF9dHJ5e3JldHVybiBEZnx8ISFmZih3bixjZihyKSl9Y2F0Y2h7cmV0dXJuITB9fTtHaS5zaGFtPSEwO1VpLmV4cG9ydHM9IUhpfHxhZihmdW5jdGlvbigpe3ZhciBlO3JldHVybiB6dCh6dC5jYWxsKXx8IXp0KE9iamVjdCl8fCF6dChmdW5jdGlvbigpe2U9ITB9KXx8ZX0pP0dpOnp0fSk7dmFyIFlpPXhlKChFeSxLaSk9Pnt2YXIgemk9Ym4oKSxtZj1KaSgpLGRmPVN0KCksZ2Y9YnQoKSx5Zj1nZihcInNwZWNpZXNcIiksWGk9QXJyYXk7S2kuZXhwb3J0cz1mdW5jdGlvbihlKXt2YXIgcjtyZXR1cm4gemkoZSkmJihyPWUuY29uc3RydWN0b3IsbWYocikmJihyPT09WGl8fHppKHIucHJvdG90eXBlKSk/cj12b2lkIDA6ZGYocikmJihyPXJbeWZdLHI9PT1udWxsJiYocj12b2lkIDApKSkscj09PXZvaWQgMD9YaTpyfX0pO3ZhciBfbj14ZSgoRnksUWkpPT57dmFyIGhmPVlpKCk7UWkuZXhwb3J0cz1mdW5jdGlvbihlLHIpe3JldHVybiBuZXcoaGYoZSkpKHI9PT0wPzA6cil9fSk7dmFyIFppPXhlKCgpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHZmPUp0KCksQ2Y9Qm4oKSxFZj1IdCgpLEZmPXlyKCksQWY9a3QoKSxTZj1fbigpO3ZmKHt0YXJnZXQ6XCJBcnJheVwiLHByb3RvOiEwfSx7ZmxhdE1hcDpmdW5jdGlvbihyKXt2YXIgdD1GZih0aGlzKSxzPUFmKHQpLGE7cmV0dXJuIEVmKHIpLGE9U2YodCwwKSxhLmxlbmd0aD1DZihhLHQsdCxzLDAsMSxyLGFyZ3VtZW50cy5sZW5ndGg+MT9hcmd1bWVudHNbMV06dm9pZCAwKSxhfX0pfSk7dmFyIFBuPXhlKCh4eSxlYSk9PntlYS5leHBvcnRzPXt9fSk7dmFyIHJhPXhlKChieSx0YSk9Pnt2YXIgeGY9YnQoKSxiZj1QbigpLFRmPXhmKFwiaXRlcmF0b3JcIiksQmY9QXJyYXkucHJvdG90eXBlO3RhLmV4cG9ydHM9ZnVuY3Rpb24oZSl7cmV0dXJuIGUhPT12b2lkIDAmJihiZi5BcnJheT09PWV8fEJmW1RmXT09PWUpfX0pO3ZhciBJbj14ZSgoVHksdWEpPT57dmFyIE5mPU5uKCksbmE9bXIoKSx3Zj1jcigpLF9mPVBuKCksUGY9YnQoKSxJZj1QZihcIml0ZXJhdG9yXCIpO3VhLmV4cG9ydHM9ZnVuY3Rpb24oZSl7aWYoIXdmKGUpKXJldHVybiBuYShlLElmKXx8bmEoZSxcIkBAaXRlcmF0b3JcIil8fF9mW05mKGUpXX19KTt2YXIgaWE9eGUoKEJ5LHNhKT0+e3ZhciBrZj1BdCgpLExmPUh0KCksT2Y9VHQoKSxqZj1EcigpLHFmPUluKCksTWY9VHlwZUVycm9yO3NhLmV4cG9ydHM9ZnVuY3Rpb24oZSxyKXt2YXIgdD1hcmd1bWVudHMubGVuZ3RoPDI/cWYoZSk6cjtpZihMZih0KSlyZXR1cm4gT2Yoa2YodCxlKSk7dGhyb3cgTWYoamYoZSkrXCIgaXMgbm90IGl0ZXJhYmxlXCIpfX0pO3ZhciBsYT14ZSgoTnksb2EpPT57dmFyIFJmPUF0KCksYWE9VHQoKSwkZj1tcigpO29hLmV4cG9ydHM9ZnVuY3Rpb24oZSxyLHQpe3ZhciBzLGE7YWEoZSk7dHJ5e2lmKHM9JGYoZSxcInJldHVyblwiKSwhcyl7aWYocj09PVwidGhyb3dcIil0aHJvdyB0O3JldHVybiB0fXM9UmYocyxlKX1jYXRjaChuKXthPSEwLHM9bn1pZihyPT09XCJ0aHJvd1wiKXRocm93IHQ7aWYoYSl0aHJvdyBzO3JldHVybiBhYShzKSx0fX0pO3ZhciBtYT14ZSgod3ksRGEpPT57dmFyIFZmPVRuKCksV2Y9QXQoKSxIZj1UdCgpLEdmPURyKCksVWY9cmEoKSxKZj1rdCgpLGNhPVhyKCksemY9aWEoKSxYZj1JbigpLHBhPWxhKCksS2Y9VHlwZUVycm9yLGJyPWZ1bmN0aW9uKGUscil7dGhpcy5zdG9wcGVkPWUsdGhpcy5yZXN1bHQ9cn0sZmE9YnIucHJvdG90eXBlO0RhLmV4cG9ydHM9ZnVuY3Rpb24oZSxyLHQpe3ZhciBzPXQmJnQudGhhdCxhPSEhKHQmJnQuQVNfRU5UUklFUyksbj0hISh0JiZ0LklTX1JFQ09SRCksdT0hISh0JiZ0LklTX0lURVJBVE9SKSxpPSEhKHQmJnQuSU5URVJSVVBURUQpLGw9VmYocixzKSxwLGQseSxnLGMsRCxFLF89ZnVuY3Rpb24oRil7cmV0dXJuIHAmJnBhKHAsXCJub3JtYWxcIixGKSxuZXcgYnIoITAsRil9LHc9ZnVuY3Rpb24oRil7cmV0dXJuIGE/KEhmKEYpLGk/bChGWzBdLEZbMV0sXyk6bChGWzBdLEZbMV0pKTppP2woRixfKTpsKEYpfTtpZihuKXA9ZS5pdGVyYXRvcjtlbHNlIGlmKHUpcD1lO2Vsc2V7aWYoZD1YZihlKSwhZCl0aHJvdyBLZihHZihlKStcIiBpcyBub3QgaXRlcmFibGVcIik7aWYoVWYoZCkpe2Zvcih5PTAsZz1KZihlKTtnPnk7eSsrKWlmKGM9dyhlW3ldKSxjJiZjYShmYSxjKSlyZXR1cm4gYztyZXR1cm4gbmV3IGJyKCExKX1wPXpmKGUsZCl9Zm9yKEQ9bj9lLm5leHQ6cC5uZXh0OyEoRT1XZihELHApKS5kb25lOyl7dHJ5e2M9dyhFLnZhbHVlKX1jYXRjaChGKXtwYShwLFwidGhyb3dcIixGKX1pZih0eXBlb2YgYz09XCJvYmplY3RcIiYmYyYmY2EoZmEsYykpcmV0dXJuIGN9cmV0dXJuIG5ldyBicighMSl9fSk7dmFyIGdhPXhlKChfeSxkYSk9PntcInVzZSBzdHJpY3RcIjt2YXIgWWY9aHIoKSxRZj1JdCgpLFpmPWxyKCk7ZGEuZXhwb3J0cz1mdW5jdGlvbihlLHIsdCl7dmFyIHM9WWYocik7cyBpbiBlP1FmLmYoZSxzLFpmKDAsdCkpOmVbc109dH19KTt2YXIgeWE9eGUoKCk9Pnt2YXIgZUQ9SnQoKSx0RD1tYSgpLHJEPWdhKCk7ZUQoe3RhcmdldDpcIk9iamVjdFwiLHN0YXQ6ITB9LHtmcm9tRW50cmllczpmdW5jdGlvbihyKXt2YXIgdD17fTtyZXR1cm4gdEQocixmdW5jdGlvbihzLGEpe3JEKHQscyxhKX0se0FTX0VOVFJJRVM6ITB9KSx0fX0pfSk7dmFyIENhPXhlKChreSx2YSk9Pnt2YXIgaGE9QW4oKSxuRD1JdCgpO3ZhLmV4cG9ydHM9ZnVuY3Rpb24oZSxyLHQpe3JldHVybiB0LmdldCYmaGEodC5nZXQscix7Z2V0dGVyOiEwfSksdC5zZXQmJmhhKHQuc2V0LHIse3NldHRlcjohMH0pLG5ELmYoZSxyLHQpfX0pO3ZhciBGYT14ZSgoTHksRWEpPT57XCJ1c2Ugc3RyaWN0XCI7dmFyIHVEPVR0KCk7RWEuZXhwb3J0cz1mdW5jdGlvbigpe3ZhciBlPXVEKHRoaXMpLHI9XCJcIjtyZXR1cm4gZS5oYXNJbmRpY2VzJiYocis9XCJkXCIpLGUuZ2xvYmFsJiYocis9XCJnXCIpLGUuaWdub3JlQ2FzZSYmKHIrPVwiaVwiKSxlLm11bHRpbGluZSYmKHIrPVwibVwiKSxlLmRvdEFsbCYmKHIrPVwic1wiKSxlLnVuaWNvZGUmJihyKz1cInVcIiksZS51bmljb2RlU2V0cyYmKHIrPVwidlwiKSxlLnN0aWNreSYmKHIrPVwieVwiKSxyfX0pO3ZhciB4YT14ZSgoKT0+e3ZhciBzRD1wdCgpLGlEPXl0KCksYUQ9Q2EoKSxvRD1GYSgpLGxEPUR0KCksQWE9c0QuUmVnRXhwLFNhPUFhLnByb3RvdHlwZSxjRD1pRCYmbEQoZnVuY3Rpb24oKXt2YXIgZT0hMDt0cnl7QWEoXCIuXCIsXCJkXCIpfWNhdGNoe2U9ITF9dmFyIHI9e30sdD1cIlwiLHM9ZT9cImRnaW1zeVwiOlwiZ2ltc3lcIixhPWZ1bmN0aW9uKGwscCl7T2JqZWN0LmRlZmluZVByb3BlcnR5KHIsbCx7Z2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHQrPXAsITB9fSl9LG49e2RvdEFsbDpcInNcIixnbG9iYWw6XCJnXCIsaWdub3JlQ2FzZTpcImlcIixtdWx0aWxpbmU6XCJtXCIsc3RpY2t5OlwieVwifTtlJiYobi5oYXNJbmRpY2VzPVwiZFwiKTtmb3IodmFyIHUgaW4gbilhKHUsblt1XSk7dmFyIGk9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTYSxcImZsYWdzXCIpLmdldC5jYWxsKHIpO3JldHVybiBpIT09c3x8dCE9PXN9KTtjRCYmYUQoU2EsXCJmbGFnc1wiLHtjb25maWd1cmFibGU6ITAsZ2V0Om9EfSl9KTt2YXIgYmE9eGUoKCk9Pnt2YXIgcEQ9SnQoKSxrbj1wdCgpO3BEKHtnbG9iYWw6ITAsZm9yY2VkOmtuLmdsb2JhbFRoaXMhPT1rbn0se2dsb2JhbFRoaXM6a259KX0pO3ZhciBUYT14ZSgoKT0+e2JhKCl9KTt2YXIgQmE9eGUoKCk9PntcInVzZSBzdHJpY3RcIjt2YXIgZkQ9SnQoKSxERD1CbigpLG1EPXlyKCksZEQ9a3QoKSxnRD1TcigpLHlEPV9uKCk7ZkQoe3RhcmdldDpcIkFycmF5XCIscHJvdG86ITB9LHtmbGF0OmZ1bmN0aW9uKCl7dmFyIHI9YXJndW1lbnRzLmxlbmd0aD9hcmd1bWVudHNbMF06dm9pZCAwLHQ9bUQodGhpcykscz1kRCh0KSxhPXlEKHQsMCk7cmV0dXJuIGEubGVuZ3RoPUREKGEsdCx0LHMsMCxyPT09dm9pZCAwPzE6Z0QocikpLGF9fSl9KTt2YXIgWmc9eGUoKEd5LGpvKT0+e3ZhciBoRD1bXCJjbGlOYW1lXCIsXCJjbGlDYXRlZ29yeVwiLFwiY2xpRGVzY3JpcHRpb25cIl0sdkQ9W1wiX1wiXSxDRD1bXCJsYW5ndWFnZUlkXCJdO2Z1bmN0aW9uIEhuKGUscil7aWYoZT09bnVsbClyZXR1cm57fTt2YXIgdD1FRChlLHIpLHMsYTtpZihPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKXt2YXIgbj1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2ZvcihhPTA7YTxuLmxlbmd0aDthKyspcz1uW2FdLCEoci5pbmRleE9mKHMpPj0wKSYmT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKGUscykmJih0W3NdPWVbc10pfXJldHVybiB0fWZ1bmN0aW9uIEVEKGUscil7aWYoZT09bnVsbClyZXR1cm57fTt2YXIgdD17fSxzPU9iamVjdC5rZXlzKGUpLGEsbjtmb3Iobj0wO248cy5sZW5ndGg7bisrKWE9c1tuXSwhKHIuaW5kZXhPZihhKT49MCkmJih0W2FdPWVbYV0pO3JldHVybiB0fVppKCk7eWEoKTt4YSgpO1RhKCk7QmEoKTt2YXIgRkQ9T2JqZWN0LmNyZWF0ZSxfcj1PYmplY3QuZGVmaW5lUHJvcGVydHksQUQ9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcixHbj1PYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyxTRD1PYmplY3QuZ2V0UHJvdG90eXBlT2YseEQ9T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSxodD0oZSxyKT0+ZnVuY3Rpb24oKXtyZXR1cm4gZSYmKHI9KDAsZVtHbihlKVswXV0pKGU9MCkpLHJ9LHRlPShlLHIpPT5mdW5jdGlvbigpe3JldHVybiByfHwoMCxlW0duKGUpWzBdXSkoKHI9e2V4cG9ydHM6e319KS5leHBvcnRzLHIpLHIuZXhwb3J0c30sS3Q9KGUscik9Pntmb3IodmFyIHQgaW4gcilfcihlLHQse2dldDpyW3RdLGVudW1lcmFibGU6ITB9KX0sUGE9KGUscix0LHMpPT57aWYociYmdHlwZW9mIHI9PVwib2JqZWN0XCJ8fHR5cGVvZiByPT1cImZ1bmN0aW9uXCIpZm9yKGxldCBhIG9mIEduKHIpKSF4RC5jYWxsKGUsYSkmJmEhPT10JiZfcihlLGEse2dldDooKT0+clthXSxlbnVtZXJhYmxlOiEocz1BRChyLGEpKXx8cy5lbnVtZXJhYmxlfSk7cmV0dXJuIGV9LGJEPShlLHIsdCk9Pih0PWUhPW51bGw/RkQoU0QoZSkpOnt9LFBhKHJ8fCFlfHwhZS5fX2VzTW9kdWxlP19yKHQsXCJkZWZhdWx0XCIse3ZhbHVlOmUsZW51bWVyYWJsZTohMH0pOnQsZSkpLGZ0PWU9PlBhKF9yKHt9LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUpLHd0LG5lPWh0KHtcIjxkZWZpbmU6cHJvY2Vzcz5cIigpe3d0PXtlbnY6e30sYXJndjpbXX19fSksSWE9dGUoe1wicGFja2FnZS5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e3ZlcnNpb246XCIyLjguM1wifX19KSxURD10ZSh7XCJub2RlX21vZHVsZXMvZGlmZi9saWIvZGlmZi9iYXNlLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmRlZmF1bHQ9cjtmdW5jdGlvbiByKCl7fXIucHJvdG90eXBlPXtkaWZmOmZ1bmN0aW9uKG4sdSl7dmFyIGk9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOnt9LGw9aS5jYWxsYmFjazt0eXBlb2YgaT09XCJmdW5jdGlvblwiJiYobD1pLGk9e30pLHRoaXMub3B0aW9ucz1pO3ZhciBwPXRoaXM7ZnVuY3Rpb24gZChTKXtyZXR1cm4gbD8oc2V0VGltZW91dChmdW5jdGlvbigpe2wodm9pZCAwLFMpfSwwKSwhMCk6U31uPXRoaXMuY2FzdElucHV0KG4pLHU9dGhpcy5jYXN0SW5wdXQodSksbj10aGlzLnJlbW92ZUVtcHR5KHRoaXMudG9rZW5pemUobikpLHU9dGhpcy5yZW1vdmVFbXB0eSh0aGlzLnRva2VuaXplKHUpKTt2YXIgeT11Lmxlbmd0aCxnPW4ubGVuZ3RoLGM9MSxEPXkrZyxFPVt7bmV3UG9zOi0xLGNvbXBvbmVudHM6W119XSxfPXRoaXMuZXh0cmFjdENvbW1vbihFWzBdLHUsbiwwKTtpZihFWzBdLm5ld1BvcysxPj15JiZfKzE+PWcpcmV0dXJuIGQoW3t2YWx1ZTp0aGlzLmpvaW4odSksY291bnQ6dS5sZW5ndGh9XSk7ZnVuY3Rpb24gdygpe2Zvcih2YXIgUz0tMSpjO1M8PWM7Uys9Mil7dmFyIE49dm9pZCAwLEk9RVtTLTFdLFA9RVtTKzFdLCQ9KFA/UC5uZXdQb3M6MCktUztJJiYoRVtTLTFdPXZvaWQgMCk7dmFyIGY9SSYmSS5uZXdQb3MrMTx5LFQ9UCYmMDw9JCYmJDxnO2lmKCFmJiYhVCl7RVtTXT12b2lkIDA7Y29udGludWV9aWYoIWZ8fFQmJkkubmV3UG9zPFAubmV3UG9zPyhOPXMoUCkscC5wdXNoQ29tcG9uZW50KE4uY29tcG9uZW50cyx2b2lkIDAsITApKTooTj1JLE4ubmV3UG9zKysscC5wdXNoQ29tcG9uZW50KE4uY29tcG9uZW50cywhMCx2b2lkIDApKSwkPXAuZXh0cmFjdENvbW1vbihOLHUsbixTKSxOLm5ld1BvcysxPj15JiYkKzE+PWcpcmV0dXJuIGQodChwLE4uY29tcG9uZW50cyx1LG4scC51c2VMb25nZXN0VG9rZW4pKTtFW1NdPU59YysrfWlmKGwpKGZ1bmN0aW9uIFMoKXtzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7aWYoYz5EKXJldHVybiBsKCk7dygpfHxTKCl9LDApfSkoKTtlbHNlIGZvcig7Yzw9RDspe3ZhciBGPXcoKTtpZihGKXJldHVybiBGfX0scHVzaENvbXBvbmVudDpmdW5jdGlvbihuLHUsaSl7dmFyIGw9bltuLmxlbmd0aC0xXTtsJiZsLmFkZGVkPT09dSYmbC5yZW1vdmVkPT09aT9uW24ubGVuZ3RoLTFdPXtjb3VudDpsLmNvdW50KzEsYWRkZWQ6dSxyZW1vdmVkOml9Om4ucHVzaCh7Y291bnQ6MSxhZGRlZDp1LHJlbW92ZWQ6aX0pfSxleHRyYWN0Q29tbW9uOmZ1bmN0aW9uKG4sdSxpLGwpe2Zvcih2YXIgcD11Lmxlbmd0aCxkPWkubGVuZ3RoLHk9bi5uZXdQb3MsZz15LWwsYz0wO3krMTxwJiZnKzE8ZCYmdGhpcy5lcXVhbHModVt5KzFdLGlbZysxXSk7KXkrKyxnKyssYysrO3JldHVybiBjJiZuLmNvbXBvbmVudHMucHVzaCh7Y291bnQ6Y30pLG4ubmV3UG9zPXksZ30sZXF1YWxzOmZ1bmN0aW9uKG4sdSl7cmV0dXJuIHRoaXMub3B0aW9ucy5jb21wYXJhdG9yP3RoaXMub3B0aW9ucy5jb21wYXJhdG9yKG4sdSk6bj09PXV8fHRoaXMub3B0aW9ucy5pZ25vcmVDYXNlJiZuLnRvTG93ZXJDYXNlKCk9PT11LnRvTG93ZXJDYXNlKCl9LHJlbW92ZUVtcHR5OmZ1bmN0aW9uKG4pe2Zvcih2YXIgdT1bXSxpPTA7aTxuLmxlbmd0aDtpKyspbltpXSYmdS5wdXNoKG5baV0pO3JldHVybiB1fSxjYXN0SW5wdXQ6ZnVuY3Rpb24obil7cmV0dXJuIG59LHRva2VuaXplOmZ1bmN0aW9uKG4pe3JldHVybiBuLnNwbGl0KFwiXCIpfSxqb2luOmZ1bmN0aW9uKG4pe3JldHVybiBuLmpvaW4oXCJcIil9fTtmdW5jdGlvbiB0KGEsbix1LGksbCl7Zm9yKHZhciBwPTAsZD1uLmxlbmd0aCx5PTAsZz0wO3A8ZDtwKyspe3ZhciBjPW5bcF07aWYoYy5yZW1vdmVkKXtpZihjLnZhbHVlPWEuam9pbihpLnNsaWNlKGcsZytjLmNvdW50KSksZys9Yy5jb3VudCxwJiZuW3AtMV0uYWRkZWQpe3ZhciBFPW5bcC0xXTtuW3AtMV09bltwXSxuW3BdPUV9fWVsc2V7aWYoIWMuYWRkZWQmJmwpe3ZhciBEPXUuc2xpY2UoeSx5K2MuY291bnQpO0Q9RC5tYXAoZnVuY3Rpb24odyxGKXt2YXIgUz1pW2crRl07cmV0dXJuIFMubGVuZ3RoPncubGVuZ3RoP1M6d30pLGMudmFsdWU9YS5qb2luKEQpfWVsc2UgYy52YWx1ZT1hLmpvaW4odS5zbGljZSh5LHkrYy5jb3VudCkpO3krPWMuY291bnQsYy5hZGRlZHx8KGcrPWMuY291bnQpfX12YXIgXz1uW2QtMV07cmV0dXJuIGQ+MSYmdHlwZW9mIF8udmFsdWU9PVwic3RyaW5nXCImJihfLmFkZGVkfHxfLnJlbW92ZWQpJiZhLmVxdWFscyhcIlwiLF8udmFsdWUpJiYobltkLTJdLnZhbHVlKz1fLnZhbHVlLG4ucG9wKCkpLG59ZnVuY3Rpb24gcyhhKXtyZXR1cm57bmV3UG9zOmEubmV3UG9zLGNvbXBvbmVudHM6YS5jb21wb25lbnRzLnNsaWNlKDApfX19fSksQkQ9dGUoe1wibm9kZV9tb2R1bGVzL2RpZmYvbGliL2RpZmYvYXJyYXkuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZGlmZkFycmF5cz1hLGUuYXJyYXlEaWZmPXZvaWQgMDt2YXIgcj10KFREKCkpO2Z1bmN0aW9uIHQobil7cmV0dXJuIG4mJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59fXZhciBzPW5ldyByLmRlZmF1bHQ7ZS5hcnJheURpZmY9cyxzLnRva2VuaXplPWZ1bmN0aW9uKG4pe3JldHVybiBuLnNsaWNlKCl9LHMuam9pbj1zLnJlbW92ZUVtcHR5PWZ1bmN0aW9uKG4pe3JldHVybiBufTtmdW5jdGlvbiBhKG4sdSxpKXtyZXR1cm4gcy5kaWZmKG4sdSxpKX19fSksVW49dGUoe1wic3JjL2RvY3VtZW50L2RvYy1idWlsZGVycy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KHYpe3JldHVybnt0eXBlOlwiY29uY2F0XCIscGFydHM6dn19ZnVuY3Rpb24gcyh2KXtyZXR1cm57dHlwZTpcImluZGVudFwiLGNvbnRlbnRzOnZ9fWZ1bmN0aW9uIGEodixvKXtyZXR1cm57dHlwZTpcImFsaWduXCIsY29udGVudHM6byxuOnZ9fWZ1bmN0aW9uIG4odil7bGV0IG89YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOnt9O3JldHVybnt0eXBlOlwiZ3JvdXBcIixpZDpvLmlkLGNvbnRlbnRzOnYsYnJlYWs6Qm9vbGVhbihvLnNob3VsZEJyZWFrKSxleHBhbmRlZFN0YXRlczpvLmV4cGFuZGVkU3RhdGVzfX1mdW5jdGlvbiB1KHYpe3JldHVybiBhKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSx2KX1mdW5jdGlvbiBpKHYpe3JldHVybiBhKHt0eXBlOlwicm9vdFwifSx2KX1mdW5jdGlvbiBsKHYpe3JldHVybiBhKC0xLHYpfWZ1bmN0aW9uIHAodixvKXtyZXR1cm4gbih2WzBdLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7fSx7ZXhwYW5kZWRTdGF0ZXM6dn0pKX1mdW5jdGlvbiBkKHYpe3JldHVybnt0eXBlOlwiZmlsbFwiLHBhcnRzOnZ9fWZ1bmN0aW9uIHkodixvKXtsZXQgaD1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06e307cmV0dXJue3R5cGU6XCJpZi1icmVha1wiLGJyZWFrQ29udGVudHM6dixmbGF0Q29udGVudHM6byxncm91cElkOmguZ3JvdXBJZH19ZnVuY3Rpb24gZyh2LG8pe3JldHVybnt0eXBlOlwiaW5kZW50LWlmLWJyZWFrXCIsY29udGVudHM6dixncm91cElkOm8uZ3JvdXBJZCxuZWdhdGU6by5uZWdhdGV9fWZ1bmN0aW9uIGModil7cmV0dXJue3R5cGU6XCJsaW5lLXN1ZmZpeFwiLGNvbnRlbnRzOnZ9fXZhciBEPXt0eXBlOlwibGluZS1zdWZmaXgtYm91bmRhcnlcIn0sRT17dHlwZTpcImJyZWFrLXBhcmVudFwifSxfPXt0eXBlOlwidHJpbVwifSx3PXt0eXBlOlwibGluZVwiLGhhcmQ6ITB9LEY9e3R5cGU6XCJsaW5lXCIsaGFyZDohMCxsaXRlcmFsOiEwfSxTPXt0eXBlOlwibGluZVwifSxOPXt0eXBlOlwibGluZVwiLHNvZnQ6ITB9LEk9dChbdyxFXSksUD10KFtGLEVdKSwkPXt0eXBlOlwiY3Vyc29yXCIscGxhY2Vob2xkZXI6U3ltYm9sKFwiY3Vyc29yXCIpfTtmdW5jdGlvbiBmKHYsbyl7bGV0IGg9W107Zm9yKGxldCBDPTA7QzxvLmxlbmd0aDtDKyspQyE9PTAmJmgucHVzaCh2KSxoLnB1c2gob1tDXSk7cmV0dXJuIHQoaCl9ZnVuY3Rpb24gVCh2LG8saCl7bGV0IEM9djtpZihvPjApe2ZvcihsZXQgeD0wO3g8TWF0aC5mbG9vcihvL2gpOysreClDPXMoQyk7Qz1hKG8laCxDKSxDPWEoTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZLEMpfXJldHVybiBDfWZ1bmN0aW9uIG0odixvKXtyZXR1cm57dHlwZTpcImxhYmVsXCIsbGFiZWw6dixjb250ZW50czpvfX1yLmV4cG9ydHM9e2NvbmNhdDp0LGpvaW46ZixsaW5lOlMsc29mdGxpbmU6TixoYXJkbGluZTpJLGxpdGVyYWxsaW5lOlAsZ3JvdXA6bixjb25kaXRpb25hbEdyb3VwOnAsZmlsbDpkLGxpbmVTdWZmaXg6YyxsaW5lU3VmZml4Qm91bmRhcnk6RCxjdXJzb3I6JCxicmVha1BhcmVudDpFLGlmQnJlYWs6eSx0cmltOl8saW5kZW50OnMsaW5kZW50SWZCcmVhazpnLGFsaWduOmEsYWRkQWxpZ25tZW50VG9Eb2M6VCxtYXJrQXNSb290OmksZGVkZW50VG9Sb290OnUsZGVkZW50OmwsaGFyZGxpbmVXaXRob3V0QnJlYWtQYXJlbnQ6dyxsaXRlcmFsbGluZVdpdGhvdXRCcmVha1BhcmVudDpGLGxhYmVsOm19fX0pLEpuPXRlKHtcInNyYy9jb21tb24vZW5kLW9mLWxpbmUuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7ZnVuY3Rpb24gdCh1KXtsZXQgaT11LmluZGV4T2YoXCJcXHJcIik7cmV0dXJuIGk+PTA/dS5jaGFyQXQoaSsxKT09PWBcbmA/XCJjcmxmXCI6XCJjclwiOlwibGZcIn1mdW5jdGlvbiBzKHUpe3N3aXRjaCh1KXtjYXNlXCJjclwiOnJldHVyblwiXFxyXCI7Y2FzZVwiY3JsZlwiOnJldHVybmBcXHJcbmA7ZGVmYXVsdDpyZXR1cm5gXG5gfX1mdW5jdGlvbiBhKHUsaSl7bGV0IGw7c3dpdGNoKGkpe2Nhc2VgXG5gOmw9L1xcbi9nO2JyZWFrO2Nhc2VcIlxcclwiOmw9L1xcci9nO2JyZWFrO2Nhc2VgXFxyXG5gOmw9L1xcclxcbi9nO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIFwiZW9sXCIgJHtKU09OLnN0cmluZ2lmeShpKX0uYCl9bGV0IHA9dS5tYXRjaChsKTtyZXR1cm4gcD9wLmxlbmd0aDowfWZ1bmN0aW9uIG4odSl7cmV0dXJuIHUucmVwbGFjZSgvXFxyXFxuPy9nLGBcbmApfXIuZXhwb3J0cz17Z3Vlc3NFbmRPZkxpbmU6dCxjb252ZXJ0RW5kT2ZMaW5lVG9DaGFyczpzLGNvdW50RW5kT2ZMaW5lQ2hhcnM6YSxub3JtYWxpemVFbmRPZkxpbmU6bn19fSksbHQ9dGUoe1wic3JjL3V0aWxzL2dldC1sYXN0LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PXM9PnNbcy5sZW5ndGgtMV07ci5leHBvcnRzPXR9fSk7ZnVuY3Rpb24gTkQoKXtsZXR7b25seUZpcnN0OmU9ITF9PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fSxyPVtcIltcXFxcdTAwMUJcXFxcdTAwOUJdW1tcXFxcXSgpIzs/XSooPzooPzooPzooPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10rKSp8W2EtekEtWlxcXFxkXSsoPzo7Wy1hLXpBLVpcXFxcZFxcXFwvIyYuOj0/JUB+X10qKSopP1xcXFx1MDAwNylcIixcIig/Oig/OlxcXFxkezEsNH0oPzo7XFxcXGR7MCw0fSkqKT9bXFxcXGRBLVBSLVRaY2YtbnRxcnk9Pjx+XSkpXCJdLmpvaW4oXCJ8XCIpO3JldHVybiBuZXcgUmVnRXhwKHIsZT92b2lkIDA6XCJnXCIpfXZhciB3RD1odCh7XCJub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9ub2RlX21vZHVsZXMvYW5zaS1yZWdleC9pbmRleC5qc1wiKCl7bmUoKX19KTtmdW5jdGlvbiBfRChlKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGBFeHBlY3RlZCBhIFxcYHN0cmluZ1xcYCwgZ290IFxcYCR7dHlwZW9mIGV9XFxgYCk7cmV0dXJuIGUucmVwbGFjZShORCgpLFwiXCIpfXZhciBQRD1odCh7XCJub2RlX21vZHVsZXMvc3RyaXAtYW5zaS9pbmRleC5qc1wiKCl7bmUoKSx3RCgpfX0pO2Z1bmN0aW9uIElEKGUpe3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGUpP2U+PTQzNTImJihlPD00NDQ3fHxlPT09OTAwMXx8ZT09PTkwMDJ8fDExOTA0PD1lJiZlPD0xMjg3MSYmZSE9PTEyMzUxfHwxMjg4MDw9ZSYmZTw9MTk5MDN8fDE5OTY4PD1lJiZlPD00MjE4Mnx8NDMzNjA8PWUmJmU8PTQzMzg4fHw0NDAzMjw9ZSYmZTw9NTUyMDN8fDYzNzQ0PD1lJiZlPD02NDI1NXx8NjUwNDA8PWUmJmU8PTY1MDQ5fHw2NTA3Mjw9ZSYmZTw9NjUxMzF8fDY1MjgxPD1lJiZlPD02NTM3Nnx8NjU1MDQ8PWUmJmU8PTY1NTEwfHwxMTA1OTI8PWUmJmU8PTExMDU5M3x8MTI3NDg4PD1lJiZlPD0xMjc1Njl8fDEzMTA3Mjw9ZSYmZTw9MjYyMTQxKTohMX12YXIga0Q9aHQoe1wibm9kZV9tb2R1bGVzL2lzLWZ1bGx3aWR0aC1jb2RlLXBvaW50L2luZGV4LmpzXCIoKXtuZSgpfX0pLExEPXRlKHtcIm5vZGVfbW9kdWxlcy9lbW9qaS1yZWdleC9pbmRleC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxyLmV4cG9ydHM9ZnVuY3Rpb24oKXtyZXR1cm4vXFx1RDgzQ1xcdURGRjRcXHVEQjQwXFx1REM2N1xcdURCNDBcXHVEQzYyKD86XFx1REI0MFxcdURDNzdcXHVEQjQwXFx1REM2Q1xcdURCNDBcXHVEQzczfFxcdURCNDBcXHVEQzczXFx1REI0MFxcdURDNjNcXHVEQjQwXFx1REM3NHxcXHVEQjQwXFx1REM2NVxcdURCNDBcXHVEQzZFXFx1REI0MFxcdURDNjcpXFx1REI0MFxcdURDN0Z8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGRlxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkZcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZFXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGRVxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkVcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZEXFx1REZGRl0pfCg/OlxcdUQ4M0VcXHVEREQxXFx1RDgzQ1xcdURGRkRcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKT9cXHVEODNFXFx1REREMXxcXHVEODNEXFx1REM2OVxcdUQ4M0NcXHVERkZEXFx1MjAwRFxcdUQ4M0VcXHVERDFEXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKSkoPzpcXHVEODNDW1xcdURGRkJcXHVERkZDXFx1REZGRVxcdURGRkZdKXwoPzpcXHVEODNFXFx1REREMVxcdUQ4M0NcXHVERkZDXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCk/XFx1RDgzRVxcdURERDF8XFx1RDgzRFxcdURDNjlcXHVEODNDXFx1REZGQ1xcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMEQoPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpKD86XFx1RDgzQ1tcXHVERkZCXFx1REZGRC1cXHVERkZGXSl8KD86XFx1RDgzRVxcdURERDFcXHVEODNDXFx1REZGQlxcdTIwMERcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0VcXHVEREQxfFxcdUQ4M0RcXHVEQzY5XFx1RDgzQ1xcdURGRkJcXHUyMDBEXFx1RDgzRVxcdUREMURcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pKSg/OlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjgoPzpcXHVEODNDXFx1REZGQig/OlxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pKXxcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQy1cXHVERkZGXSl8W1xcdTI2OTVcXHUyNjk2XFx1MjcwOF1cXHVGRTBGfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSkpP3woPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKXxcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSkpfFxcdTIwMEQoPzpcXHUyNzY0XFx1RkUwRlxcdTIwMEQoPzpcXHVEODNEXFx1REM4QlxcdTIwMEQpP1xcdUQ4M0RcXHVEQzY4fCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKVxcdTIwMEQoPzpcXHVEODNEXFx1REM2NlxcdTIwMERcXHVEODNEXFx1REM2NnxcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSkpfFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkVdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZFXFx1MjAwRCg/OlxcdUQ4M0VcXHVERDFEXFx1MjAwRFxcdUQ4M0RcXHVEQzY4KD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkRcXHVERkZGXSl8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNEXFx1REM2OCg/OlxcdUQ4M0NbXFx1REZGQlxcdURGRkNcXHVERkZFXFx1REZGRl0pfFxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRFxcdURDNjgoPzpcXHVEODNDW1xcdURGRkJcXHVERkZELVxcdURGRkZdKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfCg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZFXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZEXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZDXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSlcXHVGRTBGfFxcdTIwMEQoPzooPzpcXHVEODNEW1xcdURDNjhcXHVEQzY5XSlcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY2XFx1REM2N10pfFxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNDXFx1REZGRnxcXHVEODNDXFx1REZGRXxcXHVEODNDXFx1REZGRHxcXHVEODNDXFx1REZGQyk/fCg/OlxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkJcXHUyMDBEXFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXwoPzpcXHVEODNDW1xcdURGRkMtXFx1REZGRl0pXFx1MjAwRFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzhCXFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNEW1xcdURDNjhcXHVEQzY5XSkpfFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1tcXHVERkZCLVxcdURGRkZdKVxcdTIwMERcXHVEODNFXFx1REQxRFxcdTIwMERcXHVEODNFXFx1REREMSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY3XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKSl8XFx1RDgzRFxcdURDNjkoPzpcXHUyMDBEKD86XFx1Mjc2NFxcdUZFMEZcXHUyMDBEKD86XFx1RDgzRFxcdURDOEJcXHUyMDBEKD86XFx1RDgzRFtcXHVEQzY4XFx1REM2OV0pfFxcdUQ4M0RbXFx1REM2OFxcdURDNjldKXxcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZGXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKXxcXHVEODNDXFx1REZGRFxcdTIwMEQoPzpcXHVEODNDW1xcdURGM0VcXHVERjczXFx1REY3Q1xcdURGOTNcXHVERkE0XFx1REZBOFxcdURGRUJcXHVERkVEXXxcXHVEODNEW1xcdURDQkJcXHVEQ0JDXFx1REQyN1xcdUREMkNcXHVERTgwXFx1REU5Ml18XFx1RDgzRVtcXHVEREFGLVxcdUREQjNcXHVEREJDXFx1RERCRF0pfFxcdUQ4M0NcXHVERkZDXFx1MjAwRCg/OlxcdUQ4M0NbXFx1REYzRVxcdURGNzNcXHVERjdDXFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkJcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjkzXFx1REZBNFxcdURGQThcXHVERkVCXFx1REZFRF18XFx1RDgzRFtcXHVEQ0JCXFx1RENCQ1xcdUREMjdcXHVERDJDXFx1REU4MFxcdURFOTJdfFxcdUQ4M0VbXFx1RERBRi1cXHVEREIzXFx1RERCQ1xcdUREQkRdKSl8XFx1RDgzRVxcdURERDEoPzpcXHUyMDBEKD86XFx1RDgzRVxcdUREMURcXHUyMDBEXFx1RDgzRVxcdURERDF8XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkZcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkVcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkRcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkNcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSl8XFx1RDgzQ1xcdURGRkJcXHUyMDBEKD86XFx1RDgzQ1tcXHVERjNFXFx1REY3M1xcdURGN0NcXHVERjg0XFx1REY5M1xcdURGQTRcXHVERkE4XFx1REZFQlxcdURGRURdfFxcdUQ4M0RbXFx1RENCQlxcdURDQkNcXHVERDI3XFx1REQyQ1xcdURFODBcXHVERTkyXXxcXHVEODNFW1xcdUREQUYtXFx1RERCM1xcdUREQkNcXHVEREJEXSkpfFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY2XFx1MjAwRFxcdUQ4M0RcXHVEQzY2fFxcdUQ4M0RcXHVEQzY5XFx1MjAwRFxcdUQ4M0RcXHVEQzY5XFx1MjAwRCg/OlxcdUQ4M0RbXFx1REM2NlxcdURDNjddKXxcXHVEODNEXFx1REM2OVxcdTIwMERcXHVEODNEXFx1REM2N1xcdTIwMEQoPzpcXHVEODNEW1xcdURDNjZcXHVEQzY3XSl8KD86XFx1RDgzRFxcdURDNDFcXHVGRTBGXFx1MjAwRFxcdUQ4M0RcXHVEREU4fFxcdUQ4M0VcXHVEREQxKD86XFx1RDgzQ1xcdURGRkZcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkVcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkRcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkNcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1RDgzQ1xcdURGRkJcXHUyMDBEW1xcdTI2OTVcXHUyNjk2XFx1MjcwOF18XFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdKXxcXHVEODNEXFx1REM2OSg/OlxcdUQ4M0NcXHVERkZGXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZFXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZEXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZDXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdUQ4M0NcXHVERkZCXFx1MjAwRFtcXHUyNjk1XFx1MjY5NlxcdTI3MDhdfFxcdTIwMERbXFx1MjY5NVxcdTI2OTZcXHUyNzA4XSl8XFx1RDgzRFxcdURFMzZcXHUyMDBEXFx1RDgzQ1xcdURGMkJ8XFx1RDgzQ1xcdURGRjNcXHVGRTBGXFx1MjAwRFxcdTI2QTd8XFx1RDgzRFxcdURDM0JcXHUyMDBEXFx1Mjc0NHwoPzooPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MFxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8XFx1RDgzRFxcdURDNkZ8XFx1RDgzRVtcXHVERDNDXFx1RERERVxcdUREREZdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pXFx1MjAwRFtcXHUyNjQwXFx1MjY0Ml18XFx1RDgzQ1xcdURGRjRcXHUyMDBEXFx1MjYyMHwoPzpcXHVEODNDW1xcdURGQzNcXHVERkM0XFx1REZDQV18XFx1RDgzRFtcXHVEQzZFXFx1REM3MFxcdURDNzFcXHVEQzczXFx1REM3N1xcdURDODFcXHVEQzgyXFx1REM4NlxcdURDODdcXHVERTQ1LVxcdURFNDdcXHVERTRCXFx1REU0RFxcdURFNEVcXHVERUEzXFx1REVCNC1cXHVERUI2XXxcXHVEODNFW1xcdUREMjZcXHVERDM1XFx1REQzNy1cXHVERDM5XFx1REQzRFxcdUREM0VcXHVEREI4XFx1RERCOVxcdUREQ0QtXFx1RERDRlxcdURERDRcXHVEREQ2LVxcdURERERdKVxcdTIwMERbXFx1MjY0MFxcdTI2NDJdfFtcXHhBOVxceEFFXFx1MjAzQ1xcdTIwNDlcXHUyMTIyXFx1MjEzOVxcdTIxOTQtXFx1MjE5OVxcdTIxQTlcXHUyMUFBXFx1MjMyOFxcdTIzQ0ZcXHUyM0VELVxcdTIzRUZcXHUyM0YxXFx1MjNGMlxcdTIzRjgtXFx1MjNGQVxcdTI0QzJcXHUyNUFBXFx1MjVBQlxcdTI1QjZcXHUyNUMwXFx1MjVGQlxcdTI1RkNcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MThcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2OTJcXHUyNjk0LVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBN1xcdTI2QjBcXHUyNkIxXFx1MjZDOFxcdTI2Q0ZcXHUyNkQxXFx1MjZEM1xcdTI2RTlcXHUyNkYwXFx1MjZGMVxcdTI2RjRcXHUyNkY3XFx1MjZGOFxcdTI3MDJcXHUyNzA4XFx1MjcwOVxcdTI3MEZcXHUyNzEyXFx1MjcxNFxcdTI3MTZcXHUyNzFEXFx1MjcyMVxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzYzXFx1MjdBMVxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MzAzMFxcdTMwM0RcXHUzMjk3XFx1MzI5OV18XFx1RDgzQ1tcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REUwMlxcdURFMzdcXHVERjIxXFx1REYyNC1cXHVERjJDXFx1REYzNlxcdURGN0RcXHVERjk2XFx1REY5N1xcdURGOTktXFx1REY5QlxcdURGOUVcXHVERjlGXFx1REZDRFxcdURGQ0VcXHVERkQ0LVxcdURGREZcXHVERkY1XFx1REZGN118XFx1RDgzRFtcXHVEQzNGXFx1RENGRFxcdURENDlcXHVERDRBXFx1REQ2RlxcdURENzBcXHVERDczXFx1REQ3Ni1cXHVERDc5XFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREQTVcXHVEREE4XFx1RERCMVxcdUREQjJcXHVEREJDXFx1RERDMi1cXHVEREM0XFx1REREMS1cXHVEREQzXFx1REREQy1cXHVERERFXFx1RERFMVxcdURERTNcXHVEREU4XFx1RERFRlxcdURERjNcXHVEREZBXFx1REVDQlxcdURFQ0QtXFx1REVDRlxcdURFRTAtXFx1REVFNVxcdURFRTlcXHVERUYwXFx1REVGM10pXFx1RkUwRnxcXHVEODNDXFx1REZGM1xcdUZFMEZcXHUyMDBEXFx1RDgzQ1xcdURGMDh8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjd8XFx1RDgzRFxcdURDNjlcXHUyMDBEXFx1RDgzRFxcdURDNjZ8XFx1RDgzRFxcdURFMzVcXHUyMDBEXFx1RDgzRFxcdURDQUJ8XFx1RDgzRFxcdURFMkVcXHUyMDBEXFx1RDgzRFxcdURDQTh8XFx1RDgzRFxcdURDMTVcXHUyMDBEXFx1RDgzRVxcdUREQkF8XFx1RDgzRVxcdURERDEoPzpcXHVEODNDXFx1REZGRnxcXHVEODNDXFx1REZGRXxcXHVEODNDXFx1REZGRHxcXHVEODNDXFx1REZGQ3xcXHVEODNDXFx1REZGQik/fFxcdUQ4M0RcXHVEQzY5KD86XFx1RDgzQ1xcdURGRkZ8XFx1RDgzQ1xcdURGRkV8XFx1RDgzQ1xcdURGRkR8XFx1RDgzQ1xcdURGRkN8XFx1RDgzQ1xcdURGRkIpP3xcXHVEODNDXFx1RERGRFxcdUQ4M0NcXHVEREYwfFxcdUQ4M0NcXHVEREY2XFx1RDgzQ1xcdURERTZ8XFx1RDgzQ1xcdURERjRcXHVEODNDXFx1RERGMnxcXHVEODNEXFx1REMwOFxcdTIwMERcXHUyQjFCfFxcdTI3NjRcXHVGRTBGXFx1MjAwRCg/OlxcdUQ4M0RcXHVERDI1fFxcdUQ4M0VcXHVERTc5KXxcXHVEODNEXFx1REM0MVxcdUZFMEZ8XFx1RDgzQ1xcdURGRjNcXHVGRTBGfFxcdUQ4M0NcXHVEREZGKD86XFx1RDgzQ1tcXHVEREU2XFx1RERGMlxcdURERkNdKXxcXHVEODNDXFx1RERGRSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjldKXxcXHVEODNDXFx1RERGQyg/OlxcdUQ4M0NbXFx1RERFQlxcdURERjhdKXxcXHVEODNDXFx1RERGQig/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERUVcXHVEREYzXFx1RERGQV0pfFxcdUQ4M0NcXHVEREZBKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFQ1xcdURERjJcXHVEREYzXFx1RERGOFxcdURERkVcXHVEREZGXSl8XFx1RDgzQ1xcdURERjkoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFOVxcdURERUItXFx1RERFRFxcdURERUYtXFx1RERGNFxcdURERjdcXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZGXSl8XFx1RDgzQ1xcdURERjgoPzpcXHVEODNDW1xcdURERTYtXFx1RERFQVxcdURERUMtXFx1RERGNFxcdURERjctXFx1RERGOVxcdURERkJcXHVEREZELVxcdURERkZdKXxcXHVEODNDXFx1RERGNyg/OlxcdUQ4M0NbXFx1RERFQVxcdURERjRcXHVEREY4XFx1RERGQVxcdURERkNdKXxcXHVEODNDXFx1RERGNSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERUEtXFx1RERFRFxcdURERjAtXFx1RERGM1xcdURERjctXFx1RERGOVxcdURERkNcXHVEREZFXSl8XFx1RDgzQ1xcdURERjMoPzpcXHVEODNDW1xcdURERTZcXHVEREU4XFx1RERFQS1cXHVEREVDXFx1RERFRVxcdURERjFcXHVEREY0XFx1RERGNVxcdURERjdcXHVEREZBXFx1RERGRl0pfFxcdUQ4M0NcXHVEREYyKD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOC1cXHVEREVEXFx1RERGMC1cXHVEREZGXSl8XFx1RDgzQ1xcdURERjEoPzpcXHVEODNDW1xcdURERTYtXFx1RERFOFxcdURERUVcXHVEREYwXFx1RERGNy1cXHVEREZCXFx1RERGRV0pfFxcdUQ4M0NcXHVEREYwKD86XFx1RDgzQ1tcXHVEREVBXFx1RERFQy1cXHVEREVFXFx1RERGMlxcdURERjNcXHVEREY1XFx1RERGN1xcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREVGKD86XFx1RDgzQ1tcXHVEREVBXFx1RERGMlxcdURERjRcXHVEREY1XSl8XFx1RDgzQ1xcdURERUUoPzpcXHVEODNDW1xcdURERTgtXFx1RERFQVxcdURERjEtXFx1RERGNFxcdURERjYtXFx1RERGOV0pfFxcdUQ4M0NcXHVEREVEKD86XFx1RDgzQ1tcXHVEREYwXFx1RERGMlxcdURERjNcXHVEREY3XFx1RERGOVxcdURERkFdKXxcXHVEODNDXFx1RERFQyg/OlxcdUQ4M0NbXFx1RERFNlxcdURERTdcXHVEREU5LVxcdURERUVcXHVEREYxLVxcdURERjNcXHVEREY1LVxcdURERkFcXHVEREZDXFx1RERGRV0pfFxcdUQ4M0NcXHVEREVCKD86XFx1RDgzQ1tcXHVEREVFLVxcdURERjBcXHVEREYyXFx1RERGNFxcdURERjddKXxcXHVEODNDXFx1RERFQSg/OlxcdUQ4M0NbXFx1RERFNlxcdURERThcXHVEREVBXFx1RERFQ1xcdURERURcXHVEREY3LVxcdURERkFdKXxcXHVEODNDXFx1RERFOSg/OlxcdUQ4M0NbXFx1RERFQVxcdURERUNcXHVEREVGXFx1RERGMFxcdURERjJcXHVEREY0XFx1RERGRl0pfFxcdUQ4M0NcXHVEREU4KD86XFx1RDgzQ1tcXHVEREU2XFx1RERFOFxcdURERTlcXHVEREVCLVxcdURERUVcXHVEREYwLVxcdURERjVcXHVEREY3XFx1RERGQS1cXHVEREZGXSl8XFx1RDgzQ1xcdURERTcoPzpcXHVEODNDW1xcdURERTZcXHVEREU3XFx1RERFOS1cXHVEREVGXFx1RERGMS1cXHVEREY0XFx1RERGNi1cXHVEREY5XFx1RERGQlxcdURERkNcXHVEREZFXFx1RERGRl0pfFxcdUQ4M0NcXHVEREU2KD86XFx1RDgzQ1tcXHVEREU4LVxcdURERUNcXHVEREVFXFx1RERGMVxcdURERjJcXHVEREY0XFx1RERGNi1cXHVEREZBXFx1RERGQ1xcdURERkRcXHVEREZGXSl8WyNcXCowLTldXFx1RkUwRlxcdTIwRTN8XFx1Mjc2NFxcdUZFMEZ8KD86XFx1RDgzQ1tcXHVERkMzXFx1REZDNFxcdURGQ0FdfFxcdUQ4M0RbXFx1REM2RVxcdURDNzBcXHVEQzcxXFx1REM3M1xcdURDNzdcXHVEQzgxXFx1REM4MlxcdURDODZcXHVEQzg3XFx1REU0NS1cXHVERTQ3XFx1REU0QlxcdURFNERcXHVERTRFXFx1REVBM1xcdURFQjQtXFx1REVCNl18XFx1RDgzRVtcXHVERDI2XFx1REQzNVxcdUREMzctXFx1REQzOVxcdUREM0RcXHVERDNFXFx1RERCOFxcdUREQjlcXHVERENELVxcdUREQ0ZcXHVEREQ0XFx1RERENi1cXHVEREREXSkoPzpcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfCg/OlxcdTI2Rjl8XFx1RDgzQ1tcXHVERkNCXFx1REZDQ118XFx1RDgzRFxcdURENzUpKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFxcdUQ4M0NcXHVERkY0fCg/OltcXHUyNzBBXFx1MjcwQl18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3QVxcdUREOTVcXHVERDk2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBDXFx1REQwRlxcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM0XFx1REQzNlxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyXFx1REREM1xcdURERDVdKSg/OlxcdUQ4M0NbXFx1REZGQi1cXHVERkZGXSl8KD86W1xcdTI2MURcXHUyNzBDXFx1MjcwRF18XFx1RDgzRFtcXHVERDc0XFx1REQ5MF0pKD86XFx1RkUwRnxcXHVEODNDW1xcdURGRkItXFx1REZGRl0pfFtcXHUyNzBBXFx1MjcwQl18XFx1RDgzQ1tcXHVERjg1XFx1REZDMlxcdURGQzddfFxcdUQ4M0RbXFx1REMwOFxcdURDMTVcXHVEQzNCXFx1REM0MlxcdURDNDNcXHVEQzQ2LVxcdURDNTBcXHVEQzY2XFx1REM2N1xcdURDNkItXFx1REM2RFxcdURDNzJcXHVEQzc0LVxcdURDNzZcXHVEQzc4XFx1REM3Q1xcdURDODNcXHVEQzg1XFx1REM4RlxcdURDOTFcXHVEQ0FBXFx1REQ3QVxcdUREOTVcXHVERDk2XFx1REUyRVxcdURFMzVcXHVERTM2XFx1REU0Q1xcdURFNEZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBDXFx1REQwRlxcdUREMTgtXFx1REQxQ1xcdUREMUVcXHVERDFGXFx1REQzMC1cXHVERDM0XFx1REQzNlxcdURENzdcXHVEREI1XFx1RERCNlxcdUREQkJcXHVEREQyXFx1REREM1xcdURERDVdfFxcdUQ4M0NbXFx1REZDM1xcdURGQzRcXHVERkNBXXxcXHVEODNEW1xcdURDNkVcXHVEQzcwXFx1REM3MVxcdURDNzNcXHVEQzc3XFx1REM4MVxcdURDODJcXHVEQzg2XFx1REM4N1xcdURFNDUtXFx1REU0N1xcdURFNEJcXHVERTREXFx1REU0RVxcdURFQTNcXHVERUI0LVxcdURFQjZdfFxcdUQ4M0VbXFx1REQyNlxcdUREMzVcXHVERDM3LVxcdUREMzlcXHVERDNEXFx1REQzRVxcdUREQjhcXHVEREI5XFx1RERDRC1cXHVERENGXFx1RERENFxcdURERDYtXFx1RERERF18XFx1RDgzRFxcdURDNkZ8XFx1RDgzRVtcXHVERDNDXFx1RERERVxcdUREREZdfFtcXHUyMzFBXFx1MjMxQlxcdTIzRTktXFx1MjNFQ1xcdTIzRjBcXHUyM0YzXFx1MjVGRFxcdTI1RkVcXHUyNjE0XFx1MjYxNVxcdTI2NDgtXFx1MjY1M1xcdTI2N0ZcXHUyNjkzXFx1MjZBMVxcdTI2QUFcXHUyNkFCXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2Q0VcXHUyNkQ0XFx1MjZFQVxcdTI2RjJcXHUyNkYzXFx1MjZGNVxcdTI2RkFcXHUyNkZEXFx1MjcwNVxcdTI3MjhcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzk1LVxcdTI3OTdcXHUyN0IwXFx1MjdCRlxcdTJCMUJcXHUyQjFDXFx1MkI1MFxcdTJCNTVdfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDhFXFx1REQ5MS1cXHVERDlBXFx1REUwMVxcdURFMUFcXHVERTJGXFx1REUzMi1cXHVERTM2XFx1REUzOC1cXHVERTNBXFx1REU1MFxcdURFNTFcXHVERjAwLVxcdURGMjBcXHVERjJELVxcdURGMzVcXHVERjM3LVxcdURGN0NcXHVERjdFLVxcdURGODRcXHVERjg2LVxcdURGOTNcXHVERkEwLVxcdURGQzFcXHVERkM1XFx1REZDNlxcdURGQzhcXHVERkM5XFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGOC1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1REMwN1xcdURDMDktXFx1REMxNFxcdURDMTYtXFx1REMzQVxcdURDM0MtXFx1REMzRVxcdURDNDBcXHVEQzQ0XFx1REM0NVxcdURDNTEtXFx1REM2NVxcdURDNkFcXHVEQzc5LVxcdURDN0JcXHVEQzdELVxcdURDODBcXHVEQzg0XFx1REM4OC1cXHVEQzhFXFx1REM5MFxcdURDOTItXFx1RENBOVxcdURDQUItXFx1RENGQ1xcdURDRkYtXFx1REQzRFxcdURENEItXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdUREQTRcXHVEREZCLVxcdURFMkRcXHVERTJGLVxcdURFMzRcXHVERTM3LVxcdURFNDRcXHVERTQ4LVxcdURFNEFcXHVERTgwLVxcdURFQTJcXHVERUE0LVxcdURFQjNcXHVERUI3LVxcdURFQkZcXHVERUMxLVxcdURFQzVcXHVERUQwLVxcdURFRDJcXHVERUQ1LVxcdURFRDdcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGQ1xcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBEXFx1REQwRVxcdUREMTAtXFx1REQxN1xcdUREMURcXHVERDIwLVxcdUREMjVcXHVERDI3LVxcdUREMkZcXHVERDNBXFx1REQzRi1cXHVERDQ1XFx1REQ0Ny1cXHVERDc2XFx1REQ3OFxcdUREN0EtXFx1RERCNFxcdUREQjdcXHVEREJBXFx1RERCQy1cXHVERENCXFx1REREMFxcdURERTAtXFx1RERGRlxcdURFNzAtXFx1REU3NFxcdURFNzgtXFx1REU3QVxcdURFODAtXFx1REU4NlxcdURFOTAtXFx1REVBOFxcdURFQjAtXFx1REVCNlxcdURFQzAtXFx1REVDMlxcdURFRDAtXFx1REVENl18KD86W1xcdTIzMUFcXHUyMzFCXFx1MjNFOS1cXHUyM0VDXFx1MjNGMFxcdTIzRjNcXHUyNUZEXFx1MjVGRVxcdTI2MTRcXHUyNjE1XFx1MjY0OC1cXHUyNjUzXFx1MjY3RlxcdTI2OTNcXHUyNkExXFx1MjZBQVxcdTI2QUJcXHUyNkJEXFx1MjZCRVxcdTI2QzRcXHUyNkM1XFx1MjZDRVxcdTI2RDRcXHUyNkVBXFx1MjZGMlxcdTI2RjNcXHUyNkY1XFx1MjZGQVxcdTI2RkRcXHUyNzA1XFx1MjcwQVxcdTI3MEJcXHUyNzI4XFx1Mjc0Q1xcdTI3NEVcXHUyNzUzLVxcdTI3NTVcXHUyNzU3XFx1Mjc5NS1cXHUyNzk3XFx1MjdCMFxcdTI3QkZcXHUyQjFCXFx1MkIxQ1xcdTJCNTBcXHUyQjU1XXxcXHVEODNDW1xcdURDMDRcXHVEQ0NGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTFBXFx1REUyRlxcdURFMzItXFx1REUzNlxcdURFMzgtXFx1REUzQVxcdURFNTBcXHVERTUxXFx1REYwMC1cXHVERjIwXFx1REYyRC1cXHVERjM1XFx1REYzNy1cXHVERjdDXFx1REY3RS1cXHVERjkzXFx1REZBMC1cXHVERkNBXFx1REZDRi1cXHVERkQzXFx1REZFMC1cXHVERkYwXFx1REZGNFxcdURGRjgtXFx1REZGRl18XFx1RDgzRFtcXHVEQzAwLVxcdURDM0VcXHVEQzQwXFx1REM0Mi1cXHVEQ0ZDXFx1RENGRi1cXHVERDNEXFx1REQ0Qi1cXHVERDRFXFx1REQ1MC1cXHVERDY3XFx1REQ3QVxcdUREOTVcXHVERDk2XFx1RERBNFxcdURERkItXFx1REU0RlxcdURFODAtXFx1REVDNVxcdURFQ0NcXHVERUQwLVxcdURFRDJcXHVERUQ1LVxcdURFRDdcXHVERUVCXFx1REVFQ1xcdURFRjQtXFx1REVGQ1xcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURENzhcXHVERDdBLVxcdUREQ0JcXHVERENELVxcdURERkZcXHVERTcwLVxcdURFNzRcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODZcXHVERTkwLVxcdURFQThcXHVERUIwLVxcdURFQjZcXHVERUMwLVxcdURFQzJcXHVERUQwLVxcdURFRDZdKXwoPzpbI1xcKjAtOVxceEE5XFx4QUVcXHUyMDNDXFx1MjA0OVxcdTIxMjJcXHUyMTM5XFx1MjE5NC1cXHUyMTk5XFx1MjFBOVxcdTIxQUFcXHUyMzFBXFx1MjMxQlxcdTIzMjhcXHUyM0NGXFx1MjNFOS1cXHUyM0YzXFx1MjNGOC1cXHUyM0ZBXFx1MjRDMlxcdTI1QUFcXHUyNUFCXFx1MjVCNlxcdTI1QzBcXHUyNUZCLVxcdTI1RkVcXHUyNjAwLVxcdTI2MDRcXHUyNjBFXFx1MjYxMVxcdTI2MTRcXHUyNjE1XFx1MjYxOFxcdTI2MURcXHUyNjIwXFx1MjYyMlxcdTI2MjNcXHUyNjI2XFx1MjYyQVxcdTI2MkVcXHUyNjJGXFx1MjYzOC1cXHUyNjNBXFx1MjY0MFxcdTI2NDJcXHUyNjQ4LVxcdTI2NTNcXHUyNjVGXFx1MjY2MFxcdTI2NjNcXHUyNjY1XFx1MjY2NlxcdTI2NjhcXHUyNjdCXFx1MjY3RVxcdTI2N0ZcXHUyNjkyLVxcdTI2OTdcXHUyNjk5XFx1MjY5QlxcdTI2OUNcXHUyNkEwXFx1MjZBMVxcdTI2QTdcXHUyNkFBXFx1MjZBQlxcdTI2QjBcXHUyNkIxXFx1MjZCRFxcdTI2QkVcXHUyNkM0XFx1MjZDNVxcdTI2QzhcXHUyNkNFXFx1MjZDRlxcdTI2RDFcXHUyNkQzXFx1MjZENFxcdTI2RTlcXHUyNkVBXFx1MjZGMC1cXHUyNkY1XFx1MjZGNy1cXHUyNkZBXFx1MjZGRFxcdTI3MDJcXHUyNzA1XFx1MjcwOC1cXHUyNzBEXFx1MjcwRlxcdTI3MTJcXHUyNzE0XFx1MjcxNlxcdTI3MURcXHUyNzIxXFx1MjcyOFxcdTI3MzNcXHUyNzM0XFx1Mjc0NFxcdTI3NDdcXHUyNzRDXFx1Mjc0RVxcdTI3NTMtXFx1Mjc1NVxcdTI3NTdcXHUyNzYzXFx1Mjc2NFxcdTI3OTUtXFx1Mjc5N1xcdTI3QTFcXHUyN0IwXFx1MjdCRlxcdTI5MzRcXHUyOTM1XFx1MkIwNS1cXHUyQjA3XFx1MkIxQlxcdTJCMUNcXHUyQjUwXFx1MkI1NVxcdTMwMzBcXHUzMDNEXFx1MzI5N1xcdTMyOTldfFxcdUQ4M0NbXFx1REMwNFxcdURDQ0ZcXHVERDcwXFx1REQ3MVxcdUREN0VcXHVERDdGXFx1REQ4RVxcdUREOTEtXFx1REQ5QVxcdURERTYtXFx1RERGRlxcdURFMDFcXHVERTAyXFx1REUxQVxcdURFMkZcXHVERTMyLVxcdURFM0FcXHVERTUwXFx1REU1MVxcdURGMDAtXFx1REYyMVxcdURGMjQtXFx1REY5M1xcdURGOTZcXHVERjk3XFx1REY5OS1cXHVERjlCXFx1REY5RS1cXHVERkYwXFx1REZGMy1cXHVERkY1XFx1REZGNy1cXHVERkZGXXxcXHVEODNEW1xcdURDMDAtXFx1RENGRFxcdURDRkYtXFx1REQzRFxcdURENDktXFx1REQ0RVxcdURENTAtXFx1REQ2N1xcdURENkZcXHVERDcwXFx1REQ3My1cXHVERDdBXFx1REQ4N1xcdUREOEEtXFx1REQ4RFxcdUREOTBcXHVERDk1XFx1REQ5NlxcdUREQTRcXHVEREE1XFx1RERBOFxcdUREQjFcXHVEREIyXFx1RERCQ1xcdUREQzItXFx1RERDNFxcdURERDEtXFx1REREM1xcdUREREMtXFx1RERERVxcdURERTFcXHVEREUzXFx1RERFOFxcdURERUZcXHVEREYzXFx1RERGQS1cXHVERTRGXFx1REU4MC1cXHVERUM1XFx1REVDQi1cXHVERUQyXFx1REVENS1cXHVERUQ3XFx1REVFMC1cXHVERUU1XFx1REVFOVxcdURFRUJcXHVERUVDXFx1REVGMFxcdURFRjMtXFx1REVGQ1xcdURGRTAtXFx1REZFQl18XFx1RDgzRVtcXHVERDBDLVxcdUREM0FcXHVERDNDLVxcdURENDVcXHVERDQ3LVxcdURENzhcXHVERDdBLVxcdUREQ0JcXHVERENELVxcdURERkZcXHVERTcwLVxcdURFNzRcXHVERTc4LVxcdURFN0FcXHVERTgwLVxcdURFODZcXHVERTkwLVxcdURFQThcXHVERUIwLVxcdURFQjZcXHVERUMwLVxcdURFQzJcXHVERUQwLVxcdURFRDZdKVxcdUZFMEZ8KD86W1xcdTI2MURcXHUyNkY5XFx1MjcwQS1cXHUyNzBEXXxcXHVEODNDW1xcdURGODVcXHVERkMyLVxcdURGQzRcXHVERkM3XFx1REZDQS1cXHVERkNDXXxcXHVEODNEW1xcdURDNDJcXHVEQzQzXFx1REM0Ni1cXHVEQzUwXFx1REM2Ni1cXHVEQzc4XFx1REM3Q1xcdURDODEtXFx1REM4M1xcdURDODUtXFx1REM4N1xcdURDOEZcXHVEQzkxXFx1RENBQVxcdURENzRcXHVERDc1XFx1REQ3QVxcdUREOTBcXHVERDk1XFx1REQ5NlxcdURFNDUtXFx1REU0N1xcdURFNEItXFx1REU0RlxcdURFQTNcXHVERUI0LVxcdURFQjZcXHVERUMwXFx1REVDQ118XFx1RDgzRVtcXHVERDBDXFx1REQwRlxcdUREMTgtXFx1REQxRlxcdUREMjZcXHVERDMwLVxcdUREMzlcXHVERDNDLVxcdUREM0VcXHVERDc3XFx1RERCNVxcdUREQjZcXHVEREI4XFx1RERCOVxcdUREQkJcXHVERENELVxcdUREQ0ZcXHVEREQxLVxcdURERERdKS9nfX19KSxrYT17fTtLdChrYSx7ZGVmYXVsdDooKT0+T0R9KTtmdW5jdGlvbiBPRChlKXtpZih0eXBlb2YgZSE9XCJzdHJpbmdcInx8ZS5sZW5ndGg9PT0wfHwoZT1fRChlKSxlLmxlbmd0aD09PTApKXJldHVybiAwO2U9ZS5yZXBsYWNlKCgwLExhLmRlZmF1bHQpKCksXCIgIFwiKTtsZXQgcj0wO2ZvcihsZXQgdD0wO3Q8ZS5sZW5ndGg7dCsrKXtsZXQgcz1lLmNvZGVQb2ludEF0KHQpO3M8PTMxfHxzPj0xMjcmJnM8PTE1OXx8cz49NzY4JiZzPD04Nzl8fChzPjY1NTM1JiZ0Kysscis9SUQocyk/MjoxKX1yZXR1cm4gcn12YXIgTGEsakQ9aHQoe1wibm9kZV9tb2R1bGVzL3N0cmluZy13aWR0aC9pbmRleC5qc1wiKCl7bmUoKSxQRCgpLGtEKCksTGE9YkQoTEQoKSl9fSksT2E9dGUoe1wic3JjL3V0aWxzL2dldC1zdHJpbmctd2lkdGguanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9KGpEKCksZnQoa2EpKS5kZWZhdWx0LHM9L1teXFx4MjAtXFx4N0ZdLztmdW5jdGlvbiBhKG4pe3JldHVybiBuP3MudGVzdChuKT90KG4pOm4ubGVuZ3RoOjB9ci5leHBvcnRzPWF9fSksWXQ9dGUoe1wic3JjL2RvY3VtZW50L2RvYy11dGlscy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1sdCgpLHtsaXRlcmFsbGluZTpzLGpvaW46YX09VW4oKSxuPW89PkFycmF5LmlzQXJyYXkobyl8fG8mJm8udHlwZT09PVwiY29uY2F0XCIsdT1vPT57aWYoQXJyYXkuaXNBcnJheShvKSlyZXR1cm4gbztpZihvLnR5cGUhPT1cImNvbmNhdFwiJiZvLnR5cGUhPT1cImZpbGxcIil0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3QgZG9jIHR5cGUgdG8gYmUgYGNvbmNhdGAgb3IgYGZpbGxgLlwiKTtyZXR1cm4gby5wYXJ0c30saT17fTtmdW5jdGlvbiBsKG8saCxDLHgpe2xldCBiPVtvXTtmb3IoO2IubGVuZ3RoPjA7KXtsZXQgQj1iLnBvcCgpO2lmKEI9PT1pKXtDKGIucG9wKCkpO2NvbnRpbnVlfWlmKEMmJmIucHVzaChCLGkpLCFofHxoKEIpIT09ITEpaWYobihCKXx8Qi50eXBlPT09XCJmaWxsXCIpe2xldCBrPXUoQik7Zm9yKGxldCBNPWsubGVuZ3RoLFI9TS0xO1I+PTA7LS1SKWIucHVzaChrW1JdKX1lbHNlIGlmKEIudHlwZT09PVwiaWYtYnJlYWtcIilCLmZsYXRDb250ZW50cyYmYi5wdXNoKEIuZmxhdENvbnRlbnRzKSxCLmJyZWFrQ29udGVudHMmJmIucHVzaChCLmJyZWFrQ29udGVudHMpO2Vsc2UgaWYoQi50eXBlPT09XCJncm91cFwiJiZCLmV4cGFuZGVkU3RhdGVzKWlmKHgpZm9yKGxldCBrPUIuZXhwYW5kZWRTdGF0ZXMubGVuZ3RoLE09ay0xO00+PTA7LS1NKWIucHVzaChCLmV4cGFuZGVkU3RhdGVzW01dKTtlbHNlIGIucHVzaChCLmNvbnRlbnRzKTtlbHNlIEIuY29udGVudHMmJmIucHVzaChCLmNvbnRlbnRzKX19ZnVuY3Rpb24gcChvLGgpe2xldCBDPW5ldyBNYXA7cmV0dXJuIHgobyk7ZnVuY3Rpb24geChCKXtpZihDLmhhcyhCKSlyZXR1cm4gQy5nZXQoQik7bGV0IGs9YihCKTtyZXR1cm4gQy5zZXQoQixrKSxrfWZ1bmN0aW9uIGIoQil7aWYoQXJyYXkuaXNBcnJheShCKSlyZXR1cm4gaChCLm1hcCh4KSk7aWYoQi50eXBlPT09XCJjb25jYXRcInx8Qi50eXBlPT09XCJmaWxsXCIpe2xldCBrPUIucGFydHMubWFwKHgpO3JldHVybiBoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxCKSx7fSx7cGFydHM6a30pKX1pZihCLnR5cGU9PT1cImlmLWJyZWFrXCIpe2xldCBrPUIuYnJlYWtDb250ZW50cyYmeChCLmJyZWFrQ29udGVudHMpLE09Qi5mbGF0Q29udGVudHMmJngoQi5mbGF0Q29udGVudHMpO3JldHVybiBoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxCKSx7fSx7YnJlYWtDb250ZW50czprLGZsYXRDb250ZW50czpNfSkpfWlmKEIudHlwZT09PVwiZ3JvdXBcIiYmQi5leHBhbmRlZFN0YXRlcyl7bGV0IGs9Qi5leHBhbmRlZFN0YXRlcy5tYXAoeCksTT1rWzBdO3JldHVybiBoKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxCKSx7fSx7Y29udGVudHM6TSxleHBhbmRlZFN0YXRlczprfSkpfWlmKEIuY29udGVudHMpe2xldCBrPXgoQi5jb250ZW50cyk7cmV0dXJuIGgoT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LEIpLHt9LHtjb250ZW50czprfSkpfXJldHVybiBoKEIpfX1mdW5jdGlvbiBkKG8saCxDKXtsZXQgeD1DLGI9ITE7ZnVuY3Rpb24gQihrKXtsZXQgTT1oKGspO2lmKE0hPT12b2lkIDAmJihiPSEwLHg9TSksYilyZXR1cm4hMX1yZXR1cm4gbChvLEIpLHh9ZnVuY3Rpb24geShvKXtpZihvLnR5cGU9PT1cImdyb3VwXCImJm8uYnJlYWt8fG8udHlwZT09PVwibGluZVwiJiZvLmhhcmR8fG8udHlwZT09PVwiYnJlYWstcGFyZW50XCIpcmV0dXJuITB9ZnVuY3Rpb24gZyhvKXtyZXR1cm4gZChvLHksITEpfWZ1bmN0aW9uIGMobyl7aWYoby5sZW5ndGg+MCl7bGV0IGg9dChvKTshaC5leHBhbmRlZFN0YXRlcyYmIWguYnJlYWsmJihoLmJyZWFrPVwicHJvcGFnYXRlZFwiKX1yZXR1cm4gbnVsbH1mdW5jdGlvbiBEKG8pe2xldCBoPW5ldyBTZXQsQz1bXTtmdW5jdGlvbiB4KEIpe2lmKEIudHlwZT09PVwiYnJlYWstcGFyZW50XCImJmMoQyksQi50eXBlPT09XCJncm91cFwiKXtpZihDLnB1c2goQiksaC5oYXMoQikpcmV0dXJuITE7aC5hZGQoQil9fWZ1bmN0aW9uIGIoQil7Qi50eXBlPT09XCJncm91cFwiJiZDLnBvcCgpLmJyZWFrJiZjKEMpfWwobyx4LGIsITApfWZ1bmN0aW9uIEUobyl7cmV0dXJuIG8udHlwZT09PVwibGluZVwiJiYhby5oYXJkP28uc29mdD9cIlwiOlwiIFwiOm8udHlwZT09PVwiaWYtYnJlYWtcIj9vLmZsYXRDb250ZW50c3x8XCJcIjpvfWZ1bmN0aW9uIF8obyl7cmV0dXJuIHAobyxFKX12YXIgdz0obyxoKT0+byYmby50eXBlPT09XCJsaW5lXCImJm8uaGFyZCYmaCYmaC50eXBlPT09XCJicmVhay1wYXJlbnRcIjtmdW5jdGlvbiBGKG8pe2lmKCFvKXJldHVybiBvO2lmKG4obyl8fG8udHlwZT09PVwiZmlsbFwiKXtsZXQgaD11KG8pO2Zvcig7aC5sZW5ndGg+MSYmdyguLi5oLnNsaWNlKC0yKSk7KWgubGVuZ3RoLT0yO2lmKGgubGVuZ3RoPjApe2xldCBDPUYodChoKSk7aFtoLmxlbmd0aC0xXT1DfXJldHVybiBBcnJheS5pc0FycmF5KG8pP2g6T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHt9LHtwYXJ0czpofSl9c3dpdGNoKG8udHlwZSl7Y2FzZVwiYWxpZ25cIjpjYXNlXCJpbmRlbnRcIjpjYXNlXCJpbmRlbnQtaWYtYnJlYWtcIjpjYXNlXCJncm91cFwiOmNhc2VcImxpbmUtc3VmZml4XCI6Y2FzZVwibGFiZWxcIjp7bGV0IGg9RihvLmNvbnRlbnRzKTtyZXR1cm4gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LG8pLHt9LHtjb250ZW50czpofSl9Y2FzZVwiaWYtYnJlYWtcIjp7bGV0IGg9RihvLmJyZWFrQ29udGVudHMpLEM9RihvLmZsYXRDb250ZW50cyk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7fSx7YnJlYWtDb250ZW50czpoLGZsYXRDb250ZW50czpDfSl9fXJldHVybiBvfWZ1bmN0aW9uIFMobyl7cmV0dXJuIEYoSShvKSl9ZnVuY3Rpb24gTihvKXtzd2l0Y2goby50eXBlKXtjYXNlXCJmaWxsXCI6aWYoby5wYXJ0cy5ldmVyeShDPT5DPT09XCJcIikpcmV0dXJuXCJcIjticmVhaztjYXNlXCJncm91cFwiOmlmKCFvLmNvbnRlbnRzJiYhby5pZCYmIW8uYnJlYWsmJiFvLmV4cGFuZGVkU3RhdGVzKXJldHVyblwiXCI7aWYoby5jb250ZW50cy50eXBlPT09XCJncm91cFwiJiZvLmNvbnRlbnRzLmlkPT09by5pZCYmby5jb250ZW50cy5icmVhaz09PW8uYnJlYWsmJm8uY29udGVudHMuZXhwYW5kZWRTdGF0ZXM9PT1vLmV4cGFuZGVkU3RhdGVzKXJldHVybiBvLmNvbnRlbnRzO2JyZWFrO2Nhc2VcImFsaWduXCI6Y2FzZVwiaW5kZW50XCI6Y2FzZVwiaW5kZW50LWlmLWJyZWFrXCI6Y2FzZVwibGluZS1zdWZmaXhcIjppZighby5jb250ZW50cylyZXR1cm5cIlwiO2JyZWFrO2Nhc2VcImlmLWJyZWFrXCI6aWYoIW8uZmxhdENvbnRlbnRzJiYhby5icmVha0NvbnRlbnRzKXJldHVyblwiXCI7YnJlYWt9aWYoIW4obykpcmV0dXJuIG87bGV0IGg9W107Zm9yKGxldCBDIG9mIHUobykpe2lmKCFDKWNvbnRpbnVlO2xldFt4LC4uLmJdPW4oQyk/dShDKTpbQ107dHlwZW9mIHg9PVwic3RyaW5nXCImJnR5cGVvZiB0KGgpPT1cInN0cmluZ1wiP2hbaC5sZW5ndGgtMV0rPXg6aC5wdXNoKHgpLGgucHVzaCguLi5iKX1yZXR1cm4gaC5sZW5ndGg9PT0wP1wiXCI6aC5sZW5ndGg9PT0xP2hbMF06QXJyYXkuaXNBcnJheShvKT9oOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7fSx7cGFydHM6aH0pfWZ1bmN0aW9uIEkobyl7cmV0dXJuIHAobyxoPT5OKGgpKX1mdW5jdGlvbiBQKG8pe2xldCBoPVtdLEM9by5maWx0ZXIoQm9vbGVhbik7Zm9yKDtDLmxlbmd0aD4wOyl7bGV0IHg9Qy5zaGlmdCgpO2lmKHgpe2lmKG4oeCkpe0MudW5zaGlmdCguLi51KHgpKTtjb250aW51ZX1pZihoLmxlbmd0aD4wJiZ0eXBlb2YgdChoKT09XCJzdHJpbmdcIiYmdHlwZW9mIHg9PVwic3RyaW5nXCIpe2hbaC5sZW5ndGgtMV0rPXg7Y29udGludWV9aC5wdXNoKHgpfX1yZXR1cm4gaH1mdW5jdGlvbiAkKG8pe3JldHVybiBwKG8saD0+QXJyYXkuaXNBcnJheShoKT9QKGgpOmgucGFydHM/T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LGgpLHt9LHtwYXJ0czpQKGgucGFydHMpfSk6aCl9ZnVuY3Rpb24gZihvKXtyZXR1cm4gcChvLGg9PnR5cGVvZiBoPT1cInN0cmluZ1wiJiZoLmluY2x1ZGVzKGBcbmApP1QoaCk6aCl9ZnVuY3Rpb24gVChvKXtsZXQgaD1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06cztyZXR1cm4gYShoLG8uc3BsaXQoYFxuYCkpLnBhcnRzfWZ1bmN0aW9uIG0obyl7aWYoby50eXBlPT09XCJsaW5lXCIpcmV0dXJuITB9ZnVuY3Rpb24gdihvKXtyZXR1cm4gZChvLG0sITEpfXIuZXhwb3J0cz17aXNDb25jYXQ6bixnZXREb2NQYXJ0czp1LHdpbGxCcmVhazpnLHRyYXZlcnNlRG9jOmwsZmluZEluRG9jOmQsbWFwRG9jOnAscHJvcGFnYXRlQnJlYWtzOkQscmVtb3ZlTGluZXM6XyxzdHJpcFRyYWlsaW5nSGFyZGxpbmU6Uyxub3JtYWxpemVQYXJ0czpQLG5vcm1hbGl6ZURvYzokLGNsZWFuRG9jOkkscmVwbGFjZVRleHRFbmRPZkxpbmU6VCxyZXBsYWNlRW5kT2ZMaW5lOmYsY2FuQnJlYWs6dn19fSkscUQ9dGUoe1wic3JjL2RvY3VtZW50L2RvYy1wcmludGVyLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3Zhcntjb252ZXJ0RW5kT2ZMaW5lVG9DaGFyczp0fT1KbigpLHM9bHQoKSxhPU9hKCkse2ZpbGw6bixjdXJzb3I6dSxpbmRlbnQ6aX09VW4oKSx7aXNDb25jYXQ6bCxnZXREb2NQYXJ0czpwfT1ZdCgpLGQseT0xLGc9MjtmdW5jdGlvbiBjKCl7cmV0dXJue3ZhbHVlOlwiXCIsbGVuZ3RoOjAscXVldWU6W119fWZ1bmN0aW9uIEQoTixJKXtyZXR1cm4gXyhOLHt0eXBlOlwiaW5kZW50XCJ9LEkpfWZ1bmN0aW9uIEUoTixJLFApe3JldHVybiBJPT09TnVtYmVyLk5FR0FUSVZFX0lORklOSVRZP04ucm9vdHx8YygpOkk8MD9fKE4se3R5cGU6XCJkZWRlbnRcIn0sUCk6ST9JLnR5cGU9PT1cInJvb3RcIj9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sTikse30se3Jvb3Q6Tn0pOl8oTix7dHlwZTp0eXBlb2YgST09XCJzdHJpbmdcIj9cInN0cmluZ0FsaWduXCI6XCJudW1iZXJBbGlnblwiLG46SX0sUCk6Tn1mdW5jdGlvbiBfKE4sSSxQKXtsZXQgJD1JLnR5cGU9PT1cImRlZGVudFwiP04ucXVldWUuc2xpY2UoMCwtMSk6Wy4uLk4ucXVldWUsSV0sZj1cIlwiLFQ9MCxtPTAsdj0wO2ZvcihsZXQgayBvZiAkKXN3aXRjaChrLnR5cGUpe2Nhc2VcImluZGVudFwiOkMoKSxQLnVzZVRhYnM/bygxKTpoKFAudGFiV2lkdGgpO2JyZWFrO2Nhc2VcInN0cmluZ0FsaWduXCI6QygpLGYrPWsubixUKz1rLm4ubGVuZ3RoO2JyZWFrO2Nhc2VcIm51bWJlckFsaWduXCI6bSs9MSx2Kz1rLm47YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSAnJHtrLnR5cGV9J2ApfXJldHVybiBiKCksT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LE4pLHt9LHt2YWx1ZTpmLGxlbmd0aDpULHF1ZXVlOiR9KTtmdW5jdGlvbiBvKGspe2YrPVwiXHRcIi5yZXBlYXQoayksVCs9UC50YWJXaWR0aCprfWZ1bmN0aW9uIGgoayl7Zis9XCIgXCIucmVwZWF0KGspLFQrPWt9ZnVuY3Rpb24gQygpe1AudXNlVGFicz94KCk6YigpfWZ1bmN0aW9uIHgoKXttPjAmJm8obSksQigpfWZ1bmN0aW9uIGIoKXt2PjAmJmgodiksQigpfWZ1bmN0aW9uIEIoKXttPTAsdj0wfX1mdW5jdGlvbiB3KE4pe2lmKE4ubGVuZ3RoPT09MClyZXR1cm4gMDtsZXQgST0wO2Zvcig7Ti5sZW5ndGg+MCYmdHlwZW9mIHMoTik9PVwic3RyaW5nXCImJi9eW1xcdCBdKiQvLnRlc3QocyhOKSk7KUkrPU4ucG9wKCkubGVuZ3RoO2lmKE4ubGVuZ3RoPjAmJnR5cGVvZiBzKE4pPT1cInN0cmluZ1wiKXtsZXQgUD1zKE4pLnJlcGxhY2UoL1tcXHQgXSokLyxcIlwiKTtJKz1zKE4pLmxlbmd0aC1QLmxlbmd0aCxOW04ubGVuZ3RoLTFdPVB9cmV0dXJuIEl9ZnVuY3Rpb24gRihOLEksUCwkLGYpe2xldCBUPUkubGVuZ3RoLG09W05dLHY9W107Zm9yKDtQPj0wOyl7aWYobS5sZW5ndGg9PT0wKXtpZihUPT09MClyZXR1cm4hMDttLnB1c2goSVstLVRdKTtjb250aW51ZX1sZXR7bW9kZTpvLGRvYzpofT1tLnBvcCgpO2lmKHR5cGVvZiBoPT1cInN0cmluZ1wiKXYucHVzaChoKSxQLT1hKGgpO2Vsc2UgaWYobChoKXx8aC50eXBlPT09XCJmaWxsXCIpe2xldCBDPXAoaCk7Zm9yKGxldCB4PUMubGVuZ3RoLTE7eD49MDt4LS0pbS5wdXNoKHttb2RlOm8sZG9jOkNbeF19KX1lbHNlIHN3aXRjaChoLnR5cGUpe2Nhc2VcImluZGVudFwiOmNhc2VcImFsaWduXCI6Y2FzZVwiaW5kZW50LWlmLWJyZWFrXCI6Y2FzZVwibGFiZWxcIjptLnB1c2goe21vZGU6byxkb2M6aC5jb250ZW50c30pO2JyZWFrO2Nhc2VcInRyaW1cIjpQKz13KHYpO2JyZWFrO2Nhc2VcImdyb3VwXCI6e2lmKGYmJmguYnJlYWspcmV0dXJuITE7bGV0IEM9aC5icmVhaz95Om8seD1oLmV4cGFuZGVkU3RhdGVzJiZDPT09eT9zKGguZXhwYW5kZWRTdGF0ZXMpOmguY29udGVudHM7bS5wdXNoKHttb2RlOkMsZG9jOnh9KTticmVha31jYXNlXCJpZi1icmVha1wiOntsZXQgeD0oaC5ncm91cElkP2RbaC5ncm91cElkXXx8ZzpvKT09PXk/aC5icmVha0NvbnRlbnRzOmguZmxhdENvbnRlbnRzO3gmJm0ucHVzaCh7bW9kZTpvLGRvYzp4fSk7YnJlYWt9Y2FzZVwibGluZVwiOmlmKG89PT15fHxoLmhhcmQpcmV0dXJuITA7aC5zb2Z0fHwodi5wdXNoKFwiIFwiKSxQLS0pO2JyZWFrO2Nhc2VcImxpbmUtc3VmZml4XCI6JD0hMDticmVhaztjYXNlXCJsaW5lLXN1ZmZpeC1ib3VuZGFyeVwiOmlmKCQpcmV0dXJuITE7YnJlYWt9fXJldHVybiExfWZ1bmN0aW9uIFMoTixJKXtkPXt9O2xldCBQPUkucHJpbnRXaWR0aCwkPXQoSS5lbmRPZkxpbmUpLGY9MCxUPVt7aW5kOmMoKSxtb2RlOnksZG9jOk59XSxtPVtdLHY9ITEsbz1bXTtmb3IoO1QubGVuZ3RoPjA7KXtsZXR7aW5kOkMsbW9kZTp4LGRvYzpifT1ULnBvcCgpO2lmKHR5cGVvZiBiPT1cInN0cmluZ1wiKXtsZXQgQj0kIT09YFxuYD9iLnJlcGxhY2UoL1xcbi9nLCQpOmI7bS5wdXNoKEIpLGYrPWEoQil9ZWxzZSBpZihsKGIpKXtsZXQgQj1wKGIpO2ZvcihsZXQgaz1CLmxlbmd0aC0xO2s+PTA7ay0tKVQucHVzaCh7aW5kOkMsbW9kZTp4LGRvYzpCW2tdfSl9ZWxzZSBzd2l0Y2goYi50eXBlKXtjYXNlXCJjdXJzb3JcIjptLnB1c2godS5wbGFjZWhvbGRlcik7YnJlYWs7Y2FzZVwiaW5kZW50XCI6VC5wdXNoKHtpbmQ6RChDLEkpLG1vZGU6eCxkb2M6Yi5jb250ZW50c30pO2JyZWFrO2Nhc2VcImFsaWduXCI6VC5wdXNoKHtpbmQ6RShDLGIubixJKSxtb2RlOngsZG9jOmIuY29udGVudHN9KTticmVhaztjYXNlXCJ0cmltXCI6Zi09dyhtKTticmVhaztjYXNlXCJncm91cFwiOnN3aXRjaCh4KXtjYXNlIGc6aWYoIXYpe1QucHVzaCh7aW5kOkMsbW9kZTpiLmJyZWFrP3k6Zyxkb2M6Yi5jb250ZW50c30pO2JyZWFrfWNhc2UgeTp7dj0hMTtsZXQgQj17aW5kOkMsbW9kZTpnLGRvYzpiLmNvbnRlbnRzfSxrPVAtZixNPW8ubGVuZ3RoPjA7aWYoIWIuYnJlYWsmJkYoQixULGssTSkpVC5wdXNoKEIpO2Vsc2UgaWYoYi5leHBhbmRlZFN0YXRlcyl7bGV0IFI9cyhiLmV4cGFuZGVkU3RhdGVzKTtpZihiLmJyZWFrKXtULnB1c2goe2luZDpDLG1vZGU6eSxkb2M6Un0pO2JyZWFrfWVsc2UgZm9yKGxldCBxPTE7cTxiLmV4cGFuZGVkU3RhdGVzLmxlbmd0aCsxO3ErKylpZihxPj1iLmV4cGFuZGVkU3RhdGVzLmxlbmd0aCl7VC5wdXNoKHtpbmQ6Qyxtb2RlOnksZG9jOlJ9KTticmVha31lbHNle2xldCBKPWIuZXhwYW5kZWRTdGF0ZXNbcV0sTD17aW5kOkMsbW9kZTpnLGRvYzpKfTtpZihGKEwsVCxrLE0pKXtULnB1c2goTCk7YnJlYWt9fX1lbHNlIFQucHVzaCh7aW5kOkMsbW9kZTp5LGRvYzpiLmNvbnRlbnRzfSk7YnJlYWt9fWIuaWQmJihkW2IuaWRdPXMoVCkubW9kZSk7YnJlYWs7Y2FzZVwiZmlsbFwiOntsZXQgQj1QLWYse3BhcnRzOmt9PWI7aWYoay5sZW5ndGg9PT0wKWJyZWFrO2xldFtNLFJdPWsscT17aW5kOkMsbW9kZTpnLGRvYzpNfSxKPXtpbmQ6Qyxtb2RlOnksZG9jOk19LEw9RihxLFtdLEIsby5sZW5ndGg+MCwhMCk7aWYoay5sZW5ndGg9PT0xKXtMP1QucHVzaChxKTpULnB1c2goSik7YnJlYWt9bGV0IFE9e2luZDpDLG1vZGU6Zyxkb2M6Un0sVj17aW5kOkMsbW9kZTp5LGRvYzpSfTtpZihrLmxlbmd0aD09PTIpe0w/VC5wdXNoKFEscSk6VC5wdXNoKFYsSik7YnJlYWt9ay5zcGxpY2UoMCwyKTtsZXQgaj17aW5kOkMsbW9kZTp4LGRvYzpuKGspfSxZPWtbMF07Rih7aW5kOkMsbW9kZTpnLGRvYzpbTSxSLFldfSxbXSxCLG8ubGVuZ3RoPjAsITApP1QucHVzaChqLFEscSk6TD9ULnB1c2goaixWLHEpOlQucHVzaChqLFYsSik7YnJlYWt9Y2FzZVwiaWYtYnJlYWtcIjpjYXNlXCJpbmRlbnQtaWYtYnJlYWtcIjp7bGV0IEI9Yi5ncm91cElkP2RbYi5ncm91cElkXTp4O2lmKEI9PT15KXtsZXQgaz1iLnR5cGU9PT1cImlmLWJyZWFrXCI/Yi5icmVha0NvbnRlbnRzOmIubmVnYXRlP2IuY29udGVudHM6aShiLmNvbnRlbnRzKTtrJiZULnB1c2goe2luZDpDLG1vZGU6eCxkb2M6a30pfWlmKEI9PT1nKXtsZXQgaz1iLnR5cGU9PT1cImlmLWJyZWFrXCI/Yi5mbGF0Q29udGVudHM6Yi5uZWdhdGU/aShiLmNvbnRlbnRzKTpiLmNvbnRlbnRzO2smJlQucHVzaCh7aW5kOkMsbW9kZTp4LGRvYzprfSl9YnJlYWt9Y2FzZVwibGluZS1zdWZmaXhcIjpvLnB1c2goe2luZDpDLG1vZGU6eCxkb2M6Yi5jb250ZW50c30pO2JyZWFrO2Nhc2VcImxpbmUtc3VmZml4LWJvdW5kYXJ5XCI6by5sZW5ndGg+MCYmVC5wdXNoKHtpbmQ6Qyxtb2RlOngsZG9jOnt0eXBlOlwibGluZVwiLGhhcmQ6ITB9fSk7YnJlYWs7Y2FzZVwibGluZVwiOnN3aXRjaCh4KXtjYXNlIGc6aWYoYi5oYXJkKXY9ITA7ZWxzZXtiLnNvZnR8fChtLnB1c2goXCIgXCIpLGYrPTEpO2JyZWFrfWNhc2UgeTppZihvLmxlbmd0aD4wKXtULnB1c2goe2luZDpDLG1vZGU6eCxkb2M6Yn0sLi4uby5yZXZlcnNlKCkpLG8ubGVuZ3RoPTA7YnJlYWt9Yi5saXRlcmFsP0Mucm9vdD8obS5wdXNoKCQsQy5yb290LnZhbHVlKSxmPUMucm9vdC5sZW5ndGgpOihtLnB1c2goJCksZj0wKTooZi09dyhtKSxtLnB1c2goJCtDLnZhbHVlKSxmPUMubGVuZ3RoKTticmVha31icmVhaztjYXNlXCJsYWJlbFwiOlQucHVzaCh7aW5kOkMsbW9kZTp4LGRvYzpiLmNvbnRlbnRzfSk7YnJlYWs7ZGVmYXVsdDp9VC5sZW5ndGg9PT0wJiZvLmxlbmd0aD4wJiYoVC5wdXNoKC4uLm8ucmV2ZXJzZSgpKSxvLmxlbmd0aD0wKX1sZXQgaD1tLmluZGV4T2YodS5wbGFjZWhvbGRlcik7aWYoaCE9PS0xKXtsZXQgQz1tLmluZGV4T2YodS5wbGFjZWhvbGRlcixoKzEpLHg9bS5zbGljZSgwLGgpLmpvaW4oXCJcIiksYj1tLnNsaWNlKGgrMSxDKS5qb2luKFwiXCIpLEI9bS5zbGljZShDKzEpLmpvaW4oXCJcIik7cmV0dXJue2Zvcm1hdHRlZDp4K2IrQixjdXJzb3JOb2RlU3RhcnQ6eC5sZW5ndGgsY3Vyc29yTm9kZVRleHQ6Yn19cmV0dXJue2Zvcm1hdHRlZDptLmpvaW4oXCJcIil9fXIuZXhwb3J0cz17cHJpbnREb2NUb1N0cmluZzpTfX19KSxNRD10ZSh7XCJzcmMvZG9jdW1lbnQvZG9jLWRlYnVnLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3Zhcntpc0NvbmNhdDp0LGdldERvY1BhcnRzOnN9PVl0KCk7ZnVuY3Rpb24gYSh1KXtpZighdSlyZXR1cm5cIlwiO2lmKHQodSkpe2xldCBpPVtdO2ZvcihsZXQgbCBvZiBzKHUpKWlmKHQobCkpaS5wdXNoKC4uLmEobCkucGFydHMpO2Vsc2V7bGV0IHA9YShsKTtwIT09XCJcIiYmaS5wdXNoKHApfXJldHVybnt0eXBlOlwiY29uY2F0XCIscGFydHM6aX19cmV0dXJuIHUudHlwZT09PVwiaWYtYnJlYWtcIj9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse30se2JyZWFrQ29udGVudHM6YSh1LmJyZWFrQ29udGVudHMpLGZsYXRDb250ZW50czphKHUuZmxhdENvbnRlbnRzKX0pOnUudHlwZT09PVwiZ3JvdXBcIj9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse30se2NvbnRlbnRzOmEodS5jb250ZW50cyksZXhwYW5kZWRTdGF0ZXM6dS5leHBhbmRlZFN0YXRlcyYmdS5leHBhbmRlZFN0YXRlcy5tYXAoYSl9KTp1LnR5cGU9PT1cImZpbGxcIj97dHlwZTpcImZpbGxcIixwYXJ0czp1LnBhcnRzLm1hcChhKX06dS5jb250ZW50cz9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdSkse30se2NvbnRlbnRzOmEodS5jb250ZW50cyl9KTp1fWZ1bmN0aW9uIG4odSl7bGV0IGk9T2JqZWN0LmNyZWF0ZShudWxsKSxsPW5ldyBTZXQ7cmV0dXJuIHAoYSh1KSk7ZnVuY3Rpb24gcCh5LGcsYyl7aWYodHlwZW9mIHk9PVwic3RyaW5nXCIpcmV0dXJuIEpTT04uc3RyaW5naWZ5KHkpO2lmKHQoeSkpe2xldCBEPXMoeSkubWFwKHApLmZpbHRlcihCb29sZWFuKTtyZXR1cm4gRC5sZW5ndGg9PT0xP0RbMF06YFske0Quam9pbihcIiwgXCIpfV1gfWlmKHkudHlwZT09PVwibGluZVwiKXtsZXQgRD1BcnJheS5pc0FycmF5KGMpJiZjW2crMV0mJmNbZysxXS50eXBlPT09XCJicmVhay1wYXJlbnRcIjtyZXR1cm4geS5saXRlcmFsP0Q/XCJsaXRlcmFsbGluZVwiOlwibGl0ZXJhbGxpbmVXaXRob3V0QnJlYWtQYXJlbnRcIjp5LmhhcmQ/RD9cImhhcmRsaW5lXCI6XCJoYXJkbGluZVdpdGhvdXRCcmVha1BhcmVudFwiOnkuc29mdD9cInNvZnRsaW5lXCI6XCJsaW5lXCJ9aWYoeS50eXBlPT09XCJicmVhay1wYXJlbnRcIilyZXR1cm4gQXJyYXkuaXNBcnJheShjKSYmY1tnLTFdJiZjW2ctMV0udHlwZT09PVwibGluZVwiJiZjW2ctMV0uaGFyZD92b2lkIDA6XCJicmVha1BhcmVudFwiO2lmKHkudHlwZT09PVwidHJpbVwiKXJldHVyblwidHJpbVwiO2lmKHkudHlwZT09PVwiaW5kZW50XCIpcmV0dXJuXCJpbmRlbnQoXCIrcCh5LmNvbnRlbnRzKStcIilcIjtpZih5LnR5cGU9PT1cImFsaWduXCIpcmV0dXJuIHkubj09PU51bWJlci5ORUdBVElWRV9JTkZJTklUWT9cImRlZGVudFRvUm9vdChcIitwKHkuY29udGVudHMpK1wiKVwiOnkubjwwP1wiZGVkZW50KFwiK3AoeS5jb250ZW50cykrXCIpXCI6eS5uLnR5cGU9PT1cInJvb3RcIj9cIm1hcmtBc1Jvb3QoXCIrcCh5LmNvbnRlbnRzKStcIilcIjpcImFsaWduKFwiK0pTT04uc3RyaW5naWZ5KHkubikrXCIsIFwiK3AoeS5jb250ZW50cykrXCIpXCI7aWYoeS50eXBlPT09XCJpZi1icmVha1wiKXJldHVyblwiaWZCcmVhayhcIitwKHkuYnJlYWtDb250ZW50cykrKHkuZmxhdENvbnRlbnRzP1wiLCBcIitwKHkuZmxhdENvbnRlbnRzKTpcIlwiKSsoeS5ncm91cElkPyh5LmZsYXRDb250ZW50cz9cIlwiOicsIFwiXCInKStgLCB7IGdyb3VwSWQ6ICR7ZCh5Lmdyb3VwSWQpfSB9YDpcIlwiKStcIilcIjtpZih5LnR5cGU9PT1cImluZGVudC1pZi1icmVha1wiKXtsZXQgRD1bXTt5Lm5lZ2F0ZSYmRC5wdXNoKFwibmVnYXRlOiB0cnVlXCIpLHkuZ3JvdXBJZCYmRC5wdXNoKGBncm91cElkOiAke2QoeS5ncm91cElkKX1gKTtsZXQgRT1ELmxlbmd0aD4wP2AsIHsgJHtELmpvaW4oXCIsIFwiKX0gfWA6XCJcIjtyZXR1cm5gaW5kZW50SWZCcmVhaygke3AoeS5jb250ZW50cyl9JHtFfSlgfWlmKHkudHlwZT09PVwiZ3JvdXBcIil7bGV0IEQ9W107eS5icmVhayYmeS5icmVhayE9PVwicHJvcGFnYXRlZFwiJiZELnB1c2goXCJzaG91bGRCcmVhazogdHJ1ZVwiKSx5LmlkJiZELnB1c2goYGlkOiAke2QoeS5pZCl9YCk7bGV0IEU9RC5sZW5ndGg+MD9gLCB7ICR7RC5qb2luKFwiLCBcIil9IH1gOlwiXCI7cmV0dXJuIHkuZXhwYW5kZWRTdGF0ZXM/YGNvbmRpdGlvbmFsR3JvdXAoWyR7eS5leHBhbmRlZFN0YXRlcy5tYXAoXz0+cChfKSkuam9pbihcIixcIil9XSR7RX0pYDpgZ3JvdXAoJHtwKHkuY29udGVudHMpfSR7RX0pYH1pZih5LnR5cGU9PT1cImZpbGxcIilyZXR1cm5gZmlsbChbJHt5LnBhcnRzLm1hcChEPT5wKEQpKS5qb2luKFwiLCBcIil9XSlgO2lmKHkudHlwZT09PVwibGluZS1zdWZmaXhcIilyZXR1cm5cImxpbmVTdWZmaXgoXCIrcCh5LmNvbnRlbnRzKStcIilcIjtpZih5LnR5cGU9PT1cImxpbmUtc3VmZml4LWJvdW5kYXJ5XCIpcmV0dXJuXCJsaW5lU3VmZml4Qm91bmRhcnlcIjtpZih5LnR5cGU9PT1cImxhYmVsXCIpcmV0dXJuYGxhYmVsKCR7SlNPTi5zdHJpbmdpZnkoeS5sYWJlbCl9LCAke3AoeS5jb250ZW50cyl9KWA7dGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBkb2MgdHlwZSBcIit5LnR5cGUpfWZ1bmN0aW9uIGQoeSl7aWYodHlwZW9mIHkhPVwic3ltYm9sXCIpcmV0dXJuIEpTT04uc3RyaW5naWZ5KFN0cmluZyh5KSk7aWYoeSBpbiBpKXJldHVybiBpW3ldO2xldCBnPVN0cmluZyh5KS5zbGljZSg3LC0xKXx8XCJzeW1ib2xcIjtmb3IobGV0IGM9MDs7YysrKXtsZXQgRD1nKyhjPjA/YCAjJHtjfWA6XCJcIik7aWYoIWwuaGFzKEQpKXJldHVybiBsLmFkZChEKSxpW3ldPWBTeW1ib2wuZm9yKCR7SlNPTi5zdHJpbmdpZnkoRCl9KWB9fX1yLmV4cG9ydHM9e3ByaW50RG9jVG9EZWJ1ZzpufX19KSxxZT10ZSh7XCJzcmMvZG9jdW1lbnQvaW5kZXguanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCksci5leHBvcnRzPXtidWlsZGVyczpVbigpLHByaW50ZXI6cUQoKSx1dGlsczpZdCgpLGRlYnVnOk1EKCl9fX0pLGphPXt9O0t0KGphLHtkZWZhdWx0OigpPT5SRH0pO2Z1bmN0aW9uIFJEKGUpe2lmKHR5cGVvZiBlIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJFeHBlY3RlZCBhIHN0cmluZ1wiKTtyZXR1cm4gZS5yZXBsYWNlKC9bfFxcXFx7fSgpW1xcXV4kKyo/Ll0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC8tL2csXCJcXFxceDJkXCIpfXZhciAkRD1odCh7XCJub2RlX21vZHVsZXMvZXNjYXBlLXN0cmluZy1yZWdleHAvaW5kZXguanNcIigpe25lKCl9fSkscWE9dGUoe1wibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9kZWJ1Zy5qc1wiKGUscil7bmUoKTt2YXIgdD10eXBlb2Ygd3Q9PVwib2JqZWN0XCImJnd0LmVudiYmd3QuZW52Lk5PREVfREVCVUcmJi9cXGJzZW12ZXJcXGIvaS50ZXN0KHd0LmVudi5OT0RFX0RFQlVHKT9mdW5jdGlvbigpe2Zvcih2YXIgcz1hcmd1bWVudHMubGVuZ3RoLGE9bmV3IEFycmF5KHMpLG49MDtuPHM7bisrKWFbbl09YXJndW1lbnRzW25dO3JldHVybiBjb25zb2xlLmVycm9yKFwiU0VNVkVSXCIsLi4uYSl9OigpPT57fTtyLmV4cG9ydHM9dH19KSxNYT10ZSh7XCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL2NvbnN0YW50cy5qc1wiKGUscil7bmUoKTt2YXIgdD1cIjIuMC4wXCIscz0yNTYsYT1OdW1iZXIuTUFYX1NBRkVfSU5URUdFUnx8OTAwNzE5OTI1NDc0MDk5MSxuPTE2O3IuZXhwb3J0cz17U0VNVkVSX1NQRUNfVkVSU0lPTjp0LE1BWF9MRU5HVEg6cyxNQVhfU0FGRV9JTlRFR0VSOmEsTUFYX1NBRkVfQ09NUE9ORU5UX0xFTkdUSDpufX19KSxWRD10ZSh7XCJub2RlX21vZHVsZXMvc2VtdmVyL2ludGVybmFsL3JlLmpzXCIoZSxyKXtuZSgpO3ZhcntNQVhfU0FGRV9DT01QT05FTlRfTEVOR1RIOnR9PU1hKCkscz1xYSgpO2U9ci5leHBvcnRzPXt9O3ZhciBhPWUucmU9W10sbj1lLnNyYz1bXSx1PWUudD17fSxpPTAsbD0ocCxkLHkpPT57bGV0IGc9aSsrO3MocCxnLGQpLHVbcF09ZyxuW2ddPWQsYVtnXT1uZXcgUmVnRXhwKGQseT9cImdcIjp2b2lkIDApfTtsKFwiTlVNRVJJQ0lERU5USUZJRVJcIixcIjB8WzEtOV1cXFxcZCpcIiksbChcIk5VTUVSSUNJREVOVElGSUVSTE9PU0VcIixcIlswLTldK1wiKSxsKFwiTk9OTlVNRVJJQ0lERU5USUZJRVJcIixcIlxcXFxkKlthLXpBLVotXVthLXpBLVowLTktXSpcIiksbChcIk1BSU5WRVJTSU9OXCIsYCgke25bdS5OVU1FUklDSURFTlRJRklFUl19KVxcXFwuKCR7blt1Lk5VTUVSSUNJREVOVElGSUVSXX0pXFxcXC4oJHtuW3UuTlVNRVJJQ0lERU5USUZJRVJdfSlgKSxsKFwiTUFJTlZFUlNJT05MT09TRVwiLGAoJHtuW3UuTlVNRVJJQ0lERU5USUZJRVJMT09TRV19KVxcXFwuKCR7blt1Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfSlcXFxcLigke25bdS5OVU1FUklDSURFTlRJRklFUkxPT1NFXX0pYCksbChcIlBSRVJFTEVBU0VJREVOVElGSUVSXCIsYCg/OiR7blt1Lk5VTUVSSUNJREVOVElGSUVSXX18JHtuW3UuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKSxsKFwiUFJFUkVMRUFTRUlERU5USUZJRVJMT09TRVwiLGAoPzoke25bdS5OVU1FUklDSURFTlRJRklFUkxPT1NFXX18JHtuW3UuTk9OTlVNRVJJQ0lERU5USUZJRVJdfSlgKSxsKFwiUFJFUkVMRUFTRVwiLGAoPzotKCR7blt1LlBSRVJFTEVBU0VJREVOVElGSUVSXX0oPzpcXFxcLiR7blt1LlBSRVJFTEVBU0VJREVOVElGSUVSXX0pKikpYCksbChcIlBSRVJFTEVBU0VMT09TRVwiLGAoPzotPygke25bdS5QUkVSRUxFQVNFSURFTlRJRklFUkxPT1NFXX0oPzpcXFxcLiR7blt1LlBSRVJFTEVBU0VJREVOVElGSUVSTE9PU0VdfSkqKSlgKSxsKFwiQlVJTERJREVOVElGSUVSXCIsXCJbMC05QS1aYS16LV0rXCIpLGwoXCJCVUlMRFwiLGAoPzpcXFxcKygke25bdS5CVUlMRElERU5USUZJRVJdfSg/OlxcXFwuJHtuW3UuQlVJTERJREVOVElGSUVSXX0pKikpYCksbChcIkZVTExQTEFJTlwiLGB2PyR7blt1Lk1BSU5WRVJTSU9OXX0ke25bdS5QUkVSRUxFQVNFXX0/JHtuW3UuQlVJTERdfT9gKSxsKFwiRlVMTFwiLGBeJHtuW3UuRlVMTFBMQUlOXX0kYCksbChcIkxPT1NFUExBSU5cIixgW3Y9XFxcXHNdKiR7blt1Lk1BSU5WRVJTSU9OTE9PU0VdfSR7blt1LlBSRVJFTEVBU0VMT09TRV19PyR7blt1LkJVSUxEXX0/YCksbChcIkxPT1NFXCIsYF4ke25bdS5MT09TRVBMQUlOXX0kYCksbChcIkdUTFRcIixcIigoPzo8fD4pPz0/KVwiKSxsKFwiWFJBTkdFSURFTlRJRklFUkxPT1NFXCIsYCR7blt1Lk5VTUVSSUNJREVOVElGSUVSTE9PU0VdfXx4fFh8XFxcXCpgKSxsKFwiWFJBTkdFSURFTlRJRklFUlwiLGAke25bdS5OVU1FUklDSURFTlRJRklFUl19fHh8WHxcXFxcKmApLGwoXCJYUkFOR0VQTEFJTlwiLGBbdj1cXFxcc10qKCR7blt1LlhSQU5HRUlERU5USUZJRVJdfSkoPzpcXFxcLigke25bdS5YUkFOR0VJREVOVElGSUVSXX0pKD86XFxcXC4oJHtuW3UuWFJBTkdFSURFTlRJRklFUl19KSg/OiR7blt1LlBSRVJFTEVBU0VdfSk/JHtuW3UuQlVJTERdfT8pPyk/YCksbChcIlhSQU5HRVBMQUlOTE9PU0VcIixgW3Y9XFxcXHNdKigke25bdS5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSkoPzpcXFxcLigke25bdS5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSkoPzpcXFxcLigke25bdS5YUkFOR0VJREVOVElGSUVSTE9PU0VdfSkoPzoke25bdS5QUkVSRUxFQVNFTE9PU0VdfSk/JHtuW3UuQlVJTERdfT8pPyk/YCksbChcIlhSQU5HRVwiLGBeJHtuW3UuR1RMVF19XFxcXHMqJHtuW3UuWFJBTkdFUExBSU5dfSRgKSxsKFwiWFJBTkdFTE9PU0VcIixgXiR7blt1LkdUTFRdfVxcXFxzKiR7blt1LlhSQU5HRVBMQUlOTE9PU0VdfSRgKSxsKFwiQ09FUkNFXCIsYChefFteXFxcXGRdKShcXFxcZHsxLCR7dH19KSg/OlxcXFwuKFxcXFxkezEsJHt0fX0pKT8oPzpcXFxcLihcXFxcZHsxLCR7dH19KSk/KD86JHxbXlxcXFxkXSlgKSxsKFwiQ09FUkNFUlRMXCIsblt1LkNPRVJDRV0sITApLGwoXCJMT05FVElMREVcIixcIig/On4+PylcIiksbChcIlRJTERFVFJJTVwiLGAoXFxcXHMqKSR7blt1LkxPTkVUSUxERV19XFxcXHMrYCwhMCksZS50aWxkZVRyaW1SZXBsYWNlPVwiJDF+XCIsbChcIlRJTERFXCIsYF4ke25bdS5MT05FVElMREVdfSR7blt1LlhSQU5HRVBMQUlOXX0kYCksbChcIlRJTERFTE9PU0VcIixgXiR7blt1LkxPTkVUSUxERV19JHtuW3UuWFJBTkdFUExBSU5MT09TRV19JGApLGwoXCJMT05FQ0FSRVRcIixcIig/OlxcXFxeKVwiKSxsKFwiQ0FSRVRUUklNXCIsYChcXFxccyopJHtuW3UuTE9ORUNBUkVUXX1cXFxccytgLCEwKSxlLmNhcmV0VHJpbVJlcGxhY2U9XCIkMV5cIixsKFwiQ0FSRVRcIixgXiR7blt1LkxPTkVDQVJFVF19JHtuW3UuWFJBTkdFUExBSU5dfSRgKSxsKFwiQ0FSRVRMT09TRVwiLGBeJHtuW3UuTE9ORUNBUkVUXX0ke25bdS5YUkFOR0VQTEFJTkxPT1NFXX0kYCksbChcIkNPTVBBUkFUT1JMT09TRVwiLGBeJHtuW3UuR1RMVF19XFxcXHMqKCR7blt1LkxPT1NFUExBSU5dfSkkfF4kYCksbChcIkNPTVBBUkFUT1JcIixgXiR7blt1LkdUTFRdfVxcXFxzKigke25bdS5GVUxMUExBSU5dfSkkfF4kYCksbChcIkNPTVBBUkFUT1JUUklNXCIsYChcXFxccyopJHtuW3UuR1RMVF19XFxcXHMqKCR7blt1LkxPT1NFUExBSU5dfXwke25bdS5YUkFOR0VQTEFJTl19KWAsITApLGUuY29tcGFyYXRvclRyaW1SZXBsYWNlPVwiJDEkMiQzXCIsbChcIkhZUEhFTlJBTkdFXCIsYF5cXFxccyooJHtuW3UuWFJBTkdFUExBSU5dfSlcXFxccystXFxcXHMrKCR7blt1LlhSQU5HRVBMQUlOXX0pXFxcXHMqJGApLGwoXCJIWVBIRU5SQU5HRUxPT1NFXCIsYF5cXFxccyooJHtuW3UuWFJBTkdFUExBSU5MT09TRV19KVxcXFxzKy1cXFxccysoJHtuW3UuWFJBTkdFUExBSU5MT09TRV19KVxcXFxzKiRgKSxsKFwiU1RBUlwiLFwiKDx8Pik/PT9cXFxccypcXFxcKlwiKSxsKFwiR1RFMFwiLFwiXlxcXFxzKj49XFxcXHMqMFxcXFwuMFxcXFwuMFxcXFxzKiRcIiksbChcIkdURTBQUkVcIixcIl5cXFxccyo+PVxcXFxzKjBcXFxcLjBcXFxcLjAtMFxcXFxzKiRcIil9fSksV0Q9dGUoe1wibm9kZV9tb2R1bGVzL3NlbXZlci9pbnRlcm5hbC9wYXJzZS1vcHRpb25zLmpzXCIoZSxyKXtuZSgpO3ZhciB0PVtcImluY2x1ZGVQcmVyZWxlYXNlXCIsXCJsb29zZVwiLFwicnRsXCJdLHM9YT0+YT90eXBlb2YgYSE9XCJvYmplY3RcIj97bG9vc2U6ITB9OnQuZmlsdGVyKG49PmFbbl0pLnJlZHVjZSgobix1KT0+KG5bdV09ITAsbikse30pOnt9O3IuZXhwb3J0cz1zfX0pLEhEPXRlKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvaW50ZXJuYWwvaWRlbnRpZmllcnMuanNcIihlLHIpe25lKCk7dmFyIHQ9L15bMC05XSskLyxzPShuLHUpPT57bGV0IGk9dC50ZXN0KG4pLGw9dC50ZXN0KHUpO3JldHVybiBpJiZsJiYobj0rbix1PSt1KSxuPT09dT8wOmkmJiFsPy0xOmwmJiFpPzE6bjx1Py0xOjF9LGE9KG4sdSk9PnModSxuKTtyLmV4cG9ydHM9e2NvbXBhcmVJZGVudGlmaWVyczpzLHJjb21wYXJlSWRlbnRpZmllcnM6YX19fSksR0Q9dGUoe1wibm9kZV9tb2R1bGVzL3NlbXZlci9jbGFzc2VzL3NlbXZlci5qc1wiKGUscil7bmUoKTt2YXIgdD1xYSgpLHtNQVhfTEVOR1RIOnMsTUFYX1NBRkVfSU5URUdFUjphfT1NYSgpLHtyZTpuLHQ6dX09VkQoKSxpPVdEKCkse2NvbXBhcmVJZGVudGlmaWVyczpsfT1IRCgpLHA9Y2xhc3N7Y29uc3RydWN0b3IoZCx5KXtpZih5PWkoeSksZCBpbnN0YW5jZW9mIHApe2lmKGQubG9vc2U9PT0hIXkubG9vc2UmJmQuaW5jbHVkZVByZXJlbGVhc2U9PT0hIXkuaW5jbHVkZVByZXJlbGVhc2UpcmV0dXJuIGQ7ZD1kLnZlcnNpb259ZWxzZSBpZih0eXBlb2YgZCE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKGBJbnZhbGlkIFZlcnNpb246ICR7ZH1gKTtpZihkLmxlbmd0aD5zKXRocm93IG5ldyBUeXBlRXJyb3IoYHZlcnNpb24gaXMgbG9uZ2VyIHRoYW4gJHtzfSBjaGFyYWN0ZXJzYCk7dChcIlNlbVZlclwiLGQseSksdGhpcy5vcHRpb25zPXksdGhpcy5sb29zZT0hIXkubG9vc2UsdGhpcy5pbmNsdWRlUHJlcmVsZWFzZT0hIXkuaW5jbHVkZVByZXJlbGVhc2U7bGV0IGc9ZC50cmltKCkubWF0Y2goeS5sb29zZT9uW3UuTE9PU0VdOm5bdS5GVUxMXSk7aWYoIWcpdGhyb3cgbmV3IFR5cGVFcnJvcihgSW52YWxpZCBWZXJzaW9uOiAke2R9YCk7aWYodGhpcy5yYXc9ZCx0aGlzLm1ham9yPStnWzFdLHRoaXMubWlub3I9K2dbMl0sdGhpcy5wYXRjaD0rZ1szXSx0aGlzLm1ham9yPmF8fHRoaXMubWFqb3I8MCl0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBtYWpvciB2ZXJzaW9uXCIpO2lmKHRoaXMubWlub3I+YXx8dGhpcy5taW5vcjwwKXRocm93IG5ldyBUeXBlRXJyb3IoXCJJbnZhbGlkIG1pbm9yIHZlcnNpb25cIik7aWYodGhpcy5wYXRjaD5hfHx0aGlzLnBhdGNoPDApdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgcGF0Y2ggdmVyc2lvblwiKTtnWzRdP3RoaXMucHJlcmVsZWFzZT1nWzRdLnNwbGl0KFwiLlwiKS5tYXAoYz0+e2lmKC9eWzAtOV0rJC8udGVzdChjKSl7bGV0IEQ9K2M7aWYoRD49MCYmRDxhKXJldHVybiBEfXJldHVybiBjfSk6dGhpcy5wcmVyZWxlYXNlPVtdLHRoaXMuYnVpbGQ9Z1s1XT9nWzVdLnNwbGl0KFwiLlwiKTpbXSx0aGlzLmZvcm1hdCgpfWZvcm1hdCgpe3JldHVybiB0aGlzLnZlcnNpb249YCR7dGhpcy5tYWpvcn0uJHt0aGlzLm1pbm9yfS4ke3RoaXMucGF0Y2h9YCx0aGlzLnByZXJlbGVhc2UubGVuZ3RoJiYodGhpcy52ZXJzaW9uKz1gLSR7dGhpcy5wcmVyZWxlYXNlLmpvaW4oXCIuXCIpfWApLHRoaXMudmVyc2lvbn10b1N0cmluZygpe3JldHVybiB0aGlzLnZlcnNpb259Y29tcGFyZShkKXtpZih0KFwiU2VtVmVyLmNvbXBhcmVcIix0aGlzLnZlcnNpb24sdGhpcy5vcHRpb25zLGQpLCEoZCBpbnN0YW5jZW9mIHApKXtpZih0eXBlb2YgZD09XCJzdHJpbmdcIiYmZD09PXRoaXMudmVyc2lvbilyZXR1cm4gMDtkPW5ldyBwKGQsdGhpcy5vcHRpb25zKX1yZXR1cm4gZC52ZXJzaW9uPT09dGhpcy52ZXJzaW9uPzA6dGhpcy5jb21wYXJlTWFpbihkKXx8dGhpcy5jb21wYXJlUHJlKGQpfWNvbXBhcmVNYWluKGQpe3JldHVybiBkIGluc3RhbmNlb2YgcHx8KGQ9bmV3IHAoZCx0aGlzLm9wdGlvbnMpKSxsKHRoaXMubWFqb3IsZC5tYWpvcil8fGwodGhpcy5taW5vcixkLm1pbm9yKXx8bCh0aGlzLnBhdGNoLGQucGF0Y2gpfWNvbXBhcmVQcmUoZCl7aWYoZCBpbnN0YW5jZW9mIHB8fChkPW5ldyBwKGQsdGhpcy5vcHRpb25zKSksdGhpcy5wcmVyZWxlYXNlLmxlbmd0aCYmIWQucHJlcmVsZWFzZS5sZW5ndGgpcmV0dXJuLTE7aWYoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGgmJmQucHJlcmVsZWFzZS5sZW5ndGgpcmV0dXJuIDE7aWYoIXRoaXMucHJlcmVsZWFzZS5sZW5ndGgmJiFkLnByZXJlbGVhc2UubGVuZ3RoKXJldHVybiAwO2xldCB5PTA7ZG97bGV0IGc9dGhpcy5wcmVyZWxlYXNlW3ldLGM9ZC5wcmVyZWxlYXNlW3ldO2lmKHQoXCJwcmVyZWxlYXNlIGNvbXBhcmVcIix5LGcsYyksZz09PXZvaWQgMCYmYz09PXZvaWQgMClyZXR1cm4gMDtpZihjPT09dm9pZCAwKXJldHVybiAxO2lmKGc9PT12b2lkIDApcmV0dXJuLTE7aWYoZz09PWMpY29udGludWU7cmV0dXJuIGwoZyxjKX13aGlsZSgrK3kpfWNvbXBhcmVCdWlsZChkKXtkIGluc3RhbmNlb2YgcHx8KGQ9bmV3IHAoZCx0aGlzLm9wdGlvbnMpKTtsZXQgeT0wO2Rve2xldCBnPXRoaXMuYnVpbGRbeV0sYz1kLmJ1aWxkW3ldO2lmKHQoXCJwcmVyZWxlYXNlIGNvbXBhcmVcIix5LGcsYyksZz09PXZvaWQgMCYmYz09PXZvaWQgMClyZXR1cm4gMDtpZihjPT09dm9pZCAwKXJldHVybiAxO2lmKGc9PT12b2lkIDApcmV0dXJuLTE7aWYoZz09PWMpY29udGludWU7cmV0dXJuIGwoZyxjKX13aGlsZSgrK3kpfWluYyhkLHkpe3N3aXRjaChkKXtjYXNlXCJwcmVtYWpvclwiOnRoaXMucHJlcmVsZWFzZS5sZW5ndGg9MCx0aGlzLnBhdGNoPTAsdGhpcy5taW5vcj0wLHRoaXMubWFqb3IrKyx0aGlzLmluYyhcInByZVwiLHkpO2JyZWFrO2Nhc2VcInByZW1pbm9yXCI6dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD0wLHRoaXMucGF0Y2g9MCx0aGlzLm1pbm9yKyssdGhpcy5pbmMoXCJwcmVcIix5KTticmVhaztjYXNlXCJwcmVwYXRjaFwiOnRoaXMucHJlcmVsZWFzZS5sZW5ndGg9MCx0aGlzLmluYyhcInBhdGNoXCIseSksdGhpcy5pbmMoXCJwcmVcIix5KTticmVhaztjYXNlXCJwcmVyZWxlYXNlXCI6dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD09PTAmJnRoaXMuaW5jKFwicGF0Y2hcIix5KSx0aGlzLmluYyhcInByZVwiLHkpO2JyZWFrO2Nhc2VcIm1ham9yXCI6KHRoaXMubWlub3IhPT0wfHx0aGlzLnBhdGNoIT09MHx8dGhpcy5wcmVyZWxlYXNlLmxlbmd0aD09PTApJiZ0aGlzLm1ham9yKyssdGhpcy5taW5vcj0wLHRoaXMucGF0Y2g9MCx0aGlzLnByZXJlbGVhc2U9W107YnJlYWs7Y2FzZVwibWlub3JcIjoodGhpcy5wYXRjaCE9PTB8fHRoaXMucHJlcmVsZWFzZS5sZW5ndGg9PT0wKSYmdGhpcy5taW5vcisrLHRoaXMucGF0Y2g9MCx0aGlzLnByZXJlbGVhc2U9W107YnJlYWs7Y2FzZVwicGF0Y2hcIjp0aGlzLnByZXJlbGVhc2UubGVuZ3RoPT09MCYmdGhpcy5wYXRjaCsrLHRoaXMucHJlcmVsZWFzZT1bXTticmVhaztjYXNlXCJwcmVcIjppZih0aGlzLnByZXJlbGVhc2UubGVuZ3RoPT09MCl0aGlzLnByZXJlbGVhc2U9WzBdO2Vsc2V7bGV0IGc9dGhpcy5wcmVyZWxlYXNlLmxlbmd0aDtmb3IoOy0tZz49MDspdHlwZW9mIHRoaXMucHJlcmVsZWFzZVtnXT09XCJudW1iZXJcIiYmKHRoaXMucHJlcmVsZWFzZVtnXSsrLGc9LTIpO2c9PT0tMSYmdGhpcy5wcmVyZWxlYXNlLnB1c2goMCl9eSYmKGwodGhpcy5wcmVyZWxlYXNlWzBdLHkpPT09MD9pc05hTih0aGlzLnByZXJlbGVhc2VbMV0pJiYodGhpcy5wcmVyZWxlYXNlPVt5LDBdKTp0aGlzLnByZXJlbGVhc2U9W3ksMF0pO2JyZWFrO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBpbnZhbGlkIGluY3JlbWVudCBhcmd1bWVudDogJHtkfWApfXJldHVybiB0aGlzLmZvcm1hdCgpLHRoaXMucmF3PXRoaXMudmVyc2lvbix0aGlzfX07ci5leHBvcnRzPXB9fSksem49dGUoe1wibm9kZV9tb2R1bGVzL3NlbXZlci9mdW5jdGlvbnMvY29tcGFyZS5qc1wiKGUscil7bmUoKTt2YXIgdD1HRCgpLHM9KGEsbix1KT0+bmV3IHQoYSx1KS5jb21wYXJlKG5ldyB0KG4sdSkpO3IuZXhwb3J0cz1zfX0pLFVEPXRlKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2x0LmpzXCIoZSxyKXtuZSgpO3ZhciB0PXpuKCkscz0oYSxuLHUpPT50KGEsbix1KTwwO3IuZXhwb3J0cz1zfX0pLEpEPXRlKHtcIm5vZGVfbW9kdWxlcy9zZW12ZXIvZnVuY3Rpb25zL2d0ZS5qc1wiKGUscil7bmUoKTt2YXIgdD16bigpLHM9KGEsbix1KT0+dChhLG4sdSk+PTA7ci5leHBvcnRzPXN9fSksekQ9dGUoe1wic3JjL3V0aWxzL2FycmF5aWZ5LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpLHIuZXhwb3J0cz0odCxzKT0+T2JqZWN0LmVudHJpZXModCkubWFwKGE9PntsZXRbbix1XT1hO3JldHVybiBPYmplY3QuYXNzaWduKHtbc106bn0sdSl9KX19KSxYRD10ZSh7XCJub2RlX21vZHVsZXMvb3V0ZGVudC9saWIvaW5kZXguanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5vdXRkZW50PXZvaWQgMDtmdW5jdGlvbiB0KCl7Zm9yKHZhciBGPVtdLFM9MDtTPGFyZ3VtZW50cy5sZW5ndGg7UysrKUZbU109YXJndW1lbnRzW1NdfWZ1bmN0aW9uIHMoKXtyZXR1cm4gdHlwZW9mIFdlYWtNYXA8XCJ1XCI/bmV3IFdlYWtNYXA6YSgpfWZ1bmN0aW9uIGEoKXtyZXR1cm57YWRkOnQsZGVsZXRlOnQsZ2V0OnQsc2V0OnQsaGFzOmZ1bmN0aW9uKEYpe3JldHVybiExfX19dmFyIG49T2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eSx1PWZ1bmN0aW9uKEYsUyl7cmV0dXJuIG4uY2FsbChGLFMpfTtmdW5jdGlvbiBpKEYsUyl7Zm9yKHZhciBOIGluIFMpdShTLE4pJiYoRltOXT1TW05dKTtyZXR1cm4gRn12YXIgbD0vXlsgXFx0XSooPzpcXHJcXG58XFxyfFxcbikvLHA9Lyg/OlxcclxcbnxcXHJ8XFxuKVsgXFx0XSokLyxkPS9eKD86W1xcclxcbl18JCkvLHk9Lyg/OlxcclxcbnxcXHJ8XFxuKShbIFxcdF0qKSg/OlteIFxcdFxcclxcbl18JCkvLGc9L15bIFxcdF0qW1xcclxcbl1bIFxcdFxcclxcbl0qJC87ZnVuY3Rpb24gYyhGLFMsTil7dmFyIEk9MCxQPUZbMF0ubWF0Y2goeSk7UCYmKEk9UFsxXS5sZW5ndGgpO3ZhciAkPVwiKFxcXFxyXFxcXG58XFxcXHJ8XFxcXG4pLnswLFwiK0krXCJ9XCIsZj1uZXcgUmVnRXhwKCQsXCJnXCIpO1MmJihGPUYuc2xpY2UoMSkpO3ZhciBUPU4ubmV3bGluZSxtPU4udHJpbUxlYWRpbmdOZXdsaW5lLHY9Ti50cmltVHJhaWxpbmdOZXdsaW5lLG89dHlwZW9mIFQ9PVwic3RyaW5nXCIsaD1GLmxlbmd0aCxDPUYubWFwKGZ1bmN0aW9uKHgsYil7cmV0dXJuIHg9eC5yZXBsYWNlKGYsXCIkMVwiKSxiPT09MCYmbSYmKHg9eC5yZXBsYWNlKGwsXCJcIikpLGI9PT1oLTEmJnYmJih4PXgucmVwbGFjZShwLFwiXCIpKSxvJiYoeD14LnJlcGxhY2UoL1xcclxcbnxcXG58XFxyL2csZnVuY3Rpb24oQil7cmV0dXJuIFR9KSkseH0pO3JldHVybiBDfWZ1bmN0aW9uIEQoRixTKXtmb3IodmFyIE49XCJcIixJPTAsUD1GLmxlbmd0aDtJPFA7SSsrKU4rPUZbSV0sSTxQLTEmJihOKz1TW0ldKTtyZXR1cm4gTn1mdW5jdGlvbiBFKEYpe3JldHVybiB1KEYsXCJyYXdcIikmJnUoRixcImxlbmd0aFwiKX1mdW5jdGlvbiBfKEYpe3ZhciBTPXMoKSxOPXMoKTtmdW5jdGlvbiBJKCQpe2Zvcih2YXIgZj1bXSxUPTE7VDxhcmd1bWVudHMubGVuZ3RoO1QrKylmW1QtMV09YXJndW1lbnRzW1RdO2lmKEUoJCkpe3ZhciBtPSQsdj0oZlswXT09PUl8fGZbMF09PT13KSYmZy50ZXN0KG1bMF0pJiZkLnRlc3QobVsxXSksbz12P046UyxoPW8uZ2V0KG0pO2lmKGh8fChoPWMobSx2LEYpLG8uc2V0KG0saCkpLGYubGVuZ3RoPT09MClyZXR1cm4gaFswXTt2YXIgQz1EKGgsdj9mLnNsaWNlKDEpOmYpO3JldHVybiBDfWVsc2UgcmV0dXJuIF8oaShpKHt9LEYpLCR8fHt9KSl9dmFyIFA9aShJLHtzdHJpbmc6ZnVuY3Rpb24oJCl7cmV0dXJuIGMoWyRdLCExLEYpWzBdfX0pO3JldHVybiBQfXZhciB3PV8oe3RyaW1MZWFkaW5nTmV3bGluZTohMCx0cmltVHJhaWxpbmdOZXdsaW5lOiEwfSk7aWYoZS5vdXRkZW50PXcsZS5kZWZhdWx0PXcsdHlwZW9mIHI8XCJ1XCIpdHJ5e3IuZXhwb3J0cz13LE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh3LFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLHcuZGVmYXVsdD13LHcub3V0ZGVudD13fWNhdGNoe319fSksS0Q9dGUoe1wic3JjL21haW4vY29yZS1vcHRpb25zLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntvdXRkZW50OnR9PVhEKCkscz1cIkNvbmZpZ1wiLGE9XCJFZGl0b3JcIixuPVwiRm9ybWF0XCIsdT1cIk90aGVyXCIsaT1cIk91dHB1dFwiLGw9XCJHbG9iYWxcIixwPVwiU3BlY2lhbFwiLGQ9e2N1cnNvck9mZnNldDp7c2luY2U6XCIxLjQuMFwiLGNhdGVnb3J5OnAsdHlwZTpcImludFwiLGRlZmF1bHQ6LTEscmFuZ2U6e3N0YXJ0Oi0xLGVuZDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksc3RlcDoxfSxkZXNjcmlwdGlvbjp0YFxuICAgICAgUHJpbnQgKHRvIHN0ZGVycikgd2hlcmUgYSBjdXJzb3IgYXQgdGhlIGdpdmVuIHBvc2l0aW9uIHdvdWxkIG1vdmUgdG8gYWZ0ZXIgZm9ybWF0dGluZy5cbiAgICAgIFRoaXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggLS1yYW5nZS1zdGFydCBhbmQgLS1yYW5nZS1lbmQuXG4gICAgYCxjbGlDYXRlZ29yeTphfSxlbmRPZkxpbmU6e3NpbmNlOlwiMS4xNS4wXCIsY2F0ZWdvcnk6bCx0eXBlOlwiY2hvaWNlXCIsZGVmYXVsdDpbe3NpbmNlOlwiMS4xNS4wXCIsdmFsdWU6XCJhdXRvXCJ9LHtzaW5jZTpcIjIuMC4wXCIsdmFsdWU6XCJsZlwifV0sZGVzY3JpcHRpb246XCJXaGljaCBlbmQgb2YgbGluZSBjaGFyYWN0ZXJzIHRvIGFwcGx5LlwiLGNob2ljZXM6W3t2YWx1ZTpcImxmXCIsZGVzY3JpcHRpb246XCJMaW5lIEZlZWQgb25seSAoXFxcXG4pLCBjb21tb24gb24gTGludXggYW5kIG1hY09TIGFzIHdlbGwgYXMgaW5zaWRlIGdpdCByZXBvc1wifSx7dmFsdWU6XCJjcmxmXCIsZGVzY3JpcHRpb246XCJDYXJyaWFnZSBSZXR1cm4gKyBMaW5lIEZlZWQgY2hhcmFjdGVycyAoXFxcXHJcXFxcbiksIGNvbW1vbiBvbiBXaW5kb3dzXCJ9LHt2YWx1ZTpcImNyXCIsZGVzY3JpcHRpb246XCJDYXJyaWFnZSBSZXR1cm4gY2hhcmFjdGVyIG9ubHkgKFxcXFxyKSwgdXNlZCB2ZXJ5IHJhcmVseVwifSx7dmFsdWU6XCJhdXRvXCIsZGVzY3JpcHRpb246dGBcbiAgICAgICAgICBNYWludGFpbiBleGlzdGluZ1xuICAgICAgICAgIChtaXhlZCB2YWx1ZXMgd2l0aGluIG9uZSBmaWxlIGFyZSBub3JtYWxpc2VkIGJ5IGxvb2tpbmcgYXQgd2hhdCdzIHVzZWQgYWZ0ZXIgdGhlIGZpcnN0IGxpbmUpXG4gICAgICAgIGB9XX0sZmlsZXBhdGg6e3NpbmNlOlwiMS40LjBcIixjYXRlZ29yeTpwLHR5cGU6XCJwYXRoXCIsZGVzY3JpcHRpb246XCJTcGVjaWZ5IHRoZSBpbnB1dCBmaWxlcGF0aC4gVGhpcyB3aWxsIGJlIHVzZWQgdG8gZG8gcGFyc2VyIGluZmVyZW5jZS5cIixjbGlOYW1lOlwic3RkaW4tZmlsZXBhdGhcIixjbGlDYXRlZ29yeTp1LGNsaURlc2NyaXB0aW9uOlwiUGF0aCB0byB0aGUgZmlsZSB0byBwcmV0ZW5kIHRoYXQgc3RkaW4gY29tZXMgZnJvbS5cIn0saW5zZXJ0UHJhZ21hOntzaW5jZTpcIjEuOC4wXCIsY2F0ZWdvcnk6cCx0eXBlOlwiYm9vbGVhblwiLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJJbnNlcnQgQGZvcm1hdCBwcmFnbWEgaW50byBmaWxlJ3MgZmlyc3QgZG9jYmxvY2sgY29tbWVudC5cIixjbGlDYXRlZ29yeTp1fSxwYXJzZXI6e3NpbmNlOlwiMC4wLjEwXCIsY2F0ZWdvcnk6bCx0eXBlOlwiY2hvaWNlXCIsZGVmYXVsdDpbe3NpbmNlOlwiMC4wLjEwXCIsdmFsdWU6XCJiYWJ5bG9uXCJ9LHtzaW5jZTpcIjEuMTMuMFwiLHZhbHVlOnZvaWQgMH1dLGRlc2NyaXB0aW9uOlwiV2hpY2ggcGFyc2VyIHRvIHVzZS5cIixleGNlcHRpb246eT0+dHlwZW9mIHk9PVwic3RyaW5nXCJ8fHR5cGVvZiB5PT1cImZ1bmN0aW9uXCIsY2hvaWNlczpbe3ZhbHVlOlwiZmxvd1wiLGRlc2NyaXB0aW9uOlwiRmxvd1wifSx7dmFsdWU6XCJiYWJlbFwiLHNpbmNlOlwiMS4xNi4wXCIsZGVzY3JpcHRpb246XCJKYXZhU2NyaXB0XCJ9LHt2YWx1ZTpcImJhYmVsLWZsb3dcIixzaW5jZTpcIjEuMTYuMFwiLGRlc2NyaXB0aW9uOlwiRmxvd1wifSx7dmFsdWU6XCJiYWJlbC10c1wiLHNpbmNlOlwiMi4wLjBcIixkZXNjcmlwdGlvbjpcIlR5cGVTY3JpcHRcIn0se3ZhbHVlOlwidHlwZXNjcmlwdFwiLHNpbmNlOlwiMS40LjBcIixkZXNjcmlwdGlvbjpcIlR5cGVTY3JpcHRcIn0se3ZhbHVlOlwiYWNvcm5cIixzaW5jZTpcIjIuNi4wXCIsZGVzY3JpcHRpb246XCJKYXZhU2NyaXB0XCJ9LHt2YWx1ZTpcImVzcHJlZVwiLHNpbmNlOlwiMi4yLjBcIixkZXNjcmlwdGlvbjpcIkphdmFTY3JpcHRcIn0se3ZhbHVlOlwibWVyaXlhaFwiLHNpbmNlOlwiMi4yLjBcIixkZXNjcmlwdGlvbjpcIkphdmFTY3JpcHRcIn0se3ZhbHVlOlwiY3NzXCIsc2luY2U6XCIxLjcuMVwiLGRlc2NyaXB0aW9uOlwiQ1NTXCJ9LHt2YWx1ZTpcImxlc3NcIixzaW5jZTpcIjEuNy4xXCIsZGVzY3JpcHRpb246XCJMZXNzXCJ9LHt2YWx1ZTpcInNjc3NcIixzaW5jZTpcIjEuNy4xXCIsZGVzY3JpcHRpb246XCJTQ1NTXCJ9LHt2YWx1ZTpcImpzb25cIixzaW5jZTpcIjEuNS4wXCIsZGVzY3JpcHRpb246XCJKU09OXCJ9LHt2YWx1ZTpcImpzb241XCIsc2luY2U6XCIxLjEzLjBcIixkZXNjcmlwdGlvbjpcIkpTT041XCJ9LHt2YWx1ZTpcImpzb24tc3RyaW5naWZ5XCIsc2luY2U6XCIxLjEzLjBcIixkZXNjcmlwdGlvbjpcIkpTT04uc3RyaW5naWZ5XCJ9LHt2YWx1ZTpcImdyYXBocWxcIixzaW5jZTpcIjEuNS4wXCIsZGVzY3JpcHRpb246XCJHcmFwaFFMXCJ9LHt2YWx1ZTpcIm1hcmtkb3duXCIsc2luY2U6XCIxLjguMFwiLGRlc2NyaXB0aW9uOlwiTWFya2Rvd25cIn0se3ZhbHVlOlwibWR4XCIsc2luY2U6XCIxLjE1LjBcIixkZXNjcmlwdGlvbjpcIk1EWFwifSx7dmFsdWU6XCJ2dWVcIixzaW5jZTpcIjEuMTAuMFwiLGRlc2NyaXB0aW9uOlwiVnVlXCJ9LHt2YWx1ZTpcInlhbWxcIixzaW5jZTpcIjEuMTQuMFwiLGRlc2NyaXB0aW9uOlwiWUFNTFwifSx7dmFsdWU6XCJnbGltbWVyXCIsc2luY2U6XCIyLjMuMFwiLGRlc2NyaXB0aW9uOlwiRW1iZXIgLyBIYW5kbGViYXJzXCJ9LHt2YWx1ZTpcImh0bWxcIixzaW5jZTpcIjEuMTUuMFwiLGRlc2NyaXB0aW9uOlwiSFRNTFwifSx7dmFsdWU6XCJhbmd1bGFyXCIsc2luY2U6XCIxLjE1LjBcIixkZXNjcmlwdGlvbjpcIkFuZ3VsYXJcIn0se3ZhbHVlOlwibHdjXCIsc2luY2U6XCIxLjE3LjBcIixkZXNjcmlwdGlvbjpcIkxpZ2h0bmluZyBXZWIgQ29tcG9uZW50c1wifV19LHBsdWdpbnM6e3NpbmNlOlwiMS4xMC4wXCIsdHlwZTpcInBhdGhcIixhcnJheTohMCxkZWZhdWx0Olt7dmFsdWU6W119XSxjYXRlZ29yeTpsLGRlc2NyaXB0aW9uOlwiQWRkIGEgcGx1Z2luLiBNdWx0aXBsZSBwbHVnaW5zIGNhbiBiZSBwYXNzZWQgYXMgc2VwYXJhdGUgYC0tcGx1Z2luYHMuXCIsZXhjZXB0aW9uOnk9PnR5cGVvZiB5PT1cInN0cmluZ1wifHx0eXBlb2YgeT09XCJvYmplY3RcIixjbGlOYW1lOlwicGx1Z2luXCIsY2xpQ2F0ZWdvcnk6c30scGx1Z2luU2VhcmNoRGlyczp7c2luY2U6XCIxLjEzLjBcIix0eXBlOlwicGF0aFwiLGFycmF5OiEwLGRlZmF1bHQ6W3t2YWx1ZTpbXX1dLGNhdGVnb3J5OmwsZGVzY3JpcHRpb246dGBcbiAgICAgIEN1c3RvbSBkaXJlY3RvcnkgdGhhdCBjb250YWlucyBwcmV0dGllciBwbHVnaW5zIGluIG5vZGVfbW9kdWxlcyBzdWJkaXJlY3RvcnkuXG4gICAgICBPdmVycmlkZXMgZGVmYXVsdCBiZWhhdmlvciB3aGVuIHBsdWdpbnMgYXJlIHNlYXJjaGVkIHJlbGF0aXZlbHkgdG8gdGhlIGxvY2F0aW9uIG9mIFByZXR0aWVyLlxuICAgICAgTXVsdGlwbGUgdmFsdWVzIGFyZSBhY2NlcHRlZC5cbiAgICBgLGV4Y2VwdGlvbjp5PT50eXBlb2YgeT09XCJzdHJpbmdcInx8dHlwZW9mIHk9PVwib2JqZWN0XCIsY2xpTmFtZTpcInBsdWdpbi1zZWFyY2gtZGlyXCIsY2xpQ2F0ZWdvcnk6c30scHJpbnRXaWR0aDp7c2luY2U6XCIwLjAuMFwiLGNhdGVnb3J5OmwsdHlwZTpcImludFwiLGRlZmF1bHQ6ODAsZGVzY3JpcHRpb246XCJUaGUgbGluZSBsZW5ndGggd2hlcmUgUHJldHRpZXIgd2lsbCB0cnkgd3JhcC5cIixyYW5nZTp7c3RhcnQ6MCxlbmQ6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHN0ZXA6MX19LHJhbmdlRW5kOntzaW5jZTpcIjEuNC4wXCIsY2F0ZWdvcnk6cCx0eXBlOlwiaW50XCIsZGVmYXVsdDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFkscmFuZ2U6e3N0YXJ0OjAsZW5kOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxzdGVwOjF9LGRlc2NyaXB0aW9uOnRgXG4gICAgICBGb3JtYXQgY29kZSBlbmRpbmcgYXQgYSBnaXZlbiBjaGFyYWN0ZXIgb2Zmc2V0IChleGNsdXNpdmUpLlxuICAgICAgVGhlIHJhbmdlIHdpbGwgZXh0ZW5kIGZvcndhcmRzIHRvIHRoZSBlbmQgb2YgdGhlIHNlbGVjdGVkIHN0YXRlbWVudC5cbiAgICAgIFRoaXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggLS1jdXJzb3Itb2Zmc2V0LlxuICAgIGAsY2xpQ2F0ZWdvcnk6YX0scmFuZ2VTdGFydDp7c2luY2U6XCIxLjQuMFwiLGNhdGVnb3J5OnAsdHlwZTpcImludFwiLGRlZmF1bHQ6MCxyYW5nZTp7c3RhcnQ6MCxlbmQ6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZLHN0ZXA6MX0sZGVzY3JpcHRpb246dGBcbiAgICAgIEZvcm1hdCBjb2RlIHN0YXJ0aW5nIGF0IGEgZ2l2ZW4gY2hhcmFjdGVyIG9mZnNldC5cbiAgICAgIFRoZSByYW5nZSB3aWxsIGV4dGVuZCBiYWNrd2FyZHMgdG8gdGhlIHN0YXJ0IG9mIHRoZSBmaXJzdCBsaW5lIGNvbnRhaW5pbmcgdGhlIHNlbGVjdGVkIHN0YXRlbWVudC5cbiAgICAgIFRoaXMgb3B0aW9uIGNhbm5vdCBiZSB1c2VkIHdpdGggLS1jdXJzb3Itb2Zmc2V0LlxuICAgIGAsY2xpQ2F0ZWdvcnk6YX0scmVxdWlyZVByYWdtYTp7c2luY2U6XCIxLjcuMFwiLGNhdGVnb3J5OnAsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiExLGRlc2NyaXB0aW9uOnRgXG4gICAgICBSZXF1aXJlIGVpdGhlciAnQHByZXR0aWVyJyBvciAnQGZvcm1hdCcgdG8gYmUgcHJlc2VudCBpbiB0aGUgZmlsZSdzIGZpcnN0IGRvY2Jsb2NrIGNvbW1lbnRcbiAgICAgIGluIG9yZGVyIGZvciBpdCB0byBiZSBmb3JtYXR0ZWQuXG4gICAgYCxjbGlDYXRlZ29yeTp1fSx0YWJXaWR0aDp7dHlwZTpcImludFwiLGNhdGVnb3J5OmwsZGVmYXVsdDoyLGRlc2NyaXB0aW9uOlwiTnVtYmVyIG9mIHNwYWNlcyBwZXIgaW5kZW50YXRpb24gbGV2ZWwuXCIscmFuZ2U6e3N0YXJ0OjAsZW5kOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxzdGVwOjF9fSx1c2VUYWJzOntzaW5jZTpcIjEuMC4wXCIsY2F0ZWdvcnk6bCx0eXBlOlwiYm9vbGVhblwiLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJJbmRlbnQgd2l0aCB0YWJzIGluc3RlYWQgb2Ygc3BhY2VzLlwifSxlbWJlZGRlZExhbmd1YWdlRm9ybWF0dGluZzp7c2luY2U6XCIyLjEuMFwiLGNhdGVnb3J5OmwsdHlwZTpcImNob2ljZVwiLGRlZmF1bHQ6W3tzaW5jZTpcIjIuMS4wXCIsdmFsdWU6XCJhdXRvXCJ9XSxkZXNjcmlwdGlvbjpcIkNvbnRyb2wgaG93IFByZXR0aWVyIGZvcm1hdHMgcXVvdGVkIGNvZGUgZW1iZWRkZWQgaW4gdGhlIGZpbGUuXCIsY2hvaWNlczpbe3ZhbHVlOlwiYXV0b1wiLGRlc2NyaXB0aW9uOlwiRm9ybWF0IGVtYmVkZGVkIGNvZGUgaWYgUHJldHRpZXIgY2FuIGF1dG9tYXRpY2FsbHkgaWRlbnRpZnkgaXQuXCJ9LHt2YWx1ZTpcIm9mZlwiLGRlc2NyaXB0aW9uOlwiTmV2ZXIgYXV0b21hdGljYWxseSBmb3JtYXQgZW1iZWRkZWQgY29kZS5cIn1dfX07ci5leHBvcnRzPXtDQVRFR09SWV9DT05GSUc6cyxDQVRFR09SWV9FRElUT1I6YSxDQVRFR09SWV9GT1JNQVQ6bixDQVRFR09SWV9PVEhFUjp1LENBVEVHT1JZX09VVFBVVDppLENBVEVHT1JZX0dMT0JBTDpsLENBVEVHT1JZX1NQRUNJQUw6cCxvcHRpb25zOmR9fX0pLFhuPXRlKHtcInNyYy9tYWluL3N1cHBvcnQuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9e2NvbXBhcmU6em4oKSxsdDpVRCgpLGd0ZTpKRCgpfSxzPXpEKCksYT1JYSgpLnZlcnNpb24sbj1LRCgpLm9wdGlvbnM7ZnVuY3Rpb24gdSgpe2xldHtwbHVnaW5zOmw9W10sc2hvd1VucmVsZWFzZWQ6cD0hMSxzaG93RGVwcmVjYXRlZDpkPSExLHNob3dJbnRlcm5hbDp5PSExfT1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06e30sZz1hLnNwbGl0KFwiLVwiLDEpWzBdLGM9bC5mbGF0TWFwKEY9PkYubGFuZ3VhZ2VzfHxbXSkuZmlsdGVyKEUpLEQ9cyhPYmplY3QuYXNzaWduKHt9LC4uLmwubWFwKEY9PntsZXR7b3B0aW9uczpTfT1GO3JldHVybiBTfSksbiksXCJuYW1lXCIpLmZpbHRlcihGPT5FKEYpJiZfKEYpKS5zb3J0KChGLFMpPT5GLm5hbWU9PT1TLm5hbWU/MDpGLm5hbWU8Uy5uYW1lPy0xOjEpLm1hcCh3KS5tYXAoRj0+e0Y9T2JqZWN0LmFzc2lnbih7fSxGKSxBcnJheS5pc0FycmF5KEYuZGVmYXVsdCkmJihGLmRlZmF1bHQ9Ri5kZWZhdWx0Lmxlbmd0aD09PTE/Ri5kZWZhdWx0WzBdLnZhbHVlOkYuZGVmYXVsdC5maWx0ZXIoRSkuc29ydCgoTixJKT0+dC5jb21wYXJlKEkuc2luY2UsTi5zaW5jZSkpWzBdLnZhbHVlKSxBcnJheS5pc0FycmF5KEYuY2hvaWNlcykmJihGLmNob2ljZXM9Ri5jaG9pY2VzLmZpbHRlcihOPT5FKE4pJiZfKE4pKSxGLm5hbWU9PT1cInBhcnNlclwiJiZpKEYsYyxsKSk7bGV0IFM9T2JqZWN0LmZyb21FbnRyaWVzKGwuZmlsdGVyKE49Pk4uZGVmYXVsdE9wdGlvbnMmJk4uZGVmYXVsdE9wdGlvbnNbRi5uYW1lXSE9PXZvaWQgMCkubWFwKE49PltOLm5hbWUsTi5kZWZhdWx0T3B0aW9uc1tGLm5hbWVdXSkpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sRikse30se3BsdWdpbkRlZmF1bHRzOlN9KX0pO3JldHVybntsYW5ndWFnZXM6YyxvcHRpb25zOkR9O2Z1bmN0aW9uIEUoRil7cmV0dXJuIHB8fCEoXCJzaW5jZVwiaW4gRil8fEYuc2luY2UmJnQuZ3RlKGcsRi5zaW5jZSl9ZnVuY3Rpb24gXyhGKXtyZXR1cm4gZHx8IShcImRlcHJlY2F0ZWRcImluIEYpfHxGLmRlcHJlY2F0ZWQmJnQubHQoZyxGLmRlcHJlY2F0ZWQpfWZ1bmN0aW9uIHcoRil7aWYoeSlyZXR1cm4gRjtsZXR7Y2xpTmFtZTpTLGNsaUNhdGVnb3J5Ok4sY2xpRGVzY3JpcHRpb246SX09RjtyZXR1cm4gSG4oRixoRCl9fWZ1bmN0aW9uIGkobCxwLGQpe2xldCB5PW5ldyBTZXQobC5jaG9pY2VzLm1hcChnPT5nLnZhbHVlKSk7Zm9yKGxldCBnIG9mIHApaWYoZy5wYXJzZXJzKXtmb3IobGV0IGMgb2YgZy5wYXJzZXJzKWlmKCF5LmhhcyhjKSl7eS5hZGQoYyk7bGV0IEQ9ZC5maW5kKF89Pl8ucGFyc2VycyYmXy5wYXJzZXJzW2NdKSxFPWcubmFtZTtEJiZELm5hbWUmJihFKz1gIChwbHVnaW46ICR7RC5uYW1lfSlgKSxsLmNob2ljZXMucHVzaCh7dmFsdWU6YyxkZXNjcmlwdGlvbjpFfSl9fX1yLmV4cG9ydHM9e2dldFN1cHBvcnRJbmZvOnV9fX0pLEtuPXRlKHtcInNyYy91dGlscy9pcy1ub24tZW1wdHktYXJyYXkuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7ZnVuY3Rpb24gdChzKXtyZXR1cm4gQXJyYXkuaXNBcnJheShzKSYmcy5sZW5ndGg+MH1yLmV4cG9ydHM9dH19KSxQcj10ZSh7XCJzcmMvdXRpbHMvdGV4dC9za2lwLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO2Z1bmN0aW9uIHQoaSl7cmV0dXJuKGwscCxkKT0+e2xldCB5PWQmJmQuYmFja3dhcmRzO2lmKHA9PT0hMSlyZXR1cm4hMTtsZXR7bGVuZ3RoOmd9PWwsYz1wO2Zvcig7Yz49MCYmYzxnOyl7bGV0IEQ9bC5jaGFyQXQoYyk7aWYoaSBpbnN0YW5jZW9mIFJlZ0V4cCl7aWYoIWkudGVzdChEKSlyZXR1cm4gY31lbHNlIGlmKCFpLmluY2x1ZGVzKEQpKXJldHVybiBjO3k/Yy0tOmMrK31yZXR1cm4gYz09PS0xfHxjPT09Zz9jOiExfX12YXIgcz10KC9cXHMvKSxhPXQoXCIgXHRcIiksbj10KFwiLDsgXHRcIiksdT10KC9bXlxcblxccl0vKTtyLmV4cG9ydHM9e3NraXBXaGl0ZXNwYWNlOnMsc2tpcFNwYWNlczphLHNraXBUb0xpbmVFbmQ6bixza2lwRXZlcnl0aGluZ0J1dE5ld0xpbmU6dX19fSksUmE9dGUoe1wic3JjL3V0aWxzL3RleHQvc2tpcC1pbmxpbmUtY29tbWVudC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KHMsYSl7aWYoYT09PSExKXJldHVybiExO2lmKHMuY2hhckF0KGEpPT09XCIvXCImJnMuY2hhckF0KGErMSk9PT1cIipcIil7Zm9yKGxldCBuPWErMjtuPHMubGVuZ3RoOysrbilpZihzLmNoYXJBdChuKT09PVwiKlwiJiZzLmNoYXJBdChuKzEpPT09XCIvXCIpcmV0dXJuIG4rMn1yZXR1cm4gYX1yLmV4cG9ydHM9dH19KSwkYT10ZSh7XCJzcmMvdXRpbHMvdGV4dC9za2lwLXRyYWlsaW5nLWNvbW1lbnQuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3NraXBFdmVyeXRoaW5nQnV0TmV3TGluZTp0fT1QcigpO2Z1bmN0aW9uIHMoYSxuKXtyZXR1cm4gbj09PSExPyExOmEuY2hhckF0KG4pPT09XCIvXCImJmEuY2hhckF0KG4rMSk9PT1cIi9cIj90KGEsbik6bn1yLmV4cG9ydHM9c319KSxWYT10ZSh7XCJzcmMvdXRpbHMvdGV4dC9za2lwLW5ld2xpbmUuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7ZnVuY3Rpb24gdChzLGEsbil7bGV0IHU9biYmbi5iYWNrd2FyZHM7aWYoYT09PSExKXJldHVybiExO2xldCBpPXMuY2hhckF0KGEpO2lmKHUpe2lmKHMuY2hhckF0KGEtMSk9PT1cIlxcclwiJiZpPT09YFxuYClyZXR1cm4gYS0yO2lmKGk9PT1gXG5gfHxpPT09XCJcXHJcInx8aT09PVwiXFx1MjAyOFwifHxpPT09XCJcXHUyMDI5XCIpcmV0dXJuIGEtMX1lbHNle2lmKGk9PT1cIlxcclwiJiZzLmNoYXJBdChhKzEpPT09YFxuYClyZXR1cm4gYSsyO2lmKGk9PT1gXG5gfHxpPT09XCJcXHJcInx8aT09PVwiXFx1MjAyOFwifHxpPT09XCJcXHUyMDI5XCIpcmV0dXJuIGErMX1yZXR1cm4gYX1yLmV4cG9ydHM9dH19KSxZRD10ZSh7XCJzcmMvdXRpbHMvdGV4dC9nZXQtbmV4dC1ub24tc3BhY2Utbm9uLWNvbW1lbnQtY2hhcmFjdGVyLWluZGV4LXdpdGgtc3RhcnQtaW5kZXguanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9UmEoKSxzPVZhKCksYT0kYSgpLHtza2lwU3BhY2VzOm59PVByKCk7ZnVuY3Rpb24gdShpLGwpe2xldCBwPW51bGwsZD1sO2Zvcig7ZCE9PXA7KXA9ZCxkPW4oaSxkKSxkPXQoaSxkKSxkPWEoaSxkKSxkPXMoaSxkKTtyZXR1cm4gZH1yLmV4cG9ydHM9dX19KSxVZT10ZSh7XCJzcmMvY29tbW9uL3V0aWwuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2RlZmF1bHQ6dH09KCREKCksZnQoamEpKSxzPWx0KCkse2dldFN1cHBvcnRJbmZvOmF9PVhuKCksbj1LbigpLHU9T2EoKSx7c2tpcFdoaXRlc3BhY2U6aSxza2lwU3BhY2VzOmwsc2tpcFRvTGluZUVuZDpwLHNraXBFdmVyeXRoaW5nQnV0TmV3TGluZTpkfT1QcigpLHk9UmEoKSxnPSRhKCksYz1WYSgpLEQ9WUQoKSxFPVY9PlZbVi5sZW5ndGgtMl07ZnVuY3Rpb24gXyhWKXtyZXR1cm4oaixZLGllKT0+e2xldCBlZT1pZSYmaWUuYmFja3dhcmRzO2lmKFk9PT0hMSlyZXR1cm4hMTtsZXR7bGVuZ3RoOmxlfT1qLFc9WTtmb3IoO1c+PTAmJlc8bGU7KXtsZXQgSz1qLmNoYXJBdChXKTtpZihWIGluc3RhbmNlb2YgUmVnRXhwKXtpZighVi50ZXN0KEspKXJldHVybiBXfWVsc2UgaWYoIVYuaW5jbHVkZXMoSykpcmV0dXJuIFc7ZWU/Vy0tOlcrK31yZXR1cm4gVz09PS0xfHxXPT09bGU/VzohMX19ZnVuY3Rpb24gdyhWLGope2xldCBZPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTp7fSxpZT1sKFYsWS5iYWNrd2FyZHM/ai0xOmosWSksZWU9YyhWLGllLFkpO3JldHVybiBpZSE9PWVlfWZ1bmN0aW9uIEYoVixqLFkpe2ZvcihsZXQgaWU9ajtpZTxZOysraWUpaWYoVi5jaGFyQXQoaWUpPT09YFxuYClyZXR1cm4hMDtyZXR1cm4hMX1mdW5jdGlvbiBTKFYsaixZKXtsZXQgaWU9WShqKS0xO2llPWwoVixpZSx7YmFja3dhcmRzOiEwfSksaWU9YyhWLGllLHtiYWNrd2FyZHM6ITB9KSxpZT1sKFYsaWUse2JhY2t3YXJkczohMH0pO2xldCBlZT1jKFYsaWUse2JhY2t3YXJkczohMH0pO3JldHVybiBpZSE9PWVlfWZ1bmN0aW9uIE4oVixqKXtsZXQgWT1udWxsLGllPWo7Zm9yKDtpZSE9PVk7KVk9aWUsaWU9cChWLGllKSxpZT15KFYsaWUpLGllPWwoVixpZSk7cmV0dXJuIGllPWcoVixpZSksaWU9YyhWLGllKSxpZSE9PSExJiZ3KFYsaWUpfWZ1bmN0aW9uIEkoVixqLFkpe3JldHVybiBOKFYsWShqKSl9ZnVuY3Rpb24gUChWLGosWSl7cmV0dXJuIEQoVixZKGopKX1mdW5jdGlvbiAkKFYsaixZKXtyZXR1cm4gVi5jaGFyQXQoUChWLGosWSkpfWZ1bmN0aW9uIGYoVixqKXtsZXQgWT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06e307cmV0dXJuIGwoVixZLmJhY2t3YXJkcz9qLTE6aixZKSE9PWp9ZnVuY3Rpb24gVChWLGope2xldCBZPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTowLGllPTA7Zm9yKGxldCBlZT1ZO2VlPFYubGVuZ3RoOysrZWUpVltlZV09PT1cIlx0XCI/aWU9aWUrai1pZSVqOmllKys7cmV0dXJuIGllfWZ1bmN0aW9uIG0oVixqKXtsZXQgWT1WLmxhc3RJbmRleE9mKGBcbmApO3JldHVybiBZPT09LTE/MDpUKFYuc2xpY2UoWSsxKS5tYXRjaCgvXltcXHQgXSovKVswXSxqKX1mdW5jdGlvbiB2KFYsail7bGV0IFk9e3F1b3RlOidcIicscmVnZXg6L1wiL2csZXNjYXBlZDpcIiZxdW90O1wifSxpZT17cXVvdGU6XCInXCIscmVnZXg6LycvZyxlc2NhcGVkOlwiJmFwb3M7XCJ9LGVlPWo9PT1cIidcIj9pZTpZLGxlPWVlPT09aWU/WTppZSxXPWVlO2lmKFYuaW5jbHVkZXMoZWUucXVvdGUpfHxWLmluY2x1ZGVzKGxlLnF1b3RlKSl7bGV0IEs9KFYubWF0Y2goZWUucmVnZXgpfHxbXSkubGVuZ3RoLGRlPShWLm1hdGNoKGxlLnJlZ2V4KXx8W10pLmxlbmd0aDtXPUs+ZGU/bGU6ZWV9cmV0dXJuIFd9ZnVuY3Rpb24gbyhWLGope2xldCBZPVYuc2xpY2UoMSwtMSksaWU9ai5wYXJzZXI9PT1cImpzb25cInx8ai5wYXJzZXI9PT1cImpzb241XCImJmoucXVvdGVQcm9wcz09PVwicHJlc2VydmVcIiYmIWouc2luZ2xlUXVvdGU/J1wiJzpqLl9faXNJbkh0bWxBdHRyaWJ1dGU/XCInXCI6dihZLGouc2luZ2xlUXVvdGU/XCInXCI6J1wiJykucXVvdGU7cmV0dXJuIGgoWSxpZSwhKGoucGFyc2VyPT09XCJjc3NcInx8ai5wYXJzZXI9PT1cImxlc3NcInx8ai5wYXJzZXI9PT1cInNjc3NcInx8ai5fX2VtYmVkZGVkSW5IdG1sKSl9ZnVuY3Rpb24gaChWLGosWSl7bGV0IGllPWo9PT0nXCInP1wiJ1wiOidcIicsZWU9L1xcXFwoLil8KFtcIiddKS9ncyxsZT1WLnJlcGxhY2UoZWUsKFcsSyxkZSk9Pks9PT1pZT9LOmRlPT09aj9cIlxcXFxcIitkZTpkZXx8KFkmJi9eW15cXG5cXHJcIicwLTdcXFxcYmZucnQtdnhcXHUyMDI4XFx1MjAyOV0kLy50ZXN0KEspP0s6XCJcXFxcXCIrSykpO3JldHVybiBqK2xlK2p9ZnVuY3Rpb24gQyhWKXtyZXR1cm4gVi50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL14oWystXT9bXFxkLl0rZSkoPzpcXCt8KC0pKT8wKihcXGQpLyxcIiQxJDIkM1wiKS5yZXBsYWNlKC9eKFsrLV0/W1xcZC5dKyllWystXT8wKyQvLFwiJDFcIikucmVwbGFjZSgvXihbKy1dKT9cXC4vLFwiJDEwLlwiKS5yZXBsYWNlKC8oXFwuXFxkKz8pMCsoPz1lfCQpLyxcIiQxXCIpLnJlcGxhY2UoL1xcLig/PWV8JCkvLFwiXCIpfWZ1bmN0aW9uIHgoVixqKXtsZXQgWT1WLm1hdGNoKG5ldyBSZWdFeHAoYCgke3Qoail9KStgLFwiZ1wiKSk7cmV0dXJuIFk9PT1udWxsPzA6WS5yZWR1Y2UoKGllLGVlKT0+TWF0aC5tYXgoaWUsZWUubGVuZ3RoL2oubGVuZ3RoKSwwKX1mdW5jdGlvbiBiKFYsail7bGV0IFk9Vi5tYXRjaChuZXcgUmVnRXhwKGAoJHt0KGopfSkrYCxcImdcIikpO2lmKFk9PT1udWxsKXJldHVybiAwO2xldCBpZT1uZXcgTWFwLGVlPTA7Zm9yKGxldCBsZSBvZiBZKXtsZXQgVz1sZS5sZW5ndGgvai5sZW5ndGg7aWUuc2V0KFcsITApLFc+ZWUmJihlZT1XKX1mb3IobGV0IGxlPTE7bGU8ZWU7bGUrKylpZighaWUuZ2V0KGxlKSlyZXR1cm4gbGU7cmV0dXJuIGVlKzF9ZnVuY3Rpb24gQihWLGopeyhWLmNvbW1lbnRzfHwoVi5jb21tZW50cz1bXSkpLnB1c2goaiksai5wcmludGVkPSExLGoubm9kZURlc2NyaXB0aW9uPVEoVil9ZnVuY3Rpb24gayhWLGope2oubGVhZGluZz0hMCxqLnRyYWlsaW5nPSExLEIoVixqKX1mdW5jdGlvbiBNKFYsaixZKXtqLmxlYWRpbmc9ITEsai50cmFpbGluZz0hMSxZJiYoai5tYXJrZXI9WSksQihWLGopfWZ1bmN0aW9uIFIoVixqKXtqLmxlYWRpbmc9ITEsai50cmFpbGluZz0hMCxCKFYsail9ZnVuY3Rpb24gcShWLGope2xldHtsYW5ndWFnZXM6WX09YSh7cGx1Z2luczpqLnBsdWdpbnN9KSxpZT1ZLmZpbmQoZWU9PntsZXR7bmFtZTpsZX09ZWU7cmV0dXJuIGxlLnRvTG93ZXJDYXNlKCk9PT1WfSl8fFkuZmluZChlZT0+e2xldHthbGlhc2VzOmxlfT1lZTtyZXR1cm4gQXJyYXkuaXNBcnJheShsZSkmJmxlLmluY2x1ZGVzKFYpfSl8fFkuZmluZChlZT0+e2xldHtleHRlbnNpb25zOmxlfT1lZTtyZXR1cm4gQXJyYXkuaXNBcnJheShsZSkmJmxlLmluY2x1ZGVzKGAuJHtWfWApfSk7cmV0dXJuIGllJiZpZS5wYXJzZXJzWzBdfWZ1bmN0aW9uIEooVil7cmV0dXJuIFYmJlYudHlwZT09PVwiZnJvbnQtbWF0dGVyXCJ9ZnVuY3Rpb24gTChWKXtsZXQgaj1uZXcgV2Vha01hcDtyZXR1cm4gZnVuY3Rpb24oWSl7cmV0dXJuIGouaGFzKFkpfHxqLnNldChZLFN5bWJvbChWKSksai5nZXQoWSl9fWZ1bmN0aW9uIFEoVil7bGV0IGo9Vi50eXBlfHxWLmtpbmR8fFwiKHVua25vd24gdHlwZSlcIixZPVN0cmluZyhWLm5hbWV8fFYuaWQmJih0eXBlb2YgVi5pZD09XCJvYmplY3RcIj9WLmlkLm5hbWU6Vi5pZCl8fFYua2V5JiYodHlwZW9mIFYua2V5PT1cIm9iamVjdFwiP1Yua2V5Lm5hbWU6Vi5rZXkpfHxWLnZhbHVlJiYodHlwZW9mIFYudmFsdWU9PVwib2JqZWN0XCI/XCJcIjpTdHJpbmcoVi52YWx1ZSkpfHxWLm9wZXJhdG9yfHxcIlwiKTtyZXR1cm4gWS5sZW5ndGg+MjAmJihZPVkuc2xpY2UoMCwxOSkrXCJcXHUyMDI2XCIpLGorKFk/XCIgXCIrWTpcIlwiKX1yLmV4cG9ydHM9e2luZmVyUGFyc2VyQnlMYW5ndWFnZTpxLGdldFN0cmluZ1dpZHRoOnUsZ2V0TWF4Q29udGludW91c0NvdW50OngsZ2V0TWluTm90UHJlc2VudENvbnRpbnVvdXNDb3VudDpiLGdldFBlbnVsdGltYXRlOkUsZ2V0TGFzdDpzLGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleFdpdGhTdGFydEluZGV4OkQsZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4OlAsZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlcjokLHNraXA6Xyxza2lwV2hpdGVzcGFjZTppLHNraXBTcGFjZXM6bCxza2lwVG9MaW5lRW5kOnAsc2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lOmQsc2tpcElubGluZUNvbW1lbnQ6eSxza2lwVHJhaWxpbmdDb21tZW50Omcsc2tpcE5ld2xpbmU6Yyxpc05leHRMaW5lRW1wdHlBZnRlckluZGV4Ok4saXNOZXh0TGluZUVtcHR5OkksaXNQcmV2aW91c0xpbmVFbXB0eTpTLGhhc05ld2xpbmU6dyxoYXNOZXdsaW5lSW5SYW5nZTpGLGhhc1NwYWNlczpmLGdldEFsaWdubWVudFNpemU6VCxnZXRJbmRlbnRTaXplOm0sZ2V0UHJlZmVycmVkUXVvdGU6dixwcmludFN0cmluZzpvLHByaW50TnVtYmVyOkMsbWFrZVN0cmluZzpoLGFkZExlYWRpbmdDb21tZW50OmssYWRkRGFuZ2xpbmdDb21tZW50Ok0sYWRkVHJhaWxpbmdDb21tZW50OlIsaXNGcm9udE1hdHRlck5vZGU6Sixpc05vbkVtcHR5QXJyYXk6bixjcmVhdGVHcm91cElkTWFwcGVyOkx9fX0pLFdhPXt9O0t0KFdhLHtiYXNlbmFtZTooKT0+emEsZGVmYXVsdDooKT0+S2EsZGVsaW1pdGVyOigpPT5NbixkaXJuYW1lOigpPT5KYSxleHRuYW1lOigpPT5YYSxpc0Fic29sdXRlOigpPT5Rbixqb2luOigpPT5HYSxub3JtYWxpemU6KCk9PlluLHJlbGF0aXZlOigpPT5VYSxyZXNvbHZlOigpPT53cixzZXA6KCk9PnFufSk7ZnVuY3Rpb24gSGEoZSxyKXtmb3IodmFyIHQ9MCxzPWUubGVuZ3RoLTE7cz49MDtzLS0pe3ZhciBhPWVbc107YT09PVwiLlwiP2Uuc3BsaWNlKHMsMSk6YT09PVwiLi5cIj8oZS5zcGxpY2UocywxKSx0KyspOnQmJihlLnNwbGljZShzLDEpLHQtLSl9aWYocilmb3IoO3QtLTt0KWUudW5zaGlmdChcIi4uXCIpO3JldHVybiBlfWZ1bmN0aW9uIHdyKCl7Zm9yKHZhciBlPVwiXCIscj0hMSx0PWFyZ3VtZW50cy5sZW5ndGgtMTt0Pj0tMSYmIXI7dC0tKXt2YXIgcz10Pj0wP2FyZ3VtZW50c1t0XTpcIi9cIjtpZih0eXBlb2YgcyE9XCJzdHJpbmdcIil0aHJvdyBuZXcgVHlwZUVycm9yKFwiQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3NcIik7aWYoIXMpY29udGludWU7ZT1zK1wiL1wiK2Uscj1zLmNoYXJBdCgwKT09PVwiL1wifXJldHVybiBlPUhhKFpuKGUuc3BsaXQoXCIvXCIpLGZ1bmN0aW9uKGEpe3JldHVybiEhYX0pLCFyKS5qb2luKFwiL1wiKSwocj9cIi9cIjpcIlwiKStlfHxcIi5cIn1mdW5jdGlvbiBZbihlKXt2YXIgcj1RbihlKSx0PVlhKGUsLTEpPT09XCIvXCI7cmV0dXJuIGU9SGEoWm4oZS5zcGxpdChcIi9cIiksZnVuY3Rpb24ocyl7cmV0dXJuISFzfSksIXIpLmpvaW4oXCIvXCIpLCFlJiYhciYmKGU9XCIuXCIpLGUmJnQmJihlKz1cIi9cIiksKHI/XCIvXCI6XCJcIikrZX1mdW5jdGlvbiBRbihlKXtyZXR1cm4gZS5jaGFyQXQoMCk9PT1cIi9cIn1mdW5jdGlvbiBHYSgpe3ZhciBlPUFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywwKTtyZXR1cm4gWW4oWm4oZSxmdW5jdGlvbihyLHQpe2lmKHR5cGVvZiByIT1cInN0cmluZ1wiKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudHMgdG8gcGF0aC5qb2luIG11c3QgYmUgc3RyaW5nc1wiKTtyZXR1cm4gcn0pLmpvaW4oXCIvXCIpKX1mdW5jdGlvbiBVYShlLHIpe2U9d3IoZSkuc3Vic3RyKDEpLHI9d3Iocikuc3Vic3RyKDEpO2Z1bmN0aW9uIHQocCl7Zm9yKHZhciBkPTA7ZDxwLmxlbmd0aCYmcFtkXT09PVwiXCI7ZCsrKTtmb3IodmFyIHk9cC5sZW5ndGgtMTt5Pj0wJiZwW3ldPT09XCJcIjt5LS0pO3JldHVybiBkPnk/W106cC5zbGljZShkLHktZCsxKX1mb3IodmFyIHM9dChlLnNwbGl0KFwiL1wiKSksYT10KHIuc3BsaXQoXCIvXCIpKSxuPU1hdGgubWluKHMubGVuZ3RoLGEubGVuZ3RoKSx1PW4saT0wO2k8bjtpKyspaWYoc1tpXSE9PWFbaV0pe3U9aTticmVha31mb3IodmFyIGw9W10saT11O2k8cy5sZW5ndGg7aSsrKWwucHVzaChcIi4uXCIpO3JldHVybiBsPWwuY29uY2F0KGEuc2xpY2UodSkpLGwuam9pbihcIi9cIil9ZnVuY3Rpb24gSmEoZSl7dmFyIHI9SXIoZSksdD1yWzBdLHM9clsxXTtyZXR1cm4hdCYmIXM/XCIuXCI6KHMmJihzPXMuc3Vic3RyKDAscy5sZW5ndGgtMSkpLHQrcyl9ZnVuY3Rpb24gemEoZSxyKXt2YXIgdD1JcihlKVsyXTtyZXR1cm4gciYmdC5zdWJzdHIoLTEqci5sZW5ndGgpPT09ciYmKHQ9dC5zdWJzdHIoMCx0Lmxlbmd0aC1yLmxlbmd0aCkpLHR9ZnVuY3Rpb24gWGEoZSl7cmV0dXJuIElyKGUpWzNdfWZ1bmN0aW9uIFpuKGUscil7aWYoZS5maWx0ZXIpcmV0dXJuIGUuZmlsdGVyKHIpO2Zvcih2YXIgdD1bXSxzPTA7czxlLmxlbmd0aDtzKyspcihlW3NdLHMsZSkmJnQucHVzaChlW3NdKTtyZXR1cm4gdH12YXIgTmEsSXIscW4sTW4sS2EsWWEsUUQ9aHQoe1wibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpwYXRoXCIoKXtuZSgpLE5hPS9eKFxcLz98KShbXFxzXFxTXSo/KSgoPzpcXC57MSwyfXxbXlxcL10rP3wpKFxcLlteLlxcL10qfCkpKD86W1xcL10qKSQvLElyPWZ1bmN0aW9uKGUpe3JldHVybiBOYS5leGVjKGUpLnNsaWNlKDEpfSxxbj1cIi9cIixNbj1cIjpcIixLYT17ZXh0bmFtZTpYYSxiYXNlbmFtZTp6YSxkaXJuYW1lOkphLHNlcDpxbixkZWxpbWl0ZXI6TW4scmVsYXRpdmU6VWEsam9pbjpHYSxpc0Fic29sdXRlOlFuLG5vcm1hbGl6ZTpZbixyZXNvbHZlOndyfSxZYT1cImFiXCIuc3Vic3RyKC0xKT09PVwiYlwiP2Z1bmN0aW9uKGUscix0KXtyZXR1cm4gZS5zdWJzdHIocix0KX06ZnVuY3Rpb24oZSxyLHQpe3JldHVybiByPDAmJihyPWUubGVuZ3RoK3IpLGUuc3Vic3RyKHIsdCl9fX0pLFpEPXRlKHtcIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6cGF0aFwiKGUscil7bmUoKTt2YXIgdD0oUUQoKSxmdChXYSkpO2lmKHQmJnQuZGVmYXVsdCl7ci5leHBvcnRzPXQuZGVmYXVsdDtmb3IobGV0IHMgaW4gdClyLmV4cG9ydHNbc109dFtzXX1lbHNlIHQmJihyLmV4cG9ydHM9dCl9fSksUXQ9dGUoe1wic3JjL2NvbW1vbi9lcnJvcnMuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9Y2xhc3MgZXh0ZW5kcyBFcnJvcnt9LHM9Y2xhc3MgZXh0ZW5kcyBFcnJvcnt9LGE9Y2xhc3MgZXh0ZW5kcyBFcnJvcnt9LG49Y2xhc3MgZXh0ZW5kcyBFcnJvcnt9O3IuZXhwb3J0cz17Q29uZmlnRXJyb3I6dCxEZWJ1Z0Vycm9yOnMsVW5kZWZpbmVkUGFyc2VyRXJyb3I6YSxBcmdFeHBhbnNpb25CYWlsb3V0Om59fX0pLHZ0PXt9O0t0KHZ0LHtfX2Fzc2lnbjooKT0+TnIsX19hc3luY0RlbGVnYXRvcjooKT0+Zm0sX19hc3luY0dlbmVyYXRvcjooKT0+cG0sX19hc3luY1ZhbHVlczooKT0+RG0sX19hd2FpdDooKT0+WHQsX19hd2FpdGVyOigpPT5zbSxfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OigpPT55bSxfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0OigpPT5obSxfX2NyZWF0ZUJpbmRpbmc6KCk9PmFtLF9fZGVjb3JhdGU6KCk9PnJtLF9fZXhwb3J0U3RhcjooKT0+b20sX19leHRlbmRzOigpPT5lbSxfX2dlbmVyYXRvcjooKT0+aW0sX19pbXBvcnREZWZhdWx0OigpPT5nbSxfX2ltcG9ydFN0YXI6KCk9PmRtLF9fbWFrZVRlbXBsYXRlT2JqZWN0OigpPT5tbSxfX21ldGFkYXRhOigpPT51bSxfX3BhcmFtOigpPT5ubSxfX3JlYWQ6KCk9PlFhLF9fcmVzdDooKT0+dG0sX19zcHJlYWQ6KCk9PmxtLF9fc3ByZWFkQXJyYXlzOigpPT5jbSxfX3ZhbHVlczooKT0+Um59KTtmdW5jdGlvbiBlbShlLHIpe0JyKGUscik7ZnVuY3Rpb24gdCgpe3RoaXMuY29uc3RydWN0b3I9ZX1lLnByb3RvdHlwZT1yPT09bnVsbD9PYmplY3QuY3JlYXRlKHIpOih0LnByb3RvdHlwZT1yLnByb3RvdHlwZSxuZXcgdCl9ZnVuY3Rpb24gdG0oZSxyKXt2YXIgdD17fTtmb3IodmFyIHMgaW4gZSlPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoZSxzKSYmci5pbmRleE9mKHMpPDAmJih0W3NdPWVbc10pO2lmKGUhPW51bGwmJnR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzPT1cImZ1bmN0aW9uXCIpZm9yKHZhciBhPTAscz1PYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKGUpO2E8cy5sZW5ndGg7YSsrKXIuaW5kZXhPZihzW2FdKTwwJiZPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoZSxzW2FdKSYmKHRbc1thXV09ZVtzW2FdXSk7cmV0dXJuIHR9ZnVuY3Rpb24gcm0oZSxyLHQscyl7dmFyIGE9YXJndW1lbnRzLmxlbmd0aCxuPWE8Mz9yOnM9PT1udWxsP3M9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihyLHQpOnMsdTtpZih0eXBlb2YgUmVmbGVjdD09XCJvYmplY3RcIiYmdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGU9PVwiZnVuY3Rpb25cIiluPVJlZmxlY3QuZGVjb3JhdGUoZSxyLHQscyk7ZWxzZSBmb3IodmFyIGk9ZS5sZW5ndGgtMTtpPj0wO2ktLSkodT1lW2ldKSYmKG49KGE8Mz91KG4pOmE+Mz91KHIsdCxuKTp1KHIsdCkpfHxuKTtyZXR1cm4gYT4zJiZuJiZPYmplY3QuZGVmaW5lUHJvcGVydHkocix0LG4pLG59ZnVuY3Rpb24gbm0oZSxyKXtyZXR1cm4gZnVuY3Rpb24odCxzKXtyKHQscyxlKX19ZnVuY3Rpb24gdW0oZSxyKXtpZih0eXBlb2YgUmVmbGVjdD09XCJvYmplY3RcIiYmdHlwZW9mIFJlZmxlY3QubWV0YWRhdGE9PVwiZnVuY3Rpb25cIilyZXR1cm4gUmVmbGVjdC5tZXRhZGF0YShlLHIpfWZ1bmN0aW9uIHNtKGUscix0LHMpe2Z1bmN0aW9uIGEobil7cmV0dXJuIG4gaW5zdGFuY2VvZiB0P246bmV3IHQoZnVuY3Rpb24odSl7dShuKX0pfXJldHVybiBuZXcodHx8KHQ9UHJvbWlzZSkpKGZ1bmN0aW9uKG4sdSl7ZnVuY3Rpb24gaShkKXt0cnl7cChzLm5leHQoZCkpfWNhdGNoKHkpe3UoeSl9fWZ1bmN0aW9uIGwoZCl7dHJ5e3Aocy50aHJvdyhkKSl9Y2F0Y2goeSl7dSh5KX19ZnVuY3Rpb24gcChkKXtkLmRvbmU/bihkLnZhbHVlKTphKGQudmFsdWUpLnRoZW4oaSxsKX1wKChzPXMuYXBwbHkoZSxyfHxbXSkpLm5leHQoKSl9KX1mdW5jdGlvbiBpbShlLHIpe3ZhciB0PXtsYWJlbDowLHNlbnQ6ZnVuY3Rpb24oKXtpZihuWzBdJjEpdGhyb3cgblsxXTtyZXR1cm4gblsxXX0sdHJ5czpbXSxvcHM6W119LHMsYSxuLHU7cmV0dXJuIHU9e25leHQ6aSgwKSx0aHJvdzppKDEpLHJldHVybjppKDIpfSx0eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJih1W1N5bWJvbC5pdGVyYXRvcl09ZnVuY3Rpb24oKXtyZXR1cm4gdGhpc30pLHU7ZnVuY3Rpb24gaShwKXtyZXR1cm4gZnVuY3Rpb24oZCl7cmV0dXJuIGwoW3AsZF0pfX1mdW5jdGlvbiBsKHApe2lmKHMpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7Zm9yKDt0Oyl0cnl7aWYocz0xLGEmJihuPXBbMF0mMj9hLnJldHVybjpwWzBdP2EudGhyb3d8fCgobj1hLnJldHVybikmJm4uY2FsbChhKSwwKTphLm5leHQpJiYhKG49bi5jYWxsKGEscFsxXSkpLmRvbmUpcmV0dXJuIG47c3dpdGNoKGE9MCxuJiYocD1bcFswXSYyLG4udmFsdWVdKSxwWzBdKXtjYXNlIDA6Y2FzZSAxOm49cDticmVhaztjYXNlIDQ6cmV0dXJuIHQubGFiZWwrKyx7dmFsdWU6cFsxXSxkb25lOiExfTtjYXNlIDU6dC5sYWJlbCsrLGE9cFsxXSxwPVswXTtjb250aW51ZTtjYXNlIDc6cD10Lm9wcy5wb3AoKSx0LnRyeXMucG9wKCk7Y29udGludWU7ZGVmYXVsdDppZihuPXQudHJ5cywhKG49bi5sZW5ndGg+MCYmbltuLmxlbmd0aC0xXSkmJihwWzBdPT09Nnx8cFswXT09PTIpKXt0PTA7Y29udGludWV9aWYocFswXT09PTMmJighbnx8cFsxXT5uWzBdJiZwWzFdPG5bM10pKXt0LmxhYmVsPXBbMV07YnJlYWt9aWYocFswXT09PTYmJnQubGFiZWw8blsxXSl7dC5sYWJlbD1uWzFdLG49cDticmVha31pZihuJiZ0LmxhYmVsPG5bMl0pe3QubGFiZWw9blsyXSx0Lm9wcy5wdXNoKHApO2JyZWFrfW5bMl0mJnQub3BzLnBvcCgpLHQudHJ5cy5wb3AoKTtjb250aW51ZX1wPXIuY2FsbChlLHQpfWNhdGNoKGQpe3A9WzYsZF0sYT0wfWZpbmFsbHl7cz1uPTB9aWYocFswXSY1KXRocm93IHBbMV07cmV0dXJue3ZhbHVlOnBbMF0/cFsxXTp2b2lkIDAsZG9uZTohMH19fWZ1bmN0aW9uIGFtKGUscix0LHMpe3M9PT12b2lkIDAmJihzPXQpLGVbc109clt0XX1mdW5jdGlvbiBvbShlLHIpe2Zvcih2YXIgdCBpbiBlKXQhPT1cImRlZmF1bHRcIiYmIXIuaGFzT3duUHJvcGVydHkodCkmJihyW3RdPWVbdF0pfWZ1bmN0aW9uIFJuKGUpe3ZhciByPXR5cGVvZiBTeW1ib2w9PVwiZnVuY3Rpb25cIiYmU3ltYm9sLml0ZXJhdG9yLHQ9ciYmZVtyXSxzPTA7aWYodClyZXR1cm4gdC5jYWxsKGUpO2lmKGUmJnR5cGVvZiBlLmxlbmd0aD09XCJudW1iZXJcIilyZXR1cm57bmV4dDpmdW5jdGlvbigpe3JldHVybiBlJiZzPj1lLmxlbmd0aCYmKGU9dm9pZCAwKSx7dmFsdWU6ZSYmZVtzKytdLGRvbmU6IWV9fX07dGhyb3cgbmV3IFR5cGVFcnJvcihyP1wiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIjpcIlN5bWJvbC5pdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIil9ZnVuY3Rpb24gUWEoZSxyKXt2YXIgdD10eXBlb2YgU3ltYm9sPT1cImZ1bmN0aW9uXCImJmVbU3ltYm9sLml0ZXJhdG9yXTtpZighdClyZXR1cm4gZTt2YXIgcz10LmNhbGwoZSksYSxuPVtdLHU7dHJ5e2Zvcig7KHI9PT12b2lkIDB8fHItLSA+MCkmJiEoYT1zLm5leHQoKSkuZG9uZTspbi5wdXNoKGEudmFsdWUpfWNhdGNoKGkpe3U9e2Vycm9yOml9fWZpbmFsbHl7dHJ5e2EmJiFhLmRvbmUmJih0PXMucmV0dXJuKSYmdC5jYWxsKHMpfWZpbmFsbHl7aWYodSl0aHJvdyB1LmVycm9yfX1yZXR1cm4gbn1mdW5jdGlvbiBsbSgpe2Zvcih2YXIgZT1bXSxyPTA7cjxhcmd1bWVudHMubGVuZ3RoO3IrKyllPWUuY29uY2F0KFFhKGFyZ3VtZW50c1tyXSkpO3JldHVybiBlfWZ1bmN0aW9uIGNtKCl7Zm9yKHZhciBlPTAscj0wLHQ9YXJndW1lbnRzLmxlbmd0aDtyPHQ7cisrKWUrPWFyZ3VtZW50c1tyXS5sZW5ndGg7Zm9yKHZhciBzPUFycmF5KGUpLGE9MCxyPTA7cjx0O3IrKylmb3IodmFyIG49YXJndW1lbnRzW3JdLHU9MCxpPW4ubGVuZ3RoO3U8aTt1KyssYSsrKXNbYV09blt1XTtyZXR1cm4gc31mdW5jdGlvbiBYdChlKXtyZXR1cm4gdGhpcyBpbnN0YW5jZW9mIFh0Pyh0aGlzLnY9ZSx0aGlzKTpuZXcgWHQoZSl9ZnVuY3Rpb24gcG0oZSxyLHQpe2lmKCFTeW1ib2wuYXN5bmNJdGVyYXRvcil0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO3ZhciBzPXQuYXBwbHkoZSxyfHxbXSksYSxuPVtdO3JldHVybiBhPXt9LHUoXCJuZXh0XCIpLHUoXCJ0aHJvd1wiKSx1KFwicmV0dXJuXCIpLGFbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LGE7ZnVuY3Rpb24gdShnKXtzW2ddJiYoYVtnXT1mdW5jdGlvbihjKXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oRCxFKXtuLnB1c2goW2csYyxELEVdKT4xfHxpKGcsYyl9KX0pfWZ1bmN0aW9uIGkoZyxjKXt0cnl7bChzW2ddKGMpKX1jYXRjaChEKXt5KG5bMF1bM10sRCl9fWZ1bmN0aW9uIGwoZyl7Zy52YWx1ZSBpbnN0YW5jZW9mIFh0P1Byb21pc2UucmVzb2x2ZShnLnZhbHVlLnYpLnRoZW4ocCxkKTp5KG5bMF1bMl0sZyl9ZnVuY3Rpb24gcChnKXtpKFwibmV4dFwiLGcpfWZ1bmN0aW9uIGQoZyl7aShcInRocm93XCIsZyl9ZnVuY3Rpb24geShnLGMpe2coYyksbi5zaGlmdCgpLG4ubGVuZ3RoJiZpKG5bMF1bMF0sblswXVsxXSl9fWZ1bmN0aW9uIGZtKGUpe3ZhciByLHQ7cmV0dXJuIHI9e30scyhcIm5leHRcIikscyhcInRocm93XCIsZnVuY3Rpb24oYSl7dGhyb3cgYX0pLHMoXCJyZXR1cm5cIikscltTeW1ib2wuaXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHI7ZnVuY3Rpb24gcyhhLG4pe3JbYV09ZVthXT9mdW5jdGlvbih1KXtyZXR1cm4odD0hdCk/e3ZhbHVlOlh0KGVbYV0odSkpLGRvbmU6YT09PVwicmV0dXJuXCJ9Om4/bih1KTp1fTpufX1mdW5jdGlvbiBEbShlKXtpZighU3ltYm9sLmFzeW5jSXRlcmF0b3IpdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTt2YXIgcj1lW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSx0O3JldHVybiByP3IuY2FsbChlKTooZT10eXBlb2YgUm49PVwiZnVuY3Rpb25cIj9SbihlKTplW1N5bWJvbC5pdGVyYXRvcl0oKSx0PXt9LHMoXCJuZXh0XCIpLHMoXCJ0aHJvd1wiKSxzKFwicmV0dXJuXCIpLHRbU3ltYm9sLmFzeW5jSXRlcmF0b3JdPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXN9LHQpO2Z1bmN0aW9uIHMobil7dFtuXT1lW25dJiZmdW5jdGlvbih1KXtyZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24oaSxsKXt1PWVbbl0odSksYShpLGwsdS5kb25lLHUudmFsdWUpfSl9fWZ1bmN0aW9uIGEobix1LGksbCl7UHJvbWlzZS5yZXNvbHZlKGwpLnRoZW4oZnVuY3Rpb24ocCl7bih7dmFsdWU6cCxkb25lOml9KX0sdSl9fWZ1bmN0aW9uIG1tKGUscil7cmV0dXJuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eT9PYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcInJhd1wiLHt2YWx1ZTpyfSk6ZS5yYXc9cixlfWZ1bmN0aW9uIGRtKGUpe2lmKGUmJmUuX19lc01vZHVsZSlyZXR1cm4gZTt2YXIgcj17fTtpZihlIT1udWxsKWZvcih2YXIgdCBpbiBlKU9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKGUsdCkmJihyW3RdPWVbdF0pO3JldHVybiByLmRlZmF1bHQ9ZSxyfWZ1bmN0aW9uIGdtKGUpe3JldHVybiBlJiZlLl9fZXNNb2R1bGU/ZTp7ZGVmYXVsdDplfX1mdW5jdGlvbiB5bShlLHIpe2lmKCFyLmhhcyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIGdldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gci5nZXQoZSl9ZnVuY3Rpb24gaG0oZSxyLHQpe2lmKCFyLmhhcyhlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXR0ZW1wdGVkIHRvIHNldCBwcml2YXRlIGZpZWxkIG9uIG5vbi1pbnN0YW5jZVwiKTtyZXR1cm4gci5zZXQoZSx0KSx0fXZhciBCcixOcixFdD1odCh7XCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuZXM2LmpzXCIoKXtuZSgpLEJyPWZ1bmN0aW9uKGUscil7cmV0dXJuIEJyPU9iamVjdC5zZXRQcm90b3R5cGVPZnx8e19fcHJvdG9fXzpbXX1pbnN0YW5jZW9mIEFycmF5JiZmdW5jdGlvbih0LHMpe3QuX19wcm90b19fPXN9fHxmdW5jdGlvbih0LHMpe2Zvcih2YXIgYSBpbiBzKXMuaGFzT3duUHJvcGVydHkoYSkmJih0W2FdPXNbYV0pfSxCcihlLHIpfSxOcj1mdW5jdGlvbigpe3JldHVybiBOcj1PYmplY3QuYXNzaWdufHxmdW5jdGlvbihyKXtmb3IodmFyIHQscz0xLGE9YXJndW1lbnRzLmxlbmd0aDtzPGE7cysrKXt0PWFyZ3VtZW50c1tzXTtmb3IodmFyIG4gaW4gdClPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKSYmKHJbbl09dFtuXSl9cmV0dXJuIHJ9LE5yLmFwcGx5KHRoaXMsYXJndW1lbnRzKX19fSksWmE9dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvZGVzY3JpcHRvcnMvYXBpLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KSxlLmFwaURlc2NyaXB0b3I9e2tleTpyPT4vXlskX2EtekEtWl1bJF9hLXpBLVowLTldKiQvLnRlc3Qocik/cjpKU09OLnN0cmluZ2lmeShyKSx2YWx1ZShyKXtpZihyPT09bnVsbHx8dHlwZW9mIHIhPVwib2JqZWN0XCIpcmV0dXJuIEpTT04uc3RyaW5naWZ5KHIpO2lmKEFycmF5LmlzQXJyYXkocikpcmV0dXJuYFske3IubWFwKHM9PmUuYXBpRGVzY3JpcHRvci52YWx1ZShzKSkuam9pbihcIiwgXCIpfV1gO2xldCB0PU9iamVjdC5rZXlzKHIpO3JldHVybiB0Lmxlbmd0aD09PTA/XCJ7fVwiOmB7ICR7dC5tYXAocz0+YCR7ZS5hcGlEZXNjcmlwdG9yLmtleShzKX06ICR7ZS5hcGlEZXNjcmlwdG9yLnZhbHVlKHJbc10pfWApLmpvaW4oXCIsIFwiKX0gfWB9LHBhaXI6cj0+e2xldHtrZXk6dCx2YWx1ZTpzfT1yO3JldHVybiBlLmFwaURlc2NyaXB0b3IudmFsdWUoe1t0XTpzfSl9fX19KSx2bT10ZSh7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9kZXNjcmlwdG9ycy9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9KEV0KCksZnQodnQpKTtyLl9fZXhwb3J0U3RhcihaYSgpLGUpfX0pLGtyPXRlKHtcInNjcmlwdHMvYnVpbGQvc2hpbXMvY2hhbGsuY2pzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PXM9PnM7dC5ncmV5PXQsdC5yZWQ9dCx0LmJvbGQ9dCx0LnllbGxvdz10LHQuYmx1ZT10LHQuZGVmYXVsdD10LHIuZXhwb3J0cz10fX0pLGVvPXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL2hhbmRsZXJzL2RlcHJlY2F0ZWQvY29tbW9uLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1rcigpO2UuY29tbW9uRGVwcmVjYXRlZEhhbmRsZXI9KHQscyxhKT0+e2xldHtkZXNjcmlwdG9yOm59PWEsdT1bYCR7ci5kZWZhdWx0LnllbGxvdyh0eXBlb2YgdD09XCJzdHJpbmdcIj9uLmtleSh0KTpuLnBhaXIodCkpfSBpcyBkZXByZWNhdGVkYF07cmV0dXJuIHMmJnUucHVzaChgd2Ugbm93IHRyZWF0IGl0IGFzICR7ci5kZWZhdWx0LmJsdWUodHlwZW9mIHM9PVwic3RyaW5nXCI/bi5rZXkocyk6bi5wYWlyKHMpKX1gKSx1LmpvaW4oXCI7IFwiKStcIi5cIn19fSksQ209dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaGFuZGxlcnMvZGVwcmVjYXRlZC9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9KEV0KCksZnQodnQpKTtyLl9fZXhwb3J0U3RhcihlbygpLGUpfX0pLEVtPXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL2hhbmRsZXJzL2ludmFsaWQvY29tbW9uLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1rcigpO2UuY29tbW9uSW52YWxpZEhhbmRsZXI9KHQscyxhKT0+W2BJbnZhbGlkICR7ci5kZWZhdWx0LnJlZChhLmRlc2NyaXB0b3Iua2V5KHQpKX0gdmFsdWUuYCxgRXhwZWN0ZWQgJHtyLmRlZmF1bHQuYmx1ZShhLnNjaGVtYXNbdF0uZXhwZWN0ZWQoYSkpfSxgLGBidXQgcmVjZWl2ZWQgJHtyLmRlZmF1bHQucmVkKGEuZGVzY3JpcHRvci52YWx1ZShzKSl9LmBdLmpvaW4oXCIgXCIpfX0pLHRvPXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL2hhbmRsZXJzL2ludmFsaWQvaW5kZXguanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPShFdCgpLGZ0KHZ0KSk7ci5fX2V4cG9ydFN0YXIoRW0oKSxlKX19KSxGbT10ZSh7XCJub2RlX21vZHVsZXMvdm5vcHRzL25vZGVfbW9kdWxlcy9sZXZlbi9pbmRleC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1bXSxzPVtdO3IuZXhwb3J0cz1mdW5jdGlvbihhLG4pe2lmKGE9PT1uKXJldHVybiAwO3ZhciB1PWE7YS5sZW5ndGg+bi5sZW5ndGgmJihhPW4sbj11KTt2YXIgaT1hLmxlbmd0aCxsPW4ubGVuZ3RoO2lmKGk9PT0wKXJldHVybiBsO2lmKGw9PT0wKXJldHVybiBpO2Zvcig7aT4wJiZhLmNoYXJDb2RlQXQofi1pKT09PW4uY2hhckNvZGVBdCh+LWwpOylpLS0sbC0tO2lmKGk9PT0wKXJldHVybiBsO2Zvcih2YXIgcD0wO3A8aSYmYS5jaGFyQ29kZUF0KHApPT09bi5jaGFyQ29kZUF0KHApOylwKys7aWYoaS09cCxsLT1wLGk9PT0wKXJldHVybiBsO2Zvcih2YXIgZCx5LGcsYyxEPTAsRT0wO0Q8aTspc1twK0RdPWEuY2hhckNvZGVBdChwK0QpLHRbRF09KytEO2Zvcig7RTxsOylmb3IoZD1uLmNoYXJDb2RlQXQocCtFKSxnPUUrKyx5PUUsRD0wO0Q8aTtEKyspYz1kPT09c1twK0RdP2c6ZysxLGc9dFtEXSx5PXRbRF09Zz55P2M+eT95KzE6YzpjPmc/ZysxOmM7cmV0dXJuIHl9fX0pLHJvPXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL2hhbmRsZXJzL3Vua25vd24vbGV2ZW4uanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWtyKCksdD1GbSgpO2UubGV2ZW5Vbmtub3duSGFuZGxlcj0ocyxhLG4pPT57bGV0e2Rlc2NyaXB0b3I6dSxsb2dnZXI6aSxzY2hlbWFzOmx9PW4scD1bYElnbm9yZWQgdW5rbm93biBvcHRpb24gJHtyLmRlZmF1bHQueWVsbG93KHUucGFpcih7a2V5OnMsdmFsdWU6YX0pKX0uYF0sZD1PYmplY3Qua2V5cyhsKS5zb3J0KCkuZmluZCh5PT50KHMseSk8Myk7ZCYmcC5wdXNoKGBEaWQgeW91IG1lYW4gJHtyLmRlZmF1bHQuYmx1ZSh1LmtleShkKSl9P2ApLGkud2FybihwLmpvaW4oXCIgXCIpKX19fSksQW09dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvaGFuZGxlcnMvdW5rbm93bi9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9KEV0KCksZnQodnQpKTtyLl9fZXhwb3J0U3RhcihybygpLGUpfX0pLFNtPXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL2hhbmRsZXJzL2luZGV4LmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj0oRXQoKSxmdCh2dCkpO3IuX19leHBvcnRTdGFyKENtKCksZSksci5fX2V4cG9ydFN0YXIodG8oKSxlKSxyLl9fZXhwb3J0U3RhcihBbSgpLGUpfX0pLEZ0PXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL3NjaGVtYS5qc1wiKGUpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9W1wiZGVmYXVsdFwiLFwiZXhwZWN0ZWRcIixcInZhbGlkYXRlXCIsXCJkZXByZWNhdGVkXCIsXCJmb3J3YXJkXCIsXCJyZWRpcmVjdFwiLFwib3ZlcmxhcFwiLFwicHJlcHJvY2Vzc1wiLFwicG9zdHByb2Nlc3NcIl07ZnVuY3Rpb24gdChuLHUpe2xldCBpPW5ldyBuKHUpLGw9T2JqZWN0LmNyZWF0ZShpKTtmb3IobGV0IHAgb2YgcilwIGluIHUmJihsW3BdPWEodVtwXSxpLHMucHJvdG90eXBlW3BdLmxlbmd0aCkpO3JldHVybiBsfWUuY3JlYXRlU2NoZW1hPXQ7dmFyIHM9Y2xhc3N7Y29uc3RydWN0b3Iobil7dGhpcy5uYW1lPW4ubmFtZX1zdGF0aWMgY3JlYXRlKG4pe3JldHVybiB0KHRoaXMsbil9ZGVmYXVsdChuKXt9ZXhwZWN0ZWQobil7cmV0dXJuXCJub3RoaW5nXCJ9dmFsaWRhdGUobix1KXtyZXR1cm4hMX1kZXByZWNhdGVkKG4sdSl7cmV0dXJuITF9Zm9yd2FyZChuLHUpe31yZWRpcmVjdChuLHUpe31vdmVybGFwKG4sdSxpKXtyZXR1cm4gbn1wcmVwcm9jZXNzKG4sdSl7cmV0dXJuIG59cG9zdHByb2Nlc3Mobix1KXtyZXR1cm4gbn19O2UuU2NoZW1hPXM7ZnVuY3Rpb24gYShuLHUsaSl7cmV0dXJuIHR5cGVvZiBuPT1cImZ1bmN0aW9uXCI/ZnVuY3Rpb24oKXtmb3IodmFyIGw9YXJndW1lbnRzLmxlbmd0aCxwPW5ldyBBcnJheShsKSxkPTA7ZDxsO2QrKylwW2RdPWFyZ3VtZW50c1tkXTtyZXR1cm4gbiguLi5wLnNsaWNlKDAsaS0xKSx1LC4uLnAuc2xpY2UoaS0xKSl9OigpPT5ufX19KSx4bT10ZSh7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL2FsaWFzLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1GdCgpLHQ9Y2xhc3MgZXh0ZW5kcyByLlNjaGVtYXtjb25zdHJ1Y3RvcihzKXtzdXBlcihzKSx0aGlzLl9zb3VyY2VOYW1lPXMuc291cmNlTmFtZX1leHBlY3RlZChzKXtyZXR1cm4gcy5zY2hlbWFzW3RoaXMuX3NvdXJjZU5hbWVdLmV4cGVjdGVkKHMpfXZhbGlkYXRlKHMsYSl7cmV0dXJuIGEuc2NoZW1hc1t0aGlzLl9zb3VyY2VOYW1lXS52YWxpZGF0ZShzLGEpfXJlZGlyZWN0KHMsYSl7cmV0dXJuIHRoaXMuX3NvdXJjZU5hbWV9fTtlLkFsaWFzU2NoZW1hPXR9fSksYm09dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvc2NoZW1hcy9hbnkuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPUZ0KCksdD1jbGFzcyBleHRlbmRzIHIuU2NoZW1he2V4cGVjdGVkKCl7cmV0dXJuXCJhbnl0aGluZ1wifXZhbGlkYXRlKCl7cmV0dXJuITB9fTtlLkFueVNjaGVtYT10fX0pLFRtPXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL3NjaGVtYXMvYXJyYXkuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPShFdCgpLGZ0KHZ0KSksdD1GdCgpLHM9Y2xhc3MgZXh0ZW5kcyB0LlNjaGVtYXtjb25zdHJ1Y3RvcihuKXt2YXJ7dmFsdWVTY2hlbWE6dSxuYW1lOmk9dS5uYW1lfT1uLGw9ci5fX3Jlc3QobixbXCJ2YWx1ZVNjaGVtYVwiLFwibmFtZVwiXSk7c3VwZXIoT2JqZWN0LmFzc2lnbih7fSxsLHtuYW1lOml9KSksdGhpcy5fdmFsdWVTY2hlbWE9dX1leHBlY3RlZChuKXtyZXR1cm5gYW4gYXJyYXkgb2YgJHt0aGlzLl92YWx1ZVNjaGVtYS5leHBlY3RlZChuKX1gfXZhbGlkYXRlKG4sdSl7aWYoIUFycmF5LmlzQXJyYXkobikpcmV0dXJuITE7bGV0IGk9W107Zm9yKGxldCBsIG9mIG4pe2xldCBwPXUubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQodGhpcy5fdmFsdWVTY2hlbWEudmFsaWRhdGUobCx1KSxsKTtwIT09ITAmJmkucHVzaChwLnZhbHVlKX1yZXR1cm4gaS5sZW5ndGg9PT0wPyEwOnt2YWx1ZTppfX1kZXByZWNhdGVkKG4sdSl7bGV0IGk9W107Zm9yKGxldCBsIG9mIG4pe2xldCBwPXUubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5kZXByZWNhdGVkKGwsdSksbCk7cCE9PSExJiZpLnB1c2goLi4ucC5tYXAoZD0+e2xldHt2YWx1ZTp5fT1kO3JldHVybnt2YWx1ZTpbeV19fSkpfXJldHVybiBpfWZvcndhcmQobix1KXtsZXQgaT1bXTtmb3IobGV0IGwgb2Ygbil7bGV0IHA9dS5ub3JtYWxpemVGb3J3YXJkUmVzdWx0KHRoaXMuX3ZhbHVlU2NoZW1hLmZvcndhcmQobCx1KSxsKTtpLnB1c2goLi4ucC5tYXAoYSkpfXJldHVybiBpfXJlZGlyZWN0KG4sdSl7bGV0IGk9W10sbD1bXTtmb3IobGV0IHAgb2Ygbil7bGV0IGQ9dS5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdCh0aGlzLl92YWx1ZVNjaGVtYS5yZWRpcmVjdChwLHUpLHApO1wicmVtYWluXCJpbiBkJiZpLnB1c2goZC5yZW1haW4pLGwucHVzaCguLi5kLnJlZGlyZWN0Lm1hcChhKSl9cmV0dXJuIGkubGVuZ3RoPT09MD97cmVkaXJlY3Q6bH06e3JlZGlyZWN0OmwscmVtYWluOml9fW92ZXJsYXAobix1KXtyZXR1cm4gbi5jb25jYXQodSl9fTtlLkFycmF5U2NoZW1hPXM7ZnVuY3Rpb24gYShuKXtsZXR7ZnJvbTp1LHRvOml9PW47cmV0dXJue2Zyb206W3VdLHRvOml9fX19KSxCbT10ZSh7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL2Jvb2xlYW4uanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPUZ0KCksdD1jbGFzcyBleHRlbmRzIHIuU2NoZW1he2V4cGVjdGVkKCl7cmV0dXJuXCJ0cnVlIG9yIGZhbHNlXCJ9dmFsaWRhdGUocyl7cmV0dXJuIHR5cGVvZiBzPT1cImJvb2xlYW5cIn19O2UuQm9vbGVhblNjaGVtYT10fX0pLGV1PXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL3V0aWxzLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTtmdW5jdGlvbiByKGMsRCl7bGV0IEU9T2JqZWN0LmNyZWF0ZShudWxsKTtmb3IobGV0IF8gb2YgYyl7bGV0IHc9X1tEXTtpZihFW3ddKXRocm93IG5ldyBFcnJvcihgRHVwbGljYXRlICR7RH0gJHtKU09OLnN0cmluZ2lmeSh3KX1gKTtFW3ddPV99cmV0dXJuIEV9ZS5yZWNvcmRGcm9tQXJyYXk9cjtmdW5jdGlvbiB0KGMsRCl7bGV0IEU9bmV3IE1hcDtmb3IobGV0IF8gb2YgYyl7bGV0IHc9X1tEXTtpZihFLmhhcyh3KSl0aHJvdyBuZXcgRXJyb3IoYER1cGxpY2F0ZSAke0R9ICR7SlNPTi5zdHJpbmdpZnkodyl9YCk7RS5zZXQodyxfKX1yZXR1cm4gRX1lLm1hcEZyb21BcnJheT10O2Z1bmN0aW9uIHMoKXtsZXQgYz1PYmplY3QuY3JlYXRlKG51bGwpO3JldHVybiBEPT57bGV0IEU9SlNPTi5zdHJpbmdpZnkoRCk7cmV0dXJuIGNbRV0/ITA6KGNbRV09ITAsITEpfX1lLmNyZWF0ZUF1dG9DaGVja2xpc3Q9cztmdW5jdGlvbiBhKGMsRCl7bGV0IEU9W10sXz1bXTtmb3IobGV0IHcgb2YgYylEKHcpP0UucHVzaCh3KTpfLnB1c2godyk7cmV0dXJuW0UsX119ZS5wYXJ0aXRpb249YTtmdW5jdGlvbiBuKGMpe3JldHVybiBjPT09TWF0aC5mbG9vcihjKX1lLmlzSW50PW47ZnVuY3Rpb24gdShjLEQpe2lmKGM9PT1EKXJldHVybiAwO2xldCBFPXR5cGVvZiBjLF89dHlwZW9mIEQsdz1bXCJ1bmRlZmluZWRcIixcIm9iamVjdFwiLFwiYm9vbGVhblwiLFwibnVtYmVyXCIsXCJzdHJpbmdcIl07cmV0dXJuIEUhPT1fP3cuaW5kZXhPZihFKS13LmluZGV4T2YoXyk6RSE9PVwic3RyaW5nXCI/TnVtYmVyKGMpLU51bWJlcihEKTpjLmxvY2FsZUNvbXBhcmUoRCl9ZS5jb21wYXJlUHJpbWl0aXZlPXU7ZnVuY3Rpb24gaShjKXtyZXR1cm4gYz09PXZvaWQgMD97fTpjfWUubm9ybWFsaXplRGVmYXVsdFJlc3VsdD1pO2Z1bmN0aW9uIGwoYyxEKXtyZXR1cm4gYz09PSEwPyEwOmM9PT0hMT97dmFsdWU6RH06Y31lLm5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0PWw7ZnVuY3Rpb24gcChjLEQpe2xldCBFPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTohMTtyZXR1cm4gYz09PSExPyExOmM9PT0hMD9FPyEwOlt7dmFsdWU6RH1dOlwidmFsdWVcImluIGM/W2NdOmMubGVuZ3RoPT09MD8hMTpjfWUubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdD1wO2Z1bmN0aW9uIGQoYyxEKXtyZXR1cm4gdHlwZW9mIGM9PVwic3RyaW5nXCJ8fFwia2V5XCJpbiBjP3tmcm9tOkQsdG86Y306XCJmcm9tXCJpbiBjP3tmcm9tOmMuZnJvbSx0bzpjLnRvfTp7ZnJvbTpELHRvOmMudG99fWUubm9ybWFsaXplVHJhbnNmZXJSZXN1bHQ9ZDtmdW5jdGlvbiB5KGMsRCl7cmV0dXJuIGM9PT12b2lkIDA/W106QXJyYXkuaXNBcnJheShjKT9jLm1hcChFPT5kKEUsRCkpOltkKGMsRCldfWUubm9ybWFsaXplRm9yd2FyZFJlc3VsdD15O2Z1bmN0aW9uIGcoYyxEKXtsZXQgRT15KHR5cGVvZiBjPT1cIm9iamVjdFwiJiZcInJlZGlyZWN0XCJpbiBjP2MucmVkaXJlY3Q6YyxEKTtyZXR1cm4gRS5sZW5ndGg9PT0wP3tyZW1haW46RCxyZWRpcmVjdDpFfTp0eXBlb2YgYz09XCJvYmplY3RcIiYmXCJyZW1haW5cImluIGM/e3JlbWFpbjpjLnJlbWFpbixyZWRpcmVjdDpFfTp7cmVkaXJlY3Q6RX19ZS5ub3JtYWxpemVSZWRpcmVjdFJlc3VsdD1nfX0pLE5tPXRlKHtcIm5vZGVfbW9kdWxlcy92bm9wdHMvbGliL3NjaGVtYXMvY2hvaWNlLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1GdCgpLHQ9ZXUoKSxzPWNsYXNzIGV4dGVuZHMgci5TY2hlbWF7Y29uc3RydWN0b3IoYSl7c3VwZXIoYSksdGhpcy5fY2hvaWNlcz10Lm1hcEZyb21BcnJheShhLmNob2ljZXMubWFwKG49Pm4mJnR5cGVvZiBuPT1cIm9iamVjdFwiP246e3ZhbHVlOm59KSxcInZhbHVlXCIpfWV4cGVjdGVkKGEpe2xldHtkZXNjcmlwdG9yOm59PWEsdT1BcnJheS5mcm9tKHRoaXMuX2Nob2ljZXMua2V5cygpKS5tYXAocD0+dGhpcy5fY2hvaWNlcy5nZXQocCkpLmZpbHRlcihwPT4hcC5kZXByZWNhdGVkKS5tYXAocD0+cC52YWx1ZSkuc29ydCh0LmNvbXBhcmVQcmltaXRpdmUpLm1hcChuLnZhbHVlKSxpPXUuc2xpY2UoMCwtMiksbD11LnNsaWNlKC0yKTtyZXR1cm4gaS5jb25jYXQobC5qb2luKFwiIG9yIFwiKSkuam9pbihcIiwgXCIpfXZhbGlkYXRlKGEpe3JldHVybiB0aGlzLl9jaG9pY2VzLmhhcyhhKX1kZXByZWNhdGVkKGEpe2xldCBuPXRoaXMuX2Nob2ljZXMuZ2V0KGEpO3JldHVybiBuJiZuLmRlcHJlY2F0ZWQ/e3ZhbHVlOmF9OiExfWZvcndhcmQoYSl7bGV0IG49dGhpcy5fY2hvaWNlcy5nZXQoYSk7cmV0dXJuIG4/bi5mb3J3YXJkOnZvaWQgMH1yZWRpcmVjdChhKXtsZXQgbj10aGlzLl9jaG9pY2VzLmdldChhKTtyZXR1cm4gbj9uLnJlZGlyZWN0OnZvaWQgMH19O2UuQ2hvaWNlU2NoZW1hPXN9fSksbm89dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvc2NoZW1hcy9udW1iZXIuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPUZ0KCksdD1jbGFzcyBleHRlbmRzIHIuU2NoZW1he2V4cGVjdGVkKCl7cmV0dXJuXCJhIG51bWJlclwifXZhbGlkYXRlKHMsYSl7cmV0dXJuIHR5cGVvZiBzPT1cIm51bWJlclwifX07ZS5OdW1iZXJTY2hlbWE9dH19KSx3bT10ZSh7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9zY2hlbWFzL2ludGVnZXIuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWV1KCksdD1ubygpLHM9Y2xhc3MgZXh0ZW5kcyB0Lk51bWJlclNjaGVtYXtleHBlY3RlZCgpe3JldHVyblwiYW4gaW50ZWdlclwifXZhbGlkYXRlKGEsbil7cmV0dXJuIG4ubm9ybWFsaXplVmFsaWRhdGVSZXN1bHQoc3VwZXIudmFsaWRhdGUoYSxuKSxhKT09PSEwJiZyLmlzSW50KGEpfX07ZS5JbnRlZ2VyU2NoZW1hPXN9fSksX209dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvc2NoZW1hcy9zdHJpbmcuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPUZ0KCksdD1jbGFzcyBleHRlbmRzIHIuU2NoZW1he2V4cGVjdGVkKCl7cmV0dXJuXCJhIHN0cmluZ1wifXZhbGlkYXRlKHMpe3JldHVybiB0eXBlb2Ygcz09XCJzdHJpbmdcIn19O2UuU3RyaW5nU2NoZW1hPXR9fSksUG09dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvc2NoZW1hcy9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9KEV0KCksZnQodnQpKTtyLl9fZXhwb3J0U3Rhcih4bSgpLGUpLHIuX19leHBvcnRTdGFyKGJtKCksZSksci5fX2V4cG9ydFN0YXIoVG0oKSxlKSxyLl9fZXhwb3J0U3RhcihCbSgpLGUpLHIuX19leHBvcnRTdGFyKE5tKCksZSksci5fX2V4cG9ydFN0YXIod20oKSxlKSxyLl9fZXhwb3J0U3RhcihubygpLGUpLHIuX19leHBvcnRTdGFyKF9tKCksZSl9fSksSW09dGUoe1wibm9kZV9tb2R1bGVzL3Zub3B0cy9saWIvZGVmYXVsdHMuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPVphKCksdD1lbygpLHM9dG8oKSxhPXJvKCk7ZS5kZWZhdWx0RGVzY3JpcHRvcj1yLmFwaURlc2NyaXB0b3IsZS5kZWZhdWx0VW5rbm93bkhhbmRsZXI9YS5sZXZlblVua25vd25IYW5kbGVyLGUuZGVmYXVsdEludmFsaWRIYW5kbGVyPXMuY29tbW9uSW52YWxpZEhhbmRsZXIsZS5kZWZhdWx0RGVwcmVjYXRlZEhhbmRsZXI9dC5jb21tb25EZXByZWNhdGVkSGFuZGxlcn19KSxrbT10ZSh7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9ub3JtYWxpemUuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPUltKCksdD1ldSgpO2Uubm9ybWFsaXplPShhLG4sdSk9Pm5ldyBzKG4sdSkubm9ybWFsaXplKGEpO3ZhciBzPWNsYXNze2NvbnN0cnVjdG9yKGEsbil7bGV0e2xvZ2dlcjp1PWNvbnNvbGUsZGVzY3JpcHRvcjppPXIuZGVmYXVsdERlc2NyaXB0b3IsdW5rbm93bjpsPXIuZGVmYXVsdFVua25vd25IYW5kbGVyLGludmFsaWQ6cD1yLmRlZmF1bHRJbnZhbGlkSGFuZGxlcixkZXByZWNhdGVkOmQ9ci5kZWZhdWx0RGVwcmVjYXRlZEhhbmRsZXJ9PW58fHt9O3RoaXMuX3V0aWxzPXtkZXNjcmlwdG9yOmksbG9nZ2VyOnV8fHt3YXJuOigpPT57fX0sc2NoZW1hczp0LnJlY29yZEZyb21BcnJheShhLFwibmFtZVwiKSxub3JtYWxpemVEZWZhdWx0UmVzdWx0OnQubm9ybWFsaXplRGVmYXVsdFJlc3VsdCxub3JtYWxpemVEZXByZWNhdGVkUmVzdWx0OnQubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdCxub3JtYWxpemVGb3J3YXJkUmVzdWx0OnQubm9ybWFsaXplRm9yd2FyZFJlc3VsdCxub3JtYWxpemVSZWRpcmVjdFJlc3VsdDp0Lm5vcm1hbGl6ZVJlZGlyZWN0UmVzdWx0LG5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0OnQubm9ybWFsaXplVmFsaWRhdGVSZXN1bHR9LHRoaXMuX3Vua25vd25IYW5kbGVyPWwsdGhpcy5faW52YWxpZEhhbmRsZXI9cCx0aGlzLl9kZXByZWNhdGVkSGFuZGxlcj1kLHRoaXMuY2xlYW5IaXN0b3J5KCl9Y2xlYW5IaXN0b3J5KCl7dGhpcy5faGFzRGVwcmVjYXRpb25XYXJuZWQ9dC5jcmVhdGVBdXRvQ2hlY2tsaXN0KCl9bm9ybWFsaXplKGEpe2xldCBuPXt9LHU9W2FdLGk9KCk9Pntmb3IoO3UubGVuZ3RoIT09MDspe2xldCBsPXUuc2hpZnQoKSxwPXRoaXMuX2FwcGx5Tm9ybWFsaXphdGlvbihsLG4pO3UucHVzaCguLi5wKX19O2koKTtmb3IobGV0IGwgb2YgT2JqZWN0LmtleXModGhpcy5fdXRpbHMuc2NoZW1hcykpe2xldCBwPXRoaXMuX3V0aWxzLnNjaGVtYXNbbF07aWYoIShsIGluIG4pKXtsZXQgZD10Lm5vcm1hbGl6ZURlZmF1bHRSZXN1bHQocC5kZWZhdWx0KHRoaXMuX3V0aWxzKSk7XCJ2YWx1ZVwiaW4gZCYmdS5wdXNoKHtbbF06ZC52YWx1ZX0pfX1pKCk7Zm9yKGxldCBsIG9mIE9iamVjdC5rZXlzKHRoaXMuX3V0aWxzLnNjaGVtYXMpKXtsZXQgcD10aGlzLl91dGlscy5zY2hlbWFzW2xdO2wgaW4gbiYmKG5bbF09cC5wb3N0cHJvY2VzcyhuW2xdLHRoaXMuX3V0aWxzKSl9cmV0dXJuIG59X2FwcGx5Tm9ybWFsaXphdGlvbihhLG4pe2xldCB1PVtdLFtpLGxdPXQucGFydGl0aW9uKE9iamVjdC5rZXlzKGEpLHA9PnAgaW4gdGhpcy5fdXRpbHMuc2NoZW1hcyk7Zm9yKGxldCBwIG9mIGkpe2xldCBkPXRoaXMuX3V0aWxzLnNjaGVtYXNbcF0seT1kLnByZXByb2Nlc3MoYVtwXSx0aGlzLl91dGlscyksZz10Lm5vcm1hbGl6ZVZhbGlkYXRlUmVzdWx0KGQudmFsaWRhdGUoeSx0aGlzLl91dGlscykseSk7aWYoZyE9PSEwKXtsZXR7dmFsdWU6d309ZyxGPXRoaXMuX2ludmFsaWRIYW5kbGVyKHAsdyx0aGlzLl91dGlscyk7dGhyb3cgdHlwZW9mIEY9PVwic3RyaW5nXCI/bmV3IEVycm9yKEYpOkZ9bGV0IGM9dz0+e2xldHtmcm9tOkYsdG86U309dzt1LnB1c2godHlwZW9mIFM9PVwic3RyaW5nXCI/e1tTXTpGfTp7W1Mua2V5XTpTLnZhbHVlfSl9LEQ9dz0+e2xldHt2YWx1ZTpGLHJlZGlyZWN0VG86U309dyxOPXQubm9ybWFsaXplRGVwcmVjYXRlZFJlc3VsdChkLmRlcHJlY2F0ZWQoRix0aGlzLl91dGlscykseSwhMCk7aWYoTiE9PSExKWlmKE49PT0hMCl0aGlzLl9oYXNEZXByZWNhdGlvbldhcm5lZChwKXx8dGhpcy5fdXRpbHMubG9nZ2VyLndhcm4odGhpcy5fZGVwcmVjYXRlZEhhbmRsZXIocCxTLHRoaXMuX3V0aWxzKSk7ZWxzZSBmb3IobGV0e3ZhbHVlOkl9b2YgTil7bGV0IFA9e2tleTpwLHZhbHVlOkl9O2lmKCF0aGlzLl9oYXNEZXByZWNhdGlvbldhcm5lZChQKSl7bGV0ICQ9dHlwZW9mIFM9PVwic3RyaW5nXCI/e2tleTpTLHZhbHVlOkl9OlM7dGhpcy5fdXRpbHMubG9nZ2VyLndhcm4odGhpcy5fZGVwcmVjYXRlZEhhbmRsZXIoUCwkLHRoaXMuX3V0aWxzKSl9fX07dC5ub3JtYWxpemVGb3J3YXJkUmVzdWx0KGQuZm9yd2FyZCh5LHRoaXMuX3V0aWxzKSx5KS5mb3JFYWNoKGMpO2xldCBfPXQubm9ybWFsaXplUmVkaXJlY3RSZXN1bHQoZC5yZWRpcmVjdCh5LHRoaXMuX3V0aWxzKSx5KTtpZihfLnJlZGlyZWN0LmZvckVhY2goYyksXCJyZW1haW5cImluIF8pe2xldCB3PV8ucmVtYWluO25bcF09cCBpbiBuP2Qub3ZlcmxhcChuW3BdLHcsdGhpcy5fdXRpbHMpOncsRCh7dmFsdWU6d30pfWZvcihsZXR7ZnJvbTp3LHRvOkZ9b2YgXy5yZWRpcmVjdClEKHt2YWx1ZTp3LHJlZGlyZWN0VG86Rn0pfWZvcihsZXQgcCBvZiBsKXtsZXQgZD1hW3BdLHk9dGhpcy5fdW5rbm93bkhhbmRsZXIocCxkLHRoaXMuX3V0aWxzKTtpZih5KWZvcihsZXQgZyBvZiBPYmplY3Qua2V5cyh5KSl7bGV0IGM9e1tnXTp5W2ddfTtnIGluIHRoaXMuX3V0aWxzLnNjaGVtYXM/dS5wdXNoKGMpOk9iamVjdC5hc3NpZ24obixjKX19cmV0dXJuIHV9fTtlLk5vcm1hbGl6ZXI9c319KSxMbT10ZSh7XCJub2RlX21vZHVsZXMvdm5vcHRzL2xpYi9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSk7dmFyIHI9KEV0KCksZnQodnQpKTtyLl9fZXhwb3J0U3Rhcih2bSgpLGUpLHIuX19leHBvcnRTdGFyKFNtKCksZSksci5fX2V4cG9ydFN0YXIoUG0oKSxlKSxyLl9fZXhwb3J0U3RhcihrbSgpLGUpLHIuX19leHBvcnRTdGFyKEZ0KCksZSl9fSksT209dGUoe1wic3JjL21haW4vb3B0aW9ucy1ub3JtYWxpemVyLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PUxtKCkscz1sdCgpLGE9e2tleTpnPT5nLmxlbmd0aD09PTE/YC0ke2d9YDpgLS0ke2d9YCx2YWx1ZTpnPT50LmFwaURlc2NyaXB0b3IudmFsdWUoZykscGFpcjpnPT57bGV0e2tleTpjLHZhbHVlOkR9PWc7cmV0dXJuIEQ9PT0hMT9gLS1uby0ke2N9YDpEPT09ITA/YS5rZXkoYyk6RD09PVwiXCI/YCR7YS5rZXkoYyl9IHdpdGhvdXQgYW4gYXJndW1lbnRgOmAke2Eua2V5KGMpfT0ke0R9YH19LG49Zz0+e2xldHtjb2xvcnNNb2R1bGU6YyxsZXZlbnNodGVpbkRpc3RhbmNlOkR9PWc7cmV0dXJuIGNsYXNzIGV4dGVuZHMgdC5DaG9pY2VTY2hlbWF7Y29uc3RydWN0b3IoXyl7bGV0e25hbWU6dyxmbGFnczpGfT1fO3N1cGVyKHtuYW1lOncsY2hvaWNlczpGfSksdGhpcy5fZmxhZ3M9Wy4uLkZdLnNvcnQoKX1wcmVwcm9jZXNzKF8sdyl7aWYodHlwZW9mIF89PVwic3RyaW5nXCImJl8ubGVuZ3RoPjAmJiF0aGlzLl9mbGFncy5pbmNsdWRlcyhfKSl7bGV0IEY9dGhpcy5fZmxhZ3MuZmluZChTPT5EKFMsXyk8Myk7aWYoRilyZXR1cm4gdy5sb2dnZXIud2FybihbYFVua25vd24gZmxhZyAke2MueWVsbG93KHcuZGVzY3JpcHRvci52YWx1ZShfKSl9LGAsYGRpZCB5b3UgbWVhbiAke2MuYmx1ZSh3LmRlc2NyaXB0b3IudmFsdWUoRikpfT9gXS5qb2luKFwiIFwiKSksRn1yZXR1cm4gX31leHBlY3RlZCgpe3JldHVyblwiYSBmbGFnXCJ9fX0sdTtmdW5jdGlvbiBpKGcsYyl7bGV0e2xvZ2dlcjpEPSExLGlzQ0xJOkU9ITEscGFzc1Rocm91Z2g6Xz0hMSxjb2xvcnNNb2R1bGU6dz1udWxsLGxldmVuc2h0ZWluRGlzdGFuY2U6Rj1udWxsfT1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06e30sUz1fP0FycmF5LmlzQXJyYXkoXyk/KFQsbSk9Pl8uaW5jbHVkZXMoVCk/e1tUXTptfTp2b2lkIDA6KFQsbSk9Pih7W1RdOm19KTooVCxtLHYpPT57bGV0IG89di5zY2hlbWFzLHtfOmh9PW8sQz1IbihvLHZEKTtyZXR1cm4gdC5sZXZlblVua25vd25IYW5kbGVyKFQsbSxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdikse30se3NjaGVtYXM6Q30pKX0sTj1FP2E6dC5hcGlEZXNjcmlwdG9yLEk9bChjLHtpc0NMSTpFLGNvbG9yc01vZHVsZTp3LGxldmVuc2h0ZWluRGlzdGFuY2U6Rn0pLFA9bmV3IHQuTm9ybWFsaXplcihJLHtsb2dnZXI6RCx1bmtub3duOlMsZGVzY3JpcHRvcjpOfSksJD1EIT09ITE7JCYmdSYmKFAuX2hhc0RlcHJlY2F0aW9uV2FybmVkPXUpO2xldCBmPVAubm9ybWFsaXplKGcpO3JldHVybiAkJiYodT1QLl9oYXNEZXByZWNhdGlvbldhcm5lZCksRSYmZltcInBsdWdpbi1zZWFyY2hcIl09PT0hMSYmKGZbXCJwbHVnaW4tc2VhcmNoLWRpclwiXT0hMSksZn1mdW5jdGlvbiBsKGcsYyl7bGV0e2lzQ0xJOkQsY29sb3JzTW9kdWxlOkUsbGV2ZW5zaHRlaW5EaXN0YW5jZTpffT1jLHc9W107RCYmdy5wdXNoKHQuQW55U2NoZW1hLmNyZWF0ZSh7bmFtZTpcIl9cIn0pKTtmb3IobGV0IEYgb2YgZyl3LnB1c2gocChGLHtpc0NMSTpELG9wdGlvbkluZm9zOmcsY29sb3JzTW9kdWxlOkUsbGV2ZW5zaHRlaW5EaXN0YW5jZTpffSkpLEYuYWxpYXMmJkQmJncucHVzaCh0LkFsaWFzU2NoZW1hLmNyZWF0ZSh7bmFtZTpGLmFsaWFzLHNvdXJjZU5hbWU6Ri5uYW1lfSkpO3JldHVybiB3fWZ1bmN0aW9uIHAoZyxjKXtsZXR7aXNDTEk6RCxvcHRpb25JbmZvczpFLGNvbG9yc01vZHVsZTpfLGxldmVuc2h0ZWluRGlzdGFuY2U6d309Yyx7bmFtZTpGfT1nO2lmKEY9PT1cInBsdWdpbi1zZWFyY2gtZGlyXCJ8fEY9PT1cInBsdWdpblNlYXJjaERpcnNcIilyZXR1cm4gdC5BbnlTY2hlbWEuY3JlYXRlKHtuYW1lOkYscHJlcHJvY2VzcyhQKXtyZXR1cm4gUD09PSExfHwoUD1BcnJheS5pc0FycmF5KFApP1A6W1BdKSxQfSx2YWxpZGF0ZShQKXtyZXR1cm4gUD09PSExPyEwOlAuZXZlcnkoJD0+dHlwZW9mICQ9PVwic3RyaW5nXCIpfSxleHBlY3RlZCgpe3JldHVyblwiZmFsc2Ugb3IgcGF0aHMgdG8gcGx1Z2luIHNlYXJjaCBkaXJcIn19KTtsZXQgUz17bmFtZTpGfSxOLEk9e307c3dpdGNoKGcudHlwZSl7Y2FzZVwiaW50XCI6Tj10LkludGVnZXJTY2hlbWEsRCYmKFMucHJlcHJvY2Vzcz1OdW1iZXIpO2JyZWFrO2Nhc2VcInN0cmluZ1wiOk49dC5TdHJpbmdTY2hlbWE7YnJlYWs7Y2FzZVwiY2hvaWNlXCI6Tj10LkNob2ljZVNjaGVtYSxTLmNob2ljZXM9Zy5jaG9pY2VzLm1hcChQPT50eXBlb2YgUD09XCJvYmplY3RcIiYmUC5yZWRpcmVjdD9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sUCkse30se3JlZGlyZWN0Ont0bzp7a2V5OmcubmFtZSx2YWx1ZTpQLnJlZGlyZWN0fX19KTpQKTticmVhaztjYXNlXCJib29sZWFuXCI6Tj10LkJvb2xlYW5TY2hlbWE7YnJlYWs7Y2FzZVwiZmxhZ1wiOk49bih7Y29sb3JzTW9kdWxlOl8sbGV2ZW5zaHRlaW5EaXN0YW5jZTp3fSksUy5mbGFncz1FLmZsYXRNYXAoUD0+W1AuYWxpYXMsUC5kZXNjcmlwdGlvbiYmUC5uYW1lLFAub3Bwb3NpdGVEZXNjcmlwdGlvbiYmYG5vLSR7UC5uYW1lfWBdLmZpbHRlcihCb29sZWFuKSk7YnJlYWs7Y2FzZVwicGF0aFwiOk49dC5TdHJpbmdTY2hlbWE7YnJlYWs7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVuZXhwZWN0ZWQgdHlwZSAke2cudHlwZX1gKX1pZihnLmV4Y2VwdGlvbj9TLnZhbGlkYXRlPShQLCQsZik9PmcuZXhjZXB0aW9uKFApfHwkLnZhbGlkYXRlKFAsZik6Uy52YWxpZGF0ZT0oUCwkLGYpPT5QPT09dm9pZCAwfHwkLnZhbGlkYXRlKFAsZiksZy5yZWRpcmVjdCYmKEkucmVkaXJlY3Q9UD0+UD97dG86e2tleTpnLnJlZGlyZWN0Lm9wdGlvbix2YWx1ZTpnLnJlZGlyZWN0LnZhbHVlfX06dm9pZCAwKSxnLmRlcHJlY2F0ZWQmJihJLmRlcHJlY2F0ZWQ9ITApLEQmJiFnLmFycmF5KXtsZXQgUD1TLnByZXByb2Nlc3N8fCgkPT4kKTtTLnByZXByb2Nlc3M9KCQsZixUKT0+Zi5wcmVwcm9jZXNzKFAoQXJyYXkuaXNBcnJheSgkKT9zKCQpOiQpLFQpfXJldHVybiBnLmFycmF5P3QuQXJyYXlTY2hlbWEuY3JlYXRlKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LEQ/e3ByZXByb2Nlc3M6UD0+QXJyYXkuaXNBcnJheShQKT9QOltQXX06e30pLEkpLHt9LHt2YWx1ZVNjaGVtYTpOLmNyZWF0ZShTKX0pKTpOLmNyZWF0ZShPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sUyksSSkpfWZ1bmN0aW9uIGQoZyxjLEQpe3JldHVybiBpKGcsYyxEKX1mdW5jdGlvbiB5KGcsYyxEKXtyZXR1cm4gaShnLGMsT2JqZWN0LmFzc2lnbih7aXNDTEk6ITB9LEQpKX1yLmV4cG9ydHM9e25vcm1hbGl6ZUFwaU9wdGlvbnM6ZCxub3JtYWxpemVDbGlPcHRpb25zOnl9fX0pLHV0PXRlKHtcInNyYy9sYW5ndWFnZS1qcy9sb2MuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9S24oKTtmdW5jdGlvbiBzKGwpe3ZhciBwLGQ7bGV0IHk9bC5yYW5nZT9sLnJhbmdlWzBdOmwuc3RhcnQsZz0ocD0oZD1sLmRlY2xhcmF0aW9uKT09PW51bGx8fGQ9PT12b2lkIDA/dm9pZCAwOmQuZGVjb3JhdG9ycykhPT1udWxsJiZwIT09dm9pZCAwP3A6bC5kZWNvcmF0b3JzO3JldHVybiB0KGcpP01hdGgubWluKHMoZ1swXSkseSk6eX1mdW5jdGlvbiBhKGwpe3JldHVybiBsLnJhbmdlP2wucmFuZ2VbMV06bC5lbmR9ZnVuY3Rpb24gbihsLHApe2xldCBkPXMobCk7cmV0dXJuIE51bWJlci5pc0ludGVnZXIoZCkmJmQ9PT1zKHApfWZ1bmN0aW9uIHUobCxwKXtsZXQgZD1hKGwpO3JldHVybiBOdW1iZXIuaXNJbnRlZ2VyKGQpJiZkPT09YShwKX1mdW5jdGlvbiBpKGwscCl7cmV0dXJuIG4obCxwKSYmdShsLHApfXIuZXhwb3J0cz17bG9jU3RhcnQ6cyxsb2NFbmQ6YSxoYXNTYW1lTG9jU3RhcnQ6bixoYXNTYW1lTG9jOml9fX0pLGptPXRlKHtcInNyYy9tYWluL2xvYWQtcGFyc2VyLmpzXCIoZSxyKXtuZSgpLHIuZXhwb3J0cz0oKT0+e319fSkscW09dGUoe1wic2NyaXB0cy9idWlsZC9zaGltcy9iYWJlbC1oaWdobGlnaHQuY2pzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PWtyKCkscz17c2hvdWxkSGlnaGxpZ2h0OigpPT4hMSxnZXRDaGFsazooKT0+dH07ci5leHBvcnRzPXN9fSksTW09dGUoe1wibm9kZV9tb2R1bGVzL0BiYWJlbC9jb2RlLWZyYW1lL2xpYi9pbmRleC5qc1wiKGUpe1widXNlIHN0cmljdFwiO25lKCksT2JqZWN0LmRlZmluZVByb3BlcnR5KGUsXCJfX2VzTW9kdWxlXCIse3ZhbHVlOiEwfSksZS5jb2RlRnJhbWVDb2x1bW5zPXUsZS5kZWZhdWx0PWk7dmFyIHI9cW0oKSx0PSExO2Z1bmN0aW9uIHMobCl7cmV0dXJue2d1dHRlcjpsLmdyZXksbWFya2VyOmwucmVkLmJvbGQsbWVzc2FnZTpsLnJlZC5ib2xkfX12YXIgYT0vXFxyXFxufFtcXG5cXHJcXHUyMDI4XFx1MjAyOV0vO2Z1bmN0aW9uIG4obCxwLGQpe2xldCB5PU9iamVjdC5hc3NpZ24oe2NvbHVtbjowLGxpbmU6LTF9LGwuc3RhcnQpLGc9T2JqZWN0LmFzc2lnbih7fSx5LGwuZW5kKSx7bGluZXNBYm92ZTpjPTIsbGluZXNCZWxvdzpEPTN9PWR8fHt9LEU9eS5saW5lLF89eS5jb2x1bW4sdz1nLmxpbmUsRj1nLmNvbHVtbixTPU1hdGgubWF4KEUtKGMrMSksMCksTj1NYXRoLm1pbihwLmxlbmd0aCx3K0QpO0U9PT0tMSYmKFM9MCksdz09PS0xJiYoTj1wLmxlbmd0aCk7bGV0IEk9dy1FLFA9e307aWYoSSlmb3IobGV0ICQ9MDskPD1JOyQrKyl7bGV0IGY9JCtFO2lmKCFfKVBbZl09ITA7ZWxzZSBpZigkPT09MCl7bGV0IFQ9cFtmLTFdLmxlbmd0aDtQW2ZdPVtfLFQtXysxXX1lbHNlIGlmKCQ9PT1JKVBbZl09WzAsRl07ZWxzZXtsZXQgVD1wW2YtJF0ubGVuZ3RoO1BbZl09WzAsVF19fWVsc2UgXz09PUY/Xz9QW0VdPVtfLDBdOlBbRV09ITA6UFtFXT1bXyxGLV9dO3JldHVybntzdGFydDpTLGVuZDpOLG1hcmtlckxpbmVzOlB9fWZ1bmN0aW9uIHUobCxwKXtsZXQgZD1hcmd1bWVudHMubGVuZ3RoPjImJmFyZ3VtZW50c1syXSE9PXZvaWQgMD9hcmd1bWVudHNbMl06e30seT0oZC5oaWdobGlnaHRDb2RlfHxkLmZvcmNlQ29sb3IpJiYoMCxyLnNob3VsZEhpZ2hsaWdodCkoZCksZz0oMCxyLmdldENoYWxrKShkKSxjPXMoZyksRD0oJCxmKT0+eT8kKGYpOmYsRT1sLnNwbGl0KGEpLHtzdGFydDpfLGVuZDp3LG1hcmtlckxpbmVzOkZ9PW4ocCxFLGQpLFM9cC5zdGFydCYmdHlwZW9mIHAuc3RhcnQuY29sdW1uPT1cIm51bWJlclwiLE49U3RyaW5nKHcpLmxlbmd0aCxQPSh5PygwLHIuZGVmYXVsdCkobCxkKTpsKS5zcGxpdChhLHcpLnNsaWNlKF8sdykubWFwKCgkLGYpPT57bGV0IFQ9XysxK2Ysdj1gICR7YCAke1R9YC5zbGljZSgtTil9IHxgLG89RltUXSxoPSFGW1QrMV07aWYobyl7bGV0IEM9XCJcIjtpZihBcnJheS5pc0FycmF5KG8pKXtsZXQgeD0kLnNsaWNlKDAsTWF0aC5tYXgob1swXS0xLDApKS5yZXBsYWNlKC9bXlxcdF0vZyxcIiBcIiksYj1vWzFdfHwxO0M9W2BcbiBgLEQoYy5ndXR0ZXIsdi5yZXBsYWNlKC9cXGQvZyxcIiBcIikpLFwiIFwiLHgsRChjLm1hcmtlcixcIl5cIikucmVwZWF0KGIpXS5qb2luKFwiXCIpLGgmJmQubWVzc2FnZSYmKEMrPVwiIFwiK0QoYy5tZXNzYWdlLGQubWVzc2FnZSkpfXJldHVybltEKGMubWFya2VyLFwiPlwiKSxEKGMuZ3V0dGVyLHYpLCQubGVuZ3RoPjA/YCAkeyR9YDpcIlwiLENdLmpvaW4oXCJcIil9ZWxzZSByZXR1cm5gICR7RChjLmd1dHRlcix2KX0keyQubGVuZ3RoPjA/YCAkeyR9YDpcIlwifWB9KS5qb2luKGBcbmApO3JldHVybiBkLm1lc3NhZ2UmJiFTJiYoUD1gJHtcIiBcIi5yZXBlYXQoTisxKX0ke2QubWVzc2FnZX1cbiR7UH1gKSx5P2cucmVzZXQoUCk6UH1mdW5jdGlvbiBpKGwscCxkKXtsZXQgeT1hcmd1bWVudHMubGVuZ3RoPjMmJmFyZ3VtZW50c1szXSE9PXZvaWQgMD9hcmd1bWVudHNbM106e307aWYoIXQpe3Q9ITA7bGV0IGM9XCJQYXNzaW5nIGxpbmVOdW1iZXIgYW5kIGNvbE51bWJlciBpcyBkZXByZWNhdGVkIHRvIEBiYWJlbC9jb2RlLWZyYW1lLiBQbGVhc2UgdXNlIGBjb2RlRnJhbWVDb2x1bW5zYC5cIjtpZih3dC5lbWl0V2FybmluZyl3dC5lbWl0V2FybmluZyhjLFwiRGVwcmVjYXRpb25XYXJuaW5nXCIpO2Vsc2V7bGV0IEQ9bmV3IEVycm9yKGMpO0QubmFtZT1cIkRlcHJlY2F0aW9uV2FybmluZ1wiLGNvbnNvbGUud2FybihuZXcgRXJyb3IoYykpfX1yZXR1cm4gZD1NYXRoLm1heChkLDApLHUobCx7c3RhcnQ6e2NvbHVtbjpkLGxpbmU6cH19LHkpfX19KSx0dT10ZSh7XCJzcmMvbWFpbi9wYXJzZXIuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye0NvbmZpZ0Vycm9yOnR9PVF0KCkscz11dCgpLGE9am0oKSx7bG9jU3RhcnQ6bixsb2NFbmQ6dX09cyxpPU9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzLGw9T2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtmdW5jdGlvbiBwKGcpe2xldCBjPXt9O2ZvcihsZXQgRCBvZiBnLnBsdWdpbnMpaWYoRC5wYXJzZXJzKWZvcihsZXQgRSBvZiBpKEQucGFyc2VycykpT2JqZWN0LmRlZmluZVByb3BlcnR5KGMsRSxsKEQucGFyc2VycyxFKSk7cmV0dXJuIGN9ZnVuY3Rpb24gZChnKXtsZXQgYz1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06cChnKTtpZih0eXBlb2YgZy5wYXJzZXI9PVwiZnVuY3Rpb25cIilyZXR1cm57cGFyc2U6Zy5wYXJzZXIsYXN0Rm9ybWF0OlwiZXN0cmVlXCIsbG9jU3RhcnQ6bixsb2NFbmQ6dX07aWYodHlwZW9mIGcucGFyc2VyPT1cInN0cmluZ1wiKXtpZihPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwoYyxnLnBhcnNlcikpcmV0dXJuIGNbZy5wYXJzZXJdO3Rocm93IG5ldyB0KGBDb3VsZG4ndCByZXNvbHZlIHBhcnNlciBcIiR7Zy5wYXJzZXJ9XCIuIFBhcnNlcnMgbXVzdCBiZSBleHBsaWNpdGx5IGFkZGVkIHRvIHRoZSBzdGFuZGFsb25lIGJ1bmRsZS5gKX19ZnVuY3Rpb24geShnLGMpe2xldCBEPXAoYyksRT1PYmplY3QuZGVmaW5lUHJvcGVydGllcyh7fSxPYmplY3QuZnJvbUVudHJpZXMoT2JqZWN0LmtleXMoRCkubWFwKHc9Plt3LHtlbnVtZXJhYmxlOiEwLGdldCgpe3JldHVybiBEW3ddLnBhcnNlfX1dKSkpLF89ZChjLEQpO3RyeXtyZXR1cm4gXy5wcmVwcm9jZXNzJiYoZz1fLnByZXByb2Nlc3MoZyxjKSkse3RleHQ6Zyxhc3Q6Xy5wYXJzZShnLEUsYyl9fWNhdGNoKHcpe2xldHtsb2M6Rn09dztpZihGKXtsZXR7Y29kZUZyYW1lQ29sdW1uczpTfT1NbSgpO3Rocm93IHcuY29kZUZyYW1lPVMoZyxGLHtoaWdobGlnaHRDb2RlOiEwfSksdy5tZXNzYWdlKz1gXG5gK3cuY29kZUZyYW1lLHd9dGhyb3cgd319ci5leHBvcnRzPXtwYXJzZTp5LHJlc29sdmVQYXJzZXI6ZH19fSksdW89dGUoe1wic3JjL21haW4vb3B0aW9ucy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1aRCgpLHtVbmRlZmluZWRQYXJzZXJFcnJvcjpzfT1RdCgpLHtnZXRTdXBwb3J0SW5mbzphfT1YbigpLG49T20oKSx7cmVzb2x2ZVBhcnNlcjp1fT10dSgpLGk9e2FzdEZvcm1hdDpcImVzdHJlZVwiLHByaW50ZXI6e30sb3JpZ2luYWxUZXh0OnZvaWQgMCxsb2NTdGFydDpudWxsLGxvY0VuZDpudWxsfTtmdW5jdGlvbiBsKHkpe2xldCBnPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTp7fSxjPU9iamVjdC5hc3NpZ24oe30seSksRD1hKHtwbHVnaW5zOnkucGx1Z2lucyxzaG93VW5yZWxlYXNlZDohMCxzaG93RGVwcmVjYXRlZDohMH0pLm9wdGlvbnMsRT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saSksT2JqZWN0LmZyb21FbnRyaWVzKEQuZmlsdGVyKE49Pk4uZGVmYXVsdCE9PXZvaWQgMCkubWFwKE49PltOLm5hbWUsTi5kZWZhdWx0XSkpKTtpZighYy5wYXJzZXIpe2lmKCFjLmZpbGVwYXRoKShnLmxvZ2dlcnx8Y29uc29sZSkud2FybihcIk5vIHBhcnNlciBhbmQgbm8gZmlsZXBhdGggZ2l2ZW4sIHVzaW5nICdiYWJlbCcgdGhlIHBhcnNlciBub3cgYnV0IHRoaXMgd2lsbCB0aHJvdyBhbiBlcnJvciBpbiB0aGUgZnV0dXJlLiBQbGVhc2Ugc3BlY2lmeSBhIHBhcnNlciBvciBhIGZpbGVwYXRoIHNvIG9uZSBjYW4gYmUgaW5mZXJyZWQuXCIpLGMucGFyc2VyPVwiYmFiZWxcIjtlbHNlIGlmKGMucGFyc2VyPWQoYy5maWxlcGF0aCxjLnBsdWdpbnMpLCFjLnBhcnNlcil0aHJvdyBuZXcgcyhgTm8gcGFyc2VyIGNvdWxkIGJlIGluZmVycmVkIGZvciBmaWxlOiAke2MuZmlsZXBhdGh9YCl9bGV0IF89dShuLm5vcm1hbGl6ZUFwaU9wdGlvbnMoYyxbRC5maW5kKE49Pk4ubmFtZT09PVwicGFyc2VyXCIpXSx7cGFzc1Rocm91Z2g6ITAsbG9nZ2VyOiExfSkpO2MuYXN0Rm9ybWF0PV8uYXN0Rm9ybWF0LGMubG9jRW5kPV8ubG9jRW5kLGMubG9jU3RhcnQ9Xy5sb2NTdGFydDtsZXQgdz1wKGMpO2MucHJpbnRlcj13LnByaW50ZXJzW2MuYXN0Rm9ybWF0XTtsZXQgRj1PYmplY3QuZnJvbUVudHJpZXMoRC5maWx0ZXIoTj0+Ti5wbHVnaW5EZWZhdWx0cyYmTi5wbHVnaW5EZWZhdWx0c1t3Lm5hbWVdIT09dm9pZCAwKS5tYXAoTj0+W04ubmFtZSxOLnBsdWdpbkRlZmF1bHRzW3cubmFtZV1dKSksUz1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sRSksRik7Zm9yKGxldFtOLEldb2YgT2JqZWN0LmVudHJpZXMoUykpKGNbTl09PT1udWxsfHxjW05dPT09dm9pZCAwKSYmKGNbTl09SSk7cmV0dXJuIGMucGFyc2VyPT09XCJqc29uXCImJihjLnRyYWlsaW5nQ29tbWE9XCJub25lXCIpLG4ubm9ybWFsaXplQXBpT3B0aW9ucyhjLEQsT2JqZWN0LmFzc2lnbih7cGFzc1Rocm91Z2g6T2JqZWN0LmtleXMoaSl9LGcpKX1mdW5jdGlvbiBwKHkpe2xldHthc3RGb3JtYXQ6Z309eTtpZighZyl0aHJvdyBuZXcgRXJyb3IoXCJnZXRQbHVnaW4oKSByZXF1aXJlcyBhc3RGb3JtYXQgdG8gYmUgc2V0XCIpO2xldCBjPXkucGx1Z2lucy5maW5kKEQ9PkQucHJpbnRlcnMmJkQucHJpbnRlcnNbZ10pO2lmKCFjKXRocm93IG5ldyBFcnJvcihgQ291bGRuJ3QgZmluZCBwbHVnaW4gZm9yIEFTVCBmb3JtYXQgXCIke2d9XCJgKTtyZXR1cm4gY31mdW5jdGlvbiBkKHksZyl7bGV0IGM9dC5iYXNlbmFtZSh5KS50b0xvd2VyQ2FzZSgpLEU9YSh7cGx1Z2luczpnfSkubGFuZ3VhZ2VzLmZpbHRlcihfPT5fLnNpbmNlIT09bnVsbCkuZmluZChfPT5fLmV4dGVuc2lvbnMmJl8uZXh0ZW5zaW9ucy5zb21lKHc9PmMuZW5kc1dpdGgodykpfHxfLmZpbGVuYW1lcyYmXy5maWxlbmFtZXMuc29tZSh3PT53LnRvTG93ZXJDYXNlKCk9PT1jKSk7cmV0dXJuIEUmJkUucGFyc2Vyc1swXX1yLmV4cG9ydHM9e25vcm1hbGl6ZTpsLGhpZGRlbkRlZmF1bHRzOmksaW5mZXJQYXJzZXI6ZH19fSksUm09dGUoe1wic3JjL21haW4vbWFzc2FnZS1hc3QuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7ZnVuY3Rpb24gdChzLGEsbil7aWYoQXJyYXkuaXNBcnJheShzKSlyZXR1cm4gcy5tYXAocD0+dChwLGEsbikpLmZpbHRlcihCb29sZWFuKTtpZighc3x8dHlwZW9mIHMhPVwib2JqZWN0XCIpcmV0dXJuIHM7bGV0IHU9YS5wcmludGVyLm1hc3NhZ2VBc3ROb2RlLGk7dSYmdS5pZ25vcmVkUHJvcGVydGllcz9pPXUuaWdub3JlZFByb3BlcnRpZXM6aT1uZXcgU2V0O2xldCBsPXt9O2ZvcihsZXRbcCxkXW9mIE9iamVjdC5lbnRyaWVzKHMpKSFpLmhhcyhwKSYmdHlwZW9mIGQhPVwiZnVuY3Rpb25cIiYmKGxbcF09dChkLGEscykpO2lmKHUpe2xldCBwPXUocyxsLG4pO2lmKHA9PT1udWxsKXJldHVybjtpZihwKXJldHVybiBwfXJldHVybiBsfXIuZXhwb3J0cz10fX0pLFp0PXRlKHtcInNjcmlwdHMvYnVpbGQvc2hpbXMvYXNzZXJ0LmNqc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD0oKT0+e307dC5vaz10LHQuc3RyaWN0RXF1YWw9dCxyLmV4cG9ydHM9dH19KSxldD10ZSh7XCJzcmMvbWFpbi9jb21tZW50cy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1adCgpLHtidWlsZGVyczp7bGluZTpzLGhhcmRsaW5lOmEsYnJlYWtQYXJlbnQ6bixpbmRlbnQ6dSxsaW5lU3VmZml4Omksam9pbjpsLGN1cnNvcjpwfX09cWUoKSx7aGFzTmV3bGluZTpkLHNraXBOZXdsaW5lOnksc2tpcFNwYWNlczpnLGlzUHJldmlvdXNMaW5lRW1wdHk6YyxhZGRMZWFkaW5nQ29tbWVudDpELGFkZERhbmdsaW5nQ29tbWVudDpFLGFkZFRyYWlsaW5nQ29tbWVudDpffT1VZSgpLHc9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gRihrLE0sUil7aWYoIWspcmV0dXJuO2xldHtwcmludGVyOnEsbG9jU3RhcnQ6Sixsb2NFbmQ6TH09TTtpZihSKXtpZihxLmNhbkF0dGFjaENvbW1lbnQmJnEuY2FuQXR0YWNoQ29tbWVudChrKSl7bGV0IFY7Zm9yKFY9Ui5sZW5ndGgtMTtWPj0wJiYhKEooUltWXSk8PUooaykmJkwoUltWXSk8PUwoaykpOy0tVik7Ui5zcGxpY2UoVisxLDAsayk7cmV0dXJufX1lbHNlIGlmKHcuaGFzKGspKXJldHVybiB3LmdldChrKTtsZXQgUT1xLmdldENvbW1lbnRDaGlsZE5vZGVzJiZxLmdldENvbW1lbnRDaGlsZE5vZGVzKGssTSl8fHR5cGVvZiBrPT1cIm9iamVjdFwiJiZPYmplY3QuZW50cmllcyhrKS5maWx0ZXIoVj0+e2xldFtqXT1WO3JldHVybiBqIT09XCJlbmNsb3NpbmdOb2RlXCImJmohPT1cInByZWNlZGluZ05vZGVcIiYmaiE9PVwiZm9sbG93aW5nTm9kZVwiJiZqIT09XCJ0b2tlbnNcIiYmaiE9PVwiY29tbWVudHNcIiYmaiE9PVwicGFyZW50XCJ9KS5tYXAoVj0+e2xldFssal09VjtyZXR1cm4gan0pO2lmKFEpe1J8fChSPVtdLHcuc2V0KGssUikpO2ZvcihsZXQgViBvZiBRKUYoVixNLFIpO3JldHVybiBSfX1mdW5jdGlvbiBTKGssTSxSLHEpe2xldHtsb2NTdGFydDpKLGxvY0VuZDpMfT1SLFE9SihNKSxWPUwoTSksaj1GKGssUiksWSxpZSxlZT0wLGxlPWoubGVuZ3RoO2Zvcig7ZWU8bGU7KXtsZXQgVz1lZStsZT4+MSxLPWpbV10sZGU9SihLKSx1ZT1MKEspO2lmKGRlPD1RJiZWPD11ZSlyZXR1cm4gUyhLLE0sUixLKTtpZih1ZTw9USl7WT1LLGVlPVcrMTtjb250aW51ZX1pZihWPD1kZSl7aWU9SyxsZT1XO2NvbnRpbnVlfXRocm93IG5ldyBFcnJvcihcIkNvbW1lbnQgbG9jYXRpb24gb3ZlcmxhcHMgd2l0aCBub2RlIGxvY2F0aW9uXCIpfWlmKHEmJnEudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCIpe2xldHtxdWFzaXM6V309cSxLPXYoVyxNLFIpO1kmJnYoVyxZLFIpIT09SyYmKFk9bnVsbCksaWUmJnYoVyxpZSxSKSE9PUsmJihpZT1udWxsKX1yZXR1cm57ZW5jbG9zaW5nTm9kZTpxLHByZWNlZGluZ05vZGU6WSxmb2xsb3dpbmdOb2RlOmllfX12YXIgTj0oKT0+ITE7ZnVuY3Rpb24gSShrLE0sUixxKXtpZighQXJyYXkuaXNBcnJheShrKSlyZXR1cm47bGV0IEo9W10se2xvY1N0YXJ0OkwsbG9jRW5kOlEscHJpbnRlcjp7aGFuZGxlQ29tbWVudHM6Vj17fX19PXEse2F2b2lkQXN0TXV0YXRpb246aixvd25MaW5lOlk9TixlbmRPZkxpbmU6aWU9TixyZW1haW5pbmc6ZWU9Tn09VixsZT1rLm1hcCgoVyxLKT0+T2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LFMoTSxXLHEpKSx7fSx7Y29tbWVudDpXLHRleHQ6UixvcHRpb25zOnEsYXN0Ok0saXNMYXN0Q29tbWVudDprLmxlbmd0aC0xPT09S30pKTtmb3IobGV0W1csS11vZiBsZS5lbnRyaWVzKCkpe2xldHtjb21tZW50OmRlLHByZWNlZGluZ05vZGU6dWUsZW5jbG9zaW5nTm9kZTpGZSxmb2xsb3dpbmdOb2RlOnosdGV4dDpVLG9wdGlvbnM6Wixhc3Q6c2UsaXNMYXN0Q29tbWVudDpEZX09SztpZihaLnBhcnNlcj09PVwianNvblwifHxaLnBhcnNlcj09PVwianNvbjVcInx8Wi5wYXJzZXI9PT1cIl9fanNfZXhwcmVzc2lvblwifHxaLnBhcnNlcj09PVwiX192dWVfZXhwcmVzc2lvblwifHxaLnBhcnNlcj09PVwiX192dWVfdHNfZXhwcmVzc2lvblwiKXtpZihMKGRlKS1MKHNlKTw9MCl7RChzZSxkZSk7Y29udGludWV9aWYoUShkZSktUShzZSk+PTApe18oc2UsZGUpO2NvbnRpbnVlfX1sZXQgZ2U7aWYoaj9nZT1bS106KGRlLmVuY2xvc2luZ05vZGU9RmUsZGUucHJlY2VkaW5nTm9kZT11ZSxkZS5mb2xsb3dpbmdOb2RlPXosZ2U9W2RlLFUsWixzZSxEZV0pLCQoVSxaLGxlLFcpKWRlLnBsYWNlbWVudD1cIm93bkxpbmVcIixZKC4uLmdlKXx8KHo/RCh6LGRlKTp1ZT9fKHVlLGRlKTpFKEZlfHxzZSxkZSkpO2Vsc2UgaWYoZihVLFosbGUsVykpZGUucGxhY2VtZW50PVwiZW5kT2ZMaW5lXCIsaWUoLi4uZ2UpfHwodWU/Xyh1ZSxkZSk6ej9EKHosZGUpOkUoRmV8fHNlLGRlKSk7ZWxzZSBpZihkZS5wbGFjZW1lbnQ9XCJyZW1haW5pbmdcIiwhZWUoLi4uZ2UpKWlmKHVlJiZ6KXtsZXQgaGU9Si5sZW5ndGg7aGU+MCYmSltoZS0xXS5mb2xsb3dpbmdOb2RlIT09eiYmVChKLFUsWiksSi5wdXNoKEspfWVsc2UgdWU/Xyh1ZSxkZSk6ej9EKHosZGUpOkUoRmV8fHNlLGRlKX1pZihUKEosUixxKSwhailmb3IobGV0IFcgb2YgaylkZWxldGUgVy5wcmVjZWRpbmdOb2RlLGRlbGV0ZSBXLmVuY2xvc2luZ05vZGUsZGVsZXRlIFcuZm9sbG93aW5nTm9kZX12YXIgUD1rPT4hL1tcXFNcXG5cXHUyMDI4XFx1MjAyOV0vLnRlc3Qoayk7ZnVuY3Rpb24gJChrLE0sUixxKXtsZXR7Y29tbWVudDpKLHByZWNlZGluZ05vZGU6TH09UltxXSx7bG9jU3RhcnQ6USxsb2NFbmQ6Vn09TSxqPVEoSik7aWYoTClmb3IobGV0IFk9cS0xO1k+PTA7WS0tKXtsZXR7Y29tbWVudDppZSxwcmVjZWRpbmdOb2RlOmVlfT1SW1ldO2lmKGVlIT09THx8IVAoay5zbGljZShWKGllKSxqKSkpYnJlYWs7aj1RKGllKX1yZXR1cm4gZChrLGose2JhY2t3YXJkczohMH0pfWZ1bmN0aW9uIGYoayxNLFIscSl7bGV0e2NvbW1lbnQ6Sixmb2xsb3dpbmdOb2RlOkx9PVJbcV0se2xvY1N0YXJ0OlEsbG9jRW5kOlZ9PU0saj1WKEopO2lmKEwpZm9yKGxldCBZPXErMTtZPFIubGVuZ3RoO1krKyl7bGV0e2NvbW1lbnQ6aWUsZm9sbG93aW5nTm9kZTplZX09UltZXTtpZihlZSE9PUx8fCFQKGsuc2xpY2UoaixRKGllKSkpKWJyZWFrO2o9VihpZSl9cmV0dXJuIGQoayxqKX1mdW5jdGlvbiBUKGssTSxSKXtsZXQgcT1rLmxlbmd0aDtpZihxPT09MClyZXR1cm47bGV0e3ByZWNlZGluZ05vZGU6Sixmb2xsb3dpbmdOb2RlOkwsZW5jbG9zaW5nTm9kZTpRfT1rWzBdLFY9Ui5wcmludGVyLmdldEdhcFJlZ2V4JiZSLnByaW50ZXIuZ2V0R2FwUmVnZXgoUSl8fC9eW1xccyhdKiQvLGo9Ui5sb2NTdGFydChMKSxZO2ZvcihZPXE7WT4wOy0tWSl7bGV0e2NvbW1lbnQ6aWUscHJlY2VkaW5nTm9kZTplZSxmb2xsb3dpbmdOb2RlOmxlfT1rW1ktMV07dC5zdHJpY3RFcXVhbChlZSxKKSx0LnN0cmljdEVxdWFsKGxlLEwpO2xldCBXPU0uc2xpY2UoUi5sb2NFbmQoaWUpLGopO2lmKFYudGVzdChXKSlqPVIubG9jU3RhcnQoaWUpO2Vsc2UgYnJlYWt9Zm9yKGxldFtpZSx7Y29tbWVudDplZX1db2Ygay5lbnRyaWVzKCkpaWU8WT9fKEosZWUpOkQoTCxlZSk7Zm9yKGxldCBpZSBvZltKLExdKWllLmNvbW1lbnRzJiZpZS5jb21tZW50cy5sZW5ndGg+MSYmaWUuY29tbWVudHMuc29ydCgoZWUsbGUpPT5SLmxvY1N0YXJ0KGVlKS1SLmxvY1N0YXJ0KGxlKSk7ay5sZW5ndGg9MH1mdW5jdGlvbiBtKGssTSl7bGV0IFI9ay5nZXRWYWx1ZSgpO3JldHVybiBSLnByaW50ZWQ9ITAsTS5wcmludGVyLnByaW50Q29tbWVudChrLE0pfWZ1bmN0aW9uIHYoayxNLFIpe2xldCBxPVIubG9jU3RhcnQoTSktMTtmb3IobGV0IEo9MTtKPGsubGVuZ3RoOysrSilpZihxPFIubG9jU3RhcnQoa1tKXSkpcmV0dXJuIEotMTtyZXR1cm4gMH1mdW5jdGlvbiBvKGssTSl7bGV0IFI9ay5nZXRWYWx1ZSgpLHE9W20oayxNKV0se3ByaW50ZXI6SixvcmlnaW5hbFRleHQ6TCxsb2NTdGFydDpRLGxvY0VuZDpWfT1NO2lmKEouaXNCbG9ja0NvbW1lbnQmJkouaXNCbG9ja0NvbW1lbnQoUikpe2xldCBpZT1kKEwsVihSKSk/ZChMLFEoUikse2JhY2t3YXJkczohMH0pP2E6czpcIiBcIjtxLnB1c2goaWUpfWVsc2UgcS5wdXNoKGEpO2xldCBZPXkoTCxnKEwsVihSKSkpO3JldHVybiBZIT09ITEmJmQoTCxZKSYmcS5wdXNoKGEpLHF9ZnVuY3Rpb24gaChrLE0pe2xldCBSPWsuZ2V0VmFsdWUoKSxxPW0oayxNKSx7cHJpbnRlcjpKLG9yaWdpbmFsVGV4dDpMLGxvY1N0YXJ0OlF9PU0sVj1KLmlzQmxvY2tDb21tZW50JiZKLmlzQmxvY2tDb21tZW50KFIpO2lmKGQoTCxRKFIpLHtiYWNrd2FyZHM6ITB9KSl7bGV0IFk9YyhMLFIsUSk7cmV0dXJuIGkoW2EsWT9hOlwiXCIscV0pfWxldCBqPVtcIiBcIixxXTtyZXR1cm4gVnx8KGo9W2koaiksbl0pLGp9ZnVuY3Rpb24gQyhrLE0sUixxKXtsZXQgSj1bXSxMPWsuZ2V0VmFsdWUoKTtyZXR1cm4hTHx8IUwuY29tbWVudHN8fChrLmVhY2goKCk9PntsZXQgUT1rLmdldFZhbHVlKCk7IVEubGVhZGluZyYmIVEudHJhaWxpbmcmJighcXx8cShRKSkmJkoucHVzaChtKGssTSkpfSxcImNvbW1lbnRzXCIpLEoubGVuZ3RoPT09MCk/XCJcIjpSP2woYSxKKTp1KFthLGwoYSxKKV0pfWZ1bmN0aW9uIHgoayxNLFIpe2xldCBxPWsuZ2V0VmFsdWUoKTtpZighcSlyZXR1cm57fTtsZXQgSj1xLmNvbW1lbnRzfHxbXTtSJiYoSj1KLmZpbHRlcihqPT4hUi5oYXMoaikpKTtsZXQgTD1xPT09TS5jdXJzb3JOb2RlO2lmKEoubGVuZ3RoPT09MCl7bGV0IGo9TD9wOlwiXCI7cmV0dXJue2xlYWRpbmc6aix0cmFpbGluZzpqfX1sZXQgUT1bXSxWPVtdO3JldHVybiBrLmVhY2goKCk9PntsZXQgaj1rLmdldFZhbHVlKCk7aWYoUiYmUi5oYXMoaikpcmV0dXJuO2xldHtsZWFkaW5nOlksdHJhaWxpbmc6aWV9PWo7WT9RLnB1c2gobyhrLE0pKTppZSYmVi5wdXNoKGgoayxNKSl9LFwiY29tbWVudHNcIiksTCYmKFEudW5zaGlmdChwKSxWLnB1c2gocCkpLHtsZWFkaW5nOlEsdHJhaWxpbmc6Vn19ZnVuY3Rpb24gYihrLE0sUixxKXtsZXR7bGVhZGluZzpKLHRyYWlsaW5nOkx9PXgoayxSLHEpO3JldHVybiFKJiYhTD9NOltKLE0sTF19ZnVuY3Rpb24gQihrKXtpZihrKWZvcihsZXQgTSBvZiBrKXtpZighTS5wcmludGVkKXRocm93IG5ldyBFcnJvcignQ29tbWVudCBcIicrTS52YWx1ZS50cmltKCkrJ1wiIHdhcyBub3QgcHJpbnRlZC4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yIScpO2RlbGV0ZSBNLnByaW50ZWR9fXIuZXhwb3J0cz17YXR0YWNoOkkscHJpbnRDb21tZW50czpiLHByaW50Q29tbWVudHNTZXBhcmF0ZWx5OngscHJpbnREYW5nbGluZ0NvbW1lbnRzOkMsZ2V0U29ydGVkQ2hpbGROb2RlczpGLGVuc3VyZUFsbENvbW1lbnRzUHJpbnRlZDpCfX19KSwkbT10ZSh7XCJzcmMvY29tbW9uL2FzdC1wYXRoLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PWx0KCk7ZnVuY3Rpb24gcyh1LGkpe2xldCBsPWEodS5zdGFjayxpKTtyZXR1cm4gbD09PS0xP251bGw6dS5zdGFja1tsXX1mdW5jdGlvbiBhKHUsaSl7Zm9yKGxldCBsPXUubGVuZ3RoLTE7bD49MDtsLT0yKXtsZXQgcD11W2xdO2lmKHAmJiFBcnJheS5pc0FycmF5KHApJiYtLWk8MClyZXR1cm4gbH1yZXR1cm4tMX12YXIgbj1jbGFzc3tjb25zdHJ1Y3Rvcih1KXt0aGlzLnN0YWNrPVt1XX1nZXROYW1lKCl7bGV0e3N0YWNrOnV9PXRoaXMse2xlbmd0aDppfT11O3JldHVybiBpPjE/dVtpLTJdOm51bGx9Z2V0VmFsdWUoKXtyZXR1cm4gdCh0aGlzLnN0YWNrKX1nZXROb2RlKCl7bGV0IHU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT12b2lkIDA/YXJndW1lbnRzWzBdOjA7cmV0dXJuIHModGhpcyx1KX1nZXRQYXJlbnROb2RlKCl7bGV0IHU9YXJndW1lbnRzLmxlbmd0aD4wJiZhcmd1bWVudHNbMF0hPT12b2lkIDA/YXJndW1lbnRzWzBdOjA7cmV0dXJuIHModGhpcyx1KzEpfWNhbGwodSl7bGV0e3N0YWNrOml9PXRoaXMse2xlbmd0aDpsfT1pLHA9dChpKTtmb3IodmFyIGQ9YXJndW1lbnRzLmxlbmd0aCx5PW5ldyBBcnJheShkPjE/ZC0xOjApLGc9MTtnPGQ7ZysrKXlbZy0xXT1hcmd1bWVudHNbZ107Zm9yKGxldCBEIG9mIHkpcD1wW0RdLGkucHVzaChELHApO2xldCBjPXUodGhpcyk7cmV0dXJuIGkubGVuZ3RoPWwsY31jYWxsUGFyZW50KHUpe2xldCBpPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTowLGw9YSh0aGlzLnN0YWNrLGkrMSkscD10aGlzLnN0YWNrLnNwbGljZShsKzEpLGQ9dSh0aGlzKTtyZXR1cm4gdGhpcy5zdGFjay5wdXNoKC4uLnApLGR9ZWFjaCh1KXtsZXR7c3RhY2s6aX09dGhpcyx7bGVuZ3RoOmx9PWkscD10KGkpO2Zvcih2YXIgZD1hcmd1bWVudHMubGVuZ3RoLHk9bmV3IEFycmF5KGQ+MT9kLTE6MCksZz0xO2c8ZDtnKyspeVtnLTFdPWFyZ3VtZW50c1tnXTtmb3IobGV0IGMgb2YgeSlwPXBbY10saS5wdXNoKGMscCk7Zm9yKGxldCBjPTA7YzxwLmxlbmd0aDsrK2MpaS5wdXNoKGMscFtjXSksdSh0aGlzLGMscCksaS5sZW5ndGgtPTI7aS5sZW5ndGg9bH1tYXAodSl7bGV0IGk9W107Zm9yKHZhciBsPWFyZ3VtZW50cy5sZW5ndGgscD1uZXcgQXJyYXkobD4xP2wtMTowKSxkPTE7ZDxsO2QrKylwW2QtMV09YXJndW1lbnRzW2RdO3JldHVybiB0aGlzLmVhY2goKHksZyxjKT0+e2lbZ109dSh5LGcsYyl9LC4uLnApLGl9dHJ5KHUpe2xldHtzdGFjazppfT10aGlzLGw9Wy4uLmldO3RyeXtyZXR1cm4gdSgpfWZpbmFsbHl7aS5sZW5ndGg9MCxpLnB1c2goLi4ubCl9fW1hdGNoKCl7bGV0IHU9dGhpcy5zdGFjay5sZW5ndGgtMSxpPW51bGwsbD10aGlzLnN0YWNrW3UtLV07Zm9yKHZhciBwPWFyZ3VtZW50cy5sZW5ndGgsZD1uZXcgQXJyYXkocCkseT0wO3k8cDt5KyspZFt5XT1hcmd1bWVudHNbeV07Zm9yKGxldCBnIG9mIGQpe2lmKGw9PT12b2lkIDApcmV0dXJuITE7bGV0IGM9bnVsbDtpZih0eXBlb2YgaT09XCJudW1iZXJcIiYmKGM9aSxpPXRoaXMuc3RhY2tbdS0tXSxsPXRoaXMuc3RhY2tbdS0tXSksZyYmIWcobCxpLGMpKXJldHVybiExO2k9dGhpcy5zdGFja1t1LS1dLGw9dGhpcy5zdGFja1t1LS1dfXJldHVybiEwfWZpbmRBbmNlc3Rvcih1KXtsZXQgaT10aGlzLnN0YWNrLmxlbmd0aC0xLGw9bnVsbCxwPXRoaXMuc3RhY2tbaS0tXTtmb3IoO3A7KXtsZXQgZD1udWxsO2lmKHR5cGVvZiBsPT1cIm51bWJlclwiJiYoZD1sLGw9dGhpcy5zdGFja1tpLS1dLHA9dGhpcy5zdGFja1tpLS1dKSxsIT09bnVsbCYmdShwLGwsZCkpcmV0dXJuIHA7bD10aGlzLnN0YWNrW2ktLV0scD10aGlzLnN0YWNrW2ktLV19fX07ci5leHBvcnRzPW59fSksVm09dGUoe1wic3JjL21haW4vbXVsdGlwYXJzZXIuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3V0aWxzOntzdHJpcFRyYWlsaW5nSGFyZGxpbmU6dH19PXFlKCkse25vcm1hbGl6ZTpzfT11bygpLGE9ZXQoKTtmdW5jdGlvbiBuKGksbCxwLGQpe2lmKHAucHJpbnRlci5lbWJlZCYmcC5lbWJlZGRlZExhbmd1YWdlRm9ybWF0dGluZz09PVwiYXV0b1wiKXJldHVybiBwLnByaW50ZXIuZW1iZWQoaSxsLCh5LGcsYyk9PnUoeSxnLHAsZCxjKSxwKX1mdW5jdGlvbiB1KGksbCxwLGQpe2xldHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6eT0hMX09YXJndW1lbnRzLmxlbmd0aD40JiZhcmd1bWVudHNbNF0hPT12b2lkIDA/YXJndW1lbnRzWzRdOnt9LGc9cyhPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxwKSxsKSx7fSx7cGFyZW50UGFyc2VyOnAucGFyc2VyLG9yaWdpbmFsVGV4dDppfSkse3Bhc3NUaHJvdWdoOiEwfSksYz10dSgpLnBhcnNlKGksZykse2FzdDpEfT1jO2k9Yy50ZXh0O2xldCBFPUQuY29tbWVudHM7ZGVsZXRlIEQuY29tbWVudHMsYS5hdHRhY2goRSxELGksZyksZ1tTeW1ib2wuZm9yKFwiY29tbWVudHNcIildPUV8fFtdLGdbU3ltYm9sLmZvcihcInRva2Vuc1wiKV09RC50b2tlbnN8fFtdO2xldCBfPWQoRCxnKTtyZXR1cm4gYS5lbnN1cmVBbGxDb21tZW50c1ByaW50ZWQoRSkseT90eXBlb2YgXz09XCJzdHJpbmdcIj9fLnJlcGxhY2UoLyg/Olxccj9cXG4pKiQvLFwiXCIpOnQoXyk6X31yLmV4cG9ydHM9e3ByaW50U3VidHJlZTpufX19KSxXbT10ZSh7XCJzcmMvbWFpbi9hc3QtdG8tZG9jLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PSRtKCkse2J1aWxkZXJzOntoYXJkbGluZTpzLGFkZEFsaWdubWVudFRvRG9jOmF9LHV0aWxzOntwcm9wYWdhdGVCcmVha3M6bn19PXFlKCkse3ByaW50Q29tbWVudHM6dX09ZXQoKSxpPVZtKCk7ZnVuY3Rpb24gbCh5LGcpe2xldCBjPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTowLHtwcmludGVyOkR9PWc7RC5wcmVwcm9jZXNzJiYoeT1ELnByZXByb2Nlc3MoeSxnKSk7bGV0IEU9bmV3IE1hcCxfPW5ldyB0KHkpLHc9RigpO3JldHVybiBjPjAmJih3PWEoW3Msd10sYyxnLnRhYldpZHRoKSksbih3KSx3O2Z1bmN0aW9uIEYoTixJKXtyZXR1cm4gTj09PXZvaWQgMHx8Tj09PV8/UyhJKTpBcnJheS5pc0FycmF5KE4pP18uY2FsbCgoKT0+UyhJKSwuLi5OKTpfLmNhbGwoKCk9PlMoSSksTil9ZnVuY3Rpb24gUyhOKXtsZXQgST1fLmdldFZhbHVlKCksUD1JJiZ0eXBlb2YgST09XCJvYmplY3RcIiYmTj09PXZvaWQgMDtpZihQJiZFLmhhcyhJKSlyZXR1cm4gRS5nZXQoSSk7bGV0ICQ9ZChfLGcsRixOKTtyZXR1cm4gUCYmRS5zZXQoSSwkKSwkfX1mdW5jdGlvbiBwKHksZyl7bGV0e29yaWdpbmFsVGV4dDpjLFtTeW1ib2wuZm9yKFwiY29tbWVudHNcIildOkQsbG9jU3RhcnQ6RSxsb2NFbmQ6X309Zyx3PUUoeSksRj1fKHkpLFM9bmV3IFNldDtmb3IobGV0IE4gb2YgRClFKE4pPj13JiZfKE4pPD1GJiYoTi5wcmludGVkPSEwLFMuYWRkKE4pKTtyZXR1cm57ZG9jOmMuc2xpY2UodyxGKSxwcmludGVkQ29tbWVudHM6U319ZnVuY3Rpb24gZCh5LGcsYyxEKXtsZXQgRT15LmdldFZhbHVlKCkse3ByaW50ZXI6X309Zyx3LEY7aWYoXy5oYXNQcmV0dGllcklnbm9yZSYmXy5oYXNQcmV0dGllcklnbm9yZSh5KSkoe2RvYzp3LHByaW50ZWRDb21tZW50czpGfT1wKEUsZykpO2Vsc2V7aWYoRSl0cnl7dz1pLnByaW50U3VidHJlZSh5LGMsZyxsKX1jYXRjaChTKXtpZihnbG9iYWxUaGlzLlBSRVRUSUVSX0RFQlVHKXRocm93IFN9d3x8KHc9Xy5wcmludCh5LGcsYyxEKSl9cmV0dXJuKCFfLndpbGxQcmludE93bkNvbW1lbnRzfHwhXy53aWxsUHJpbnRPd25Db21tZW50cyh5LGcpKSYmKHc9dSh5LHcsZyxGKSksd31yLmV4cG9ydHM9bH19KSxIbT10ZSh7XCJzcmMvbWFpbi9yYW5nZS11dGlsLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PVp0KCkscz1ldCgpLGE9RD0+e2xldHtwYXJzZXI6RX09RDtyZXR1cm4gRT09PVwianNvblwifHxFPT09XCJqc29uNVwifHxFPT09XCJqc29uLXN0cmluZ2lmeVwifTtmdW5jdGlvbiBuKEQsRSl7bGV0IF89W0Qubm9kZSwuLi5ELnBhcmVudE5vZGVzXSx3PW5ldyBTZXQoW0Uubm9kZSwuLi5FLnBhcmVudE5vZGVzXSk7cmV0dXJuIF8uZmluZChGPT5kLmhhcyhGLnR5cGUpJiZ3LmhhcyhGKSl9ZnVuY3Rpb24gdShEKXtsZXQgRT1ELmxlbmd0aC0xO2Zvcig7Oyl7bGV0IF89RFtFXTtpZihfJiYoXy50eXBlPT09XCJQcm9ncmFtXCJ8fF8udHlwZT09PVwiRmlsZVwiKSlFLS07ZWxzZSBicmVha31yZXR1cm4gRC5zbGljZSgwLEUrMSl9ZnVuY3Rpb24gaShELEUsXyl7bGV0e2xvY1N0YXJ0OncsbG9jRW5kOkZ9PV8sUz1ELm5vZGUsTj1FLm5vZGU7aWYoUz09PU4pcmV0dXJue3N0YXJ0Tm9kZTpTLGVuZE5vZGU6Tn07bGV0IEk9dyhELm5vZGUpO2ZvcihsZXQgJCBvZiB1KEUucGFyZW50Tm9kZXMpKWlmKHcoJCk+PUkpTj0kO2Vsc2UgYnJlYWs7bGV0IFA9RihFLm5vZGUpO2ZvcihsZXQgJCBvZiB1KEQucGFyZW50Tm9kZXMpKXtpZihGKCQpPD1QKVM9JDtlbHNlIGJyZWFrO2lmKFM9PT1OKWJyZWFrfXJldHVybntzdGFydE5vZGU6UyxlbmROb2RlOk59fWZ1bmN0aW9uIGwoRCxFLF8sdyl7bGV0IEY9YXJndW1lbnRzLmxlbmd0aD40JiZhcmd1bWVudHNbNF0hPT12b2lkIDA/YXJndW1lbnRzWzRdOltdLFM9YXJndW1lbnRzLmxlbmd0aD41P2FyZ3VtZW50c1s1XTp2b2lkIDAse2xvY1N0YXJ0Ok4sbG9jRW5kOkl9PV8sUD1OKEQpLCQ9SShEKTtpZighKEU+JHx8RTxQfHxTPT09XCJyYW5nZUVuZFwiJiZFPT09UHx8Uz09PVwicmFuZ2VTdGFydFwiJiZFPT09JCkpe2ZvcihsZXQgZiBvZiBzLmdldFNvcnRlZENoaWxkTm9kZXMoRCxfKSl7bGV0IFQ9bChmLEUsXyx3LFtELC4uLkZdLFMpO2lmKFQpcmV0dXJuIFR9aWYoIXd8fHcoRCxGWzBdKSlyZXR1cm57bm9kZTpELHBhcmVudE5vZGVzOkZ9fX1mdW5jdGlvbiBwKEQsRSl7cmV0dXJuIEUhPT1cIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiJiZEIT09XCJUeXBlUGFyYW1ldGVyRGVjbGFyYXRpb25cIiYmKEQ9PT1cIkRpcmVjdGl2ZVwifHxEPT09XCJUeXBlQWxpYXNcInx8RD09PVwiVFNFeHBvcnRBc3NpZ25tZW50XCJ8fEQuc3RhcnRzV2l0aChcIkRlY2xhcmVcIil8fEQuc3RhcnRzV2l0aChcIlRTRGVjbGFyZVwiKXx8RC5lbmRzV2l0aChcIlN0YXRlbWVudFwiKXx8RC5lbmRzV2l0aChcIkRlY2xhcmF0aW9uXCIpKX12YXIgZD1uZXcgU2V0KFtcIk9iamVjdEV4cHJlc3Npb25cIixcIkFycmF5RXhwcmVzc2lvblwiLFwiU3RyaW5nTGl0ZXJhbFwiLFwiTnVtZXJpY0xpdGVyYWxcIixcIkJvb2xlYW5MaXRlcmFsXCIsXCJOdWxsTGl0ZXJhbFwiLFwiVW5hcnlFeHByZXNzaW9uXCIsXCJUZW1wbGF0ZUxpdGVyYWxcIl0pLHk9bmV3IFNldChbXCJPcGVyYXRpb25EZWZpbml0aW9uXCIsXCJGcmFnbWVudERlZmluaXRpb25cIixcIlZhcmlhYmxlRGVmaW5pdGlvblwiLFwiVHlwZUV4dGVuc2lvbkRlZmluaXRpb25cIixcIk9iamVjdFR5cGVEZWZpbml0aW9uXCIsXCJGaWVsZERlZmluaXRpb25cIixcIkRpcmVjdGl2ZURlZmluaXRpb25cIixcIkVudW1UeXBlRGVmaW5pdGlvblwiLFwiRW51bVZhbHVlRGVmaW5pdGlvblwiLFwiSW5wdXRWYWx1ZURlZmluaXRpb25cIixcIklucHV0T2JqZWN0VHlwZURlZmluaXRpb25cIixcIlNjaGVtYURlZmluaXRpb25cIixcIk9wZXJhdGlvblR5cGVEZWZpbml0aW9uXCIsXCJJbnRlcmZhY2VUeXBlRGVmaW5pdGlvblwiLFwiVW5pb25UeXBlRGVmaW5pdGlvblwiLFwiU2NhbGFyVHlwZURlZmluaXRpb25cIl0pO2Z1bmN0aW9uIGcoRCxFLF8pe2lmKCFFKXJldHVybiExO3N3aXRjaChELnBhcnNlcil7Y2FzZVwiZmxvd1wiOmNhc2VcImJhYmVsXCI6Y2FzZVwiYmFiZWwtZmxvd1wiOmNhc2VcImJhYmVsLXRzXCI6Y2FzZVwidHlwZXNjcmlwdFwiOmNhc2VcImFjb3JuXCI6Y2FzZVwiZXNwcmVlXCI6Y2FzZVwibWVyaXlhaFwiOmNhc2VcIl9fYmFiZWxfZXN0cmVlXCI6cmV0dXJuIHAoRS50eXBlLF8mJl8udHlwZSk7Y2FzZVwianNvblwiOmNhc2VcImpzb241XCI6Y2FzZVwianNvbi1zdHJpbmdpZnlcIjpyZXR1cm4gZC5oYXMoRS50eXBlKTtjYXNlXCJncmFwaHFsXCI6cmV0dXJuIHkuaGFzKEUua2luZCk7Y2FzZVwidnVlXCI6cmV0dXJuIEUudGFnIT09XCJyb290XCJ9cmV0dXJuITF9ZnVuY3Rpb24gYyhELEUsXyl7bGV0e3JhbmdlU3RhcnQ6dyxyYW5nZUVuZDpGLGxvY1N0YXJ0OlMsbG9jRW5kOk59PUU7dC5vayhGPncpO2xldCBJPUQuc2xpY2UodyxGKS5zZWFyY2goL1xcUy8pLFA9ST09PS0xO2lmKCFQKWZvcih3Kz1JO0Y+dyYmIS9cXFMvLnRlc3QoRFtGLTFdKTstLUYpO2xldCAkPWwoXyx3LEUsKHYsbyk9PmcoRSx2LG8pLFtdLFwicmFuZ2VTdGFydFwiKSxmPVA/JDpsKF8sRixFLHY9PmcoRSx2KSxbXSxcInJhbmdlRW5kXCIpO2lmKCEkfHwhZilyZXR1cm57cmFuZ2VTdGFydDowLHJhbmdlRW5kOjB9O2xldCBULG07aWYoYShFKSl7bGV0IHY9bigkLGYpO1Q9dixtPXZ9ZWxzZSh7c3RhcnROb2RlOlQsZW5kTm9kZTptfT1pKCQsZixFKSk7cmV0dXJue3JhbmdlU3RhcnQ6TWF0aC5taW4oUyhUKSxTKG0pKSxyYW5nZUVuZDpNYXRoLm1heChOKFQpLE4obSkpfX1yLmV4cG9ydHM9e2NhbGN1bGF0ZVJhbmdlOmMsZmluZE5vZGVBdE9mZnNldDpsfX19KSxHbT10ZSh7XCJzcmMvbWFpbi9jb3JlLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntkaWZmQXJyYXlzOnR9PUJEKCkse3ByaW50ZXI6e3ByaW50RG9jVG9TdHJpbmc6c30sZGVidWc6e3ByaW50RG9jVG9EZWJ1ZzphfX09cWUoKSx7Z2V0QWxpZ25tZW50U2l6ZTpufT1VZSgpLHtndWVzc0VuZE9mTGluZTp1LGNvbnZlcnRFbmRPZkxpbmVUb0NoYXJzOmksY291bnRFbmRPZkxpbmVDaGFyczpsLG5vcm1hbGl6ZUVuZE9mTGluZTpwfT1KbigpLGQ9dW8oKS5ub3JtYWxpemUseT1SbSgpLGc9ZXQoKSxjPXR1KCksRD1XbSgpLEU9SG0oKSxfPVwiXFx1RkVGRlwiLHc9U3ltYm9sKFwiY3Vyc29yXCIpO2Z1bmN0aW9uIEYobSx2LG8pe2xldCBoPXYuY29tbWVudHM7cmV0dXJuIGgmJihkZWxldGUgdi5jb21tZW50cyxnLmF0dGFjaChoLHYsbSxvKSksb1tTeW1ib2wuZm9yKFwiY29tbWVudHNcIildPWh8fFtdLG9bU3ltYm9sLmZvcihcInRva2Vuc1wiKV09di50b2tlbnN8fFtdLG8ub3JpZ2luYWxUZXh0PW0saH1mdW5jdGlvbiBTKG0sdil7bGV0IG89YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOjA7aWYoIW18fG0udHJpbSgpLmxlbmd0aD09PTApcmV0dXJue2Zvcm1hdHRlZDpcIlwiLGN1cnNvck9mZnNldDotMSxjb21tZW50czpbXX07bGV0e2FzdDpoLHRleHQ6Q309Yy5wYXJzZShtLHYpO2lmKHYuY3Vyc29yT2Zmc2V0Pj0wKXtsZXQgaz1FLmZpbmROb2RlQXRPZmZzZXQoaCx2LmN1cnNvck9mZnNldCx2KTtrJiZrLm5vZGUmJih2LmN1cnNvck5vZGU9ay5ub2RlKX1sZXQgeD1GKEMsaCx2KSxiPUQoaCx2LG8pLEI9cyhiLHYpO2lmKGcuZW5zdXJlQWxsQ29tbWVudHNQcmludGVkKHgpLG8+MCl7bGV0IGs9Qi5mb3JtYXR0ZWQudHJpbSgpO0IuY3Vyc29yTm9kZVN0YXJ0IT09dm9pZCAwJiYoQi5jdXJzb3JOb2RlU3RhcnQtPUIuZm9ybWF0dGVkLmluZGV4T2YoaykpLEIuZm9ybWF0dGVkPWsraSh2LmVuZE9mTGluZSl9aWYodi5jdXJzb3JPZmZzZXQ+PTApe2xldCBrLE0sUixxLEo7aWYodi5jdXJzb3JOb2RlJiZCLmN1cnNvck5vZGVUZXh0PyhrPXYubG9jU3RhcnQodi5jdXJzb3JOb2RlKSxNPUMuc2xpY2Uoayx2LmxvY0VuZCh2LmN1cnNvck5vZGUpKSxSPXYuY3Vyc29yT2Zmc2V0LWsscT1CLmN1cnNvck5vZGVTdGFydCxKPUIuY3Vyc29yTm9kZVRleHQpOihrPTAsTT1DLFI9di5jdXJzb3JPZmZzZXQscT0wLEo9Qi5mb3JtYXR0ZWQpLE09PT1KKXJldHVybntmb3JtYXR0ZWQ6Qi5mb3JtYXR0ZWQsY3Vyc29yT2Zmc2V0OnErUixjb21tZW50czp4fTtsZXQgTD1bLi4uTV07TC5zcGxpY2UoUiwwLHcpO2xldCBRPVsuLi5KXSxWPXQoTCxRKSxqPXE7Zm9yKGxldCBZIG9mIFYpaWYoWS5yZW1vdmVkKXtpZihZLnZhbHVlLmluY2x1ZGVzKHcpKWJyZWFrfWVsc2Ugais9WS5jb3VudDtyZXR1cm57Zm9ybWF0dGVkOkIuZm9ybWF0dGVkLGN1cnNvck9mZnNldDpqLGNvbW1lbnRzOnh9fXJldHVybntmb3JtYXR0ZWQ6Qi5mb3JtYXR0ZWQsY3Vyc29yT2Zmc2V0Oi0xLGNvbW1lbnRzOnh9fWZ1bmN0aW9uIE4obSx2KXtsZXR7YXN0Om8sdGV4dDpofT1jLnBhcnNlKG0sdikse3JhbmdlU3RhcnQ6QyxyYW5nZUVuZDp4fT1FLmNhbGN1bGF0ZVJhbmdlKGgsdixvKSxiPWguc2xpY2UoQyx4KSxCPU1hdGgubWluKEMsaC5sYXN0SW5kZXhPZihgXG5gLEMpKzEpLGs9aC5zbGljZShCLEMpLm1hdGNoKC9eXFxzKi8pWzBdLE09bihrLHYudGFiV2lkdGgpLFI9UyhiLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx2KSx7fSx7cmFuZ2VTdGFydDowLHJhbmdlRW5kOk51bWJlci5QT1NJVElWRV9JTkZJTklUWSxjdXJzb3JPZmZzZXQ6di5jdXJzb3JPZmZzZXQ+QyYmdi5jdXJzb3JPZmZzZXQ8PXg/di5jdXJzb3JPZmZzZXQtQzotMSxlbmRPZkxpbmU6XCJsZlwifSksTSkscT1SLmZvcm1hdHRlZC50cmltRW5kKCkse2N1cnNvck9mZnNldDpKfT12O0o+eD9KKz1xLmxlbmd0aC1iLmxlbmd0aDpSLmN1cnNvck9mZnNldD49MCYmKEo9Ui5jdXJzb3JPZmZzZXQrQyk7bGV0IEw9aC5zbGljZSgwLEMpK3EraC5zbGljZSh4KTtpZih2LmVuZE9mTGluZSE9PVwibGZcIil7bGV0IFE9aSh2LmVuZE9mTGluZSk7Sj49MCYmUT09PWBcXHJcbmAmJihKKz1sKEwuc2xpY2UoMCxKKSxgXG5gKSksTD1MLnJlcGxhY2UoL1xcbi9nLFEpfXJldHVybntmb3JtYXR0ZWQ6TCxjdXJzb3JPZmZzZXQ6Sixjb21tZW50czpSLmNvbW1lbnRzfX1mdW5jdGlvbiBJKG0sdixvKXtyZXR1cm4gdHlwZW9mIHYhPVwibnVtYmVyXCJ8fE51bWJlci5pc05hTih2KXx8djwwfHx2Pm0ubGVuZ3RoP286dn1mdW5jdGlvbiBQKG0sdil7bGV0e2N1cnNvck9mZnNldDpvLHJhbmdlU3RhcnQ6aCxyYW5nZUVuZDpDfT12O3JldHVybiBvPUkobSxvLC0xKSxoPUkobSxoLDApLEM9SShtLEMsbS5sZW5ndGgpLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSx2KSx7fSx7Y3Vyc29yT2Zmc2V0Om8scmFuZ2VTdGFydDpoLHJhbmdlRW5kOkN9KX1mdW5jdGlvbiAkKG0sdil7bGV0e2N1cnNvck9mZnNldDpvLHJhbmdlU3RhcnQ6aCxyYW5nZUVuZDpDLGVuZE9mTGluZTp4fT1QKG0sdiksYj1tLmNoYXJBdCgwKT09PV87aWYoYiYmKG09bS5zbGljZSgxKSxvLS0saC0tLEMtLSkseD09PVwiYXV0b1wiJiYoeD11KG0pKSxtLmluY2x1ZGVzKFwiXFxyXCIpKXtsZXQgQj1rPT5sKG0uc2xpY2UoMCxNYXRoLm1heChrLDApKSxgXFxyXG5gKTtvLT1CKG8pLGgtPUIoaCksQy09QihDKSxtPXAobSl9cmV0dXJue2hhc0JPTTpiLHRleHQ6bSxvcHRpb25zOlAobSxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdikse30se2N1cnNvck9mZnNldDpvLHJhbmdlU3RhcnQ6aCxyYW5nZUVuZDpDLGVuZE9mTGluZTp4fSkpfX1mdW5jdGlvbiBmKG0sdil7bGV0IG89Yy5yZXNvbHZlUGFyc2VyKHYpO3JldHVybiFvLmhhc1ByYWdtYXx8by5oYXNQcmFnbWEobSl9ZnVuY3Rpb24gVChtLHYpe2xldHtoYXNCT006byx0ZXh0Omgsb3B0aW9uczpDfT0kKG0sZCh2KSk7aWYoQy5yYW5nZVN0YXJ0Pj1DLnJhbmdlRW5kJiZoIT09XCJcInx8Qy5yZXF1aXJlUHJhZ21hJiYhZihoLEMpKXJldHVybntmb3JtYXR0ZWQ6bSxjdXJzb3JPZmZzZXQ6di5jdXJzb3JPZmZzZXQsY29tbWVudHM6W119O2xldCB4O3JldHVybiBDLnJhbmdlU3RhcnQ+MHx8Qy5yYW5nZUVuZDxoLmxlbmd0aD94PU4oaCxDKTooIUMucmVxdWlyZVByYWdtYSYmQy5pbnNlcnRQcmFnbWEmJkMucHJpbnRlci5pbnNlcnRQcmFnbWEmJiFmKGgsQykmJihoPUMucHJpbnRlci5pbnNlcnRQcmFnbWEoaCkpLHg9UyhoLEMpKSxvJiYoeC5mb3JtYXR0ZWQ9Xyt4LmZvcm1hdHRlZCx4LmN1cnNvck9mZnNldD49MCYmeC5jdXJzb3JPZmZzZXQrKykseH1yLmV4cG9ydHM9e2Zvcm1hdFdpdGhDdXJzb3I6VCxwYXJzZShtLHYsbyl7bGV0e3RleHQ6aCxvcHRpb25zOkN9PSQobSxkKHYpKSx4PWMucGFyc2UoaCxDKTtyZXR1cm4gbyYmKHguYXN0PXkoeC5hc3QsQykpLHh9LGZvcm1hdEFTVChtLHYpe3Y9ZCh2KTtsZXQgbz1EKG0sdik7cmV0dXJuIHMobyx2KX0sZm9ybWF0RG9jKG0sdil7cmV0dXJuIFQoYShtKSxPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sdikse30se3BhcnNlcjpcIl9fanNfZXhwcmVzc2lvblwifSkpLmZvcm1hdHRlZH0scHJpbnRUb0RvYyhtLHYpe3Y9ZCh2KTtsZXR7YXN0Om8sdGV4dDpofT1jLnBhcnNlKG0sdik7cmV0dXJuIEYoaCxvLHYpLEQobyx2KX0scHJpbnREb2NUb1N0cmluZyhtLHYpe3JldHVybiBzKG0sZCh2KSl9fX19KSxVbT10ZSh7XCJzcmMvY29tbW9uL3V0aWwtc2hhcmVkLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntnZXRNYXhDb250aW51b3VzQ291bnQ6dCxnZXRTdHJpbmdXaWR0aDpzLGdldEFsaWdubWVudFNpemU6YSxnZXRJbmRlbnRTaXplOm4sc2tpcDp1LHNraXBXaGl0ZXNwYWNlOmksc2tpcFNwYWNlczpsLHNraXBOZXdsaW5lOnAsc2tpcFRvTGluZUVuZDpkLHNraXBFdmVyeXRoaW5nQnV0TmV3TGluZTp5LHNraXBJbmxpbmVDb21tZW50Omcsc2tpcFRyYWlsaW5nQ29tbWVudDpjLGhhc05ld2xpbmU6RCxoYXNOZXdsaW5lSW5SYW5nZTpFLGhhc1NwYWNlczpfLGlzTmV4dExpbmVFbXB0eTp3LGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6Rixpc1ByZXZpb3VzTGluZUVtcHR5OlMsZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4Ok4sbWFrZVN0cmluZzpJLGFkZExlYWRpbmdDb21tZW50OlAsYWRkRGFuZ2xpbmdDb21tZW50OiQsYWRkVHJhaWxpbmdDb21tZW50OmZ9PVVlKCk7ci5leHBvcnRzPXtnZXRNYXhDb250aW51b3VzQ291bnQ6dCxnZXRTdHJpbmdXaWR0aDpzLGdldEFsaWdubWVudFNpemU6YSxnZXRJbmRlbnRTaXplOm4sc2tpcDp1LHNraXBXaGl0ZXNwYWNlOmksc2tpcFNwYWNlczpsLHNraXBOZXdsaW5lOnAsc2tpcFRvTGluZUVuZDpkLHNraXBFdmVyeXRoaW5nQnV0TmV3TGluZTp5LHNraXBJbmxpbmVDb21tZW50Omcsc2tpcFRyYWlsaW5nQ29tbWVudDpjLGhhc05ld2xpbmU6RCxoYXNOZXdsaW5lSW5SYW5nZTpFLGhhc1NwYWNlczpfLGlzTmV4dExpbmVFbXB0eTp3LGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6Rixpc1ByZXZpb3VzTGluZUVtcHR5OlMsZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4Ok4sbWFrZVN0cmluZzpJLGFkZExlYWRpbmdDb21tZW50OlAsYWRkRGFuZ2xpbmdDb21tZW50OiQsYWRkVHJhaWxpbmdDb21tZW50OmZ9fX0pLF90PXRlKHtcInNyYy91dGlscy9jcmVhdGUtbGFuZ3VhZ2UuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCksci5leHBvcnRzPWZ1bmN0aW9uKHQscyl7bGV0e2xhbmd1YWdlSWQ6YX09dCxuPUhuKHQsQ0QpO3JldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe2xpbmd1aXN0TGFuZ3VhZ2VJZDphfSxuKSxzKHQpKX19fSksSm09dGUoe1wibm9kZV9tb2R1bGVzL2VzdXRpbHMvbGliL2FzdC5qc1wiKGUscil7bmUoKSxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHQobCl7aWYobD09bnVsbClyZXR1cm4hMTtzd2l0Y2gobC50eXBlKXtjYXNlXCJBcnJheUV4cHJlc3Npb25cIjpjYXNlXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOmNhc2VcIkJpbmFyeUV4cHJlc3Npb25cIjpjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOmNhc2VcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOmNhc2VcIklkZW50aWZpZXJcIjpjYXNlXCJMaXRlcmFsXCI6Y2FzZVwiTG9naWNhbEV4cHJlc3Npb25cIjpjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiTmV3RXhwcmVzc2lvblwiOmNhc2VcIk9iamVjdEV4cHJlc3Npb25cIjpjYXNlXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjpjYXNlXCJUaGlzRXhwcmVzc2lvblwiOmNhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOmNhc2VcIlVwZGF0ZUV4cHJlc3Npb25cIjpyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBzKGwpe2lmKGw9PW51bGwpcmV0dXJuITE7c3dpdGNoKGwudHlwZSl7Y2FzZVwiRG9XaGlsZVN0YXRlbWVudFwiOmNhc2VcIkZvckluU3RhdGVtZW50XCI6Y2FzZVwiRm9yU3RhdGVtZW50XCI6Y2FzZVwiV2hpbGVTdGF0ZW1lbnRcIjpyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBhKGwpe2lmKGw9PW51bGwpcmV0dXJuITE7c3dpdGNoKGwudHlwZSl7Y2FzZVwiQmxvY2tTdGF0ZW1lbnRcIjpjYXNlXCJCcmVha1N0YXRlbWVudFwiOmNhc2VcIkNvbnRpbnVlU3RhdGVtZW50XCI6Y2FzZVwiRGVidWdnZXJTdGF0ZW1lbnRcIjpjYXNlXCJEb1doaWxlU3RhdGVtZW50XCI6Y2FzZVwiRW1wdHlTdGF0ZW1lbnRcIjpjYXNlXCJFeHByZXNzaW9uU3RhdGVtZW50XCI6Y2FzZVwiRm9ySW5TdGF0ZW1lbnRcIjpjYXNlXCJGb3JTdGF0ZW1lbnRcIjpjYXNlXCJJZlN0YXRlbWVudFwiOmNhc2VcIkxhYmVsZWRTdGF0ZW1lbnRcIjpjYXNlXCJSZXR1cm5TdGF0ZW1lbnRcIjpjYXNlXCJTd2l0Y2hTdGF0ZW1lbnRcIjpjYXNlXCJUaHJvd1N0YXRlbWVudFwiOmNhc2VcIlRyeVN0YXRlbWVudFwiOmNhc2VcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjpjYXNlXCJXaGlsZVN0YXRlbWVudFwiOmNhc2VcIldpdGhTdGF0ZW1lbnRcIjpyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBuKGwpe3JldHVybiBhKGwpfHxsIT1udWxsJiZsLnR5cGU9PT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIn1mdW5jdGlvbiB1KGwpe3N3aXRjaChsLnR5cGUpe2Nhc2VcIklmU3RhdGVtZW50XCI6cmV0dXJuIGwuYWx0ZXJuYXRlIT1udWxsP2wuYWx0ZXJuYXRlOmwuY29uc2VxdWVudDtjYXNlXCJMYWJlbGVkU3RhdGVtZW50XCI6Y2FzZVwiRm9yU3RhdGVtZW50XCI6Y2FzZVwiRm9ySW5TdGF0ZW1lbnRcIjpjYXNlXCJXaGlsZVN0YXRlbWVudFwiOmNhc2VcIldpdGhTdGF0ZW1lbnRcIjpyZXR1cm4gbC5ib2R5fXJldHVybiBudWxsfWZ1bmN0aW9uIGkobCl7dmFyIHA7aWYobC50eXBlIT09XCJJZlN0YXRlbWVudFwifHxsLmFsdGVybmF0ZT09bnVsbClyZXR1cm4hMTtwPWwuY29uc2VxdWVudDtkb3tpZihwLnR5cGU9PT1cIklmU3RhdGVtZW50XCImJnAuYWx0ZXJuYXRlPT1udWxsKXJldHVybiEwO3A9dShwKX13aGlsZShwKTtyZXR1cm4hMX1yLmV4cG9ydHM9e2lzRXhwcmVzc2lvbjp0LGlzU3RhdGVtZW50OmEsaXNJdGVyYXRpb25TdGF0ZW1lbnQ6cyxpc1NvdXJjZUVsZW1lbnQ6bixpc1Byb2JsZW1hdGljSWZTdGF0ZW1lbnQ6aSx0cmFpbGluZ1N0YXRlbWVudDp1fX0oKX19KSxzbz10ZSh7XCJub2RlX21vZHVsZXMvZXN1dGlscy9saWIvY29kZS5qc1wiKGUscil7bmUoKSxmdW5jdGlvbigpe1widXNlIHN0cmljdFwiO3ZhciB0LHMsYSxuLHUsaTtzPXtOb25Bc2NpaUlkZW50aWZpZXJTdGFydDovW1xceEFBXFx4QjVcXHhCQVxceEMwLVxceEQ2XFx4RDgtXFx4RjZcXHhGOC1cXHUwMkMxXFx1MDJDNi1cXHUwMkQxXFx1MDJFMC1cXHUwMkU0XFx1MDJFQ1xcdTAyRUVcXHUwMzcwLVxcdTAzNzRcXHUwMzc2XFx1MDM3N1xcdTAzN0EtXFx1MDM3RFxcdTAzN0ZcXHUwMzg2XFx1MDM4OC1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjIwLVxcdTA2NEFcXHUwNjZFXFx1MDY2RlxcdTA2NzEtXFx1MDZEM1xcdTA2RDVcXHUwNkU1XFx1MDZFNlxcdTA2RUVcXHUwNkVGXFx1MDZGQS1cXHUwNkZDXFx1MDZGRlxcdTA3MTBcXHUwNzEyLVxcdTA3MkZcXHUwNzRELVxcdTA3QTVcXHUwN0IxXFx1MDdDQS1cXHUwN0VBXFx1MDdGNFxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODE1XFx1MDgxQVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDkwNC1cXHUwOTM5XFx1MDkzRFxcdTA5NTBcXHUwOTU4LVxcdTA5NjFcXHUwOTcxLVxcdTA5ODBcXHUwOTg1LVxcdTA5OENcXHUwOThGXFx1MDk5MFxcdTA5OTMtXFx1MDlBOFxcdTA5QUEtXFx1MDlCMFxcdTA5QjJcXHUwOUI2LVxcdTA5QjlcXHUwOUJEXFx1MDlDRVxcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUxXFx1MDlGMFxcdTA5RjFcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBNTktXFx1MEE1Q1xcdTBBNUVcXHUwQTcyLVxcdTBBNzRcXHUwQTg1LVxcdTBBOERcXHUwQThGLVxcdTBBOTFcXHUwQTkzLVxcdTBBQThcXHUwQUFBLVxcdTBBQjBcXHUwQUIyXFx1MEFCM1xcdTBBQjUtXFx1MEFCOVxcdTBBQkRcXHUwQUQwXFx1MEFFMFxcdTBBRTFcXHUwQUY5XFx1MEIwNS1cXHUwQjBDXFx1MEIwRlxcdTBCMTBcXHUwQjEzLVxcdTBCMjhcXHUwQjJBLVxcdTBCMzBcXHUwQjMyXFx1MEIzM1xcdTBCMzUtXFx1MEIzOVxcdTBCM0RcXHUwQjVDXFx1MEI1RFxcdTBCNUYtXFx1MEI2MVxcdTBCNzFcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCRDBcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNEXFx1MEM1OC1cXHUwQzVBXFx1MEM2MFxcdTBDNjFcXHUwQzgwXFx1MEM4NS1cXHUwQzhDXFx1MEM4RS1cXHUwQzkwXFx1MEM5Mi1cXHUwQ0E4XFx1MENBQS1cXHUwQ0IzXFx1MENCNS1cXHUwQ0I5XFx1MENCRFxcdTBDREVcXHUwQ0UwXFx1MENFMVxcdTBDRjFcXHUwQ0YyXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRFxcdTBENEVcXHUwRDU0LVxcdTBENTZcXHUwRDVGLVxcdTBENjFcXHUwRDdBLVxcdTBEN0ZcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MEUwMS1cXHUwRTMwXFx1MEUzMlxcdTBFMzNcXHUwRTQwLVxcdTBFNDZcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCMFxcdTBFQjJcXHUwRUIzXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEY0MC1cXHUwRjQ3XFx1MEY0OS1cXHUwRjZDXFx1MEY4OC1cXHUwRjhDXFx1MTAwMC1cXHUxMDJBXFx1MTAzRlxcdTEwNTAtXFx1MTA1NVxcdTEwNUEtXFx1MTA1RFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNkUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOEVcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc4MC1cXHUxN0IzXFx1MTdEN1xcdTE3RENcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4ODRcXHUxODg3LVxcdTE4QThcXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTk1MC1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MUEwMC1cXHUxQTE2XFx1MUEyMC1cXHUxQTU0XFx1MUFBN1xcdTFCMDUtXFx1MUIzM1xcdTFCNDUtXFx1MUI0QlxcdTFCODMtXFx1MUJBMFxcdTFCQUVcXHUxQkFGXFx1MUJCQS1cXHUxQkU1XFx1MUMwMC1cXHUxQzIzXFx1MUM0RC1cXHUxQzRGXFx1MUM1QS1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNFOS1cXHUxQ0VDXFx1MUNFRS1cXHUxQ0YxXFx1MUNGNVxcdTFDRjZcXHUxRDAwLVxcdTFEQkZcXHUxRTAwLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0VFXFx1MkNGMlxcdTJDRjNcXHUyRDAwLVxcdTJEMjVcXHUyRDI3XFx1MkQyRFxcdTJEMzAtXFx1MkQ2N1xcdTJENkZcXHUyRDgwLVxcdTJEOTZcXHUyREEwLVxcdTJEQTZcXHUyREE4LVxcdTJEQUVcXHUyREIwLVxcdTJEQjZcXHUyREI4LVxcdTJEQkVcXHUyREMwLVxcdTJEQzZcXHUyREM4LVxcdTJEQ0VcXHUyREQwLVxcdTJERDZcXHUyREQ4LVxcdTJEREVcXHUyRTJGXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNDXFx1MzA0MS1cXHUzMDk2XFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjFGXFx1QTYyQVxcdUE2MkJcXHVBNjQwLVxcdUE2NkVcXHVBNjdGLVxcdUE2OURcXHVBNkEwLVxcdUE2RUZcXHVBNzE3LVxcdUE3MUZcXHVBNzIyLVxcdUE3ODhcXHVBNzhCLVxcdUE3QUVcXHVBN0IwLVxcdUE3QjdcXHVBN0Y3LVxcdUE4MDFcXHVBODAzLVxcdUE4MDVcXHVBODA3LVxcdUE4MEFcXHVBODBDLVxcdUE4MjJcXHVBODQwLVxcdUE4NzNcXHVBODgyLVxcdUE4QjNcXHVBOEYyLVxcdUE4RjdcXHVBOEZCXFx1QThGRFxcdUE5MEEtXFx1QTkyNVxcdUE5MzAtXFx1QTk0NlxcdUE5NjAtXFx1QTk3Q1xcdUE5ODQtXFx1QTlCMlxcdUE5Q0ZcXHVBOUUwLVxcdUE5RTRcXHVBOUU2LVxcdUE5RUZcXHVBOUZBLVxcdUE5RkVcXHVBQTAwLVxcdUFBMjhcXHVBQTQwLVxcdUFBNDJcXHVBQTQ0LVxcdUFBNEJcXHVBQTYwLVxcdUFBNzZcXHVBQTdBXFx1QUE3RS1cXHVBQUFGXFx1QUFCMVxcdUFBQjVcXHVBQUI2XFx1QUFCOS1cXHVBQUJEXFx1QUFDMFxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUFcXHVBQUYyLVxcdUFBRjRcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRTJcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFEXFx1RkIxRi1cXHVGQjI4XFx1RkIyQS1cXHVGQjM2XFx1RkIzOC1cXHVGQjNDXFx1RkIzRVxcdUZCNDBcXHVGQjQxXFx1RkI0M1xcdUZCNDRcXHVGQjQ2LVxcdUZCQjFcXHVGQkQzLVxcdUZEM0RcXHVGRDUwLVxcdUZEOEZcXHVGRDkyLVxcdUZEQzdcXHVGREYwLVxcdUZERkJcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjIxLVxcdUZGM0FcXHVGRjQxLVxcdUZGNUFcXHVGRjY2LVxcdUZGQkVcXHVGRkMyLVxcdUZGQzdcXHVGRkNBLVxcdUZGQ0ZcXHVGRkQyLVxcdUZGRDdcXHVGRkRBLVxcdUZGRENdLyxOb25Bc2NpaUlkZW50aWZpZXJQYXJ0Oi9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzMDAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4My1cXHUwNDg3XFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1OTEtXFx1MDVCRFxcdTA1QkZcXHUwNUMxXFx1MDVDMlxcdTA1QzRcXHUwNUM1XFx1MDVDN1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MTAtXFx1MDYxQVxcdTA2MjAtXFx1MDY2OVxcdTA2NkUtXFx1MDZEM1xcdTA2RDUtXFx1MDZEQ1xcdTA2REYtXFx1MDZFOFxcdTA2RUEtXFx1MDZGQ1xcdTA2RkZcXHUwNzEwLVxcdTA3NEFcXHUwNzRELVxcdTA3QjFcXHUwN0MwLVxcdTA3RjVcXHUwN0ZBXFx1MDgwMC1cXHUwODJEXFx1MDg0MC1cXHUwODVCXFx1MDhBMC1cXHUwOEI0XFx1MDhCNi1cXHUwOEJEXFx1MDhENC1cXHUwOEUxXFx1MDhFMy1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZGXFx1MDk3MS1cXHUwOTgzXFx1MDk4NS1cXHUwOThDXFx1MDk4RlxcdTA5OTBcXHUwOTkzLVxcdTA5QThcXHUwOUFBLVxcdTA5QjBcXHUwOUIyXFx1MDlCNi1cXHUwOUI5XFx1MDlCQy1cXHUwOUM0XFx1MDlDN1xcdTA5QzhcXHUwOUNCLVxcdTA5Q0VcXHUwOUQ3XFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTNcXHUwOUU2LVxcdTA5RjFcXHUwQTAxLVxcdTBBMDNcXHUwQTA1LVxcdTBBMEFcXHUwQTBGXFx1MEExMFxcdTBBMTMtXFx1MEEyOFxcdTBBMkEtXFx1MEEzMFxcdTBBMzJcXHUwQTMzXFx1MEEzNVxcdTBBMzZcXHUwQTM4XFx1MEEzOVxcdTBBM0NcXHUwQTNFLVxcdTBBNDJcXHUwQTQ3XFx1MEE0OFxcdTBBNEItXFx1MEE0RFxcdTBBNTFcXHUwQTU5LVxcdTBBNUNcXHUwQTVFXFx1MEE2Ni1cXHUwQTc1XFx1MEE4MS1cXHUwQTgzXFx1MEE4NS1cXHUwQThEXFx1MEE4Ri1cXHUwQTkxXFx1MEE5My1cXHUwQUE4XFx1MEFBQS1cXHUwQUIwXFx1MEFCMlxcdTBBQjNcXHUwQUI1LVxcdTBBQjlcXHUwQUJDLVxcdTBBQzVcXHUwQUM3LVxcdTBBQzlcXHUwQUNCLVxcdTBBQ0RcXHUwQUQwXFx1MEFFMC1cXHUwQUUzXFx1MEFFNi1cXHUwQUVGXFx1MEFGOVxcdTBCMDEtXFx1MEIwM1xcdTBCMDUtXFx1MEIwQ1xcdTBCMEZcXHUwQjEwXFx1MEIxMy1cXHUwQjI4XFx1MEIyQS1cXHUwQjMwXFx1MEIzMlxcdTBCMzNcXHUwQjM1LVxcdTBCMzlcXHUwQjNDLVxcdTBCNDRcXHUwQjQ3XFx1MEI0OFxcdTBCNEItXFx1MEI0RFxcdTBCNTZcXHUwQjU3XFx1MEI1Q1xcdTBCNURcXHUwQjVGLVxcdTBCNjNcXHUwQjY2LVxcdTBCNkZcXHUwQjcxXFx1MEI4MlxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJCRS1cXHUwQkMyXFx1MEJDNi1cXHUwQkM4XFx1MEJDQS1cXHUwQkNEXFx1MEJEMFxcdTBCRDdcXHUwQkU2LVxcdTBCRUZcXHUwQzAwLVxcdTBDMDNcXHUwQzA1LVxcdTBDMENcXHUwQzBFLVxcdTBDMTBcXHUwQzEyLVxcdTBDMjhcXHUwQzJBLVxcdTBDMzlcXHUwQzNELVxcdTBDNDRcXHUwQzQ2LVxcdTBDNDhcXHUwQzRBLVxcdTBDNERcXHUwQzU1XFx1MEM1NlxcdTBDNTgtXFx1MEM1QVxcdTBDNjAtXFx1MEM2M1xcdTBDNjYtXFx1MEM2RlxcdTBDODAtXFx1MEM4M1xcdTBDODUtXFx1MEM4Q1xcdTBDOEUtXFx1MEM5MFxcdTBDOTItXFx1MENBOFxcdTBDQUEtXFx1MENCM1xcdTBDQjUtXFx1MENCOVxcdTBDQkMtXFx1MENDNFxcdTBDQzYtXFx1MENDOFxcdTBDQ0EtXFx1MENDRFxcdTBDRDVcXHUwQ0Q2XFx1MENERVxcdTBDRTAtXFx1MENFM1xcdTBDRTYtXFx1MENFRlxcdTBDRjFcXHUwQ0YyXFx1MEQwMS1cXHUwRDAzXFx1MEQwNS1cXHUwRDBDXFx1MEQwRS1cXHUwRDEwXFx1MEQxMi1cXHUwRDNBXFx1MEQzRC1cXHUwRDQ0XFx1MEQ0Ni1cXHUwRDQ4XFx1MEQ0QS1cXHUwRDRFXFx1MEQ1NC1cXHUwRDU3XFx1MEQ1Ri1cXHUwRDYzXFx1MEQ2Ni1cXHUwRDZGXFx1MEQ3QS1cXHUwRDdGXFx1MEQ4MlxcdTBEODNcXHUwRDg1LVxcdTBEOTZcXHUwRDlBLVxcdTBEQjFcXHUwREIzLVxcdTBEQkJcXHUwREJEXFx1MERDMC1cXHUwREM2XFx1MERDQVxcdTBEQ0YtXFx1MERENFxcdTBERDZcXHUwREQ4LVxcdTBEREZcXHUwREU2LVxcdTBERUZcXHUwREYyXFx1MERGM1xcdTBFMDEtXFx1MEUzQVxcdTBFNDAtXFx1MEU0RVxcdTBFNTAtXFx1MEU1OVxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUI5XFx1MEVCQi1cXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFQzgtXFx1MEVDRFxcdTBFRDAtXFx1MEVEOVxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjE4XFx1MEYxOVxcdTBGMjAtXFx1MEYyOVxcdTBGMzVcXHUwRjM3XFx1MEYzOVxcdTBGM0UtXFx1MEY0N1xcdTBGNDktXFx1MEY2Q1xcdTBGNzEtXFx1MEY4NFxcdTBGODYtXFx1MEY5N1xcdTBGOTktXFx1MEZCQ1xcdTBGQzZcXHUxMDAwLVxcdTEwNDlcXHUxMDUwLVxcdTEwOURcXHUxMEEwLVxcdTEwQzVcXHUxMEM3XFx1MTBDRFxcdTEwRDAtXFx1MTBGQVxcdTEwRkMtXFx1MTI0OFxcdTEyNEEtXFx1MTI0RFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVBLVxcdTEyNURcXHUxMjYwLVxcdTEyODhcXHUxMjhBLVxcdTEyOERcXHUxMjkwLVxcdTEyQjBcXHUxMkIyLVxcdTEyQjVcXHUxMkI4LVxcdTEyQkVcXHUxMkMwXFx1MTJDMi1cXHUxMkM1XFx1MTJDOC1cXHUxMkQ2XFx1MTJEOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVBXFx1MTM1RC1cXHUxMzVGXFx1MTM4MC1cXHUxMzhGXFx1MTNBMC1cXHUxM0Y1XFx1MTNGOC1cXHUxM0ZEXFx1MTQwMS1cXHUxNjZDXFx1MTY2Ri1cXHUxNjdGXFx1MTY4MS1cXHUxNjlBXFx1MTZBMC1cXHUxNkVBXFx1MTZFRS1cXHUxNkY4XFx1MTcwMC1cXHUxNzBDXFx1MTcwRS1cXHUxNzE0XFx1MTcyMC1cXHUxNzM0XFx1MTc0MC1cXHUxNzUzXFx1MTc2MC1cXHUxNzZDXFx1MTc2RS1cXHUxNzcwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3RDNcXHUxN0Q3XFx1MTdEQ1xcdTE3RERcXHUxN0UwLVxcdTE3RTlcXHUxODBCLVxcdTE4MERcXHUxODEwLVxcdTE4MTlcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTIwLVxcdTE5MkJcXHUxOTMwLVxcdTE5M0JcXHUxOTQ2LVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxOUQwLVxcdTE5RDlcXHUxQTAwLVxcdTFBMUJcXHUxQTIwLVxcdTFBNUVcXHUxQTYwLVxcdTFBN0NcXHUxQTdGLVxcdTFBODlcXHUxQTkwLVxcdTFBOTlcXHUxQUE3XFx1MUFCMC1cXHUxQUJEXFx1MUIwMC1cXHUxQjRCXFx1MUI1MC1cXHUxQjU5XFx1MUI2Qi1cXHUxQjczXFx1MUI4MC1cXHUxQkYzXFx1MUMwMC1cXHUxQzM3XFx1MUM0MC1cXHUxQzQ5XFx1MUM0RC1cXHUxQzdEXFx1MUM4MC1cXHUxQzg4XFx1MUNEMC1cXHUxQ0QyXFx1MUNENC1cXHUxQ0Y2XFx1MUNGOFxcdTFDRjlcXHUxRDAwLVxcdTFERjVcXHUxREZCLVxcdTFGMTVcXHUxRjE4LVxcdTFGMURcXHUxRjIwLVxcdTFGNDVcXHUxRjQ4LVxcdTFGNERcXHUxRjUwLVxcdTFGNTdcXHUxRjU5XFx1MUY1QlxcdTFGNURcXHUxRjVGLVxcdTFGN0RcXHUxRjgwLVxcdTFGQjRcXHUxRkI2LVxcdTFGQkNcXHUxRkJFXFx1MUZDMi1cXHUxRkM0XFx1MUZDNi1cXHUxRkNDXFx1MUZEMC1cXHUxRkQzXFx1MUZENi1cXHUxRkRCXFx1MUZFMC1cXHUxRkVDXFx1MUZGMi1cXHUxRkY0XFx1MUZGNi1cXHUxRkZDXFx1MjAwQ1xcdTIwMERcXHUyMDNGXFx1MjA0MFxcdTIwNTRcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIwRDAtXFx1MjBEQ1xcdTIwRTFcXHUyMEU1LVxcdTIwRjBcXHUyMTAyXFx1MjEwN1xcdTIxMEEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMURcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJBLVxcdTIxMkRcXHUyMTJGLVxcdTIxMzlcXHUyMTNDLVxcdTIxM0ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRFXFx1MjE2MC1cXHUyMTg4XFx1MkMwMC1cXHUyQzJFXFx1MkMzMC1cXHUyQzVFXFx1MkM2MC1cXHUyQ0U0XFx1MkNFQi1cXHUyQ0YzXFx1MkQwMC1cXHUyRDI1XFx1MkQyN1xcdTJEMkRcXHUyRDMwLVxcdTJENjdcXHUyRDZGXFx1MkQ3Ri1cXHUyRDk2XFx1MkRBMC1cXHUyREE2XFx1MkRBOC1cXHUyREFFXFx1MkRCMC1cXHUyREI2XFx1MkRCOC1cXHUyREJFXFx1MkRDMC1cXHUyREM2XFx1MkRDOC1cXHUyRENFXFx1MkREMC1cXHUyREQ2XFx1MkREOC1cXHUyRERFXFx1MkRFMC1cXHUyREZGXFx1MkUyRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTlcXHUzMDlBXFx1MzA5RC1cXHUzMDlGXFx1MzBBMS1cXHUzMEZBXFx1MzBGQy1cXHUzMEZGXFx1MzEwNS1cXHUzMTJEXFx1MzEzMS1cXHUzMThFXFx1MzFBMC1cXHUzMUJBXFx1MzFGMC1cXHUzMUZGXFx1MzQwMC1cXHU0REI1XFx1NEUwMC1cXHU5RkQ1XFx1QTAwMC1cXHVBNDhDXFx1QTREMC1cXHVBNEZEXFx1QTUwMC1cXHVBNjBDXFx1QTYxMC1cXHVBNjJCXFx1QTY0MC1cXHVBNjZGXFx1QTY3NC1cXHVBNjdEXFx1QTY3Ri1cXHVBNkYxXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODI3XFx1QTg0MC1cXHVBODczXFx1QTg4MC1cXHVBOEM1XFx1QThEMC1cXHVBOEQ5XFx1QThFMC1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTAwLVxcdUE5MkRcXHVBOTMwLVxcdUE5NTNcXHVBOTYwLVxcdUE5N0NcXHVBOTgwLVxcdUE5QzBcXHVBOUNGLVxcdUE5RDlcXHVBOUUwLVxcdUE5RkVcXHVBQTAwLVxcdUFBMzZcXHVBQTQwLVxcdUFBNERcXHVBQTUwLVxcdUFBNTlcXHVBQTYwLVxcdUFBNzZcXHVBQTdBLVxcdUFBQzJcXHVBQURCLVxcdUFBRERcXHVBQUUwLVxcdUFBRUZcXHVBQUYyLVxcdUFBRjZcXHVBQjAxLVxcdUFCMDZcXHVBQjA5LVxcdUFCMEVcXHVBQjExLVxcdUFCMTZcXHVBQjIwLVxcdUFCMjZcXHVBQjI4LVxcdUFCMkVcXHVBQjMwLVxcdUFCNUFcXHVBQjVDLVxcdUFCNjVcXHVBQjcwLVxcdUFCRUFcXHVBQkVDXFx1QUJFRFxcdUFCRjAtXFx1QUJGOVxcdUFDMDAtXFx1RDdBM1xcdUQ3QjAtXFx1RDdDNlxcdUQ3Q0ItXFx1RDdGQlxcdUY5MDAtXFx1RkE2RFxcdUZBNzAtXFx1RkFEOVxcdUZCMDAtXFx1RkIwNlxcdUZCMTMtXFx1RkIxN1xcdUZCMUQtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkUwMC1cXHVGRTBGXFx1RkUyMC1cXHVGRTJGXFx1RkUzM1xcdUZFMzRcXHVGRTRELVxcdUZFNEZcXHVGRTcwLVxcdUZFNzRcXHVGRTc2LVxcdUZFRkNcXHVGRjEwLVxcdUZGMTlcXHVGRjIxLVxcdUZGM0FcXHVGRjNGXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXS99LHQ9e05vbkFzY2lpSWRlbnRpZmllclN0YXJ0Oi9bXFx4QUFcXHhCNVxceEJBXFx4QzAtXFx4RDZcXHhEOC1cXHhGNlxceEY4LVxcdTAyQzFcXHUwMkM2LVxcdTAyRDFcXHUwMkUwLVxcdTAyRTRcXHUwMkVDXFx1MDJFRVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3QS1cXHUwMzdEXFx1MDM3RlxcdTAzODZcXHUwMzg4LVxcdTAzOEFcXHUwMzhDXFx1MDM4RS1cXHUwM0ExXFx1MDNBMy1cXHUwM0Y1XFx1MDNGNy1cXHUwNDgxXFx1MDQ4QS1cXHUwNTJGXFx1MDUzMS1cXHUwNTU2XFx1MDU1OVxcdTA1NjEtXFx1MDU4N1xcdTA1RDAtXFx1MDVFQVxcdTA1RjAtXFx1MDVGMlxcdTA2MjAtXFx1MDY0QVxcdTA2NkVcXHUwNjZGXFx1MDY3MS1cXHUwNkQzXFx1MDZENVxcdTA2RTVcXHUwNkU2XFx1MDZFRVxcdTA2RUZcXHUwNkZBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMFxcdTA3MTItXFx1MDcyRlxcdTA3NEQtXFx1MDdBNVxcdTA3QjFcXHUwN0NBLVxcdTA3RUFcXHUwN0Y0XFx1MDdGNVxcdTA3RkFcXHUwODAwLVxcdTA4MTVcXHUwODFBXFx1MDgyNFxcdTA4MjhcXHUwODQwLVxcdTA4NThcXHUwOEEwLVxcdTA4QjRcXHUwOEI2LVxcdTA4QkRcXHUwOTA0LVxcdTA5MzlcXHUwOTNEXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk4MFxcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkRcXHUwOUNFXFx1MDlEQ1xcdTA5RERcXHUwOURGLVxcdTA5RTFcXHUwOUYwXFx1MDlGMVxcdTBBMDUtXFx1MEEwQVxcdTBBMEZcXHUwQTEwXFx1MEExMy1cXHUwQTI4XFx1MEEyQS1cXHUwQTMwXFx1MEEzMlxcdTBBMzNcXHUwQTM1XFx1MEEzNlxcdTBBMzhcXHUwQTM5XFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNzItXFx1MEE3NFxcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCRFxcdTBBRDBcXHUwQUUwXFx1MEFFMVxcdTBBRjlcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzRFxcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYxXFx1MEI3MVxcdTBCODNcXHUwQjg1LVxcdTBCOEFcXHUwQjhFLVxcdTBCOTBcXHUwQjkyLVxcdTBCOTVcXHUwQjk5XFx1MEI5QVxcdTBCOUNcXHUwQjlFXFx1MEI5RlxcdTBCQTNcXHUwQkE0XFx1MEJBOC1cXHUwQkFBXFx1MEJBRS1cXHUwQkI5XFx1MEJEMFxcdTBDMDUtXFx1MEMwQ1xcdTBDMEUtXFx1MEMxMFxcdTBDMTItXFx1MEMyOFxcdTBDMkEtXFx1MEMzOVxcdTBDM0RcXHUwQzU4LVxcdTBDNUFcXHUwQzYwXFx1MEM2MVxcdTBDODBcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JEXFx1MENERVxcdTBDRTBcXHUwQ0UxXFx1MENGMVxcdTBDRjJcXHUwRDA1LVxcdTBEMENcXHUwRDBFLVxcdTBEMTBcXHUwRDEyLVxcdTBEM0FcXHUwRDNEXFx1MEQ0RVxcdTBENTQtXFx1MEQ1NlxcdTBENUYtXFx1MEQ2MVxcdTBEN0EtXFx1MEQ3RlxcdTBEODUtXFx1MEQ5NlxcdTBEOUEtXFx1MERCMVxcdTBEQjMtXFx1MERCQlxcdTBEQkRcXHUwREMwLVxcdTBEQzZcXHUwRTAxLVxcdTBFMzBcXHUwRTMyXFx1MEUzM1xcdTBFNDAtXFx1MEU0NlxcdTBFODFcXHUwRTgyXFx1MEU4NFxcdTBFODdcXHUwRTg4XFx1MEU4QVxcdTBFOERcXHUwRTk0LVxcdTBFOTdcXHUwRTk5LVxcdTBFOUZcXHUwRUExLVxcdTBFQTNcXHUwRUE1XFx1MEVBN1xcdTBFQUFcXHUwRUFCXFx1MEVBRC1cXHUwRUIwXFx1MEVCMlxcdTBFQjNcXHUwRUJEXFx1MEVDMC1cXHUwRUM0XFx1MEVDNlxcdTBFREMtXFx1MEVERlxcdTBGMDBcXHUwRjQwLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjg4LVxcdTBGOENcXHUxMDAwLVxcdTEwMkFcXHUxMDNGXFx1MTA1MC1cXHUxMDU1XFx1MTA1QS1cXHUxMDVEXFx1MTA2MVxcdTEwNjVcXHUxMDY2XFx1MTA2RS1cXHUxMDcwXFx1MTA3NS1cXHUxMDgxXFx1MTA4RVxcdTEwQTAtXFx1MTBDNVxcdTEwQzdcXHUxMENEXFx1MTBEMC1cXHUxMEZBXFx1MTBGQy1cXHUxMjQ4XFx1MTI0QS1cXHUxMjREXFx1MTI1MC1cXHUxMjU2XFx1MTI1OFxcdTEyNUEtXFx1MTI1RFxcdTEyNjAtXFx1MTI4OFxcdTEyOEEtXFx1MTI4RFxcdTEyOTAtXFx1MTJCMFxcdTEyQjItXFx1MTJCNVxcdTEyQjgtXFx1MTJCRVxcdTEyQzBcXHUxMkMyLVxcdTEyQzVcXHUxMkM4LVxcdTEyRDZcXHUxMkQ4LVxcdTEzMTBcXHUxMzEyLVxcdTEzMTVcXHUxMzE4LVxcdTEzNUFcXHUxMzgwLVxcdTEzOEZcXHUxM0EwLVxcdTEzRjVcXHUxM0Y4LVxcdTEzRkRcXHUxNDAxLVxcdTE2NkNcXHUxNjZGLVxcdTE2N0ZcXHUxNjgxLVxcdTE2OUFcXHUxNkEwLVxcdTE2RUFcXHUxNkVFLVxcdTE2RjhcXHUxNzAwLVxcdTE3MENcXHUxNzBFLVxcdTE3MTFcXHUxNzIwLVxcdTE3MzFcXHUxNzQwLVxcdTE3NTFcXHUxNzYwLVxcdTE3NkNcXHUxNzZFLVxcdTE3NzBcXHUxNzgwLVxcdTE3QjNcXHUxN0Q3XFx1MTdEQ1xcdTE4MjAtXFx1MTg3N1xcdTE4ODAtXFx1MThBOFxcdTE4QUFcXHUxOEIwLVxcdTE4RjVcXHUxOTAwLVxcdTE5MUVcXHUxOTUwLVxcdTE5NkRcXHUxOTcwLVxcdTE5NzRcXHUxOTgwLVxcdTE5QUJcXHUxOUIwLVxcdTE5QzlcXHUxQTAwLVxcdTFBMTZcXHUxQTIwLVxcdTFBNTRcXHUxQUE3XFx1MUIwNS1cXHUxQjMzXFx1MUI0NS1cXHUxQjRCXFx1MUI4My1cXHUxQkEwXFx1MUJBRVxcdTFCQUZcXHUxQkJBLVxcdTFCRTVcXHUxQzAwLVxcdTFDMjNcXHUxQzRELVxcdTFDNEZcXHUxQzVBLVxcdTFDN0RcXHUxQzgwLVxcdTFDODhcXHUxQ0U5LVxcdTFDRUNcXHUxQ0VFLVxcdTFDRjFcXHUxQ0Y1XFx1MUNGNlxcdTFEMDAtXFx1MURCRlxcdTFFMDAtXFx1MUYxNVxcdTFGMTgtXFx1MUYxRFxcdTFGMjAtXFx1MUY0NVxcdTFGNDgtXFx1MUY0RFxcdTFGNTAtXFx1MUY1N1xcdTFGNTlcXHUxRjVCXFx1MUY1RFxcdTFGNUYtXFx1MUY3RFxcdTFGODAtXFx1MUZCNFxcdTFGQjYtXFx1MUZCQ1xcdTFGQkVcXHUxRkMyLVxcdTFGQzRcXHUxRkM2LVxcdTFGQ0NcXHUxRkQwLVxcdTFGRDNcXHUxRkQ2LVxcdTFGREJcXHUxRkUwLVxcdTFGRUNcXHUxRkYyLVxcdTFGRjRcXHUxRkY2LVxcdTFGRkNcXHUyMDcxXFx1MjA3RlxcdTIwOTAtXFx1MjA5Q1xcdTIxMDJcXHUyMTA3XFx1MjEwQS1cXHUyMTEzXFx1MjExNVxcdTIxMTgtXFx1MjExRFxcdTIxMjRcXHUyMTI2XFx1MjEyOFxcdTIxMkEtXFx1MjEzOVxcdTIxM0MtXFx1MjEzRlxcdTIxNDUtXFx1MjE0OVxcdTIxNEVcXHUyMTYwLVxcdTIxODhcXHUyQzAwLVxcdTJDMkVcXHUyQzMwLVxcdTJDNUVcXHUyQzYwLVxcdTJDRTRcXHUyQ0VCLVxcdTJDRUVcXHUyQ0YyXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEODAtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOUItXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYxRlxcdUE2MkFcXHVBNjJCXFx1QTY0MC1cXHVBNjZFXFx1QTY3Ri1cXHVBNjlEXFx1QTZBMC1cXHVBNkVGXFx1QTcxNy1cXHVBNzFGXFx1QTcyMi1cXHVBNzg4XFx1QTc4Qi1cXHVBN0FFXFx1QTdCMC1cXHVBN0I3XFx1QTdGNy1cXHVBODAxXFx1QTgwMy1cXHVBODA1XFx1QTgwNy1cXHVBODBBXFx1QTgwQy1cXHVBODIyXFx1QTg0MC1cXHVBODczXFx1QTg4Mi1cXHVBOEIzXFx1QThGMi1cXHVBOEY3XFx1QThGQlxcdUE4RkRcXHVBOTBBLVxcdUE5MjVcXHVBOTMwLVxcdUE5NDZcXHVBOTYwLVxcdUE5N0NcXHVBOTg0LVxcdUE5QjJcXHVBOUNGXFx1QTlFMC1cXHVBOUU0XFx1QTlFNi1cXHVBOUVGXFx1QTlGQS1cXHVBOUZFXFx1QUEwMC1cXHVBQTI4XFx1QUE0MC1cXHVBQTQyXFx1QUE0NC1cXHVBQTRCXFx1QUE2MC1cXHVBQTc2XFx1QUE3QVxcdUFBN0UtXFx1QUFBRlxcdUFBQjFcXHVBQUI1XFx1QUFCNlxcdUFBQjktXFx1QUFCRFxcdUFBQzBcXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVBXFx1QUFGMi1cXHVBQUY0XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkUyXFx1QUMwMC1cXHVEN0EzXFx1RDdCMC1cXHVEN0M2XFx1RDdDQi1cXHVEN0ZCXFx1RjkwMC1cXHVGQTZEXFx1RkE3MC1cXHVGQUQ5XFx1RkIwMC1cXHVGQjA2XFx1RkIxMy1cXHVGQjE3XFx1RkIxRFxcdUZCMUYtXFx1RkIyOFxcdUZCMkEtXFx1RkIzNlxcdUZCMzgtXFx1RkIzQ1xcdUZCM0VcXHVGQjQwXFx1RkI0MVxcdUZCNDNcXHVGQjQ0XFx1RkI0Ni1cXHVGQkIxXFx1RkJEMy1cXHVGRDNEXFx1RkQ1MC1cXHVGRDhGXFx1RkQ5Mi1cXHVGREM3XFx1RkRGMC1cXHVGREZCXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYyMS1cXHVGRjNBXFx1RkY0MS1cXHVGRjVBXFx1RkY2Ni1cXHVGRkJFXFx1RkZDMi1cXHVGRkM3XFx1RkZDQS1cXHVGRkNGXFx1RkZEMi1cXHVGRkQ3XFx1RkZEQS1cXHVGRkRDXXxcXHVEODAwW1xcdURDMDAtXFx1REMwQlxcdURDMEQtXFx1REMyNlxcdURDMjgtXFx1REMzQVxcdURDM0NcXHVEQzNEXFx1REMzRi1cXHVEQzREXFx1REM1MC1cXHVEQzVEXFx1REM4MC1cXHVEQ0ZBXFx1REQ0MC1cXHVERDc0XFx1REU4MC1cXHVERTlDXFx1REVBMC1cXHVERUQwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjc1XFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDBcXHVERTEwLVxcdURFMTNcXHVERTE1LVxcdURFMTdcXHVERTE5LVxcdURFMzNcXHVERTYwLVxcdURFN0NcXHVERTgwLVxcdURFOUNcXHVERUMwLVxcdURFQzdcXHVERUM5LVxcdURFRTRcXHVERjAwLVxcdURGMzVcXHVERjQwLVxcdURGNTVcXHVERjYwLVxcdURGNzJcXHVERjgwLVxcdURGOTFdfFxcdUQ4MDNbXFx1REMwMC1cXHVEQzQ4XFx1REM4MC1cXHVEQ0IyXFx1RENDMC1cXHVEQ0YyXXxcXHVEODA0W1xcdURDMDMtXFx1REMzN1xcdURDODMtXFx1RENBRlxcdURDRDAtXFx1RENFOFxcdUREMDMtXFx1REQyNlxcdURENTAtXFx1REQ3MlxcdURENzZcXHVERDgzLVxcdUREQjJcXHVEREMxLVxcdUREQzRcXHVERERBXFx1REREQ1xcdURFMDAtXFx1REUxMVxcdURFMTMtXFx1REUyQlxcdURFODAtXFx1REU4NlxcdURFODhcXHVERThBLVxcdURFOERcXHVERThGLVxcdURFOURcXHVERTlGLVxcdURFQThcXHVERUIwLVxcdURFREVcXHVERjA1LVxcdURGMENcXHVERjBGXFx1REYxMFxcdURGMTMtXFx1REYyOFxcdURGMkEtXFx1REYzMFxcdURGMzJcXHVERjMzXFx1REYzNS1cXHVERjM5XFx1REYzRFxcdURGNTBcXHVERjVELVxcdURGNjFdfFxcdUQ4MDVbXFx1REMwMC1cXHVEQzM0XFx1REM0Ny1cXHVEQzRBXFx1REM4MC1cXHVEQ0FGXFx1RENDNFxcdURDQzVcXHVEQ0M3XFx1REQ4MC1cXHVEREFFXFx1REREOC1cXHVERERCXFx1REUwMC1cXHVERTJGXFx1REU0NFxcdURFODAtXFx1REVBQVxcdURGMDAtXFx1REYxOV18XFx1RDgwNltcXHVEQ0EwLVxcdURDREZcXHVEQ0ZGXFx1REVDMC1cXHVERUY4XXxcXHVEODA3W1xcdURDMDAtXFx1REMwOFxcdURDMEEtXFx1REMyRVxcdURDNDBcXHVEQzcyLVxcdURDOEZdfFxcdUQ4MDhbXFx1REMwMC1cXHVERjk5XXxcXHVEODA5W1xcdURDMDAtXFx1REM2RVxcdURDODAtXFx1REQ0M118W1xcdUQ4MENcXHVEODFDLVxcdUQ4MjBcXHVEODQwLVxcdUQ4NjhcXHVEODZBLVxcdUQ4NkNcXHVEODZGLVxcdUQ4NzJdW1xcdURDMDAtXFx1REZGRl18XFx1RDgwRFtcXHVEQzAwLVxcdURDMkVdfFxcdUQ4MTFbXFx1REMwMC1cXHVERTQ2XXxcXHVEODFBW1xcdURDMDAtXFx1REUzOFxcdURFNDAtXFx1REU1RVxcdURFRDAtXFx1REVFRFxcdURGMDAtXFx1REYyRlxcdURGNDAtXFx1REY0M1xcdURGNjMtXFx1REY3N1xcdURGN0QtXFx1REY4Rl18XFx1RDgxQltcXHVERjAwLVxcdURGNDRcXHVERjUwXFx1REY5My1cXHVERjlGXFx1REZFMF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OV18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdUREMDAtXFx1REQ0M118XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdLyxOb25Bc2NpaUlkZW50aWZpZXJQYXJ0Oi9bXFx4QUFcXHhCNVxceEI3XFx4QkFcXHhDMC1cXHhENlxceEQ4LVxceEY2XFx4RjgtXFx1MDJDMVxcdTAyQzYtXFx1MDJEMVxcdTAyRTAtXFx1MDJFNFxcdTAyRUNcXHUwMkVFXFx1MDMwMC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdBLVxcdTAzN0RcXHUwMzdGXFx1MDM4Ni1cXHUwMzhBXFx1MDM4Q1xcdTAzOEUtXFx1MDNBMVxcdTAzQTMtXFx1MDNGNVxcdTAzRjctXFx1MDQ4MVxcdTA0ODMtXFx1MDQ4N1xcdTA0OEEtXFx1MDUyRlxcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNTkxLVxcdTA1QkRcXHUwNUJGXFx1MDVDMVxcdTA1QzJcXHUwNUM0XFx1MDVDNVxcdTA1QzdcXHUwNUQwLVxcdTA1RUFcXHUwNUYwLVxcdTA1RjJcXHUwNjEwLVxcdTA2MUFcXHUwNjIwLVxcdTA2NjlcXHUwNjZFLVxcdTA2RDNcXHUwNkQ1LVxcdTA2RENcXHUwNkRGLVxcdTA2RThcXHUwNkVBLVxcdTA2RkNcXHUwNkZGXFx1MDcxMC1cXHUwNzRBXFx1MDc0RC1cXHUwN0IxXFx1MDdDMC1cXHUwN0Y1XFx1MDdGQVxcdTA4MDAtXFx1MDgyRFxcdTA4NDAtXFx1MDg1QlxcdTA4QTAtXFx1MDhCNFxcdTA4QjYtXFx1MDhCRFxcdTA4RDQtXFx1MDhFMVxcdTA4RTMtXFx1MDk2M1xcdTA5NjYtXFx1MDk2RlxcdTA5NzEtXFx1MDk4M1xcdTA5ODUtXFx1MDk4Q1xcdTA5OEZcXHUwOTkwXFx1MDk5My1cXHUwOUE4XFx1MDlBQS1cXHUwOUIwXFx1MDlCMlxcdTA5QjYtXFx1MDlCOVxcdTA5QkMtXFx1MDlDNFxcdTA5QzdcXHUwOUM4XFx1MDlDQi1cXHUwOUNFXFx1MDlEN1xcdTA5RENcXHUwOUREXFx1MDlERi1cXHUwOUUzXFx1MDlFNi1cXHUwOUYxXFx1MEEwMS1cXHUwQTAzXFx1MEEwNS1cXHUwQTBBXFx1MEEwRlxcdTBBMTBcXHUwQTEzLVxcdTBBMjhcXHUwQTJBLVxcdTBBMzBcXHUwQTMyXFx1MEEzM1xcdTBBMzVcXHUwQTM2XFx1MEEzOFxcdTBBMzlcXHUwQTNDXFx1MEEzRS1cXHUwQTQyXFx1MEE0N1xcdTBBNDhcXHUwQTRCLVxcdTBBNERcXHUwQTUxXFx1MEE1OS1cXHUwQTVDXFx1MEE1RVxcdTBBNjYtXFx1MEE3NVxcdTBBODEtXFx1MEE4M1xcdTBBODUtXFx1MEE4RFxcdTBBOEYtXFx1MEE5MVxcdTBBOTMtXFx1MEFBOFxcdTBBQUEtXFx1MEFCMFxcdTBBQjJcXHUwQUIzXFx1MEFCNS1cXHUwQUI5XFx1MEFCQy1cXHUwQUM1XFx1MEFDNy1cXHUwQUM5XFx1MEFDQi1cXHUwQUNEXFx1MEFEMFxcdTBBRTAtXFx1MEFFM1xcdTBBRTYtXFx1MEFFRlxcdTBBRjlcXHUwQjAxLVxcdTBCMDNcXHUwQjA1LVxcdTBCMENcXHUwQjBGXFx1MEIxMFxcdTBCMTMtXFx1MEIyOFxcdTBCMkEtXFx1MEIzMFxcdTBCMzJcXHUwQjMzXFx1MEIzNS1cXHUwQjM5XFx1MEIzQy1cXHUwQjQ0XFx1MEI0N1xcdTBCNDhcXHUwQjRCLVxcdTBCNERcXHUwQjU2XFx1MEI1N1xcdTBCNUNcXHUwQjVEXFx1MEI1Ri1cXHUwQjYzXFx1MEI2Ni1cXHUwQjZGXFx1MEI3MVxcdTBCODJcXHUwQjgzXFx1MEI4NS1cXHUwQjhBXFx1MEI4RS1cXHUwQjkwXFx1MEI5Mi1cXHUwQjk1XFx1MEI5OVxcdTBCOUFcXHUwQjlDXFx1MEI5RVxcdTBCOUZcXHUwQkEzXFx1MEJBNFxcdTBCQTgtXFx1MEJBQVxcdTBCQUUtXFx1MEJCOVxcdTBCQkUtXFx1MEJDMlxcdTBCQzYtXFx1MEJDOFxcdTBCQ0EtXFx1MEJDRFxcdTBCRDBcXHUwQkQ3XFx1MEJFNi1cXHUwQkVGXFx1MEMwMC1cXHUwQzAzXFx1MEMwNS1cXHUwQzBDXFx1MEMwRS1cXHUwQzEwXFx1MEMxMi1cXHUwQzI4XFx1MEMyQS1cXHUwQzM5XFx1MEMzRC1cXHUwQzQ0XFx1MEM0Ni1cXHUwQzQ4XFx1MEM0QS1cXHUwQzREXFx1MEM1NVxcdTBDNTZcXHUwQzU4LVxcdTBDNUFcXHUwQzYwLVxcdTBDNjNcXHUwQzY2LVxcdTBDNkZcXHUwQzgwLVxcdTBDODNcXHUwQzg1LVxcdTBDOENcXHUwQzhFLVxcdTBDOTBcXHUwQzkyLVxcdTBDQThcXHUwQ0FBLVxcdTBDQjNcXHUwQ0I1LVxcdTBDQjlcXHUwQ0JDLVxcdTBDQzRcXHUwQ0M2LVxcdTBDQzhcXHUwQ0NBLVxcdTBDQ0RcXHUwQ0Q1XFx1MENENlxcdTBDREVcXHUwQ0UwLVxcdTBDRTNcXHUwQ0U2LVxcdTBDRUZcXHUwQ0YxXFx1MENGMlxcdTBEMDEtXFx1MEQwM1xcdTBEMDUtXFx1MEQwQ1xcdTBEMEUtXFx1MEQxMFxcdTBEMTItXFx1MEQzQVxcdTBEM0QtXFx1MEQ0NFxcdTBENDYtXFx1MEQ0OFxcdTBENEEtXFx1MEQ0RVxcdTBENTQtXFx1MEQ1N1xcdTBENUYtXFx1MEQ2M1xcdTBENjYtXFx1MEQ2RlxcdTBEN0EtXFx1MEQ3RlxcdTBEODJcXHUwRDgzXFx1MEQ4NS1cXHUwRDk2XFx1MEQ5QS1cXHUwREIxXFx1MERCMy1cXHUwREJCXFx1MERCRFxcdTBEQzAtXFx1MERDNlxcdTBEQ0FcXHUwRENGLVxcdTBERDRcXHUwREQ2XFx1MEREOC1cXHUwRERGXFx1MERFNi1cXHUwREVGXFx1MERGMlxcdTBERjNcXHUwRTAxLVxcdTBFM0FcXHUwRTQwLVxcdTBFNEVcXHUwRTUwLVxcdTBFNTlcXHUwRTgxXFx1MEU4MlxcdTBFODRcXHUwRTg3XFx1MEU4OFxcdTBFOEFcXHUwRThEXFx1MEU5NC1cXHUwRTk3XFx1MEU5OS1cXHUwRTlGXFx1MEVBMS1cXHUwRUEzXFx1MEVBNVxcdTBFQTdcXHUwRUFBXFx1MEVBQlxcdTBFQUQtXFx1MEVCOVxcdTBFQkItXFx1MEVCRFxcdTBFQzAtXFx1MEVDNFxcdTBFQzZcXHUwRUM4LVxcdTBFQ0RcXHUwRUQwLVxcdTBFRDlcXHUwRURDLVxcdTBFREZcXHUwRjAwXFx1MEYxOFxcdTBGMTlcXHUwRjIwLVxcdTBGMjlcXHUwRjM1XFx1MEYzN1xcdTBGMzlcXHUwRjNFLVxcdTBGNDdcXHUwRjQ5LVxcdTBGNkNcXHUwRjcxLVxcdTBGODRcXHUwRjg2LVxcdTBGOTdcXHUwRjk5LVxcdTBGQkNcXHUwRkM2XFx1MTAwMC1cXHUxMDQ5XFx1MTA1MC1cXHUxMDlEXFx1MTBBMC1cXHUxMEM1XFx1MTBDN1xcdTEwQ0RcXHUxMEQwLVxcdTEwRkFcXHUxMEZDLVxcdTEyNDhcXHUxMjRBLVxcdTEyNERcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1QS1cXHUxMjVEXFx1MTI2MC1cXHUxMjg4XFx1MTI4QS1cXHUxMjhEXFx1MTI5MC1cXHUxMkIwXFx1MTJCMi1cXHUxMkI1XFx1MTJCOC1cXHUxMkJFXFx1MTJDMFxcdTEyQzItXFx1MTJDNVxcdTEyQzgtXFx1MTJENlxcdTEyRDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1QVxcdTEzNUQtXFx1MTM1RlxcdTEzNjktXFx1MTM3MVxcdTEzODAtXFx1MTM4RlxcdTEzQTAtXFx1MTNGNVxcdTEzRjgtXFx1MTNGRFxcdTE0MDEtXFx1MTY2Q1xcdTE2NkYtXFx1MTY3RlxcdTE2ODEtXFx1MTY5QVxcdTE2QTAtXFx1MTZFQVxcdTE2RUUtXFx1MTZGOFxcdTE3MDAtXFx1MTcwQ1xcdTE3MEUtXFx1MTcxNFxcdTE3MjAtXFx1MTczNFxcdTE3NDAtXFx1MTc1M1xcdTE3NjAtXFx1MTc2Q1xcdTE3NkUtXFx1MTc3MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN0QzXFx1MTdEN1xcdTE3RENcXHUxN0REXFx1MTdFMC1cXHUxN0U5XFx1MTgwQi1cXHUxODBEXFx1MTgxMC1cXHUxODE5XFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOEFBXFx1MThCMC1cXHUxOEY1XFx1MTkwMC1cXHUxOTFFXFx1MTkyMC1cXHUxOTJCXFx1MTkzMC1cXHUxOTNCXFx1MTk0Ni1cXHUxOTZEXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOUFCXFx1MTlCMC1cXHUxOUM5XFx1MTlEMC1cXHUxOURBXFx1MUEwMC1cXHUxQTFCXFx1MUEyMC1cXHUxQTVFXFx1MUE2MC1cXHUxQTdDXFx1MUE3Ri1cXHUxQTg5XFx1MUE5MC1cXHUxQTk5XFx1MUFBN1xcdTFBQjAtXFx1MUFCRFxcdTFCMDAtXFx1MUI0QlxcdTFCNTAtXFx1MUI1OVxcdTFCNkItXFx1MUI3M1xcdTFCODAtXFx1MUJGM1xcdTFDMDAtXFx1MUMzN1xcdTFDNDAtXFx1MUM0OVxcdTFDNEQtXFx1MUM3RFxcdTFDODAtXFx1MUM4OFxcdTFDRDAtXFx1MUNEMlxcdTFDRDQtXFx1MUNGNlxcdTFDRjhcXHUxQ0Y5XFx1MUQwMC1cXHUxREY1XFx1MURGQi1cXHUxRjE1XFx1MUYxOC1cXHUxRjFEXFx1MUYyMC1cXHUxRjQ1XFx1MUY0OC1cXHUxRjREXFx1MUY1MC1cXHUxRjU3XFx1MUY1OVxcdTFGNUJcXHUxRjVEXFx1MUY1Ri1cXHUxRjdEXFx1MUY4MC1cXHUxRkI0XFx1MUZCNi1cXHUxRkJDXFx1MUZCRVxcdTFGQzItXFx1MUZDNFxcdTFGQzYtXFx1MUZDQ1xcdTFGRDAtXFx1MUZEM1xcdTFGRDYtXFx1MUZEQlxcdTFGRTAtXFx1MUZFQ1xcdTFGRjItXFx1MUZGNFxcdTFGRjYtXFx1MUZGQ1xcdTIwMENcXHUyMDBEXFx1MjAzRlxcdTIwNDBcXHUyMDU0XFx1MjA3MVxcdTIwN0ZcXHUyMDkwLVxcdTIwOUNcXHUyMEQwLVxcdTIwRENcXHUyMEUxXFx1MjBFNS1cXHUyMEYwXFx1MjEwMlxcdTIxMDdcXHUyMTBBLVxcdTIxMTNcXHUyMTE1XFx1MjExOC1cXHUyMTFEXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyQS1cXHUyMTM5XFx1MjEzQy1cXHUyMTNGXFx1MjE0NS1cXHUyMTQ5XFx1MjE0RVxcdTIxNjAtXFx1MjE4OFxcdTJDMDAtXFx1MkMyRVxcdTJDMzAtXFx1MkM1RVxcdTJDNjAtXFx1MkNFNFxcdTJDRUItXFx1MkNGM1xcdTJEMDAtXFx1MkQyNVxcdTJEMjdcXHUyRDJEXFx1MkQzMC1cXHUyRDY3XFx1MkQ2RlxcdTJEN0YtXFx1MkQ5NlxcdTJEQTAtXFx1MkRBNlxcdTJEQTgtXFx1MkRBRVxcdTJEQjAtXFx1MkRCNlxcdTJEQjgtXFx1MkRCRVxcdTJEQzAtXFx1MkRDNlxcdTJEQzgtXFx1MkRDRVxcdTJERDAtXFx1MkRENlxcdTJERDgtXFx1MkRERVxcdTJERTAtXFx1MkRGRlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyRlxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzQ1xcdTMwNDEtXFx1MzA5NlxcdTMwOTktXFx1MzA5RlxcdTMwQTEtXFx1MzBGQVxcdTMwRkMtXFx1MzBGRlxcdTMxMDUtXFx1MzEyRFxcdTMxMzEtXFx1MzE4RVxcdTMxQTAtXFx1MzFCQVxcdTMxRjAtXFx1MzFGRlxcdTM0MDAtXFx1NERCNVxcdTRFMDAtXFx1OUZENVxcdUEwMDAtXFx1QTQ4Q1xcdUE0RDAtXFx1QTRGRFxcdUE1MDAtXFx1QTYwQ1xcdUE2MTAtXFx1QTYyQlxcdUE2NDAtXFx1QTY2RlxcdUE2NzQtXFx1QTY3RFxcdUE2N0YtXFx1QTZGMVxcdUE3MTctXFx1QTcxRlxcdUE3MjItXFx1QTc4OFxcdUE3OEItXFx1QTdBRVxcdUE3QjAtXFx1QTdCN1xcdUE3RjctXFx1QTgyN1xcdUE4NDAtXFx1QTg3M1xcdUE4ODAtXFx1QThDNVxcdUE4RDAtXFx1QThEOVxcdUE4RTAtXFx1QThGN1xcdUE4RkJcXHVBOEZEXFx1QTkwMC1cXHVBOTJEXFx1QTkzMC1cXHVBOTUzXFx1QTk2MC1cXHVBOTdDXFx1QTk4MC1cXHVBOUMwXFx1QTlDRi1cXHVBOUQ5XFx1QTlFMC1cXHVBOUZFXFx1QUEwMC1cXHVBQTM2XFx1QUE0MC1cXHVBQTREXFx1QUE1MC1cXHVBQTU5XFx1QUE2MC1cXHVBQTc2XFx1QUE3QS1cXHVBQUMyXFx1QUFEQi1cXHVBQUREXFx1QUFFMC1cXHVBQUVGXFx1QUFGMi1cXHVBQUY2XFx1QUIwMS1cXHVBQjA2XFx1QUIwOS1cXHVBQjBFXFx1QUIxMS1cXHVBQjE2XFx1QUIyMC1cXHVBQjI2XFx1QUIyOC1cXHVBQjJFXFx1QUIzMC1cXHVBQjVBXFx1QUI1Qy1cXHVBQjY1XFx1QUI3MC1cXHVBQkVBXFx1QUJFQ1xcdUFCRURcXHVBQkYwLVxcdUFCRjlcXHVBQzAwLVxcdUQ3QTNcXHVEN0IwLVxcdUQ3QzZcXHVEN0NCLVxcdUQ3RkJcXHVGOTAwLVxcdUZBNkRcXHVGQTcwLVxcdUZBRDlcXHVGQjAwLVxcdUZCMDZcXHVGQjEzLVxcdUZCMTdcXHVGQjFELVxcdUZCMjhcXHVGQjJBLVxcdUZCMzZcXHVGQjM4LVxcdUZCM0NcXHVGQjNFXFx1RkI0MFxcdUZCNDFcXHVGQjQzXFx1RkI0NFxcdUZCNDYtXFx1RkJCMVxcdUZCRDMtXFx1RkQzRFxcdUZENTAtXFx1RkQ4RlxcdUZEOTItXFx1RkRDN1xcdUZERjAtXFx1RkRGQlxcdUZFMDAtXFx1RkUwRlxcdUZFMjAtXFx1RkUyRlxcdUZFMzNcXHVGRTM0XFx1RkU0RC1cXHVGRTRGXFx1RkU3MC1cXHVGRTc0XFx1RkU3Ni1cXHVGRUZDXFx1RkYxMC1cXHVGRjE5XFx1RkYyMS1cXHVGRjNBXFx1RkYzRlxcdUZGNDEtXFx1RkY1QVxcdUZGNjYtXFx1RkZCRVxcdUZGQzItXFx1RkZDN1xcdUZGQ0EtXFx1RkZDRlxcdUZGRDItXFx1RkZEN1xcdUZGREEtXFx1RkZEQ118XFx1RDgwMFtcXHVEQzAwLVxcdURDMEJcXHVEQzBELVxcdURDMjZcXHVEQzI4LVxcdURDM0FcXHVEQzNDXFx1REMzRFxcdURDM0YtXFx1REM0RFxcdURDNTAtXFx1REM1RFxcdURDODAtXFx1RENGQVxcdURENDAtXFx1REQ3NFxcdURERkRcXHVERTgwLVxcdURFOUNcXHVERUEwLVxcdURFRDBcXHVERUUwXFx1REYwMC1cXHVERjFGXFx1REYzMC1cXHVERjRBXFx1REY1MC1cXHVERjdBXFx1REY4MC1cXHVERjlEXFx1REZBMC1cXHVERkMzXFx1REZDOC1cXHVERkNGXFx1REZEMS1cXHVERkQ1XXxcXHVEODAxW1xcdURDMDAtXFx1REM5RFxcdURDQTAtXFx1RENBOVxcdURDQjAtXFx1RENEM1xcdURDRDgtXFx1RENGQlxcdUREMDAtXFx1REQyN1xcdUREMzAtXFx1REQ2M1xcdURFMDAtXFx1REYzNlxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY2N118XFx1RDgwMltcXHVEQzAwLVxcdURDMDVcXHVEQzA4XFx1REMwQS1cXHVEQzM1XFx1REMzN1xcdURDMzhcXHVEQzNDXFx1REMzRi1cXHVEQzU1XFx1REM2MC1cXHVEQzc2XFx1REM4MC1cXHVEQzlFXFx1RENFMC1cXHVEQ0YyXFx1RENGNFxcdURDRjVcXHVERDAwLVxcdUREMTVcXHVERDIwLVxcdUREMzlcXHVERDgwLVxcdUREQjdcXHVEREJFXFx1RERCRlxcdURFMDAtXFx1REUwM1xcdURFMDVcXHVERTA2XFx1REUwQy1cXHVERTEzXFx1REUxNS1cXHVERTE3XFx1REUxOS1cXHVERTMzXFx1REUzOC1cXHVERTNBXFx1REUzRlxcdURFNjAtXFx1REU3Q1xcdURFODAtXFx1REU5Q1xcdURFQzAtXFx1REVDN1xcdURFQzktXFx1REVFNlxcdURGMDAtXFx1REYzNVxcdURGNDAtXFx1REY1NVxcdURGNjAtXFx1REY3MlxcdURGODAtXFx1REY5MV18XFx1RDgwM1tcXHVEQzAwLVxcdURDNDhcXHVEQzgwLVxcdURDQjJcXHVEQ0MwLVxcdURDRjJdfFxcdUQ4MDRbXFx1REMwMC1cXHVEQzQ2XFx1REM2Ni1cXHVEQzZGXFx1REM3Ri1cXHVEQ0JBXFx1RENEMC1cXHVEQ0U4XFx1RENGMC1cXHVEQ0Y5XFx1REQwMC1cXHVERDM0XFx1REQzNi1cXHVERDNGXFx1REQ1MC1cXHVERDczXFx1REQ3NlxcdUREODAtXFx1RERDNFxcdUREQ0EtXFx1RERDQ1xcdURERDAtXFx1REREQVxcdURERENcXHVERTAwLVxcdURFMTFcXHVERTEzLVxcdURFMzdcXHVERTNFXFx1REU4MC1cXHVERTg2XFx1REU4OFxcdURFOEEtXFx1REU4RFxcdURFOEYtXFx1REU5RFxcdURFOUYtXFx1REVBOFxcdURFQjAtXFx1REVFQVxcdURFRjAtXFx1REVGOVxcdURGMDAtXFx1REYwM1xcdURGMDUtXFx1REYwQ1xcdURGMEZcXHVERjEwXFx1REYxMy1cXHVERjI4XFx1REYyQS1cXHVERjMwXFx1REYzMlxcdURGMzNcXHVERjM1LVxcdURGMzlcXHVERjNDLVxcdURGNDRcXHVERjQ3XFx1REY0OFxcdURGNEItXFx1REY0RFxcdURGNTBcXHVERjU3XFx1REY1RC1cXHVERjYzXFx1REY2Ni1cXHVERjZDXFx1REY3MC1cXHVERjc0XXxcXHVEODA1W1xcdURDMDAtXFx1REM0QVxcdURDNTAtXFx1REM1OVxcdURDODAtXFx1RENDNVxcdURDQzdcXHVEQ0QwLVxcdURDRDlcXHVERDgwLVxcdUREQjVcXHVEREI4LVxcdUREQzBcXHVEREQ4LVxcdURERERcXHVERTAwLVxcdURFNDBcXHVERTQ0XFx1REU1MC1cXHVERTU5XFx1REU4MC1cXHVERUI3XFx1REVDMC1cXHVERUM5XFx1REYwMC1cXHVERjE5XFx1REYxRC1cXHVERjJCXFx1REYzMC1cXHVERjM5XXxcXHVEODA2W1xcdURDQTAtXFx1RENFOVxcdURDRkZcXHVERUMwLVxcdURFRjhdfFxcdUQ4MDdbXFx1REMwMC1cXHVEQzA4XFx1REMwQS1cXHVEQzM2XFx1REMzOC1cXHVEQzQwXFx1REM1MC1cXHVEQzU5XFx1REM3Mi1cXHVEQzhGXFx1REM5Mi1cXHVEQ0E3XFx1RENBOS1cXHVEQ0I2XXxcXHVEODA4W1xcdURDMDAtXFx1REY5OV18XFx1RDgwOVtcXHVEQzAwLVxcdURDNkVcXHVEQzgwLVxcdURENDNdfFtcXHVEODBDXFx1RDgxQy1cXHVEODIwXFx1RDg0MC1cXHVEODY4XFx1RDg2QS1cXHVEODZDXFx1RDg2Ri1cXHVEODcyXVtcXHVEQzAwLVxcdURGRkZdfFxcdUQ4MERbXFx1REMwMC1cXHVEQzJFXXxcXHVEODExW1xcdURDMDAtXFx1REU0Nl18XFx1RDgxQVtcXHVEQzAwLVxcdURFMzhcXHVERTQwLVxcdURFNUVcXHVERTYwLVxcdURFNjlcXHVERUQwLVxcdURFRURcXHVERUYwLVxcdURFRjRcXHVERjAwLVxcdURGMzZcXHVERjQwLVxcdURGNDNcXHVERjUwLVxcdURGNTlcXHVERjYzLVxcdURGNzdcXHVERjdELVxcdURGOEZdfFxcdUQ4MUJbXFx1REYwMC1cXHVERjQ0XFx1REY1MC1cXHVERjdFXFx1REY4Ri1cXHVERjlGXFx1REZFMF18XFx1RDgyMVtcXHVEQzAwLVxcdURGRUNdfFxcdUQ4MjJbXFx1REMwMC1cXHVERUYyXXxcXHVEODJDW1xcdURDMDBcXHVEQzAxXXxcXHVEODJGW1xcdURDMDAtXFx1REM2QVxcdURDNzAtXFx1REM3Q1xcdURDODAtXFx1REM4OFxcdURDOTAtXFx1REM5OVxcdURDOURcXHVEQzlFXXxcXHVEODM0W1xcdURENjUtXFx1REQ2OVxcdURENkQtXFx1REQ3MlxcdUREN0ItXFx1REQ4MlxcdUREODUtXFx1REQ4QlxcdUREQUEtXFx1RERBRFxcdURFNDItXFx1REU0NF18XFx1RDgzNVtcXHVEQzAwLVxcdURDNTRcXHVEQzU2LVxcdURDOUNcXHVEQzlFXFx1REM5RlxcdURDQTJcXHVEQ0E1XFx1RENBNlxcdURDQTktXFx1RENBQ1xcdURDQUUtXFx1RENCOVxcdURDQkJcXHVEQ0JELVxcdURDQzNcXHVEQ0M1LVxcdUREMDVcXHVERDA3LVxcdUREMEFcXHVERDBELVxcdUREMTRcXHVERDE2LVxcdUREMUNcXHVERDFFLVxcdUREMzlcXHVERDNCLVxcdUREM0VcXHVERDQwLVxcdURENDRcXHVERDQ2XFx1REQ0QS1cXHVERDUwXFx1REQ1Mi1cXHVERUE1XFx1REVBOC1cXHVERUMwXFx1REVDMi1cXHVERURBXFx1REVEQy1cXHVERUZBXFx1REVGQy1cXHVERjE0XFx1REYxNi1cXHVERjM0XFx1REYzNi1cXHVERjRFXFx1REY1MC1cXHVERjZFXFx1REY3MC1cXHVERjg4XFx1REY4QS1cXHVERkE4XFx1REZBQS1cXHVERkMyXFx1REZDNC1cXHVERkNCXFx1REZDRS1cXHVERkZGXXxcXHVEODM2W1xcdURFMDAtXFx1REUzNlxcdURFM0ItXFx1REU2Q1xcdURFNzVcXHVERTg0XFx1REU5Qi1cXHVERTlGXFx1REVBMS1cXHVERUFGXXxcXHVEODM4W1xcdURDMDAtXFx1REMwNlxcdURDMDgtXFx1REMxOFxcdURDMUItXFx1REMyMVxcdURDMjNcXHVEQzI0XFx1REMyNi1cXHVEQzJBXXxcXHVEODNBW1xcdURDMDAtXFx1RENDNFxcdURDRDAtXFx1RENENlxcdUREMDAtXFx1REQ0QVxcdURENTAtXFx1REQ1OV18XFx1RDgzQltcXHVERTAwLVxcdURFMDNcXHVERTA1LVxcdURFMUZcXHVERTIxXFx1REUyMlxcdURFMjRcXHVERTI3XFx1REUyOS1cXHVERTMyXFx1REUzNC1cXHVERTM3XFx1REUzOVxcdURFM0JcXHVERTQyXFx1REU0N1xcdURFNDlcXHVERTRCXFx1REU0RC1cXHVERTRGXFx1REU1MVxcdURFNTJcXHVERTU0XFx1REU1N1xcdURFNTlcXHVERTVCXFx1REU1RFxcdURFNUZcXHVERTYxXFx1REU2MlxcdURFNjRcXHVERTY3LVxcdURFNkFcXHVERTZDLVxcdURFNzJcXHVERTc0LVxcdURFNzdcXHVERTc5LVxcdURFN0NcXHVERTdFXFx1REU4MC1cXHVERTg5XFx1REU4Qi1cXHVERTlCXFx1REVBMS1cXHVERUEzXFx1REVBNS1cXHVERUE5XFx1REVBQi1cXHVERUJCXXxcXHVEODY5W1xcdURDMDAtXFx1REVENlxcdURGMDAtXFx1REZGRl18XFx1RDg2RFtcXHVEQzAwLVxcdURGMzRcXHVERjQwLVxcdURGRkZdfFxcdUQ4NkVbXFx1REMwMC1cXHVEQzFEXFx1REMyMC1cXHVERkZGXXxcXHVEODczW1xcdURDMDAtXFx1REVBMV18XFx1RDg3RVtcXHVEQzAwLVxcdURFMURdfFxcdURCNDBbXFx1REQwMC1cXHVEREVGXS99O2Z1bmN0aW9uIGwoRil7cmV0dXJuIDQ4PD1GJiZGPD01N31mdW5jdGlvbiBwKEYpe3JldHVybiA0ODw9RiYmRjw9NTd8fDk3PD1GJiZGPD0xMDJ8fDY1PD1GJiZGPD03MH1mdW5jdGlvbiBkKEYpe3JldHVybiBGPj00OCYmRjw9NTV9YT1bNTc2MCw4MTkyLDgxOTMsODE5NCw4MTk1LDgxOTYsODE5Nyw4MTk4LDgxOTksODIwMCw4MjAxLDgyMDIsODIzOSw4Mjg3LDEyMjg4LDY1Mjc5XTtmdW5jdGlvbiB5KEYpe3JldHVybiBGPT09MzJ8fEY9PT05fHxGPT09MTF8fEY9PT0xMnx8Rj09PTE2MHx8Rj49NTc2MCYmYS5pbmRleE9mKEYpPj0wfWZ1bmN0aW9uIGcoRil7cmV0dXJuIEY9PT0xMHx8Rj09PTEzfHxGPT09ODIzMnx8Rj09PTgyMzN9ZnVuY3Rpb24gYyhGKXtpZihGPD02NTUzNSlyZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZShGKTt2YXIgUz1TdHJpbmcuZnJvbUNoYXJDb2RlKE1hdGguZmxvb3IoKEYtNjU1MzYpLzEwMjQpKzU1Mjk2KSxOPVN0cmluZy5mcm9tQ2hhckNvZGUoKEYtNjU1MzYpJTEwMjQrNTYzMjApO3JldHVybiBTK059Zm9yKG49bmV3IEFycmF5KDEyOCksaT0wO2k8MTI4OysraSluW2ldPWk+PTk3JiZpPD0xMjJ8fGk+PTY1JiZpPD05MHx8aT09PTM2fHxpPT09OTU7Zm9yKHU9bmV3IEFycmF5KDEyOCksaT0wO2k8MTI4OysraSl1W2ldPWk+PTk3JiZpPD0xMjJ8fGk+PTY1JiZpPD05MHx8aT49NDgmJmk8PTU3fHxpPT09MzZ8fGk9PT05NTtmdW5jdGlvbiBEKEYpe3JldHVybiBGPDEyOD9uW0ZdOnMuTm9uQXNjaWlJZGVudGlmaWVyU3RhcnQudGVzdChjKEYpKX1mdW5jdGlvbiBFKEYpe3JldHVybiBGPDEyOD91W0ZdOnMuTm9uQXNjaWlJZGVudGlmaWVyUGFydC50ZXN0KGMoRikpfWZ1bmN0aW9uIF8oRil7cmV0dXJuIEY8MTI4P25bRl06dC5Ob25Bc2NpaUlkZW50aWZpZXJTdGFydC50ZXN0KGMoRikpfWZ1bmN0aW9uIHcoRil7cmV0dXJuIEY8MTI4P3VbRl06dC5Ob25Bc2NpaUlkZW50aWZpZXJQYXJ0LnRlc3QoYyhGKSl9ci5leHBvcnRzPXtpc0RlY2ltYWxEaWdpdDpsLGlzSGV4RGlnaXQ6cCxpc09jdGFsRGlnaXQ6ZCxpc1doaXRlU3BhY2U6eSxpc0xpbmVUZXJtaW5hdG9yOmcsaXNJZGVudGlmaWVyU3RhcnRFUzU6RCxpc0lkZW50aWZpZXJQYXJ0RVM1OkUsaXNJZGVudGlmaWVyU3RhcnRFUzY6Xyxpc0lkZW50aWZpZXJQYXJ0RVM2Ond9fSgpfX0pLHptPXRlKHtcIm5vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi9rZXl3b3JkLmpzXCIoZSxyKXtuZSgpLGZ1bmN0aW9uKCl7XCJ1c2Ugc3RyaWN0XCI7dmFyIHQ9c28oKTtmdW5jdGlvbiBzKEQpe3N3aXRjaChEKXtjYXNlXCJpbXBsZW1lbnRzXCI6Y2FzZVwiaW50ZXJmYWNlXCI6Y2FzZVwicGFja2FnZVwiOmNhc2VcInByaXZhdGVcIjpjYXNlXCJwcm90ZWN0ZWRcIjpjYXNlXCJwdWJsaWNcIjpjYXNlXCJzdGF0aWNcIjpjYXNlXCJsZXRcIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBhKEQsRSl7cmV0dXJuIUUmJkQ9PT1cInlpZWxkXCI/ITE6bihELEUpfWZ1bmN0aW9uIG4oRCxFKXtpZihFJiZzKEQpKXJldHVybiEwO3N3aXRjaChELmxlbmd0aCl7Y2FzZSAyOnJldHVybiBEPT09XCJpZlwifHxEPT09XCJpblwifHxEPT09XCJkb1wiO2Nhc2UgMzpyZXR1cm4gRD09PVwidmFyXCJ8fEQ9PT1cImZvclwifHxEPT09XCJuZXdcInx8RD09PVwidHJ5XCI7Y2FzZSA0OnJldHVybiBEPT09XCJ0aGlzXCJ8fEQ9PT1cImVsc2VcInx8RD09PVwiY2FzZVwifHxEPT09XCJ2b2lkXCJ8fEQ9PT1cIndpdGhcInx8RD09PVwiZW51bVwiO2Nhc2UgNTpyZXR1cm4gRD09PVwid2hpbGVcInx8RD09PVwiYnJlYWtcInx8RD09PVwiY2F0Y2hcInx8RD09PVwidGhyb3dcInx8RD09PVwiY29uc3RcInx8RD09PVwieWllbGRcInx8RD09PVwiY2xhc3NcInx8RD09PVwic3VwZXJcIjtjYXNlIDY6cmV0dXJuIEQ9PT1cInJldHVyblwifHxEPT09XCJ0eXBlb2ZcInx8RD09PVwiZGVsZXRlXCJ8fEQ9PT1cInN3aXRjaFwifHxEPT09XCJleHBvcnRcInx8RD09PVwiaW1wb3J0XCI7Y2FzZSA3OnJldHVybiBEPT09XCJkZWZhdWx0XCJ8fEQ9PT1cImZpbmFsbHlcInx8RD09PVwiZXh0ZW5kc1wiO2Nhc2UgODpyZXR1cm4gRD09PVwiZnVuY3Rpb25cInx8RD09PVwiY29udGludWVcInx8RD09PVwiZGVidWdnZXJcIjtjYXNlIDEwOnJldHVybiBEPT09XCJpbnN0YW5jZW9mXCI7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gdShELEUpe3JldHVybiBEPT09XCJudWxsXCJ8fEQ9PT1cInRydWVcInx8RD09PVwiZmFsc2VcInx8YShELEUpfWZ1bmN0aW9uIGkoRCxFKXtyZXR1cm4gRD09PVwibnVsbFwifHxEPT09XCJ0cnVlXCJ8fEQ9PT1cImZhbHNlXCJ8fG4oRCxFKX1mdW5jdGlvbiBsKEQpe3JldHVybiBEPT09XCJldmFsXCJ8fEQ9PT1cImFyZ3VtZW50c1wifWZ1bmN0aW9uIHAoRCl7dmFyIEUsXyx3O2lmKEQubGVuZ3RoPT09MHx8KHc9RC5jaGFyQ29kZUF0KDApLCF0LmlzSWRlbnRpZmllclN0YXJ0RVM1KHcpKSlyZXR1cm4hMTtmb3IoRT0xLF89RC5sZW5ndGg7RTxfOysrRSlpZih3PUQuY2hhckNvZGVBdChFKSwhdC5pc0lkZW50aWZpZXJQYXJ0RVM1KHcpKXJldHVybiExO3JldHVybiEwfWZ1bmN0aW9uIGQoRCxFKXtyZXR1cm4oRC01NTI5NikqMTAyNCsoRS01NjMyMCkrNjU1MzZ9ZnVuY3Rpb24geShEKXt2YXIgRSxfLHcsRixTO2lmKEQubGVuZ3RoPT09MClyZXR1cm4hMTtmb3IoUz10LmlzSWRlbnRpZmllclN0YXJ0RVM2LEU9MCxfPUQubGVuZ3RoO0U8XzsrK0Upe2lmKHc9RC5jaGFyQ29kZUF0KEUpLDU1Mjk2PD13JiZ3PD01NjMxOSl7aWYoKytFLEU+PV98fChGPUQuY2hhckNvZGVBdChFKSwhKDU2MzIwPD1GJiZGPD01NzM0MykpKXJldHVybiExO3c9ZCh3LEYpfWlmKCFTKHcpKXJldHVybiExO1M9dC5pc0lkZW50aWZpZXJQYXJ0RVM2fXJldHVybiEwfWZ1bmN0aW9uIGcoRCxFKXtyZXR1cm4gcChEKSYmIXUoRCxFKX1mdW5jdGlvbiBjKEQsRSl7cmV0dXJuIHkoRCkmJiFpKEQsRSl9ci5leHBvcnRzPXtpc0tleXdvcmRFUzU6YSxpc0tleXdvcmRFUzY6bixpc1Jlc2VydmVkV29yZEVTNTp1LGlzUmVzZXJ2ZWRXb3JkRVM2OmksaXNSZXN0cmljdGVkV29yZDpsLGlzSWRlbnRpZmllck5hbWVFUzU6cCxpc0lkZW50aWZpZXJOYW1lRVM2OnksaXNJZGVudGlmaWVyRVM1OmcsaXNJZGVudGlmaWVyRVM2OmN9fSgpfX0pLFhtPXRlKHtcIm5vZGVfbW9kdWxlcy9lc3V0aWxzL2xpYi91dGlscy5qc1wiKGUpe25lKCksZnVuY3Rpb24oKXtcInVzZSBzdHJpY3RcIjtlLmFzdD1KbSgpLGUuY29kZT1zbygpLGUua2V5d29yZD16bSgpfSgpfX0pLE90PXRlKHtcInNyYy9sYW5ndWFnZS1qcy91dGlscy9pcy1ibG9jay1jb21tZW50LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PW5ldyBTZXQoW1wiQmxvY2tcIixcIkNvbW1lbnRCbG9ja1wiLFwiTXVsdGlMaW5lXCJdKSxzPWE9PnQuaGFzKGE9PW51bGw/dm9pZCAwOmEudHlwZSk7ci5leHBvcnRzPXN9fSksS209dGUoe1wic3JjL2xhbmd1YWdlLWpzL3V0aWxzL2lzLW5vZGUtbWF0Y2hlcy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KGEsbil7bGV0IHU9bi5zcGxpdChcIi5cIik7Zm9yKGxldCBpPXUubGVuZ3RoLTE7aT49MDtpLS0pe2xldCBsPXVbaV07aWYoaT09PTApcmV0dXJuIGEudHlwZT09PVwiSWRlbnRpZmllclwiJiZhLm5hbWU9PT1sO2lmKGEudHlwZSE9PVwiTWVtYmVyRXhwcmVzc2lvblwifHxhLm9wdGlvbmFsfHxhLmNvbXB1dGVkfHxhLnByb3BlcnR5LnR5cGUhPT1cIklkZW50aWZpZXJcInx8YS5wcm9wZXJ0eS5uYW1lIT09bClyZXR1cm4hMTthPWEub2JqZWN0fX1mdW5jdGlvbiBzKGEsbil7cmV0dXJuIG4uc29tZSh1PT50KGEsdSkpfXIuZXhwb3J0cz1zfX0pLEtlPXRlKHtcInNyYy9sYW5ndWFnZS1qcy91dGlscy9pbmRleC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1YbSgpLmtleXdvcmQuaXNJZGVudGlmaWVyTmFtZUVTNSx7Z2V0TGFzdDpzLGhhc05ld2xpbmU6YSxza2lwV2hpdGVzcGFjZTpuLGlzTm9uRW1wdHlBcnJheTp1LGlzTmV4dExpbmVFbXB0eUFmdGVySW5kZXg6aSxnZXRTdHJpbmdXaWR0aDpsfT1VZSgpLHtsb2NTdGFydDpwLGxvY0VuZDpkLGhhc1NhbWVMb2NTdGFydDp5fT11dCgpLGc9T3QoKSxjPUttKCksRD1cIig/Oig/PS4pXFxcXHMpXCIsRT1uZXcgUmVnRXhwKGBeJHtEfSo6YCksXz1uZXcgUmVnRXhwKGBeJHtEfSo6OmApO2Z1bmN0aW9uIHcoTyl7dmFyIG1lLF9lO3JldHVybigobWU9Ty5leHRyYSk9PT1udWxsfHxtZT09PXZvaWQgMD92b2lkIDA6bWUucGFyZW50aGVzaXplZCkmJmcoKF9lPU8udHJhaWxpbmdDb21tZW50cyk9PT1udWxsfHxfZT09PXZvaWQgMD92b2lkIDA6X2VbMF0pJiZFLnRlc3QoTy50cmFpbGluZ0NvbW1lbnRzWzBdLnZhbHVlKX1mdW5jdGlvbiBGKE8pe2xldCBtZT1PPT1udWxsP3ZvaWQgMDpPWzBdO3JldHVybiBnKG1lKSYmXy50ZXN0KG1lLnZhbHVlKX1mdW5jdGlvbiBTKE8sbWUpe2lmKCFPfHx0eXBlb2YgTyE9XCJvYmplY3RcIilyZXR1cm4hMTtpZihBcnJheS5pc0FycmF5KE8pKXJldHVybiBPLnNvbWUoSGU9PlMoSGUsbWUpKTtsZXQgX2U9bWUoTyk7cmV0dXJuIHR5cGVvZiBfZT09XCJib29sZWFuXCI/X2U6T2JqZWN0LnZhbHVlcyhPKS5zb21lKEhlPT5TKEhlLG1lKSl9ZnVuY3Rpb24gTihPKXtyZXR1cm4gTy50eXBlPT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwifHxPLnR5cGU9PT1cIkJpbmFyeUV4cHJlc3Npb25cInx8Ty50eXBlPT09XCJMb2dpY2FsRXhwcmVzc2lvblwifHxPLnR5cGU9PT1cIk5HUGlwZUV4cHJlc3Npb25cInx8Ty50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cInx8ZGUoTyl8fHVlKE8pfHxPLnR5cGU9PT1cIlNlcXVlbmNlRXhwcmVzc2lvblwifHxPLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwifHxPLnR5cGU9PT1cIkJpbmRFeHByZXNzaW9uXCJ8fE8udHlwZT09PVwiVXBkYXRlRXhwcmVzc2lvblwiJiYhTy5wcmVmaXh8fHN0KE8pfHxPLnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cIn1mdW5jdGlvbiBJKE8pe3ZhciBtZSxfZSxIZSxHZSxpdCxRZTtyZXR1cm4gTy5leHByZXNzaW9ucz9PLmV4cHJlc3Npb25zWzBdOihtZT0oX2U9KEhlPShHZT0oaXQ9KFFlPU8ubGVmdCkhPT1udWxsJiZRZSE9PXZvaWQgMD9RZTpPLnRlc3QpIT09bnVsbCYmaXQhPT12b2lkIDA/aXQ6Ty5jYWxsZWUpIT09bnVsbCYmR2UhPT12b2lkIDA/R2U6Ty5vYmplY3QpIT09bnVsbCYmSGUhPT12b2lkIDA/SGU6Ty50YWcpIT09bnVsbCYmX2UhPT12b2lkIDA/X2U6Ty5hcmd1bWVudCkhPT1udWxsJiZtZSE9PXZvaWQgMD9tZTpPLmV4cHJlc3Npb259ZnVuY3Rpb24gUChPLG1lKXtpZihtZS5leHByZXNzaW9ucylyZXR1cm5bXCJleHByZXNzaW9uc1wiLDBdO2lmKG1lLmxlZnQpcmV0dXJuW1wibGVmdFwiXTtpZihtZS50ZXN0KXJldHVybltcInRlc3RcIl07aWYobWUub2JqZWN0KXJldHVybltcIm9iamVjdFwiXTtpZihtZS5jYWxsZWUpcmV0dXJuW1wiY2FsbGVlXCJdO2lmKG1lLnRhZylyZXR1cm5bXCJ0YWdcIl07aWYobWUuYXJndW1lbnQpcmV0dXJuW1wiYXJndW1lbnRcIl07aWYobWUuZXhwcmVzc2lvbilyZXR1cm5bXCJleHByZXNzaW9uXCJdO3Rocm93IG5ldyBFcnJvcihcIlVuZXhwZWN0ZWQgbm9kZSBoYXMgbm8gbGVmdCBzaWRlLlwiKX1mdW5jdGlvbiAkKE8pe3JldHVybiBPPW5ldyBTZXQoTyksbWU9Pk8uaGFzKG1lPT1udWxsP3ZvaWQgMDptZS50eXBlKX12YXIgZj0kKFtcIkxpbmVcIixcIkNvbW1lbnRMaW5lXCIsXCJTaW5nbGVMaW5lXCIsXCJIYXNoYmFuZ0NvbW1lbnRcIixcIkhUTUxPcGVuXCIsXCJIVE1MQ2xvc2VcIl0pLFQ9JChbXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIixcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIixcIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiLFwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiLFwiRXhwb3J0QWxsRGVjbGFyYXRpb25cIl0pO2Z1bmN0aW9uIG0oTyl7bGV0IG1lPU8uZ2V0UGFyZW50Tm9kZSgpO3JldHVybiBPLmdldE5hbWUoKT09PVwiZGVjbGFyYXRpb25cIiYmVChtZSk/bWU6bnVsbH12YXIgdj0kKFtcIkJvb2xlYW5MaXRlcmFsXCIsXCJEaXJlY3RpdmVMaXRlcmFsXCIsXCJMaXRlcmFsXCIsXCJOdWxsTGl0ZXJhbFwiLFwiTnVtZXJpY0xpdGVyYWxcIixcIkJpZ0ludExpdGVyYWxcIixcIkRlY2ltYWxMaXRlcmFsXCIsXCJSZWdFeHBMaXRlcmFsXCIsXCJTdHJpbmdMaXRlcmFsXCIsXCJUZW1wbGF0ZUxpdGVyYWxcIixcIlRTVHlwZUxpdGVyYWxcIixcIkpTWFRleHRcIl0pO2Z1bmN0aW9uIG8oTyl7cmV0dXJuIE8udHlwZT09PVwiTnVtZXJpY0xpdGVyYWxcInx8Ty50eXBlPT09XCJMaXRlcmFsXCImJnR5cGVvZiBPLnZhbHVlPT1cIm51bWJlclwifWZ1bmN0aW9uIGgoTyl7cmV0dXJuIE8udHlwZT09PVwiVW5hcnlFeHByZXNzaW9uXCImJihPLm9wZXJhdG9yPT09XCIrXCJ8fE8ub3BlcmF0b3I9PT1cIi1cIikmJm8oTy5hcmd1bWVudCl9ZnVuY3Rpb24gQyhPKXtyZXR1cm4gTy50eXBlPT09XCJTdHJpbmdMaXRlcmFsXCJ8fE8udHlwZT09PVwiTGl0ZXJhbFwiJiZ0eXBlb2YgTy52YWx1ZT09XCJzdHJpbmdcIn12YXIgeD0kKFtcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsXCJUU1R5cGVMaXRlcmFsXCIsXCJUU01hcHBlZFR5cGVcIl0pLGI9JChbXCJGdW5jdGlvbkV4cHJlc3Npb25cIixcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCJdKTtmdW5jdGlvbiBCKE8pe3JldHVybiBPLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwifHxPLnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCImJk8uYm9keS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwifWZ1bmN0aW9uIGsoTyl7cmV0dXJuIGRlKE8pJiZPLmNhbGxlZS50eXBlPT09XCJJZGVudGlmaWVyXCImJltcImFzeW5jXCIsXCJpbmplY3RcIixcImZha2VBc3luY1wiLFwid2FpdEZvckFzeW5jXCJdLmluY2x1ZGVzKE8uY2FsbGVlLm5hbWUpfXZhciBNPSQoW1wiSlNYRWxlbWVudFwiLFwiSlNYRnJhZ21lbnRcIl0pO2Z1bmN0aW9uIFIoTyxtZSl7aWYoTy5wYXJlbnRQYXJzZXIhPT1cIm1hcmtkb3duXCImJk8ucGFyZW50UGFyc2VyIT09XCJtZHhcIilyZXR1cm4hMTtsZXQgX2U9bWUuZ2V0Tm9kZSgpO2lmKCFfZS5leHByZXNzaW9ufHwhTShfZS5leHByZXNzaW9uKSlyZXR1cm4hMTtsZXQgSGU9bWUuZ2V0UGFyZW50Tm9kZSgpO3JldHVybiBIZS50eXBlPT09XCJQcm9ncmFtXCImJkhlLmJvZHkubGVuZ3RoPT09MX1mdW5jdGlvbiBxKE8pe3JldHVybiBPLmtpbmQ9PT1cImdldFwifHxPLmtpbmQ9PT1cInNldFwifWZ1bmN0aW9uIEooTyl7cmV0dXJuIHEoTyl8fHkoTyxPLnZhbHVlKX1mdW5jdGlvbiBMKE8pe3JldHVybihPLnR5cGU9PT1cIk9iamVjdFR5cGVQcm9wZXJ0eVwifHxPLnR5cGU9PT1cIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIikmJk8udmFsdWUudHlwZT09PVwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwiJiYhTy5zdGF0aWMmJiFKKE8pfWZ1bmN0aW9uIFEoTyl7cmV0dXJuKE8udHlwZT09PVwiVHlwZUFubm90YXRpb25cInx8Ty50eXBlPT09XCJUU1R5cGVBbm5vdGF0aW9uXCIpJiZPLnR5cGVBbm5vdGF0aW9uLnR5cGU9PT1cIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiYmIU8uc3RhdGljJiYheShPLE8udHlwZUFubm90YXRpb24pfXZhciBWPSQoW1wiQmluYXJ5RXhwcmVzc2lvblwiLFwiTG9naWNhbEV4cHJlc3Npb25cIixcIk5HUGlwZUV4cHJlc3Npb25cIl0pO2Z1bmN0aW9uIGooTyl7cmV0dXJuIHVlKE8pfHxPLnR5cGU9PT1cIkJpbmRFeHByZXNzaW9uXCImJkJvb2xlYW4oTy5vYmplY3QpfXZhciBZPW5ldyBTZXQoW1wiQW55VHlwZUFubm90YXRpb25cIixcIlRTQW55S2V5d29yZFwiLFwiTnVsbExpdGVyYWxUeXBlQW5ub3RhdGlvblwiLFwiVFNOdWxsS2V5d29yZFwiLFwiVGhpc1R5cGVBbm5vdGF0aW9uXCIsXCJUU1RoaXNUeXBlXCIsXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiLFwiVFNOdW1iZXJLZXl3b3JkXCIsXCJWb2lkVHlwZUFubm90YXRpb25cIixcIlRTVm9pZEtleXdvcmRcIixcIkJvb2xlYW5UeXBlQW5ub3RhdGlvblwiLFwiVFNCb29sZWFuS2V5d29yZFwiLFwiQmlnSW50VHlwZUFubm90YXRpb25cIixcIlRTQmlnSW50S2V5d29yZFwiLFwiU3ltYm9sVHlwZUFubm90YXRpb25cIixcIlRTU3ltYm9sS2V5d29yZFwiLFwiU3RyaW5nVHlwZUFubm90YXRpb25cIixcIlRTU3RyaW5nS2V5d29yZFwiLFwiQm9vbGVhbkxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLFwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCIsXCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIixcIk51bWJlckxpdGVyYWxUeXBlQW5ub3RhdGlvblwiLFwiVFNMaXRlcmFsVHlwZVwiLFwiVFNUZW1wbGF0ZUxpdGVyYWxUeXBlXCIsXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCIsXCJNaXhlZFR5cGVBbm5vdGF0aW9uXCIsXCJUU05ldmVyS2V5d29yZFwiLFwiVFNPYmplY3RLZXl3b3JkXCIsXCJUU1VuZGVmaW5lZEtleXdvcmRcIixcIlRTVW5rbm93bktleXdvcmRcIl0pO2Z1bmN0aW9uIGllKE8pe3JldHVybiBPPyEhKChPLnR5cGU9PT1cIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwifHxPLnR5cGU9PT1cIlRTVHlwZVJlZmVyZW5jZVwiKSYmIU8udHlwZVBhcmFtZXRlcnN8fFkuaGFzKE8udHlwZSkpOiExfWZ1bmN0aW9uIGVlKE8pe2xldCBtZT0vXig/OmJlZm9yZXxhZnRlcikoPzpFYWNofEFsbCkkLztyZXR1cm4gTy5jYWxsZWUudHlwZT09PVwiSWRlbnRpZmllclwiJiZtZS50ZXN0KE8uY2FsbGVlLm5hbWUpJiZPLmFyZ3VtZW50cy5sZW5ndGg9PT0xfXZhciBsZT1bXCJpdFwiLFwiaXQub25seVwiLFwiaXQuc2tpcFwiLFwiZGVzY3JpYmVcIixcImRlc2NyaWJlLm9ubHlcIixcImRlc2NyaWJlLnNraXBcIixcInRlc3RcIixcInRlc3Qub25seVwiLFwidGVzdC5za2lwXCIsXCJ0ZXN0LnN0ZXBcIixcInRlc3QuZGVzY3JpYmVcIixcInRlc3QuZGVzY3JpYmUub25seVwiLFwidGVzdC5kZXNjcmliZS5wYXJhbGxlbFwiLFwidGVzdC5kZXNjcmliZS5wYXJhbGxlbC5vbmx5XCIsXCJ0ZXN0LmRlc2NyaWJlLnNlcmlhbFwiLFwidGVzdC5kZXNjcmliZS5zZXJpYWwub25seVwiLFwic2tpcFwiLFwieGl0XCIsXCJ4ZGVzY3JpYmVcIixcInh0ZXN0XCIsXCJmaXRcIixcImZkZXNjcmliZVwiLFwiZnRlc3RcIl07ZnVuY3Rpb24gVyhPKXtyZXR1cm4gYyhPLGxlKX1mdW5jdGlvbiBLKE8sbWUpe2lmKE8udHlwZSE9PVwiQ2FsbEV4cHJlc3Npb25cIilyZXR1cm4hMTtpZihPLmFyZ3VtZW50cy5sZW5ndGg9PT0xKXtpZihrKE8pJiZtZSYmSyhtZSkpcmV0dXJuIGIoTy5hcmd1bWVudHNbMF0pO2lmKGVlKE8pKXJldHVybiBrKE8uYXJndW1lbnRzWzBdKX1lbHNlIGlmKChPLmFyZ3VtZW50cy5sZW5ndGg9PT0yfHxPLmFyZ3VtZW50cy5sZW5ndGg9PT0zKSYmKE8uYXJndW1lbnRzWzBdLnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwifHxDKE8uYXJndW1lbnRzWzBdKSkmJlcoTy5jYWxsZWUpKXJldHVybiBPLmFyZ3VtZW50c1syXSYmIW8oTy5hcmd1bWVudHNbMl0pPyExOihPLmFyZ3VtZW50cy5sZW5ndGg9PT0yP2IoTy5hcmd1bWVudHNbMV0pOkIoTy5hcmd1bWVudHNbMV0pJiZ2ZShPLmFyZ3VtZW50c1sxXSkubGVuZ3RoPD0xKXx8ayhPLmFyZ3VtZW50c1sxXSk7cmV0dXJuITF9dmFyIGRlPSQoW1wiQ2FsbEV4cHJlc3Npb25cIixcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIl0pLHVlPSQoW1wiTWVtYmVyRXhwcmVzc2lvblwiLFwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCJdKTtmdW5jdGlvbiBGZShPKXtsZXQgbWU9XCJleHByZXNzaW9uc1wiO08udHlwZT09PVwiVFNUZW1wbGF0ZUxpdGVyYWxUeXBlXCImJihtZT1cInR5cGVzXCIpO2xldCBfZT1PW21lXTtyZXR1cm4gX2UubGVuZ3RoPT09MD8hMTpfZS5ldmVyeShIZT0+e2lmKE1lKEhlKSlyZXR1cm4hMTtpZihIZS50eXBlPT09XCJJZGVudGlmaWVyXCJ8fEhlLnR5cGU9PT1cIlRoaXNFeHByZXNzaW9uXCIpcmV0dXJuITA7aWYodWUoSGUpKXtsZXQgR2U9SGU7Zm9yKDt1ZShHZSk7KWlmKEdlLnByb3BlcnR5LnR5cGUhPT1cIklkZW50aWZpZXJcIiYmR2UucHJvcGVydHkudHlwZSE9PVwiTGl0ZXJhbFwiJiZHZS5wcm9wZXJ0eS50eXBlIT09XCJTdHJpbmdMaXRlcmFsXCImJkdlLnByb3BlcnR5LnR5cGUhPT1cIk51bWVyaWNMaXRlcmFsXCJ8fChHZT1HZS5vYmplY3QsTWUoR2UpKSlyZXR1cm4hMTtyZXR1cm4gR2UudHlwZT09PVwiSWRlbnRpZmllclwifHxHZS50eXBlPT09XCJUaGlzRXhwcmVzc2lvblwifXJldHVybiExfSl9ZnVuY3Rpb24geihPLG1lKXtyZXR1cm4gTz09PVwiK1wifHxPPT09XCItXCI/TyttZTptZX1mdW5jdGlvbiBVKE8sbWUpe2xldCBfZT1wKG1lKSxIZT1uKE8sZChtZSkpO3JldHVybiBIZSE9PSExJiZPLnNsaWNlKF9lLF9lKzIpPT09XCIvKlwiJiZPLnNsaWNlKEhlLEhlKzIpPT09XCIqL1wifWZ1bmN0aW9uIFooTyxtZSl7cmV0dXJuIE0obWUpP09lKG1lKTpNZShtZSxUZS5MZWFkaW5nLF9lPT5hKE8sZChfZSkpKX1mdW5jdGlvbiBzZShPLG1lKXtyZXR1cm4gbWUucGFyc2VyIT09XCJqc29uXCImJkMoTy5rZXkpJiZvZShPLmtleSkuc2xpY2UoMSwtMSk9PT1PLmtleS52YWx1ZSYmKHQoTy5rZXkudmFsdWUpJiYhKG1lLnBhcnNlcj09PVwiYmFiZWwtdHNcIiYmTy50eXBlPT09XCJDbGFzc1Byb3BlcnR5XCJ8fG1lLnBhcnNlcj09PVwidHlwZXNjcmlwdFwiJiZPLnR5cGU9PT1cIlByb3BlcnR5RGVmaW5pdGlvblwiKXx8RGUoTy5rZXkudmFsdWUpJiZTdHJpbmcoTnVtYmVyKE8ua2V5LnZhbHVlKSk9PT1PLmtleS52YWx1ZSYmKG1lLnBhcnNlcj09PVwiYmFiZWxcInx8bWUucGFyc2VyPT09XCJhY29yblwifHxtZS5wYXJzZXI9PT1cImVzcHJlZVwifHxtZS5wYXJzZXI9PT1cIm1lcml5YWhcInx8bWUucGFyc2VyPT09XCJfX2JhYmVsX2VzdHJlZVwiKSl9ZnVuY3Rpb24gRGUoTyl7cmV0dXJuL14oPzpcXGQrfFxcZCtcXC5cXGQrKSQvLnRlc3QoTyl9ZnVuY3Rpb24gZ2UoTyxtZSl7bGV0IF9lPS9eW2Z4XT8oPzpkZXNjcmliZXxpdHx0ZXN0KSQvO3JldHVybiBtZS50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiYmbWUucXVhc2k9PT1PJiZtZS50YWcudHlwZT09PVwiTWVtYmVyRXhwcmVzc2lvblwiJiZtZS50YWcucHJvcGVydHkudHlwZT09PVwiSWRlbnRpZmllclwiJiZtZS50YWcucHJvcGVydHkubmFtZT09PVwiZWFjaFwiJiYobWUudGFnLm9iamVjdC50eXBlPT09XCJJZGVudGlmaWVyXCImJl9lLnRlc3QobWUudGFnLm9iamVjdC5uYW1lKXx8bWUudGFnLm9iamVjdC50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCImJm1lLnRhZy5vYmplY3QucHJvcGVydHkudHlwZT09PVwiSWRlbnRpZmllclwiJiYobWUudGFnLm9iamVjdC5wcm9wZXJ0eS5uYW1lPT09XCJvbmx5XCJ8fG1lLnRhZy5vYmplY3QucHJvcGVydHkubmFtZT09PVwic2tpcFwiKSYmbWUudGFnLm9iamVjdC5vYmplY3QudHlwZT09PVwiSWRlbnRpZmllclwiJiZfZS50ZXN0KG1lLnRhZy5vYmplY3Qub2JqZWN0Lm5hbWUpKX1mdW5jdGlvbiBoZShPKXtyZXR1cm4gTy5xdWFzaXMuc29tZShtZT0+bWUudmFsdWUucmF3LmluY2x1ZGVzKGBcbmApKX1mdW5jdGlvbiB3ZShPLG1lKXtyZXR1cm4oTy50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiYmaGUoTyl8fE8udHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCImJmhlKE8ucXVhc2kpKSYmIWEobWUscChPKSx7YmFja3dhcmRzOiEwfSl9ZnVuY3Rpb24ga2UoTyl7aWYoIU1lKE8pKXJldHVybiExO2xldCBtZT1zKGFlKE8sVGUuRGFuZ2xpbmcpKTtyZXR1cm4gbWUmJiFnKG1lKX1mdW5jdGlvbiBSZShPKXtpZihPLmxlbmd0aDw9MSlyZXR1cm4hMTtsZXQgbWU9MDtmb3IobGV0IF9lIG9mIE8paWYoYihfZSkpe2lmKG1lKz0xLG1lPjEpcmV0dXJuITB9ZWxzZSBpZihkZShfZSkpe2ZvcihsZXQgSGUgb2YgX2UuYXJndW1lbnRzKWlmKGIoSGUpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIE5lKE8pe2xldCBtZT1PLmdldFZhbHVlKCksX2U9Ty5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIGRlKG1lKSYmZGUoX2UpJiZfZS5jYWxsZWU9PT1tZSYmbWUuYXJndW1lbnRzLmxlbmd0aD5fZS5hcmd1bWVudHMubGVuZ3RoJiZfZS5hcmd1bWVudHMubGVuZ3RoPjB9ZnVuY3Rpb24gUGUoTyxtZSl7aWYobWU+PTIpcmV0dXJuITE7bGV0IF9lPVFlPT5QZShRZSxtZSsxKSxIZT1PLnR5cGU9PT1cIkxpdGVyYWxcIiYmXCJyZWdleFwiaW4gTyYmTy5yZWdleC5wYXR0ZXJufHxPLnR5cGU9PT1cIlJlZ0V4cExpdGVyYWxcIiYmTy5wYXR0ZXJuO2lmKEhlJiZsKEhlKT41KXJldHVybiExO2lmKE8udHlwZT09PVwiTGl0ZXJhbFwifHxPLnR5cGU9PT1cIkJpZ0ludExpdGVyYWxcInx8Ty50eXBlPT09XCJEZWNpbWFsTGl0ZXJhbFwifHxPLnR5cGU9PT1cIkJvb2xlYW5MaXRlcmFsXCJ8fE8udHlwZT09PVwiTnVsbExpdGVyYWxcInx8Ty50eXBlPT09XCJOdW1lcmljTGl0ZXJhbFwifHxPLnR5cGU9PT1cIlJlZ0V4cExpdGVyYWxcInx8Ty50eXBlPT09XCJTdHJpbmdMaXRlcmFsXCJ8fE8udHlwZT09PVwiSWRlbnRpZmllclwifHxPLnR5cGU9PT1cIlRoaXNFeHByZXNzaW9uXCJ8fE8udHlwZT09PVwiU3VwZXJcInx8Ty50eXBlPT09XCJQcml2YXRlTmFtZVwifHxPLnR5cGU9PT1cIlByaXZhdGVJZGVudGlmaWVyXCJ8fE8udHlwZT09PVwiQXJndW1lbnRQbGFjZWhvbGRlclwifHxPLnR5cGU9PT1cIkltcG9ydFwiKXJldHVybiEwO2lmKE8udHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCIpcmV0dXJuIE8ucXVhc2lzLmV2ZXJ5KFFlPT4hUWUudmFsdWUucmF3LmluY2x1ZGVzKGBcbmApKSYmTy5leHByZXNzaW9ucy5ldmVyeShfZSk7aWYoTy50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCIpcmV0dXJuIE8ucHJvcGVydGllcy5ldmVyeShRZT0+IVFlLmNvbXB1dGVkJiYoUWUuc2hvcnRoYW5kfHxRZS52YWx1ZSYmX2UoUWUudmFsdWUpKSk7aWYoTy50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cIilyZXR1cm4gTy5lbGVtZW50cy5ldmVyeShRZT0+UWU9PT1udWxsfHxfZShRZSkpO2lmKHR0KE8pKXJldHVybihPLnR5cGU9PT1cIkltcG9ydEV4cHJlc3Npb25cInx8UGUoTy5jYWxsZWUsbWUpKSYmWWUoTykuZXZlcnkoX2UpO2lmKHVlKE8pKXJldHVybiBQZShPLm9iamVjdCxtZSkmJlBlKE8ucHJvcGVydHksbWUpO2xldCBHZT17XCIhXCI6ITAsXCItXCI6ITAsXCIrXCI6ITAsXCJ+XCI6ITB9O2lmKE8udHlwZT09PVwiVW5hcnlFeHByZXNzaW9uXCImJkdlW08ub3BlcmF0b3JdKXJldHVybiBQZShPLmFyZ3VtZW50LG1lKTtsZXQgaXQ9e1wiKytcIjohMCxcIi0tXCI6ITB9O3JldHVybiBPLnR5cGU9PT1cIlVwZGF0ZUV4cHJlc3Npb25cIiYmaXRbTy5vcGVyYXRvcl0/UGUoTy5hcmd1bWVudCxtZSk6Ty50eXBlPT09XCJUU05vbk51bGxFeHByZXNzaW9uXCI/UGUoTy5leHByZXNzaW9uLG1lKTohMX1mdW5jdGlvbiBvZShPKXt2YXIgbWUsX2U7cmV0dXJuKG1lPShfZT1PLmV4dHJhKT09PW51bGx8fF9lPT09dm9pZCAwP3ZvaWQgMDpfZS5yYXcpIT09bnVsbCYmbWUhPT12b2lkIDA/bWU6Ty5yYXd9ZnVuY3Rpb24gSChPKXtyZXR1cm4gT31mdW5jdGlvbiBjZShPKXtyZXR1cm4gTy5maWxlcGF0aCYmL1xcLnRzeCQvaS50ZXN0KE8uZmlsZXBhdGgpfWZ1bmN0aW9uIFgoTyl7bGV0IG1lPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXTpcImVzNVwiO3JldHVybiBPLnRyYWlsaW5nQ29tbWE9PT1cImVzNVwiJiZtZT09PVwiZXM1XCJ8fE8udHJhaWxpbmdDb21tYT09PVwiYWxsXCImJihtZT09PVwiYWxsXCJ8fG1lPT09XCJlczVcIil9ZnVuY3Rpb24gcGUoTyxtZSl7c3dpdGNoKE8udHlwZSl7Y2FzZVwiQmluYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6Y2FzZVwiQXNzaWdubWVudEV4cHJlc3Npb25cIjpjYXNlXCJOR1BpcGVFeHByZXNzaW9uXCI6cmV0dXJuIHBlKE8ubGVmdCxtZSk7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOnJldHVybiBwZShPLm9iamVjdCxtZSk7Y2FzZVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6cmV0dXJuIE8udGFnLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwiPyExOnBlKE8udGFnLG1lKTtjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gTy5jYWxsZWUudHlwZT09PVwiRnVuY3Rpb25FeHByZXNzaW9uXCI/ITE6cGUoTy5jYWxsZWUsbWUpO2Nhc2VcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOnJldHVybiBwZShPLnRlc3QsbWUpO2Nhc2VcIlVwZGF0ZUV4cHJlc3Npb25cIjpyZXR1cm4hTy5wcmVmaXgmJnBlKE8uYXJndW1lbnQsbWUpO2Nhc2VcIkJpbmRFeHByZXNzaW9uXCI6cmV0dXJuIE8ub2JqZWN0JiZwZShPLm9iamVjdCxtZSk7Y2FzZVwiU2VxdWVuY2VFeHByZXNzaW9uXCI6cmV0dXJuIHBlKE8uZXhwcmVzc2lvbnNbMF0sbWUpO2Nhc2VcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOmNhc2VcIlRTQXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNOb25OdWxsRXhwcmVzc2lvblwiOnJldHVybiBwZShPLmV4cHJlc3Npb24sbWUpO2RlZmF1bHQ6cmV0dXJuIG1lKE8pfX12YXIgQWU9e1wiPT1cIjohMCxcIiE9XCI6ITAsXCI9PT1cIjohMCxcIiE9PVwiOiEwfSxDZT17XCIqXCI6ITAsXCIvXCI6ITAsXCIlXCI6ITB9LGZlPXtcIj4+XCI6ITAsXCI+Pj5cIjohMCxcIjw8XCI6ITB9O2Z1bmN0aW9uIEEoTyxtZSl7cmV0dXJuIShyZShtZSkhPT1yZShPKXx8Tz09PVwiKipcInx8QWVbT10mJkFlW21lXXx8bWU9PT1cIiVcIiYmQ2VbT118fE89PT1cIiVcIiYmQ2VbbWVdfHxtZSE9PU8mJkNlW21lXSYmQ2VbT118fGZlW09dJiZmZVttZV0pfXZhciBHPW5ldyBNYXAoW1tcInw+XCJdLFtcIj8/XCJdLFtcInx8XCJdLFtcIiYmXCJdLFtcInxcIl0sW1wiXlwiXSxbXCImXCJdLFtcIj09XCIsXCI9PT1cIixcIiE9XCIsXCIhPT1cIl0sW1wiPFwiLFwiPlwiLFwiPD1cIixcIj49XCIsXCJpblwiLFwiaW5zdGFuY2VvZlwiXSxbXCI+PlwiLFwiPDxcIixcIj4+PlwiXSxbXCIrXCIsXCItXCJdLFtcIipcIixcIi9cIixcIiVcIl0sW1wiKipcIl1dLmZsYXRNYXAoKE8sbWUpPT5PLm1hcChfZT0+W19lLG1lXSkpKTtmdW5jdGlvbiByZShPKXtyZXR1cm4gRy5nZXQoTyl9ZnVuY3Rpb24geWUoTyl7cmV0dXJuIEJvb2xlYW4oZmVbT10pfHxPPT09XCJ8XCJ8fE89PT1cIl5cInx8Tz09PVwiJlwifWZ1bmN0aW9uIEVlKE8pe3ZhciBtZTtpZihPLnJlc3QpcmV0dXJuITA7bGV0IF9lPXZlKE8pO3JldHVybigobWU9cyhfZSkpPT09bnVsbHx8bWU9PT12b2lkIDA/dm9pZCAwOm1lLnR5cGUpPT09XCJSZXN0RWxlbWVudFwifXZhciBCZT1uZXcgV2Vha01hcDtmdW5jdGlvbiB2ZShPKXtpZihCZS5oYXMoTykpcmV0dXJuIEJlLmdldChPKTtsZXQgbWU9W107cmV0dXJuIE8udGhpcyYmbWUucHVzaChPLnRoaXMpLEFycmF5LmlzQXJyYXkoTy5wYXJhbWV0ZXJzKT9tZS5wdXNoKC4uLk8ucGFyYW1ldGVycyk6QXJyYXkuaXNBcnJheShPLnBhcmFtcykmJm1lLnB1c2goLi4uTy5wYXJhbXMpLE8ucmVzdCYmbWUucHVzaChPLnJlc3QpLEJlLnNldChPLG1lKSxtZX1mdW5jdGlvbiB6ZShPLG1lKXtsZXQgX2U9Ty5nZXRWYWx1ZSgpLEhlPTAsR2U9aXQ9Pm1lKGl0LEhlKyspO19lLnRoaXMmJk8uY2FsbChHZSxcInRoaXNcIiksQXJyYXkuaXNBcnJheShfZS5wYXJhbWV0ZXJzKT9PLmVhY2goR2UsXCJwYXJhbWV0ZXJzXCIpOkFycmF5LmlzQXJyYXkoX2UucGFyYW1zKSYmTy5lYWNoKEdlLFwicGFyYW1zXCIpLF9lLnJlc3QmJk8uY2FsbChHZSxcInJlc3RcIil9dmFyIGJlPW5ldyBXZWFrTWFwO2Z1bmN0aW9uIFllKE8pe2lmKGJlLmhhcyhPKSlyZXR1cm4gYmUuZ2V0KE8pO2xldCBtZT1PLmFyZ3VtZW50cztyZXR1cm4gTy50eXBlPT09XCJJbXBvcnRFeHByZXNzaW9uXCImJihtZT1bTy5zb3VyY2VdLE8uYXR0cmlidXRlcyYmbWUucHVzaChPLmF0dHJpYnV0ZXMpKSxiZS5zZXQoTyxtZSksbWV9ZnVuY3Rpb24gU2UoTyxtZSl7bGV0IF9lPU8uZ2V0VmFsdWUoKTtfZS50eXBlPT09XCJJbXBvcnRFeHByZXNzaW9uXCI/KE8uY2FsbChIZT0+bWUoSGUsMCksXCJzb3VyY2VcIiksX2UuYXR0cmlidXRlcyYmTy5jYWxsKEhlPT5tZShIZSwxKSxcImF0dHJpYnV0ZXNcIikpOk8uZWFjaChtZSxcImFyZ3VtZW50c1wiKX1mdW5jdGlvbiBJZShPKXtyZXR1cm4gTy52YWx1ZS50cmltKCk9PT1cInByZXR0aWVyLWlnbm9yZVwiJiYhTy51bmlnbm9yZX1mdW5jdGlvbiBPZShPKXtyZXR1cm4gTyYmKE8ucHJldHRpZXJJZ25vcmV8fE1lKE8sVGUuUHJldHRpZXJJZ25vcmUpKX1mdW5jdGlvbiBKZShPKXtsZXQgbWU9Ty5nZXRWYWx1ZSgpO3JldHVybiBPZShtZSl9dmFyIFRlPXtMZWFkaW5nOjE8PDEsVHJhaWxpbmc6MTw8MixEYW5nbGluZzoxPDwzLEJsb2NrOjE8PDQsTGluZToxPDw1LFByZXR0aWVySWdub3JlOjE8PDYsRmlyc3Q6MTw8NyxMYXN0OjE8PDh9LGplPShPLG1lKT0+e2lmKHR5cGVvZiBPPT1cImZ1bmN0aW9uXCImJihtZT1PLE89MCksT3x8bWUpcmV0dXJuKF9lLEhlLEdlKT0+IShPJlRlLkxlYWRpbmcmJiFfZS5sZWFkaW5nfHxPJlRlLlRyYWlsaW5nJiYhX2UudHJhaWxpbmd8fE8mVGUuRGFuZ2xpbmcmJihfZS5sZWFkaW5nfHxfZS50cmFpbGluZyl8fE8mVGUuQmxvY2smJiFnKF9lKXx8TyZUZS5MaW5lJiYhZihfZSl8fE8mVGUuRmlyc3QmJkhlIT09MHx8TyZUZS5MYXN0JiZIZSE9PUdlLmxlbmd0aC0xfHxPJlRlLlByZXR0aWVySWdub3JlJiYhSWUoX2UpfHxtZSYmIW1lKF9lKSl9O2Z1bmN0aW9uIE1lKE8sbWUsX2Upe2lmKCF1KE89PW51bGw/dm9pZCAwOk8uY29tbWVudHMpKXJldHVybiExO2xldCBIZT1qZShtZSxfZSk7cmV0dXJuIEhlP08uY29tbWVudHMuc29tZShIZSk6ITB9ZnVuY3Rpb24gYWUoTyxtZSxfZSl7aWYoIUFycmF5LmlzQXJyYXkoTz09bnVsbD92b2lkIDA6Ty5jb21tZW50cykpcmV0dXJuW107bGV0IEhlPWplKG1lLF9lKTtyZXR1cm4gSGU/Ty5jb21tZW50cy5maWx0ZXIoSGUpOk8uY29tbWVudHN9dmFyIG50PShPLG1lKT0+e2xldHtvcmlnaW5hbFRleHQ6X2V9PW1lO3JldHVybiBpKF9lLGQoTykpfTtmdW5jdGlvbiB0dChPKXtyZXR1cm4gZGUoTyl8fE8udHlwZT09PVwiTmV3RXhwcmVzc2lvblwifHxPLnR5cGU9PT1cIkltcG9ydEV4cHJlc3Npb25cIn1mdW5jdGlvbiBWZShPKXtyZXR1cm4gTyYmKE8udHlwZT09PVwiT2JqZWN0UHJvcGVydHlcInx8Ty50eXBlPT09XCJQcm9wZXJ0eVwiJiYhTy5tZXRob2QmJk8ua2luZD09PVwiaW5pdFwiKX1mdW5jdGlvbiBXZShPKXtyZXR1cm4gQm9vbGVhbihPLl9faXNVc2luZ0hhY2tQaXBlbGluZSl9dmFyIFhlPVN5bWJvbChcImlmV2l0aG91dEJsb2NrQW5kU2FtZUxpbmVDb21tZW50XCIpO2Z1bmN0aW9uIHN0KE8pe3JldHVybiBPLnR5cGU9PT1cIlRTQXNFeHByZXNzaW9uXCJ8fE8udHlwZT09PVwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCJ9ci5leHBvcnRzPXtnZXRGdW5jdGlvblBhcmFtZXRlcnM6dmUsaXRlcmF0ZUZ1bmN0aW9uUGFyYW1ldGVyc1BhdGg6emUsZ2V0Q2FsbEFyZ3VtZW50czpZZSxpdGVyYXRlQ2FsbEFyZ3VtZW50c1BhdGg6U2UsaGFzUmVzdFBhcmFtZXRlcjpFZSxnZXRMZWZ0U2lkZTpJLGdldExlZnRTaWRlUGF0aE5hbWU6UCxnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbjptLGdldFR5cGVTY3JpcHRNYXBwZWRUeXBlTW9kaWZpZXI6eixoYXNGbG93QW5ub3RhdGlvbkNvbW1lbnQ6RixoYXNGbG93U2hvcnRoYW5kQW5ub3RhdGlvbkNvbW1lbnQ6dyxoYXNMZWFkaW5nT3duTGluZUNvbW1lbnQ6WixoYXNOYWtlZExlZnRTaWRlOk4saGFzTm9kZTpTLGhhc0lnbm9yZUNvbW1lbnQ6SmUsaGFzTm9kZUlnbm9yZUNvbW1lbnQ6T2UsaWRlbnRpdHk6SCxpc0JpbmFyeWlzaDpWLGlzQ2FsbExpa2VFeHByZXNzaW9uOnR0LGlzRW5hYmxlZEhhY2tQaXBlbGluZTpXZSxpc0xpbmVDb21tZW50OmYsaXNQcmV0dGllcklnbm9yZUNvbW1lbnQ6SWUsaXNDYWxsRXhwcmVzc2lvbjpkZSxpc01lbWJlckV4cHJlc3Npb246dWUsaXNFeHBvcnREZWNsYXJhdGlvbjpULGlzRmxvd0Fubm90YXRpb25Db21tZW50OlUsaXNGdW5jdGlvbkNvbXBvc2l0aW9uQXJnczpSZSxpc0Z1bmN0aW9uTm90YXRpb246Sixpc0Z1bmN0aW9uT3JBcnJvd0V4cHJlc3Npb246Yixpc0dldHRlck9yU2V0dGVyOnEsaXNKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbDpnZSxpc0pzeE5vZGU6TSxpc0xpdGVyYWw6dixpc0xvbmdDdXJyaWVkQ2FsbEV4cHJlc3Npb246TmUsaXNTaW1wbGVDYWxsQXJndW1lbnQ6UGUsaXNNZW1iZXJpc2g6aixpc051bWVyaWNMaXRlcmFsOm8saXNTaWduZWROdW1lcmljTGl0ZXJhbDpoLGlzT2JqZWN0UHJvcGVydHk6VmUsaXNPYmplY3RUeXBlOngsaXNPYmplY3RUeXBlUHJvcGVydHlBRnVuY3Rpb246TCxpc1NpbXBsZVR5cGU6aWUsaXNTaW1wbGVOdW1iZXI6RGUsaXNTaW1wbGVUZW1wbGF0ZUxpdGVyYWw6RmUsaXNTdHJpbmdMaXRlcmFsOkMsaXNTdHJpbmdQcm9wU2FmZVRvVW5xdW90ZTpzZSxpc1RlbXBsYXRlT25JdHNPd25MaW5lOndlLGlzVGVzdENhbGw6Syxpc1RoZU9ubHlKc3hFbGVtZW50SW5NYXJrZG93bjpSLGlzVFNYRmlsZTpjZSxpc1R5cGVBbm5vdGF0aW9uQUZ1bmN0aW9uOlEsaXNOZXh0TGluZUVtcHR5Om50LG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudDprZSxyYXdUZXh0Om9lLHNob3VsZFByaW50Q29tbWE6WCxpc0JpdHdpc2VPcGVyYXRvcjp5ZSxzaG91bGRGbGF0dGVuOkEsc3RhcnRzV2l0aE5vTG9va2FoZWFkVG9rZW46cGUsZ2V0UHJlY2VkZW5jZTpyZSxoYXNDb21tZW50Ok1lLGdldENvbW1lbnRzOmFlLENvbW1lbnRDaGVja0ZsYWdzOlRlLG1hcmtlckZvcklmV2l0aG91dEJsb2NrQW5kU2FtZUxpbmVDb21tZW50OlhlLGlzVFNUeXBlRXhwcmVzc2lvbjpzdH19fSksanQ9dGUoe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L3RlbXBsYXRlLWxpdGVyYWwuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9bHQoKSx7Z2V0U3RyaW5nV2lkdGg6cyxnZXRJbmRlbnRTaXplOmF9PVVlKCkse2J1aWxkZXJzOntqb2luOm4saGFyZGxpbmU6dSxzb2Z0bGluZTppLGdyb3VwOmwsaW5kZW50OnAsYWxpZ246ZCxsaW5lU3VmZml4Qm91bmRhcnk6eSxhZGRBbGlnbm1lbnRUb0RvYzpnfSxwcmludGVyOntwcmludERvY1RvU3RyaW5nOmN9LHV0aWxzOnttYXBEb2M6RH19PXFlKCkse2lzQmluYXJ5aXNoOkUsaXNKZXN0RWFjaFRlbXBsYXRlTGl0ZXJhbDpfLGlzU2ltcGxlVGVtcGxhdGVMaXRlcmFsOncsaGFzQ29tbWVudDpGLGlzTWVtYmVyRXhwcmVzc2lvbjpTLGlzVFNUeXBlRXhwcmVzc2lvbjpOfT1LZSgpO2Z1bmN0aW9uIEkodixvLGgpe2xldCBDPXYuZ2V0VmFsdWUoKTtpZihDLnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwiJiZfKEMsdi5nZXRQYXJlbnROb2RlKCkpKXtsZXQgUj1QKHYsaCxvKTtpZihSKXJldHVybiBSfWxldCBiPVwiZXhwcmVzc2lvbnNcIjtDLnR5cGU9PT1cIlRTVGVtcGxhdGVMaXRlcmFsVHlwZVwiJiYoYj1cInR5cGVzXCIpO2xldCBCPVtdLGs9di5tYXAobyxiKSxNPXcoQyk7cmV0dXJuIE0mJihrPWsubWFwKFI9PmMoUixPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30saCkse30se3ByaW50V2lkdGg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfSkpLmZvcm1hdHRlZCkpLEIucHVzaCh5LFwiYFwiKSx2LmVhY2goUj0+e2xldCBxPVIuZ2V0TmFtZSgpO2lmKEIucHVzaChvKCkpLHE8ay5sZW5ndGgpe2xldHt0YWJXaWR0aDpKfT1oLEw9Ui5nZXRWYWx1ZSgpLFE9YShMLnZhbHVlLnJhdyxKKSxWPWtbcV07aWYoIU0pe2xldCBZPUNbYl1bcV07KEYoWSl8fFMoWSl8fFkudHlwZT09PVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCJ8fFkudHlwZT09PVwiU2VxdWVuY2VFeHByZXNzaW9uXCJ8fE4oWSl8fEUoWSkpJiYoVj1bcChbaSxWXSksaV0pfWxldCBqPVE9PT0wJiZMLnZhbHVlLnJhdy5lbmRzV2l0aChgXG5gKT9kKE51bWJlci5ORUdBVElWRV9JTkZJTklUWSxWKTpnKFYsUSxKKTtCLnB1c2gobChbXCIke1wiLGoseSxcIn1cIl0pKX19LFwicXVhc2lzXCIpLEIucHVzaChcImBcIiksQn1mdW5jdGlvbiBQKHYsbyxoKXtsZXQgQz12LmdldE5vZGUoKSx4PUMucXVhc2lzWzBdLnZhbHVlLnJhdy50cmltKCkuc3BsaXQoL1xccypcXHxcXHMqLyk7aWYoeC5sZW5ndGg+MXx8eC5zb21lKGI9PmIubGVuZ3RoPjApKXtvLl9faW5KZXN0RWFjaD0hMDtsZXQgYj12Lm1hcChoLFwiZXhwcmVzc2lvbnNcIik7by5fX2luSmVzdEVhY2g9ITE7bGV0IEI9W10saz1iLm1hcChMPT5cIiR7XCIrYyhMLE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxvKSx7fSx7cHJpbnRXaWR0aDpOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFksZW5kT2ZMaW5lOlwibGZcIn0pKS5mb3JtYXR0ZWQrXCJ9XCIpLE09W3toYXNMaW5lQnJlYWs6ITEsY2VsbHM6W119XTtmb3IobGV0IEw9MTtMPEMucXVhc2lzLmxlbmd0aDtMKyspe2xldCBRPXQoTSksVj1rW0wtMV07US5jZWxscy5wdXNoKFYpLFYuaW5jbHVkZXMoYFxuYCkmJihRLmhhc0xpbmVCcmVhaz0hMCksQy5xdWFzaXNbTF0udmFsdWUucmF3LmluY2x1ZGVzKGBcbmApJiZNLnB1c2goe2hhc0xpbmVCcmVhazohMSxjZWxsczpbXX0pfWxldCBSPU1hdGgubWF4KHgubGVuZ3RoLC4uLk0ubWFwKEw9PkwuY2VsbHMubGVuZ3RoKSkscT1BcnJheS5mcm9tKHtsZW5ndGg6Un0pLmZpbGwoMCksSj1be2NlbGxzOnh9LC4uLk0uZmlsdGVyKEw9PkwuY2VsbHMubGVuZ3RoPjApXTtmb3IobGV0e2NlbGxzOkx9b2YgSi5maWx0ZXIoUT0+IVEuaGFzTGluZUJyZWFrKSlmb3IobGV0W1EsVl1vZiBMLmVudHJpZXMoKSlxW1FdPU1hdGgubWF4KHFbUV0scyhWKSk7cmV0dXJuIEIucHVzaCh5LFwiYFwiLHAoW3Usbih1LEoubWFwKEw9Pm4oXCIgfCBcIixMLmNlbGxzLm1hcCgoUSxWKT0+TC5oYXNMaW5lQnJlYWs/UTpRK1wiIFwiLnJlcGVhdChxW1ZdLXMoUSkpKSkpKV0pLHUsXCJgXCIpLEJ9fWZ1bmN0aW9uICQodixvKXtsZXQgaD12LmdldFZhbHVlKCksQz1vKCk7cmV0dXJuIEYoaCkmJihDPWwoW3AoW2ksQ10pLGldKSksW1wiJHtcIixDLHksXCJ9XCJdfWZ1bmN0aW9uIGYodixvKXtyZXR1cm4gdi5tYXAoaD0+JChoLG8pLFwiZXhwcmVzc2lvbnNcIil9ZnVuY3Rpb24gVCh2LG8pe3JldHVybiBEKHYsaD0+dHlwZW9mIGg9PVwic3RyaW5nXCI/bz9oLnJlcGxhY2UoLyhcXFxcKilgL2csXCIkMSQxXFxcXGBcIik6bShoKTpoKX1mdW5jdGlvbiBtKHYpe3JldHVybiB2LnJlcGxhY2UoLyhbXFxcXGBdfFxcJHspL2csXCJcXFxcJDFcIil9ci5leHBvcnRzPXtwcmludFRlbXBsYXRlTGl0ZXJhbDpJLHByaW50VGVtcGxhdGVFeHByZXNzaW9uczpmLGVzY2FwZVRlbXBsYXRlQ2hhcmFjdGVyczpULHVuY29va1RlbXBsYXRlRWxlbWVudFZhbHVlOm19fX0pLFltPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9lbWJlZC9tYXJrZG93bi5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7YnVpbGRlcnM6e2luZGVudDp0LHNvZnRsaW5lOnMsbGl0ZXJhbGxpbmU6YSxkZWRlbnRUb1Jvb3Q6bn19PXFlKCkse2VzY2FwZVRlbXBsYXRlQ2hhcmFjdGVyczp1fT1qdCgpO2Z1bmN0aW9uIGkocCxkLHkpe2xldCBjPXAuZ2V0VmFsdWUoKS5xdWFzaXNbMF0udmFsdWUucmF3LnJlcGxhY2UoLygoPzpcXFxcXFxcXCkqKVxcXFxgL2csKHcsRik9PlwiXFxcXFwiLnJlcGVhdChGLmxlbmd0aC8yKStcImBcIiksRD1sKGMpLEU9RCE9PVwiXCI7RSYmKGM9Yy5yZXBsYWNlKG5ldyBSZWdFeHAoYF4ke0R9YCxcImdtXCIpLFwiXCIpKTtsZXQgXz11KHkoYyx7cGFyc2VyOlwibWFya2Rvd25cIixfX2luSnNUZW1wbGF0ZTohMH0se3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pLCEwKTtyZXR1cm5bXCJgXCIsRT90KFtzLF9dKTpbYSxuKF8pXSxzLFwiYFwiXX1mdW5jdGlvbiBsKHApe2xldCBkPXAubWF0Y2goL14oW15cXFNcXG5dKilcXFMvbSk7cmV0dXJuIGQ9PT1udWxsP1wiXCI6ZFsxXX1yLmV4cG9ydHM9aX19KSxRbT10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvZW1iZWQvY3NzLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3Zhcntpc05vbkVtcHR5QXJyYXk6dH09VWUoKSx7YnVpbGRlcnM6e2luZGVudDpzLGhhcmRsaW5lOmEsc29mdGxpbmU6bn0sdXRpbHM6e21hcERvYzp1LHJlcGxhY2VFbmRPZkxpbmU6aSxjbGVhbkRvYzpsfX09cWUoKSx7cHJpbnRUZW1wbGF0ZUV4cHJlc3Npb25zOnB9PWp0KCk7ZnVuY3Rpb24gZChjLEQsRSl7bGV0IF89Yy5nZXRWYWx1ZSgpLHc9Xy5xdWFzaXMubWFwKFA9PlAudmFsdWUucmF3KSxGPTAsUz13LnJlZHVjZSgoUCwkLGYpPT5mPT09MD8kOlArXCJAcHJldHRpZXItcGxhY2Vob2xkZXItXCIrRisrK1wiLWlkXCIrJCxcIlwiKSxOPUUoUyx7cGFyc2VyOlwic2Nzc1wifSx7c3RyaXBUcmFpbGluZ0hhcmRsaW5lOiEwfSksST1wKGMsRCk7cmV0dXJuIHkoTixfLEkpfWZ1bmN0aW9uIHkoYyxELEUpe2lmKEQucXVhc2lzLmxlbmd0aD09PTEmJiFELnF1YXNpc1swXS52YWx1ZS5yYXcudHJpbSgpKXJldHVyblwiYGBcIjtsZXQgdz1nKGMsRSk7aWYoIXcpdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgaW5zZXJ0IGFsbCB0aGUgZXhwcmVzc2lvbnNcIik7cmV0dXJuW1wiYFwiLHMoW2Esd10pLG4sXCJgXCJdfWZ1bmN0aW9uIGcoYyxEKXtpZighdChEKSlyZXR1cm4gYztsZXQgRT0wLF89dShsKGMpLHc9PnR5cGVvZiB3IT1cInN0cmluZ1wifHwhdy5pbmNsdWRlcyhcIkBwcmV0dGllci1wbGFjZWhvbGRlclwiKT93Oncuc3BsaXQoL0BwcmV0dGllci1wbGFjZWhvbGRlci0oXFxkKyktaWQvKS5tYXAoKEYsUyk9PlMlMj09PTA/aShGKTooRSsrLERbRl0pKSk7cmV0dXJuIEQubGVuZ3RoPT09RT9fOm51bGx9ci5leHBvcnRzPWR9fSksWm09dGUoe1wic3JjL2xhbmd1YWdlLWpzL2VtYmVkL2dyYXBocWwuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOntpbmRlbnQ6dCxqb2luOnMsaGFyZGxpbmU6YX19PXFlKCkse2VzY2FwZVRlbXBsYXRlQ2hhcmFjdGVyczpuLHByaW50VGVtcGxhdGVFeHByZXNzaW9uczp1fT1qdCgpO2Z1bmN0aW9uIGkocCxkLHkpe2xldCBnPXAuZ2V0VmFsdWUoKSxjPWcucXVhc2lzLmxlbmd0aDtpZihjPT09MSYmZy5xdWFzaXNbMF0udmFsdWUucmF3LnRyaW0oKT09PVwiXCIpcmV0dXJuXCJgYFwiO2xldCBEPXUocCxkKSxFPVtdO2ZvcihsZXQgXz0wO188YztfKyspe2xldCB3PWcucXVhc2lzW19dLEY9Xz09PTAsUz1fPT09Yy0xLE49dy52YWx1ZS5jb29rZWQsST1OLnNwbGl0KGBcbmApLFA9SS5sZW5ndGgsJD1EW19dLGY9UD4yJiZJWzBdLnRyaW0oKT09PVwiXCImJklbMV0udHJpbSgpPT09XCJcIixUPVA+MiYmSVtQLTFdLnRyaW0oKT09PVwiXCImJklbUC0yXS50cmltKCk9PT1cIlwiLG09SS5ldmVyeShvPT4vXlxccyooPzojW15cXG5cXHJdKik/JC8udGVzdChvKSk7aWYoIVMmJi8jW15cXG5cXHJdKiQvLnRlc3QoSVtQLTFdKSlyZXR1cm4gbnVsbDtsZXQgdj1udWxsO20/dj1sKEkpOnY9eShOLHtwYXJzZXI6XCJncmFwaHFsXCJ9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KSx2Pyh2PW4odiwhMSksIUYmJmYmJkUucHVzaChcIlwiKSxFLnB1c2godiksIVMmJlQmJkUucHVzaChcIlwiKSk6IUYmJiFTJiZmJiZFLnB1c2goXCJcIiksJCYmRS5wdXNoKCQpfXJldHVybltcImBcIix0KFthLHMoYSxFKV0pLGEsXCJgXCJdfWZ1bmN0aW9uIGwocCl7bGV0IGQ9W10seT0hMSxnPXAubWFwKGM9PmMudHJpbSgpKTtmb3IobGV0W2MsRF1vZiBnLmVudHJpZXMoKSlEIT09XCJcIiYmKGdbYy0xXT09PVwiXCImJnk/ZC5wdXNoKFthLERdKTpkLnB1c2goRCkseT0hMCk7cmV0dXJuIGQubGVuZ3RoPT09MD9udWxsOnMoYSxkKX1yLmV4cG9ydHM9aX19KSxlZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvZW1iZWQvaHRtbC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7YnVpbGRlcnM6e2luZGVudDp0LGxpbmU6cyxoYXJkbGluZTphLGdyb3VwOm59LHV0aWxzOnttYXBEb2M6dX19PXFlKCkse3ByaW50VGVtcGxhdGVFeHByZXNzaW9uczppLHVuY29va1RlbXBsYXRlRWxlbWVudFZhbHVlOmx9PWp0KCkscD0wO2Z1bmN0aW9uIGQoeSxnLGMsRCxFKXtsZXR7cGFyc2VyOl99PUUsdz15LmdldFZhbHVlKCksRj1wO3A9cCsxPj4+MDtsZXQgUz1oPT5gUFJFVFRJRVJfSFRNTF9QTEFDRUhPTERFUl8ke2h9XyR7Rn1fSU5fSlNgLE49dy5xdWFzaXMubWFwKChoLEMseCk9PkM9PT14Lmxlbmd0aC0xP2gudmFsdWUuY29va2VkOmgudmFsdWUuY29va2VkK1MoQykpLmpvaW4oXCJcIiksST1pKHksZyk7aWYoSS5sZW5ndGg9PT0wJiZOLnRyaW0oKS5sZW5ndGg9PT0wKXJldHVyblwiYGBcIjtsZXQgUD1uZXcgUmVnRXhwKFMoXCIoXFxcXGQrKVwiKSxcImdcIiksJD0wLGY9YyhOLHtwYXJzZXI6XyxfX29uSHRtbFJvb3QoaCl7JD1oLmNoaWxkcmVuLmxlbmd0aH19LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KSxUPXUoZixoPT57aWYodHlwZW9mIGghPVwic3RyaW5nXCIpcmV0dXJuIGg7bGV0IEM9W10seD1oLnNwbGl0KFApO2ZvcihsZXQgYj0wO2I8eC5sZW5ndGg7YisrKXtsZXQgQj14W2JdO2lmKGIlMj09PTApe0ImJihCPWwoQiksRC5fX2VtYmVkZGVkSW5IdG1sJiYoQj1CLnJlcGxhY2UoLzxcXC8oc2NyaXB0KVxcYi9naSxcIjxcXFxcLyQxXCIpKSxDLnB1c2goQikpO2NvbnRpbnVlfWxldCBrPU51bWJlcihCKTtDLnB1c2goSVtrXSl9cmV0dXJuIEN9KSxtPS9eXFxzLy50ZXN0KE4pP1wiIFwiOlwiXCIsdj0vXFxzJC8udGVzdChOKT9cIiBcIjpcIlwiLG89RC5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5PT09XCJpZ25vcmVcIj9hOm0mJnY/czpudWxsO3JldHVybiBuKG8/W1wiYFwiLHQoW28sbihUKV0pLG8sXCJgXCJdOltcImBcIixtLCQ+MT90KG4oVCkpOm4oVCksdixcImBcIl0pfXIuZXhwb3J0cz1kfX0pLHRkPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9lbWJlZC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7aGFzQ29tbWVudDp0LENvbW1lbnRDaGVja0ZsYWdzOnMsaXNPYmplY3RQcm9wZXJ0eTphfT1LZSgpLG49WW0oKSx1PVFtKCksaT1abSgpLGw9ZWQoKTtmdW5jdGlvbiBwKGYpe2lmKGcoZil8fF8oZil8fHcoZil8fGMoZikpcmV0dXJuXCJjc3NcIjtpZihOKGYpKXJldHVyblwiZ3JhcGhxbFwiO2lmKFAoZikpcmV0dXJuXCJodG1sXCI7aWYoRChmKSlyZXR1cm5cImFuZ3VsYXJcIjtpZih5KGYpKXJldHVyblwibWFya2Rvd25cIn1mdW5jdGlvbiBkKGYsVCxtLHYpe2xldCBvPWYuZ2V0VmFsdWUoKTtpZihvLnR5cGUhPT1cIlRlbXBsYXRlTGl0ZXJhbFwifHwkKG8pKXJldHVybjtsZXQgaD1wKGYpO2lmKGgpe2lmKGg9PT1cIm1hcmtkb3duXCIpcmV0dXJuIG4oZixULG0pO2lmKGg9PT1cImNzc1wiKXJldHVybiB1KGYsVCxtKTtpZihoPT09XCJncmFwaHFsXCIpcmV0dXJuIGkoZixULG0pO2lmKGg9PT1cImh0bWxcInx8aD09PVwiYW5ndWxhclwiKXJldHVybiBsKGYsVCxtLHYse3BhcnNlcjpofSl9fWZ1bmN0aW9uIHkoZil7bGV0IFQ9Zi5nZXRWYWx1ZSgpLG09Zi5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIG0mJm0udHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCImJlQucXVhc2lzLmxlbmd0aD09PTEmJm0udGFnLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmKG0udGFnLm5hbWU9PT1cIm1kXCJ8fG0udGFnLm5hbWU9PT1cIm1hcmtkb3duXCIpfWZ1bmN0aW9uIGcoZil7bGV0IFQ9Zi5nZXRWYWx1ZSgpLG09Zi5nZXRQYXJlbnROb2RlKCksdj1mLmdldFBhcmVudE5vZGUoMSk7cmV0dXJuIHYmJlQucXVhc2lzJiZtLnR5cGU9PT1cIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiYmdi50eXBlPT09XCJKU1hFbGVtZW50XCImJnYub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lPT09XCJzdHlsZVwiJiZ2Lm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMuc29tZShvPT5vLm5hbWUubmFtZT09PVwianN4XCIpfHxtJiZtLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiJiZtLnRhZy50eXBlPT09XCJJZGVudGlmaWVyXCImJm0udGFnLm5hbWU9PT1cImNzc1wifHxtJiZtLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiJiZtLnRhZy50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCImJm0udGFnLm9iamVjdC5uYW1lPT09XCJjc3NcIiYmKG0udGFnLnByb3BlcnR5Lm5hbWU9PT1cImdsb2JhbFwifHxtLnRhZy5wcm9wZXJ0eS5uYW1lPT09XCJyZXNvbHZlXCIpfWZ1bmN0aW9uIGMoZil7cmV0dXJuIGYubWF0Y2goVD0+VC50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiwoVCxtKT0+VC50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cIiYmbT09PVwiZWxlbWVudHNcIiwoVCxtKT0+YShUKSYmVC5rZXkudHlwZT09PVwiSWRlbnRpZmllclwiJiZULmtleS5uYW1lPT09XCJzdHlsZXNcIiYmbT09PVwidmFsdWVcIiwuLi5FKX1mdW5jdGlvbiBEKGYpe3JldHVybiBmLm1hdGNoKFQ9PlQudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCIsKFQsbSk9PmEoVCkmJlQua2V5LnR5cGU9PT1cIklkZW50aWZpZXJcIiYmVC5rZXkubmFtZT09PVwidGVtcGxhdGVcIiYmbT09PVwidmFsdWVcIiwuLi5FKX12YXIgRT1bKGYsVCk9PmYudHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwiJiZUPT09XCJwcm9wZXJ0aWVzXCIsKGYsVCk9PmYudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cIiYmZi5jYWxsZWUudHlwZT09PVwiSWRlbnRpZmllclwiJiZmLmNhbGxlZS5uYW1lPT09XCJDb21wb25lbnRcIiYmVD09PVwiYXJndW1lbnRzXCIsKGYsVCk9PmYudHlwZT09PVwiRGVjb3JhdG9yXCImJlQ9PT1cImV4cHJlc3Npb25cIl07ZnVuY3Rpb24gXyhmKXtsZXQgVD1mLmdldFBhcmVudE5vZGUoKTtpZighVHx8VC50eXBlIT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIilyZXR1cm4hMTtsZXQgbT1ULnRhZy50eXBlPT09XCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiP1QudGFnLmV4cHJlc3Npb246VC50YWc7c3dpdGNoKG0udHlwZSl7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOnJldHVybiBGKG0ub2JqZWN0KXx8UyhtKTtjYXNlXCJDYWxsRXhwcmVzc2lvblwiOnJldHVybiBGKG0uY2FsbGVlKXx8bS5jYWxsZWUudHlwZT09PVwiTWVtYmVyRXhwcmVzc2lvblwiJiYobS5jYWxsZWUub2JqZWN0LnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cIiYmKEYobS5jYWxsZWUub2JqZWN0Lm9iamVjdCl8fFMobS5jYWxsZWUub2JqZWN0KSl8fG0uY2FsbGVlLm9iamVjdC50eXBlPT09XCJDYWxsRXhwcmVzc2lvblwiJiZGKG0uY2FsbGVlLm9iamVjdC5jYWxsZWUpKTtjYXNlXCJJZGVudGlmaWVyXCI6cmV0dXJuIG0ubmFtZT09PVwiY3NzXCI7ZGVmYXVsdDpyZXR1cm4hMX19ZnVuY3Rpb24gdyhmKXtsZXQgVD1mLmdldFBhcmVudE5vZGUoKSxtPWYuZ2V0UGFyZW50Tm9kZSgxKTtyZXR1cm4gbSYmVC50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJm0udHlwZT09PVwiSlNYQXR0cmlidXRlXCImJm0ubmFtZS50eXBlPT09XCJKU1hJZGVudGlmaWVyXCImJm0ubmFtZS5uYW1lPT09XCJjc3NcIn1mdW5jdGlvbiBGKGYpe3JldHVybiBmLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmZi5uYW1lPT09XCJzdHlsZWRcIn1mdW5jdGlvbiBTKGYpe3JldHVybi9eW0EtWl0vLnRlc3QoZi5vYmplY3QubmFtZSkmJmYucHJvcGVydHkubmFtZT09PVwiZXh0ZW5kXCJ9ZnVuY3Rpb24gTihmKXtsZXQgVD1mLmdldFZhbHVlKCksbT1mLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gSShULFwiR3JhcGhRTFwiKXx8bSYmKG0udHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCImJihtLnRhZy50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCImJm0udGFnLm9iamVjdC5uYW1lPT09XCJncmFwaHFsXCImJm0udGFnLnByb3BlcnR5Lm5hbWU9PT1cImV4cGVyaW1lbnRhbFwifHxtLnRhZy50eXBlPT09XCJJZGVudGlmaWVyXCImJihtLnRhZy5uYW1lPT09XCJncWxcInx8bS50YWcubmFtZT09PVwiZ3JhcGhxbFwiKSl8fG0udHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cIiYmbS5jYWxsZWUudHlwZT09PVwiSWRlbnRpZmllclwiJiZtLmNhbGxlZS5uYW1lPT09XCJncmFwaHFsXCIpfWZ1bmN0aW9uIEkoZixUKXtyZXR1cm4gdChmLHMuQmxvY2t8cy5MZWFkaW5nLG09PntsZXR7dmFsdWU6dn09bTtyZXR1cm4gdj09PWAgJHtUfSBgfSl9ZnVuY3Rpb24gUChmKXtyZXR1cm4gSShmLmdldFZhbHVlKCksXCJIVE1MXCIpfHxmLm1hdGNoKFQ9PlQudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCIsKFQsbSk9PlQudHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCImJlQudGFnLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmVC50YWcubmFtZT09PVwiaHRtbFwiJiZtPT09XCJxdWFzaVwiKX1mdW5jdGlvbiAkKGYpe2xldHtxdWFzaXM6VH09ZjtyZXR1cm4gVC5zb21lKG09PntsZXR7dmFsdWU6e2Nvb2tlZDp2fX09bTtyZXR1cm4gdj09PW51bGx9KX1yLmV4cG9ydHM9ZH19KSxyZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvY2xlYW4uanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9T3QoKSxzPW5ldyBTZXQoW1wicmFuZ2VcIixcInJhd1wiLFwiY29tbWVudHNcIixcImxlYWRpbmdDb21tZW50c1wiLFwidHJhaWxpbmdDb21tZW50c1wiLFwiaW5uZXJDb21tZW50c1wiLFwiZXh0cmFcIixcInN0YXJ0XCIsXCJlbmRcIixcImxvY1wiLFwiZmxhZ3NcIixcImVycm9yc1wiLFwidG9rZW5zXCJdKSxhPXU9Pntmb3IobGV0IGkgb2YgdS5xdWFzaXMpZGVsZXRlIGkudmFsdWV9O2Z1bmN0aW9uIG4odSxpLGwpe2lmKHUudHlwZT09PVwiUHJvZ3JhbVwiJiZkZWxldGUgaS5zb3VyY2VUeXBlLCh1LnR5cGU9PT1cIkJpZ0ludExpdGVyYWxcInx8dS50eXBlPT09XCJCaWdJbnRMaXRlcmFsVHlwZUFubm90YXRpb25cIikmJmkudmFsdWUmJihpLnZhbHVlPWkudmFsdWUudG9Mb3dlckNhc2UoKSksKHUudHlwZT09PVwiQmlnSW50TGl0ZXJhbFwifHx1LnR5cGU9PT1cIkxpdGVyYWxcIikmJmkuYmlnaW50JiYoaS5iaWdpbnQ9aS5iaWdpbnQudG9Mb3dlckNhc2UoKSksdS50eXBlPT09XCJEZWNpbWFsTGl0ZXJhbFwiJiYoaS52YWx1ZT1OdW1iZXIoaS52YWx1ZSkpLHUudHlwZT09PVwiTGl0ZXJhbFwiJiZpLmRlY2ltYWwmJihpLmRlY2ltYWw9TnVtYmVyKGkuZGVjaW1hbCkpLHUudHlwZT09PVwiRW1wdHlTdGF0ZW1lbnRcInx8dS50eXBlPT09XCJKU1hUZXh0XCJ8fHUudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiJiYodS5leHByZXNzaW9uLnR5cGU9PT1cIkxpdGVyYWxcInx8dS5leHByZXNzaW9uLnR5cGU9PT1cIlN0cmluZ0xpdGVyYWxcIikmJnUuZXhwcmVzc2lvbi52YWx1ZT09PVwiIFwiKXJldHVybiBudWxsO2lmKCh1LnR5cGU9PT1cIlByb3BlcnR5XCJ8fHUudHlwZT09PVwiT2JqZWN0UHJvcGVydHlcInx8dS50eXBlPT09XCJNZXRob2REZWZpbml0aW9uXCJ8fHUudHlwZT09PVwiQ2xhc3NQcm9wZXJ0eVwifHx1LnR5cGU9PT1cIkNsYXNzTWV0aG9kXCJ8fHUudHlwZT09PVwiUHJvcGVydHlEZWZpbml0aW9uXCJ8fHUudHlwZT09PVwiVFNEZWNsYXJlTWV0aG9kXCJ8fHUudHlwZT09PVwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwifHx1LnR5cGU9PT1cIk9iamVjdFR5cGVQcm9wZXJ0eVwiKSYmdHlwZW9mIHUua2V5PT1cIm9iamVjdFwiJiZ1LmtleSYmKHUua2V5LnR5cGU9PT1cIkxpdGVyYWxcInx8dS5rZXkudHlwZT09PVwiTnVtZXJpY0xpdGVyYWxcInx8dS5rZXkudHlwZT09PVwiU3RyaW5nTGl0ZXJhbFwifHx1LmtleS50eXBlPT09XCJJZGVudGlmaWVyXCIpJiZkZWxldGUgaS5rZXksdS50eXBlPT09XCJKU1hFbGVtZW50XCImJnUub3BlbmluZ0VsZW1lbnQubmFtZS5uYW1lPT09XCJzdHlsZVwiJiZ1Lm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMuc29tZSh5PT55Lm5hbWUubmFtZT09PVwianN4XCIpKWZvcihsZXR7dHlwZTp5LGV4cHJlc3Npb246Z31vZiBpLmNoaWxkcmVuKXk9PT1cIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiYmZy50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiYmYShnKTt1LnR5cGU9PT1cIkpTWEF0dHJpYnV0ZVwiJiZ1Lm5hbWUubmFtZT09PVwiY3NzXCImJnUudmFsdWUudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiJiZ1LnZhbHVlLmV4cHJlc3Npb24udHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCImJmEoaS52YWx1ZS5leHByZXNzaW9uKSx1LnR5cGU9PT1cIkpTWEF0dHJpYnV0ZVwiJiZ1LnZhbHVlJiZ1LnZhbHVlLnR5cGU9PT1cIkxpdGVyYWxcIiYmL1tcIiddfCZxdW90O3wmYXBvczsvLnRlc3QodS52YWx1ZS52YWx1ZSkmJihpLnZhbHVlLnZhbHVlPWkudmFsdWUudmFsdWUucmVwbGFjZSgvW1wiJ118JnF1b3Q7fCZhcG9zOy9nLCdcIicpKTtsZXQgcD11LmV4cHJlc3Npb258fHUuY2FsbGVlO2lmKHUudHlwZT09PVwiRGVjb3JhdG9yXCImJnAudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cIiYmcC5jYWxsZWUubmFtZT09PVwiQ29tcG9uZW50XCImJnAuYXJndW1lbnRzLmxlbmd0aD09PTEpe2xldCB5PXUuZXhwcmVzc2lvbi5hcmd1bWVudHNbMF0ucHJvcGVydGllcztmb3IobGV0W2csY11vZiBpLmV4cHJlc3Npb24uYXJndW1lbnRzWzBdLnByb3BlcnRpZXMuZW50cmllcygpKXN3aXRjaCh5W2ddLmtleS5uYW1lKXtjYXNlXCJzdHlsZXNcIjpjLnZhbHVlLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiJiZhKGMudmFsdWUuZWxlbWVudHNbMF0pO2JyZWFrO2Nhc2VcInRlbXBsYXRlXCI6Yy52YWx1ZS50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIiYmYShjLnZhbHVlKTticmVha319aWYodS50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIiYmKHUudGFnLnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cInx8dS50YWcudHlwZT09PVwiSWRlbnRpZmllclwiJiYodS50YWcubmFtZT09PVwiZ3FsXCJ8fHUudGFnLm5hbWU9PT1cImdyYXBocWxcInx8dS50YWcubmFtZT09PVwiY3NzXCJ8fHUudGFnLm5hbWU9PT1cIm1kXCJ8fHUudGFnLm5hbWU9PT1cIm1hcmtkb3duXCJ8fHUudGFnLm5hbWU9PT1cImh0bWxcIil8fHUudGFnLnR5cGU9PT1cIkNhbGxFeHByZXNzaW9uXCIpJiZhKGkucXVhc2kpLHUudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCIpe3ZhciBkOygoKGQ9dS5sZWFkaW5nQ29tbWVudHMpPT09bnVsbHx8ZD09PXZvaWQgMD92b2lkIDA6ZC5zb21lKGc9PnQoZykmJltcIkdyYXBoUUxcIixcIkhUTUxcIl0uc29tZShjPT5nLnZhbHVlPT09YCAke2N9IGApKSl8fGwudHlwZT09PVwiQ2FsbEV4cHJlc3Npb25cIiYmbC5jYWxsZWUubmFtZT09PVwiZ3JhcGhxbFwifHwhdS5sZWFkaW5nQ29tbWVudHMpJiZhKGkpfWlmKHUudHlwZT09PVwiSW50ZXJwcmV0ZXJEaXJlY3RpdmVcIiYmKGkudmFsdWU9aS52YWx1ZS50cmltRW5kKCkpLCh1LnR5cGU9PT1cIlRTSW50ZXJzZWN0aW9uVHlwZVwifHx1LnR5cGU9PT1cIlRTVW5pb25UeXBlXCIpJiZ1LnR5cGVzLmxlbmd0aD09PTEpcmV0dXJuIGkudHlwZXNbMF19bi5pZ25vcmVkUHJvcGVydGllcz1zLHIuZXhwb3J0cz1ufX0pLGlvPXt9O0t0KGlvLHtFT0w6KCk9PlduLGFyY2g6KCk9Pm5kLGNwdXM6KCk9PkRvLGRlZmF1bHQ6KCk9PnZvLGVuZGlhbm5lc3M6KCk9PmFvLGZyZWVtZW06KCk9PnBvLGdldE5ldHdvcmtJbnRlcmZhY2VzOigpPT5obyxob3N0bmFtZTooKT0+b28sbG9hZGF2ZzooKT0+bG8sbmV0d29ya0ludGVyZmFjZXM6KCk9PnlvLHBsYXRmb3JtOigpPT51ZCxyZWxlYXNlOigpPT5nbyx0bXBEaXI6KCk9PiRuLHRtcGRpcjooKT0+Vm4sdG90YWxtZW06KCk9PmZvLHR5cGU6KCk9Pm1vLHVwdGltZTooKT0+Y299KTtmdW5jdGlvbiBhbygpe2lmKHR5cGVvZiBUcj5cInVcIil7dmFyIGU9bmV3IEFycmF5QnVmZmVyKDIpLHI9bmV3IFVpbnQ4QXJyYXkoZSksdD1uZXcgVWludDE2QXJyYXkoZSk7aWYoclswXT0xLHJbMV09Mix0WzBdPT09MjU4KVRyPVwiQkVcIjtlbHNlIGlmKHRbMF09PT01MTMpVHI9XCJMRVwiO2Vsc2UgdGhyb3cgbmV3IEVycm9yKFwidW5hYmxlIHRvIGZpZ3VyZSBvdXQgZW5kaWFuZXNzXCIpfXJldHVybiBUcn1mdW5jdGlvbiBvbygpe3JldHVybiB0eXBlb2YgZ2xvYmFsVGhpcy5sb2NhdGlvbjxcInVcIj9nbG9iYWxUaGlzLmxvY2F0aW9uLmhvc3RuYW1lOlwiXCJ9ZnVuY3Rpb24gbG8oKXtyZXR1cm5bXX1mdW5jdGlvbiBjbygpe3JldHVybiAwfWZ1bmN0aW9uIHBvKCl7cmV0dXJuIE51bWJlci5NQVhfVkFMVUV9ZnVuY3Rpb24gZm8oKXtyZXR1cm4gTnVtYmVyLk1BWF9WQUxVRX1mdW5jdGlvbiBEbygpe3JldHVybltdfWZ1bmN0aW9uIG1vKCl7cmV0dXJuXCJCcm93c2VyXCJ9ZnVuY3Rpb24gZ28oKXtyZXR1cm4gdHlwZW9mIGdsb2JhbFRoaXMubmF2aWdhdG9yPFwidVwiP2dsb2JhbFRoaXMubmF2aWdhdG9yLmFwcFZlcnNpb246XCJcIn1mdW5jdGlvbiB5bygpe31mdW5jdGlvbiBobygpe31mdW5jdGlvbiBuZCgpe3JldHVyblwiamF2YXNjcmlwdFwifWZ1bmN0aW9uIHVkKCl7cmV0dXJuXCJicm93c2VyXCJ9ZnVuY3Rpb24gJG4oKXtyZXR1cm5cIi90bXBcIn12YXIgVHIsVm4sV24sdm8sc2Q9aHQoe1wibm9kZS1tb2R1bGVzLXBvbHlmaWxsczpvc1wiKCl7bmUoKSxWbj0kbixXbj1gXG5gLHZvPXtFT0w6V24sdG1wZGlyOlZuLHRtcERpcjokbixuZXR3b3JrSW50ZXJmYWNlczp5byxnZXROZXR3b3JrSW50ZXJmYWNlczpobyxyZWxlYXNlOmdvLHR5cGU6bW8sY3B1czpEbyx0b3RhbG1lbTpmbyxmcmVlbWVtOnBvLHVwdGltZTpjbyxsb2FkYXZnOmxvLGhvc3RuYW1lOm9vLGVuZGlhbm5lc3M6YW99fX0pLGlkPXRlKHtcIm5vZGUtbW9kdWxlcy1wb2x5ZmlsbHMtY29tbW9uanM6b3NcIihlLHIpe25lKCk7dmFyIHQ9KHNkKCksZnQoaW8pKTtpZih0JiZ0LmRlZmF1bHQpe3IuZXhwb3J0cz10LmRlZmF1bHQ7Zm9yKGxldCBzIGluIHQpci5leHBvcnRzW3NdPXRbc119ZWxzZSB0JiYoci5leHBvcnRzPXQpfX0pLGFkPXRlKHtcIm5vZGVfbW9kdWxlcy9kZXRlY3QtbmV3bGluZS9pbmRleC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1zPT57aWYodHlwZW9mIHMhPVwic3RyaW5nXCIpdGhyb3cgbmV3IFR5cGVFcnJvcihcIkV4cGVjdGVkIGEgc3RyaW5nXCIpO2xldCBhPXMubWF0Y2goLyg/Olxccj9cXG4pL2cpfHxbXTtpZihhLmxlbmd0aD09PTApcmV0dXJuO2xldCBuPWEuZmlsdGVyKGk9Pmk9PT1gXFxyXG5gKS5sZW5ndGgsdT1hLmxlbmd0aC1uO3JldHVybiBuPnU/YFxcclxuYDpgXG5gfTtyLmV4cG9ydHM9dCxyLmV4cG9ydHMuZ3JhY2VmdWw9cz0+dHlwZW9mIHM9PVwic3RyaW5nXCImJnQocyl8fGBcbmB9fSksb2Q9dGUoe1wibm9kZV9tb2R1bGVzL2plc3QtZG9jYmxvY2svYnVpbGQvaW5kZXguanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuZXh0cmFjdD1jLGUucGFyc2U9RSxlLnBhcnNlV2l0aENvbW1lbnRzPV8sZS5wcmludD13LGUuc3RyaXA9RDtmdW5jdGlvbiByKCl7bGV0IFM9aWQoKTtyZXR1cm4gcj1mdW5jdGlvbigpe3JldHVybiBTfSxTfWZ1bmN0aW9uIHQoKXtsZXQgUz1zKGFkKCkpO3JldHVybiB0PWZ1bmN0aW9uKCl7cmV0dXJuIFN9LFN9ZnVuY3Rpb24gcyhTKXtyZXR1cm4gUyYmUy5fX2VzTW9kdWxlP1M6e2RlZmF1bHQ6U319dmFyIGE9L1xcKlxcLyQvLG49L15cXC9cXCpcXCo/Lyx1PS9eXFxzKihcXC9cXCpcXCo/KC58XFxyP1xcbikqP1xcKlxcLykvLGk9LyhefFxccyspXFwvXFwvKFteXFxyXFxuXSopL2csbD0vXihcXHI/XFxuKSsvLHA9Lyg/Ol58XFxyP1xcbikgKihAW15cXHJcXG5dKj8pICpcXHI/XFxuICooPyFbXkBcXHJcXG5dKlxcL1xcL1teXSopKFteQFxcclxcblxcc11bXkBcXHJcXG5dKz8pICpcXHI/XFxuL2csZD0vKD86XnxcXHI/XFxuKSAqQChcXFMrKSAqKFteXFxyXFxuXSopL2cseT0vKFxccj9cXG58XikgKlxcKiA/L2csZz1bXTtmdW5jdGlvbiBjKFMpe2xldCBOPVMubWF0Y2godSk7cmV0dXJuIE4/TlswXS50cmltTGVmdCgpOlwiXCJ9ZnVuY3Rpb24gRChTKXtsZXQgTj1TLm1hdGNoKHUpO3JldHVybiBOJiZOWzBdP1Muc3Vic3RyaW5nKE5bMF0ubGVuZ3RoKTpTfWZ1bmN0aW9uIEUoUyl7cmV0dXJuIF8oUykucHJhZ21hc31mdW5jdGlvbiBfKFMpe2xldCBOPSgwLHQoKS5kZWZhdWx0KShTKXx8cigpLkVPTDtTPVMucmVwbGFjZShuLFwiXCIpLnJlcGxhY2UoYSxcIlwiKS5yZXBsYWNlKHksXCIkMVwiKTtsZXQgST1cIlwiO2Zvcig7SSE9PVM7KUk9UyxTPVMucmVwbGFjZShwLGAke059JDEgJDIke059YCk7Uz1TLnJlcGxhY2UobCxcIlwiKS50cmltUmlnaHQoKTtsZXQgUD1PYmplY3QuY3JlYXRlKG51bGwpLCQ9Uy5yZXBsYWNlKGQsXCJcIikucmVwbGFjZShsLFwiXCIpLnRyaW1SaWdodCgpLGY7Zm9yKDtmPWQuZXhlYyhTKTspe2xldCBUPWZbMl0ucmVwbGFjZShpLFwiXCIpO3R5cGVvZiBQW2ZbMV1dPT1cInN0cmluZ1wifHxBcnJheS5pc0FycmF5KFBbZlsxXV0pP1BbZlsxXV09Zy5jb25jYXQoUFtmWzFdXSxUKTpQW2ZbMV1dPVR9cmV0dXJue2NvbW1lbnRzOiQscHJhZ21hczpQfX1mdW5jdGlvbiB3KFMpe2xldHtjb21tZW50czpOPVwiXCIscHJhZ21hczpJPXt9fT1TLFA9KDAsdCgpLmRlZmF1bHQpKE4pfHxyKCkuRU9MLCQ9XCIvKipcIixmPVwiICpcIixUPVwiICovXCIsbT1PYmplY3Qua2V5cyhJKSx2PW0ubWFwKGg9PkYoaCxJW2hdKSkucmVkdWNlKChoLEMpPT5oLmNvbmNhdChDKSxbXSkubWFwKGg9PmAke2Z9ICR7aH0ke1B9YCkuam9pbihcIlwiKTtpZighTil7aWYobS5sZW5ndGg9PT0wKXJldHVyblwiXCI7aWYobS5sZW5ndGg9PT0xJiYhQXJyYXkuaXNBcnJheShJW21bMF1dKSl7bGV0IGg9SVttWzBdXTtyZXR1cm5gJHskfSAke0YobVswXSxoKVswXX0ke1R9YH19bGV0IG89Ti5zcGxpdChQKS5tYXAoaD0+YCR7Zn0gJHtofWApLmpvaW4oUCkrUDtyZXR1cm4gJCtQKyhOP286XCJcIikrKE4mJm0ubGVuZ3RoP2YrUDpcIlwiKSt2K1R9ZnVuY3Rpb24gRihTLE4pe3JldHVybiBnLmNvbmNhdChOKS5tYXAoST0+YEAke1N9ICR7SX1gLnRyaW0oKSl9fX0pLGxkPXRlKHtcInNyYy9sYW5ndWFnZS1qcy91dGlscy9nZXQtc2hlYmFuZy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KHMpe2lmKCFzLnN0YXJ0c1dpdGgoXCIjIVwiKSlyZXR1cm5cIlwiO2xldCBhPXMuaW5kZXhPZihgXG5gKTtyZXR1cm4gYT09PS0xP3M6cy5zbGljZSgwLGEpfXIuZXhwb3J0cz10fX0pLENvPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmFnbWEuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3BhcnNlV2l0aENvbW1lbnRzOnQsc3RyaXA6cyxleHRyYWN0OmEscHJpbnQ6bn09b2QoKSx7bm9ybWFsaXplRW5kT2ZMaW5lOnV9PUpuKCksaT1sZCgpO2Z1bmN0aW9uIGwoeSl7bGV0IGc9aSh5KTtnJiYoeT15LnNsaWNlKGcubGVuZ3RoKzEpKTtsZXQgYz1hKHkpLHtwcmFnbWFzOkQsY29tbWVudHM6RX09dChjKTtyZXR1cm57c2hlYmFuZzpnLHRleHQ6eSxwcmFnbWFzOkQsY29tbWVudHM6RX19ZnVuY3Rpb24gcCh5KXtsZXQgZz1PYmplY3Qua2V5cyhsKHkpLnByYWdtYXMpO3JldHVybiBnLmluY2x1ZGVzKFwicHJldHRpZXJcIil8fGcuaW5jbHVkZXMoXCJmb3JtYXRcIil9ZnVuY3Rpb24gZCh5KXtsZXR7c2hlYmFuZzpnLHRleHQ6YyxwcmFnbWFzOkQsY29tbWVudHM6RX09bCh5KSxfPXMoYyksdz1uKHtwcmFnbWFzOk9iamVjdC5hc3NpZ24oe2Zvcm1hdDpcIlwifSxEKSxjb21tZW50czpFLnRyaW1TdGFydCgpfSk7cmV0dXJuKGc/YCR7Z31cbmA6XCJcIikrdSh3KSsoXy5zdGFydHNXaXRoKGBcbmApP2BcbmA6YFxuXG5gKStffXIuZXhwb3J0cz17aGFzUHJhZ21hOnAsaW5zZXJ0UHJhZ21hOmR9fX0pLEVvPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9jb21tZW50cy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7Z2V0TGFzdDp0LGhhc05ld2xpbmU6cyxnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVySW5kZXhXaXRoU3RhcnRJbmRleDphLGdldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXI6bixoYXNOZXdsaW5lSW5SYW5nZTp1LGFkZExlYWRpbmdDb21tZW50OmksYWRkVHJhaWxpbmdDb21tZW50OmwsYWRkRGFuZ2xpbmdDb21tZW50OnAsZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4OmQsaXNOb25FbXB0eUFycmF5Onl9PVVlKCkse2dldEZ1bmN0aW9uUGFyYW1ldGVyczpnLGlzUHJldHRpZXJJZ25vcmVDb21tZW50OmMsaXNKc3hOb2RlOkQsaGFzRmxvd1Nob3J0aGFuZEFubm90YXRpb25Db21tZW50OkUsaGFzRmxvd0Fubm90YXRpb25Db21tZW50Ol8saGFzSWdub3JlQ29tbWVudDp3LGlzQ2FsbExpa2VFeHByZXNzaW9uOkYsZ2V0Q2FsbEFyZ3VtZW50czpTLGlzQ2FsbEV4cHJlc3Npb246Tixpc01lbWJlckV4cHJlc3Npb246SSxpc09iamVjdFByb3BlcnR5OlAsaXNMaW5lQ29tbWVudDokLGdldENvbW1lbnRzOmYsQ29tbWVudENoZWNrRmxhZ3M6VCxtYXJrZXJGb3JJZldpdGhvdXRCbG9ja0FuZFNhbWVMaW5lQ29tbWVudDptfT1LZSgpLHtsb2NTdGFydDp2LGxvY0VuZDpvfT11dCgpLGg9T3QoKTtmdW5jdGlvbiBDKGZlKXtyZXR1cm5bb2UsdWUsTCxSLHEsSixZLGdlLFosRGUsaGUsd2UsZWUsRmUsel0uc29tZShBPT5BKGZlKSl9ZnVuY3Rpb24geChmZSl7cmV0dXJuW00sdWUsUSxoZSxSLHEsSixZLEZlLFUsc2UsRGUsTmUseixjZV0uc29tZShBPT5BKGZlKSl9ZnVuY3Rpb24gYihmZSl7cmV0dXJuW29lLFIscSxWLGRlLGVlLERlLEssVyxILHosUGVdLnNvbWUoQT0+QShmZSkpfWZ1bmN0aW9uIEIoZmUsQSl7bGV0IEc9KGZlLmJvZHl8fGZlLnByb3BlcnRpZXMpLmZpbmQocmU9PntsZXR7dHlwZTp5ZX09cmU7cmV0dXJuIHllIT09XCJFbXB0eVN0YXRlbWVudFwifSk7Rz9pKEcsQSk6cChmZSxBKX1mdW5jdGlvbiBrKGZlLEEpe2ZlLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCI/QihmZSxBKTppKGZlLEEpfWZ1bmN0aW9uIE0oZmUpe2xldHtjb21tZW50OkEsZm9sbG93aW5nTm9kZTpHfT1mZTtyZXR1cm4gRyYmQWUoQSk/KGkoRyxBKSwhMCk6ITF9ZnVuY3Rpb24gUihmZSl7bGV0e2NvbW1lbnQ6QSxwcmVjZWRpbmdOb2RlOkcsZW5jbG9zaW5nTm9kZTpyZSxmb2xsb3dpbmdOb2RlOnllLHRleHQ6RWV9PWZlO2lmKChyZT09bnVsbD92b2lkIDA6cmUudHlwZSkhPT1cIklmU3RhdGVtZW50XCJ8fCF5ZSlyZXR1cm4hMTtpZihuKEVlLEEsbyk9PT1cIilcIilyZXR1cm4gbChHLEEpLCEwO2lmKEc9PT1yZS5jb25zZXF1ZW50JiZ5ZT09PXJlLmFsdGVybmF0ZSl7aWYoRy50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiKWwoRyxBKTtlbHNle2xldCB2ZT1BLnR5cGU9PT1cIlNpbmdsZUxpbmVcInx8QS5sb2Muc3RhcnQubGluZT09PUEubG9jLmVuZC5saW5lLHplPUEubG9jLnN0YXJ0LmxpbmU9PT1HLmxvYy5zdGFydC5saW5lO3ZlJiZ6ZT9wKEcsQSxtKTpwKHJlLEEpfXJldHVybiEwfXJldHVybiB5ZS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiPyhCKHllLEEpLCEwKTp5ZS50eXBlPT09XCJJZlN0YXRlbWVudFwiPyhrKHllLmNvbnNlcXVlbnQsQSksITApOnJlLmNvbnNlcXVlbnQ9PT15ZT8oaSh5ZSxBKSwhMCk6ITF9ZnVuY3Rpb24gcShmZSl7bGV0e2NvbW1lbnQ6QSxwcmVjZWRpbmdOb2RlOkcsZW5jbG9zaW5nTm9kZTpyZSxmb2xsb3dpbmdOb2RlOnllLHRleHQ6RWV9PWZlO3JldHVybihyZT09bnVsbD92b2lkIDA6cmUudHlwZSkhPT1cIldoaWxlU3RhdGVtZW50XCJ8fCF5ZT8hMTpuKEVlLEEsbyk9PT1cIilcIj8obChHLEEpLCEwKTp5ZS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiPyhCKHllLEEpLCEwKTpyZS5ib2R5PT09eWU/KGkoeWUsQSksITApOiExfWZ1bmN0aW9uIEooZmUpe2xldHtjb21tZW50OkEscHJlY2VkaW5nTm9kZTpHLGVuY2xvc2luZ05vZGU6cmUsZm9sbG93aW5nTm9kZTp5ZX09ZmU7cmV0dXJuKHJlPT1udWxsP3ZvaWQgMDpyZS50eXBlKSE9PVwiVHJ5U3RhdGVtZW50XCImJihyZT09bnVsbD92b2lkIDA6cmUudHlwZSkhPT1cIkNhdGNoQ2xhdXNlXCJ8fCF5ZT8hMTpyZS50eXBlPT09XCJDYXRjaENsYXVzZVwiJiZHPyhsKEcsQSksITApOnllLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCI/KEIoeWUsQSksITApOnllLnR5cGU9PT1cIlRyeVN0YXRlbWVudFwiPyhrKHllLmZpbmFsaXplcixBKSwhMCk6eWUudHlwZT09PVwiQ2F0Y2hDbGF1c2VcIj8oayh5ZS5ib2R5LEEpLCEwKTohMX1mdW5jdGlvbiBMKGZlKXtsZXR7Y29tbWVudDpBLGVuY2xvc2luZ05vZGU6Ryxmb2xsb3dpbmdOb2RlOnJlfT1mZTtyZXR1cm4gSShHKSYmKHJlPT1udWxsP3ZvaWQgMDpyZS50eXBlKT09PVwiSWRlbnRpZmllclwiPyhpKEcsQSksITApOiExfWZ1bmN0aW9uIFEoZmUpe2xldHtjb21tZW50OkEscHJlY2VkaW5nTm9kZTpHLGVuY2xvc2luZ05vZGU6cmUsZm9sbG93aW5nTm9kZTp5ZSx0ZXh0OkVlfT1mZSxCZT1HJiYhdShFZSxvKEcpLHYoQSkpO3JldHVybighR3x8IUJlKSYmKChyZT09bnVsbD92b2lkIDA6cmUudHlwZSk9PT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwifHwocmU9PW51bGw/dm9pZCAwOnJlLnR5cGUpPT09XCJUU0NvbmRpdGlvbmFsVHlwZVwiKSYmeWU/KGkoeWUsQSksITApOiExfWZ1bmN0aW9uIFYoZmUpe2xldHtjb21tZW50OkEscHJlY2VkaW5nTm9kZTpHLGVuY2xvc2luZ05vZGU6cmV9PWZlO3JldHVybiBQKHJlKSYmcmUuc2hvcnRoYW5kJiZyZS5rZXk9PT1HJiZyZS52YWx1ZS50eXBlPT09XCJBc3NpZ25tZW50UGF0dGVyblwiPyhsKHJlLnZhbHVlLmxlZnQsQSksITApOiExfXZhciBqPW5ldyBTZXQoW1wiQ2xhc3NEZWNsYXJhdGlvblwiLFwiQ2xhc3NFeHByZXNzaW9uXCIsXCJEZWNsYXJlQ2xhc3NcIixcIkRlY2xhcmVJbnRlcmZhY2VcIixcIkludGVyZmFjZURlY2xhcmF0aW9uXCIsXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCJdKTtmdW5jdGlvbiBZKGZlKXtsZXR7Y29tbWVudDpBLHByZWNlZGluZ05vZGU6RyxlbmNsb3NpbmdOb2RlOnJlLGZvbGxvd2luZ05vZGU6eWV9PWZlO2lmKGouaGFzKHJlPT1udWxsP3ZvaWQgMDpyZS50eXBlKSl7aWYoeShyZS5kZWNvcmF0b3JzKSYmISh5ZSYmeWUudHlwZT09PVwiRGVjb3JhdG9yXCIpKXJldHVybiBsKHQocmUuZGVjb3JhdG9ycyksQSksITA7aWYocmUuYm9keSYmeWU9PT1yZS5ib2R5KXJldHVybiBCKHJlLmJvZHksQSksITA7aWYoeWUpe2lmKHJlLnN1cGVyQ2xhc3MmJnllPT09cmUuc3VwZXJDbGFzcyYmRyYmKEc9PT1yZS5pZHx8Rz09PXJlLnR5cGVQYXJhbWV0ZXJzKSlyZXR1cm4gbChHLEEpLCEwO2ZvcihsZXQgRWUgb2ZbXCJpbXBsZW1lbnRzXCIsXCJleHRlbmRzXCIsXCJtaXhpbnNcIl0paWYocmVbRWVdJiZ5ZT09PXJlW0VlXVswXSlyZXR1cm4gRyYmKEc9PT1yZS5pZHx8Rz09PXJlLnR5cGVQYXJhbWV0ZXJzfHxHPT09cmUuc3VwZXJDbGFzcyk/bChHLEEpOnAocmUsQSxFZSksITB9fXJldHVybiExfXZhciBpZT1uZXcgU2V0KFtcIkNsYXNzTWV0aG9kXCIsXCJDbGFzc1Byb3BlcnR5XCIsXCJQcm9wZXJ0eURlZmluaXRpb25cIixcIlRTQWJzdHJhY3RQcm9wZXJ0eURlZmluaXRpb25cIixcIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCIsXCJUU0RlY2xhcmVNZXRob2RcIixcIk1ldGhvZERlZmluaXRpb25cIixcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiLFwiQWNjZXNzb3JQcm9wZXJ0eVwiLFwiVFNBYnN0cmFjdEFjY2Vzc29yUHJvcGVydHlcIl0pO2Z1bmN0aW9uIGVlKGZlKXtsZXR7Y29tbWVudDpBLHByZWNlZGluZ05vZGU6RyxlbmNsb3NpbmdOb2RlOnJlLHRleHQ6eWV9PWZlO3JldHVybiByZSYmRyYmbih5ZSxBLG8pPT09XCIoXCImJihyZS50eXBlPT09XCJQcm9wZXJ0eVwifHxyZS50eXBlPT09XCJUU0RlY2xhcmVNZXRob2RcInx8cmUudHlwZT09PVwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cIikmJkcudHlwZT09PVwiSWRlbnRpZmllclwiJiZyZS5rZXk9PT1HJiZuKHllLEcsbykhPT1cIjpcInx8KEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIkRlY29yYXRvclwiJiZpZS5oYXMocmU9PW51bGw/dm9pZCAwOnJlLnR5cGUpPyhsKEcsQSksITApOiExfXZhciBsZT1uZXcgU2V0KFtcIkZ1bmN0aW9uRGVjbGFyYXRpb25cIixcIkZ1bmN0aW9uRXhwcmVzc2lvblwiLFwiQ2xhc3NNZXRob2RcIixcIk1ldGhvZERlZmluaXRpb25cIixcIk9iamVjdE1ldGhvZFwiXSk7ZnVuY3Rpb24gVyhmZSl7bGV0e2NvbW1lbnQ6QSxwcmVjZWRpbmdOb2RlOkcsZW5jbG9zaW5nTm9kZTpyZSx0ZXh0OnllfT1mZTtyZXR1cm4gbih5ZSxBLG8pIT09XCIoXCI/ITE6RyYmbGUuaGFzKHJlPT1udWxsP3ZvaWQgMDpyZS50eXBlKT8obChHLEEpLCEwKTohMX1mdW5jdGlvbiBLKGZlKXtsZXR7Y29tbWVudDpBLGVuY2xvc2luZ05vZGU6Ryx0ZXh0OnJlfT1mZTtpZigoRz09bnVsbD92b2lkIDA6Ry50eXBlKSE9PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIilyZXR1cm4hMTtsZXQgeWU9ZChyZSxBLG8pO3JldHVybiB5ZSE9PSExJiZyZS5zbGljZSh5ZSx5ZSsyKT09PVwiPT5cIj8ocChHLEEpLCEwKTohMX1mdW5jdGlvbiBkZShmZSl7bGV0e2NvbW1lbnQ6QSxlbmNsb3NpbmdOb2RlOkcsdGV4dDpyZX09ZmU7cmV0dXJuIG4ocmUsQSxvKSE9PVwiKVwiPyExOkcmJihYKEcpJiZnKEcpLmxlbmd0aD09PTB8fEYoRykmJlMoRykubGVuZ3RoPT09MCk/KHAoRyxBKSwhMCk6KChHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJNZXRob2REZWZpbml0aW9uXCJ8fChHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiKSYmZyhHLnZhbHVlKS5sZW5ndGg9PT0wPyhwKEcudmFsdWUsQSksITApOiExfWZ1bmN0aW9uIHVlKGZlKXtsZXR7Y29tbWVudDpBLHByZWNlZGluZ05vZGU6RyxlbmNsb3NpbmdOb2RlOnJlLGZvbGxvd2luZ05vZGU6eWUsdGV4dDpFZX09ZmU7aWYoKEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIkZ1bmN0aW9uVHlwZVBhcmFtXCImJihyZT09bnVsbD92b2lkIDA6cmUudHlwZSk9PT1cIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiYmKHllPT1udWxsP3ZvaWQgMDp5ZS50eXBlKSE9PVwiRnVuY3Rpb25UeXBlUGFyYW1cInx8KChHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJJZGVudGlmaWVyXCJ8fChHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJBc3NpZ25tZW50UGF0dGVyblwiKSYmcmUmJlgocmUpJiZuKEVlLEEsbyk9PT1cIilcIilyZXR1cm4gbChHLEEpLCEwO2lmKChyZT09bnVsbD92b2lkIDA6cmUudHlwZSk9PT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiYmKHllPT1udWxsP3ZvaWQgMDp5ZS50eXBlKT09PVwiQmxvY2tTdGF0ZW1lbnRcIil7bGV0IEJlPSgoKT0+e2xldCB2ZT1nKHJlKTtpZih2ZS5sZW5ndGg+MClyZXR1cm4gYShFZSxvKHQodmUpKSk7bGV0IHplPWEoRWUsbyhyZS5pZCkpO3JldHVybiB6ZSE9PSExJiZhKEVlLHplKzEpfSkoKTtpZih2KEEpPkJlKXJldHVybiBCKHllLEEpLCEwfXJldHVybiExfWZ1bmN0aW9uIEZlKGZlKXtsZXR7Y29tbWVudDpBLGVuY2xvc2luZ05vZGU6R309ZmU7cmV0dXJuKEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIkxhYmVsZWRTdGF0ZW1lbnRcIj8oaShHLEEpLCEwKTohMX1mdW5jdGlvbiB6KGZlKXtsZXR7Y29tbWVudDpBLGVuY2xvc2luZ05vZGU6R309ZmU7cmV0dXJuKChHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJDb250aW51ZVN0YXRlbWVudFwifHwoRz09bnVsbD92b2lkIDA6Ry50eXBlKT09PVwiQnJlYWtTdGF0ZW1lbnRcIikmJiFHLmxhYmVsPyhsKEcsQSksITApOiExfWZ1bmN0aW9uIFUoZmUpe2xldHtjb21tZW50OkEscHJlY2VkaW5nTm9kZTpHLGVuY2xvc2luZ05vZGU6cmV9PWZlO3JldHVybiBOKHJlKSYmRyYmcmUuY2FsbGVlPT09RyYmcmUuYXJndW1lbnRzLmxlbmd0aD4wPyhpKHJlLmFyZ3VtZW50c1swXSxBKSwhMCk6ITF9ZnVuY3Rpb24gWihmZSl7bGV0e2NvbW1lbnQ6QSxwcmVjZWRpbmdOb2RlOkcsZW5jbG9zaW5nTm9kZTpyZSxmb2xsb3dpbmdOb2RlOnllfT1mZTtyZXR1cm4ocmU9PW51bGw/dm9pZCAwOnJlLnR5cGUpPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fChyZT09bnVsbD92b2lkIDA6cmUudHlwZSk9PT1cIlRTVW5pb25UeXBlXCI/KGMoQSkmJih5ZS5wcmV0dGllcklnbm9yZT0hMCxBLnVuaWdub3JlPSEwKSxHPyhsKEcsQSksITApOiExKTooKCh5ZT09bnVsbD92b2lkIDA6eWUudHlwZSk9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8KHllPT1udWxsP3ZvaWQgMDp5ZS50eXBlKT09PVwiVFNVbmlvblR5cGVcIikmJmMoQSkmJih5ZS50eXBlc1swXS5wcmV0dGllcklnbm9yZT0hMCxBLnVuaWdub3JlPSEwKSwhMSl9ZnVuY3Rpb24gc2UoZmUpe2xldHtjb21tZW50OkEsZW5jbG9zaW5nTm9kZTpHfT1mZTtyZXR1cm4gUChHKT8oaShHLEEpLCEwKTohMX1mdW5jdGlvbiBEZShmZSl7bGV0e2NvbW1lbnQ6QSxlbmNsb3NpbmdOb2RlOkcsZm9sbG93aW5nTm9kZTpyZSxhc3Q6eWUsaXNMYXN0Q29tbWVudDpFZX09ZmU7cmV0dXJuIHllJiZ5ZS5ib2R5JiZ5ZS5ib2R5Lmxlbmd0aD09PTA/KEVlP3AoeWUsQSk6aSh5ZSxBKSwhMCk6KEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIlByb2dyYW1cIiYmKEc9PW51bGw/dm9pZCAwOkcuYm9keS5sZW5ndGgpPT09MCYmIXkoRy5kaXJlY3RpdmVzKT8oRWU/cChHLEEpOmkoRyxBKSwhMCk6KHJlPT1udWxsP3ZvaWQgMDpyZS50eXBlKT09PVwiUHJvZ3JhbVwiJiYocmU9PW51bGw/dm9pZCAwOnJlLmJvZHkubGVuZ3RoKT09PTAmJihHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJNb2R1bGVFeHByZXNzaW9uXCI/KHAocmUsQSksITApOiExfWZ1bmN0aW9uIGdlKGZlKXtsZXR7Y29tbWVudDpBLGVuY2xvc2luZ05vZGU6R309ZmU7cmV0dXJuKEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIkZvckluU3RhdGVtZW50XCJ8fChHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJGb3JPZlN0YXRlbWVudFwiPyhpKEcsQSksITApOiExfWZ1bmN0aW9uIGhlKGZlKXtsZXR7Y29tbWVudDpBLHByZWNlZGluZ05vZGU6RyxlbmNsb3NpbmdOb2RlOnJlLHRleHQ6eWV9PWZlO2lmKChyZT09bnVsbD92b2lkIDA6cmUudHlwZSk9PT1cIkltcG9ydFNwZWNpZmllclwifHwocmU9PW51bGw/dm9pZCAwOnJlLnR5cGUpPT09XCJFeHBvcnRTcGVjaWZpZXJcIilyZXR1cm4gaShyZSxBKSwhMDtsZXQgRWU9KEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIkltcG9ydFNwZWNpZmllclwiJiYocmU9PW51bGw/dm9pZCAwOnJlLnR5cGUpPT09XCJJbXBvcnREZWNsYXJhdGlvblwiLEJlPShHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJFeHBvcnRTcGVjaWZpZXJcIiYmKHJlPT1udWxsP3ZvaWQgMDpyZS50eXBlKT09PVwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiO3JldHVybihFZXx8QmUpJiZzKHllLG8oQSkpPyhsKEcsQSksITApOiExfWZ1bmN0aW9uIHdlKGZlKXtsZXR7Y29tbWVudDpBLGVuY2xvc2luZ05vZGU6R309ZmU7cmV0dXJuKEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIkFzc2lnbm1lbnRQYXR0ZXJuXCI/KGkoRyxBKSwhMCk6ITF9dmFyIGtlPW5ldyBTZXQoW1wiVmFyaWFibGVEZWNsYXJhdG9yXCIsXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiLFwiVHlwZUFsaWFzXCIsXCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCJdKSxSZT1uZXcgU2V0KFtcIk9iamVjdEV4cHJlc3Npb25cIixcIkFycmF5RXhwcmVzc2lvblwiLFwiVGVtcGxhdGVMaXRlcmFsXCIsXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIixcIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIsXCJUU1R5cGVMaXRlcmFsXCJdKTtmdW5jdGlvbiBOZShmZSl7bGV0e2NvbW1lbnQ6QSxlbmNsb3NpbmdOb2RlOkcsZm9sbG93aW5nTm9kZTpyZX09ZmU7cmV0dXJuIGtlLmhhcyhHPT1udWxsP3ZvaWQgMDpHLnR5cGUpJiZyZSYmKFJlLmhhcyhyZS50eXBlKXx8aChBKSk/KGkocmUsQSksITApOiExfWZ1bmN0aW9uIFBlKGZlKXtsZXR7Y29tbWVudDpBLGVuY2xvc2luZ05vZGU6Ryxmb2xsb3dpbmdOb2RlOnJlLHRleHQ6eWV9PWZlO3JldHVybiFyZSYmKChHPT1udWxsP3ZvaWQgMDpHLnR5cGUpPT09XCJUU01ldGhvZFNpZ25hdHVyZVwifHwoRz09bnVsbD92b2lkIDA6Ry50eXBlKT09PVwiVFNEZWNsYXJlRnVuY3Rpb25cInx8KEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIlRTQWJzdHJhY3RNZXRob2REZWZpbml0aW9uXCIpJiZuKHllLEEsbyk9PT1cIjtcIj8obChHLEEpLCEwKTohMX1mdW5jdGlvbiBvZShmZSl7bGV0e2NvbW1lbnQ6QSxlbmNsb3NpbmdOb2RlOkcsZm9sbG93aW5nTm9kZTpyZX09ZmU7aWYoYyhBKSYmKEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIlRTTWFwcGVkVHlwZVwiJiYocmU9PW51bGw/dm9pZCAwOnJlLnR5cGUpPT09XCJUU1R5cGVQYXJhbWV0ZXJcIiYmcmUuY29uc3RyYWludClyZXR1cm4gRy5wcmV0dGllcklnbm9yZT0hMCxBLnVuaWdub3JlPSEwLCEwfWZ1bmN0aW9uIEgoZmUpe2xldHtjb21tZW50OkEscHJlY2VkaW5nTm9kZTpHLGVuY2xvc2luZ05vZGU6cmUsZm9sbG93aW5nTm9kZTp5ZX09ZmU7cmV0dXJuKHJlPT1udWxsP3ZvaWQgMDpyZS50eXBlKSE9PVwiVFNNYXBwZWRUeXBlXCI/ITE6KHllPT1udWxsP3ZvaWQgMDp5ZS50eXBlKT09PVwiVFNUeXBlUGFyYW1ldGVyXCImJnllLm5hbWU/KGkoeWUubmFtZSxBKSwhMCk6KEc9PW51bGw/dm9pZCAwOkcudHlwZSk9PT1cIlRTVHlwZVBhcmFtZXRlclwiJiZHLmNvbnN0cmFpbnQ/KGwoRy5jb25zdHJhaW50LEEpLCEwKTohMX1mdW5jdGlvbiBjZShmZSl7bGV0e2NvbW1lbnQ6QSxlbmNsb3NpbmdOb2RlOkcsZm9sbG93aW5nTm9kZTpyZX09ZmU7cmV0dXJuIUd8fEcudHlwZSE9PVwiU3dpdGNoQ2FzZVwifHxHLnRlc3R8fCFyZXx8cmUhPT1HLmNvbnNlcXVlbnRbMF0/ITE6KHJlLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCImJiQoQSk/QihyZSxBKTpwKEcsQSksITApfWZ1bmN0aW9uIFgoZmUpe3JldHVybiBmZS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHxmZS50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8ZmUudHlwZT09PVwiRnVuY3Rpb25EZWNsYXJhdGlvblwifHxmZS50eXBlPT09XCJPYmplY3RNZXRob2RcInx8ZmUudHlwZT09PVwiQ2xhc3NNZXRob2RcInx8ZmUudHlwZT09PVwiVFNEZWNsYXJlRnVuY3Rpb25cInx8ZmUudHlwZT09PVwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cInx8ZmUudHlwZT09PVwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwifHxmZS50eXBlPT09XCJUU01ldGhvZFNpZ25hdHVyZVwifHxmZS50eXBlPT09XCJUU0NvbnN0cnVjdG9yVHlwZVwifHxmZS50eXBlPT09XCJUU0Z1bmN0aW9uVHlwZVwifHxmZS50eXBlPT09XCJUU0RlY2xhcmVNZXRob2RcIn1mdW5jdGlvbiBwZShmZSxBKXtpZigoQS5wYXJzZXI9PT1cInR5cGVzY3JpcHRcInx8QS5wYXJzZXI9PT1cImZsb3dcInx8QS5wYXJzZXI9PT1cImFjb3JuXCJ8fEEucGFyc2VyPT09XCJlc3ByZWVcInx8QS5wYXJzZXI9PT1cIm1lcml5YWhcInx8QS5wYXJzZXI9PT1cIl9fYmFiZWxfZXN0cmVlXCIpJiZmZS50eXBlPT09XCJNZXRob2REZWZpbml0aW9uXCImJmZlLnZhbHVlJiZmZS52YWx1ZS50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cIiYmZyhmZS52YWx1ZSkubGVuZ3RoPT09MCYmIWZlLnZhbHVlLnJldHVyblR5cGUmJiF5KGZlLnZhbHVlLnR5cGVQYXJhbWV0ZXJzKSYmZmUudmFsdWUuYm9keSlyZXR1cm5bLi4uZmUuZGVjb3JhdG9yc3x8W10sZmUua2V5LGZlLnZhbHVlLmJvZHldfWZ1bmN0aW9uIEFlKGZlKXtyZXR1cm4gaChmZSkmJmZlLnZhbHVlWzBdPT09XCIqXCImJi9AdHlwZVxcYi8udGVzdChmZS52YWx1ZSl9ZnVuY3Rpb24gQ2UoZmUpe2xldCBBPWZlLmdldFZhbHVlKCksRz1mZS5nZXRQYXJlbnROb2RlKCkscmU9eWU9Pl8oZih5ZSxULkxlYWRpbmcpKXx8XyhmKHllLFQuVHJhaWxpbmcpKTtyZXR1cm4oQSYmKEQoQSl8fEUoQSl8fE4oRykmJnJlKEEpKXx8RyYmKEcudHlwZT09PVwiSlNYU3ByZWFkQXR0cmlidXRlXCJ8fEcudHlwZT09PVwiSlNYU3ByZWFkQ2hpbGRcInx8Ry50eXBlPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fEcudHlwZT09PVwiVFNVbmlvblR5cGVcInx8KEcudHlwZT09PVwiQ2xhc3NEZWNsYXJhdGlvblwifHxHLnR5cGU9PT1cIkNsYXNzRXhwcmVzc2lvblwiKSYmRy5zdXBlckNsYXNzPT09QSkpJiYoIXcoZmUpfHxHLnR5cGU9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8Ry50eXBlPT09XCJUU1VuaW9uVHlwZVwiKX1yLmV4cG9ydHM9e2hhbmRsZU93bkxpbmVDb21tZW50OkMsaGFuZGxlRW5kT2ZMaW5lQ29tbWVudDp4LGhhbmRsZVJlbWFpbmluZ0NvbW1lbnQ6Yixpc1R5cGVDYXN0Q29tbWVudDpBZSxnZXRDb21tZW50Q2hpbGROb2RlczpwZSx3aWxsUHJpbnRPd25Db21tZW50czpDZX19fSkscXQ9dGUoe1wic3JjL2xhbmd1YWdlLWpzL25lZWRzLXBhcmVucy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1sdCgpLHM9S24oKSx7Z2V0RnVuY3Rpb25QYXJhbWV0ZXJzOmEsZ2V0TGVmdFNpZGVQYXRoTmFtZTpuLGhhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudDp1LGhhc05ha2VkTGVmdFNpZGU6aSxoYXNOb2RlOmwsaXNCaXR3aXNlT3BlcmF0b3I6cCxzdGFydHNXaXRoTm9Mb29rYWhlYWRUb2tlbjpkLHNob3VsZEZsYXR0ZW46eSxnZXRQcmVjZWRlbmNlOmcsaXNDYWxsRXhwcmVzc2lvbjpjLGlzTWVtYmVyRXhwcmVzc2lvbjpELGlzT2JqZWN0UHJvcGVydHk6RSxpc1RTVHlwZUV4cHJlc3Npb246X309S2UoKTtmdW5jdGlvbiB3KGYsVCl7bGV0IG09Zi5nZXRQYXJlbnROb2RlKCk7aWYoIW0pcmV0dXJuITE7bGV0IHY9Zi5nZXROYW1lKCksbz1mLmdldE5vZGUoKTtpZihULl9faXNJbkh0bWxJbnRlcnBvbGF0aW9uJiYhVC5icmFja2V0U3BhY2luZyYmSShvKSYmUChmKSlyZXR1cm4hMDtpZihGKG8pKXJldHVybiExO2lmKFQucGFyc2VyIT09XCJmbG93XCImJnUoZi5nZXRWYWx1ZSgpKSlyZXR1cm4hMDtpZihvLnR5cGU9PT1cIklkZW50aWZpZXJcIil7aWYoby5leHRyYSYmby5leHRyYS5wYXJlbnRoZXNpemVkJiYvXlBSRVRUSUVSX0hUTUxfUExBQ0VIT0xERVJfXFxkK19cXGQrX0lOX0pTJC8udGVzdChvLm5hbWUpfHx2PT09XCJsZWZ0XCImJihvLm5hbWU9PT1cImFzeW5jXCImJiFtLmF3YWl0fHxvLm5hbWU9PT1cImxldFwiKSYmbS50eXBlPT09XCJGb3JPZlN0YXRlbWVudFwiKXJldHVybiEwO2lmKG8ubmFtZT09PVwibGV0XCIpe3ZhciBoO2xldCB4PShoPWYuZmluZEFuY2VzdG9yKGI9PmIudHlwZT09PVwiRm9yT2ZTdGF0ZW1lbnRcIikpPT09bnVsbHx8aD09PXZvaWQgMD92b2lkIDA6aC5sZWZ0O2lmKHgmJmQoeCxiPT5iPT09bykpcmV0dXJuITB9aWYodj09PVwib2JqZWN0XCImJm8ubmFtZT09PVwibGV0XCImJm0udHlwZT09PVwiTWVtYmVyRXhwcmVzc2lvblwiJiZtLmNvbXB1dGVkJiYhbS5vcHRpb25hbCl7bGV0IHg9Zi5maW5kQW5jZXN0b3IoQj0+Qi50eXBlPT09XCJFeHByZXNzaW9uU3RhdGVtZW50XCJ8fEIudHlwZT09PVwiRm9yU3RhdGVtZW50XCJ8fEIudHlwZT09PVwiRm9ySW5TdGF0ZW1lbnRcIiksYj14P3gudHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiP3guZXhwcmVzc2lvbjp4LnR5cGU9PT1cIkZvclN0YXRlbWVudFwiP3guaW5pdDp4LmxlZnQ6dm9pZCAwO2lmKGImJmQoYixCPT5CPT09bykpcmV0dXJuITB9cmV0dXJuITF9aWYoby50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiRnVuY3Rpb25FeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiQ2xhc3NFeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiRG9FeHByZXNzaW9uXCIpe3ZhciBDO2xldCB4PShDPWYuZmluZEFuY2VzdG9yKGI9PmIudHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiKSk9PT1udWxsfHxDPT09dm9pZCAwP3ZvaWQgMDpDLmV4cHJlc3Npb247aWYoeCYmZCh4LGI9PmI9PT1vKSlyZXR1cm4hMH1zd2l0Y2gobS50eXBlKXtjYXNlXCJQYXJlbnRoZXNpemVkRXhwcmVzc2lvblwiOnJldHVybiExO2Nhc2VcIkNsYXNzRGVjbGFyYXRpb25cIjpjYXNlXCJDbGFzc0V4cHJlc3Npb25cIjp7aWYodj09PVwic3VwZXJDbGFzc1wiJiYoby50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHxvLnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiQXdhaXRFeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiQmluYXJ5RXhwcmVzc2lvblwifHxvLnR5cGU9PT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwifHxvLnR5cGU9PT1cIkxvZ2ljYWxFeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiTmV3RXhwcmVzc2lvblwifHxvLnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cInx8by50eXBlPT09XCJTZXF1ZW5jZUV4cHJlc3Npb25cInx8by50eXBlPT09XCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cInx8by50eXBlPT09XCJVbmFyeUV4cHJlc3Npb25cInx8by50eXBlPT09XCJVcGRhdGVFeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiWWllbGRFeHByZXNzaW9uXCJ8fG8udHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiKSlyZXR1cm4hMDticmVha31jYXNlXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpyZXR1cm4gJChmLFQpfHxvLnR5cGU9PT1cIlNlcXVlbmNlRXhwcmVzc2lvblwiO2Nhc2VcIkRlY29yYXRvclwiOntpZih2PT09XCJleHByZXNzaW9uXCIpe2xldCB4PSExLGI9ITEsQj1vO2Zvcig7Qjspc3dpdGNoKEIudHlwZSl7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOmI9ITAsQj1CLm9iamVjdDticmVhaztjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmlmKGJ8fHgpcmV0dXJuIFQucGFyc2VyIT09XCJ0eXBlc2NyaXB0XCI7eD0hMCxCPUIuY2FsbGVlO2JyZWFrO2Nhc2VcIklkZW50aWZpZXJcIjpyZXR1cm4hMTtjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpyZXR1cm4gVC5wYXJzZXIhPT1cInR5cGVzY3JpcHRcIjtkZWZhdWx0OnJldHVybiEwfXJldHVybiEwfWJyZWFrfWNhc2VcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6e2lmKHY9PT1cImJvZHlcIiYmby50eXBlIT09XCJTZXF1ZW5jZUV4cHJlc3Npb25cIiYmZChvLHg9PngudHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwiKSlyZXR1cm4hMDticmVha319c3dpdGNoKG8udHlwZSl7Y2FzZVwiVXBkYXRlRXhwcmVzc2lvblwiOmlmKG0udHlwZT09PVwiVW5hcnlFeHByZXNzaW9uXCIpcmV0dXJuIG8ucHJlZml4JiYoby5vcGVyYXRvcj09PVwiKytcIiYmbS5vcGVyYXRvcj09PVwiK1wifHxvLm9wZXJhdG9yPT09XCItLVwiJiZtLm9wZXJhdG9yPT09XCItXCIpO2Nhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOnN3aXRjaChtLnR5cGUpe2Nhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOnJldHVybiBvLm9wZXJhdG9yPT09bS5vcGVyYXRvciYmKG8ub3BlcmF0b3I9PT1cIitcInx8by5vcGVyYXRvcj09PVwiLVwiKTtjYXNlXCJCaW5kRXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIk1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpyZXR1cm4gdj09PVwib2JqZWN0XCI7Y2FzZVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6cmV0dXJuITA7Y2FzZVwiTmV3RXhwcmVzc2lvblwiOmNhc2VcIkNhbGxFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOnJldHVybiB2PT09XCJjYWxsZWVcIjtjYXNlXCJCaW5hcnlFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cImxlZnRcIiYmbS5vcGVyYXRvcj09PVwiKipcIjtjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX1jYXNlXCJCaW5hcnlFeHByZXNzaW9uXCI6e2lmKG0udHlwZT09PVwiVXBkYXRlRXhwcmVzc2lvblwifHxvLm9wZXJhdG9yPT09XCJpblwiJiZTKGYpKXJldHVybiEwO2lmKG8ub3BlcmF0b3I9PT1cInw+XCImJm8uZXh0cmEmJm8uZXh0cmEucGFyZW50aGVzaXplZCl7bGV0IHg9Zi5nZXRQYXJlbnROb2RlKDEpO2lmKHgudHlwZT09PVwiQmluYXJ5RXhwcmVzc2lvblwiJiZ4Lm9wZXJhdG9yPT09XCJ8PlwiKXJldHVybiEwfX1jYXNlXCJUU1R5cGVBc3NlcnRpb25cIjpjYXNlXCJUU0FzRXhwcmVzc2lvblwiOmNhc2VcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOmNhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6c3dpdGNoKG0udHlwZSl7Y2FzZVwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNBc0V4cHJlc3Npb25cIjpyZXR1cm4hXyhvKTtjYXNlXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpyZXR1cm4gXyhvKTtjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cImNhbGxlZVwiO2Nhc2VcIkNsYXNzRXhwcmVzc2lvblwiOmNhc2VcIkNsYXNzRGVjbGFyYXRpb25cIjpyZXR1cm4gdj09PVwic3VwZXJDbGFzc1wiO2Nhc2VcIlRTVHlwZUFzc2VydGlvblwiOmNhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOmNhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiOmNhc2VcIlNwcmVhZEVsZW1lbnRcIjpjYXNlXCJTcHJlYWRQcm9wZXJ0eVwiOmNhc2VcIkJpbmRFeHByZXNzaW9uXCI6Y2FzZVwiQXdhaXRFeHByZXNzaW9uXCI6Y2FzZVwiVFNOb25OdWxsRXhwcmVzc2lvblwiOmNhc2VcIlVwZGF0ZUV4cHJlc3Npb25cIjpyZXR1cm4hMDtjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cIm9iamVjdFwiO2Nhc2VcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI6Y2FzZVwiQXNzaWdubWVudFBhdHRlcm5cIjpyZXR1cm4gdj09PVwibGVmdFwiJiYoby50eXBlPT09XCJUU1R5cGVBc3NlcnRpb25cInx8XyhvKSk7Y2FzZVwiTG9naWNhbEV4cHJlc3Npb25cIjppZihvLnR5cGU9PT1cIkxvZ2ljYWxFeHByZXNzaW9uXCIpcmV0dXJuIG0ub3BlcmF0b3IhPT1vLm9wZXJhdG9yO2Nhc2VcIkJpbmFyeUV4cHJlc3Npb25cIjp7bGV0e29wZXJhdG9yOngsdHlwZTpifT1vO2lmKCF4JiZiIT09XCJUU1R5cGVBc3NlcnRpb25cIilyZXR1cm4hMDtsZXQgQj1nKHgpLGs9bS5vcGVyYXRvcixNPWcoayk7cmV0dXJuIE0+Qnx8dj09PVwicmlnaHRcIiYmTT09PUJ8fE09PT1CJiYheShrLHgpPyEwOk08QiYmeD09PVwiJVwiP2s9PT1cIitcInx8az09PVwiLVwiOiEhcChrKX1kZWZhdWx0OnJldHVybiExfWNhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOnN3aXRjaChtLnR5cGUpe2Nhc2VcIlJldHVyblN0YXRlbWVudFwiOnJldHVybiExO2Nhc2VcIkZvclN0YXRlbWVudFwiOnJldHVybiExO2Nhc2VcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIjpyZXR1cm4gdiE9PVwiZXhwcmVzc2lvblwiO2Nhc2VcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6cmV0dXJuIHYhPT1cImJvZHlcIjtkZWZhdWx0OnJldHVybiEwfWNhc2VcIllpZWxkRXhwcmVzc2lvblwiOmlmKG0udHlwZT09PVwiVW5hcnlFeHByZXNzaW9uXCJ8fG0udHlwZT09PVwiQXdhaXRFeHByZXNzaW9uXCJ8fF8obSl8fG0udHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiKXJldHVybiEwO2Nhc2VcIkF3YWl0RXhwcmVzc2lvblwiOnN3aXRjaChtLnR5cGUpe2Nhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOmNhc2VcIlVuYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6Y2FzZVwiU3ByZWFkRWxlbWVudFwiOmNhc2VcIlNwcmVhZFByb3BlcnR5XCI6Y2FzZVwiVFNBc0V4cHJlc3Npb25cIjpjYXNlXCJUU1NhdGlzZmllc0V4cHJlc3Npb25cIjpjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6Y2FzZVwiQmluZEV4cHJlc3Npb25cIjpyZXR1cm4hMDtjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cIm9iamVjdFwiO2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gdj09PVwiY2FsbGVlXCI7Y2FzZVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cInRlc3RcIjtjYXNlXCJCaW5hcnlFeHByZXNzaW9uXCI6cmV0dXJuISghby5hcmd1bWVudCYmbS5vcGVyYXRvcj09PVwifD5cIik7ZGVmYXVsdDpyZXR1cm4hMX1jYXNlXCJUU0NvbmRpdGlvbmFsVHlwZVwiOmlmKHY9PT1cImV4dGVuZHNUeXBlXCImJm0udHlwZT09PVwiVFNDb25kaXRpb25hbFR5cGVcIilyZXR1cm4hMDtjYXNlXCJUU0Z1bmN0aW9uVHlwZVwiOmNhc2VcIlRTQ29uc3RydWN0b3JUeXBlXCI6aWYodj09PVwiZXh0ZW5kc1R5cGVcIiYmbS50eXBlPT09XCJUU0NvbmRpdGlvbmFsVHlwZVwiKXtsZXQgeD0oby5yZXR1cm5UeXBlfHxvLnR5cGVBbm5vdGF0aW9uKS50eXBlQW5ub3RhdGlvbjtpZih4LnR5cGU9PT1cIlRTSW5mZXJUeXBlXCImJngudHlwZVBhcmFtZXRlci5jb25zdHJhaW50KXJldHVybiEwfWlmKHY9PT1cImNoZWNrVHlwZVwiJiZtLnR5cGU9PT1cIlRTQ29uZGl0aW9uYWxUeXBlXCIpcmV0dXJuITA7Y2FzZVwiVFNVbmlvblR5cGVcIjpjYXNlXCJUU0ludGVyc2VjdGlvblR5cGVcIjppZigobS50eXBlPT09XCJUU1VuaW9uVHlwZVwifHxtLnR5cGU9PT1cIlRTSW50ZXJzZWN0aW9uVHlwZVwiKSYmbS50eXBlcy5sZW5ndGg+MSYmKCFvLnR5cGVzfHxvLnR5cGVzLmxlbmd0aD4xKSlyZXR1cm4hMDtjYXNlXCJUU0luZmVyVHlwZVwiOmlmKG8udHlwZT09PVwiVFNJbmZlclR5cGVcIiYmbS50eXBlPT09XCJUU1Jlc3RUeXBlXCIpcmV0dXJuITE7Y2FzZVwiVFNUeXBlT3BlcmF0b3JcIjpyZXR1cm4gbS50eXBlPT09XCJUU0FycmF5VHlwZVwifHxtLnR5cGU9PT1cIlRTT3B0aW9uYWxUeXBlXCJ8fG0udHlwZT09PVwiVFNSZXN0VHlwZVwifHx2PT09XCJvYmplY3RUeXBlXCImJm0udHlwZT09PVwiVFNJbmRleGVkQWNjZXNzVHlwZVwifHxtLnR5cGU9PT1cIlRTVHlwZU9wZXJhdG9yXCJ8fG0udHlwZT09PVwiVFNUeXBlQW5ub3RhdGlvblwiJiZmLmdldFBhcmVudE5vZGUoMSkudHlwZS5zdGFydHNXaXRoKFwiVFNKU0RvY1wiKTtjYXNlXCJUU1R5cGVRdWVyeVwiOnJldHVybiB2PT09XCJvYmplY3RUeXBlXCImJm0udHlwZT09PVwiVFNJbmRleGVkQWNjZXNzVHlwZVwifHx2PT09XCJlbGVtZW50VHlwZVwiJiZtLnR5cGU9PT1cIlRTQXJyYXlUeXBlXCI7Y2FzZVwiQXJyYXlUeXBlQW5ub3RhdGlvblwiOnJldHVybiBtLnR5cGU9PT1cIk51bGxhYmxlVHlwZUFubm90YXRpb25cIjtjYXNlXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiOmNhc2VcIlVuaW9uVHlwZUFubm90YXRpb25cIjpyZXR1cm4gbS50eXBlPT09XCJBcnJheVR5cGVBbm5vdGF0aW9uXCJ8fG0udHlwZT09PVwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwifHxtLnR5cGU9PT1cIkludGVyc2VjdGlvblR5cGVBbm5vdGF0aW9uXCJ8fG0udHlwZT09PVwiVW5pb25UeXBlQW5ub3RhdGlvblwifHx2PT09XCJvYmplY3RUeXBlXCImJihtLnR5cGU9PT1cIkluZGV4ZWRBY2Nlc3NUeXBlXCJ8fG0udHlwZT09PVwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiKTtjYXNlXCJOdWxsYWJsZVR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIG0udHlwZT09PVwiQXJyYXlUeXBlQW5ub3RhdGlvblwifHx2PT09XCJvYmplY3RUeXBlXCImJihtLnR5cGU9PT1cIkluZGV4ZWRBY2Nlc3NUeXBlXCJ8fG0udHlwZT09PVwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiKTtjYXNlXCJGdW5jdGlvblR5cGVBbm5vdGF0aW9uXCI6e2xldCB4PW0udHlwZT09PVwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwiP2YuZ2V0UGFyZW50Tm9kZSgxKTptO3JldHVybiB4LnR5cGU9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8eC50eXBlPT09XCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwifHx4LnR5cGU9PT1cIkFycmF5VHlwZUFubm90YXRpb25cInx8dj09PVwib2JqZWN0VHlwZVwiJiYoeC50eXBlPT09XCJJbmRleGVkQWNjZXNzVHlwZVwifHx4LnR5cGU9PT1cIk9wdGlvbmFsSW5kZXhlZEFjY2Vzc1R5cGVcIil8fHgudHlwZT09PVwiTnVsbGFibGVUeXBlQW5ub3RhdGlvblwifHxtLnR5cGU9PT1cIkZ1bmN0aW9uVHlwZVBhcmFtXCImJm0ubmFtZT09PW51bGwmJmEobykuc29tZShiPT5iLnR5cGVBbm5vdGF0aW9uJiZiLnR5cGVBbm5vdGF0aW9uLnR5cGU9PT1cIk51bGxhYmxlVHlwZUFubm90YXRpb25cIil9Y2FzZVwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiOnJldHVybiB2PT09XCJvYmplY3RUeXBlXCImJm0udHlwZT09PVwiSW5kZXhlZEFjY2Vzc1R5cGVcIjtjYXNlXCJUeXBlb2ZUeXBlQW5ub3RhdGlvblwiOnJldHVybiB2PT09XCJvYmplY3RUeXBlXCImJihtLnR5cGU9PT1cIkluZGV4ZWRBY2Nlc3NUeXBlXCJ8fG0udHlwZT09PVwiT3B0aW9uYWxJbmRleGVkQWNjZXNzVHlwZVwiKTtjYXNlXCJTdHJpbmdMaXRlcmFsXCI6Y2FzZVwiTnVtZXJpY0xpdGVyYWxcIjpjYXNlXCJMaXRlcmFsXCI6aWYodHlwZW9mIG8udmFsdWU9PVwic3RyaW5nXCImJm0udHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiJiYhbS5kaXJlY3RpdmUpe2xldCB4PWYuZ2V0UGFyZW50Tm9kZSgxKTtyZXR1cm4geC50eXBlPT09XCJQcm9ncmFtXCJ8fHgudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIn1yZXR1cm4gdj09PVwib2JqZWN0XCImJm0udHlwZT09PVwiTWVtYmVyRXhwcmVzc2lvblwiJiZ0eXBlb2Ygby52YWx1ZT09XCJudW1iZXJcIjtjYXNlXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOntsZXQgeD1mLmdldFBhcmVudE5vZGUoMSk7cmV0dXJuIHY9PT1cImJvZHlcIiYmbS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiPyEwOnY9PT1cImtleVwiJiYobS50eXBlPT09XCJDbGFzc1Byb3BlcnR5XCJ8fG0udHlwZT09PVwiUHJvcGVydHlEZWZpbml0aW9uXCIpJiZtLmNvbXB1dGVkfHwodj09PVwiaW5pdFwifHx2PT09XCJ1cGRhdGVcIikmJm0udHlwZT09PVwiRm9yU3RhdGVtZW50XCI/ITE6bS50eXBlPT09XCJFeHByZXNzaW9uU3RhdGVtZW50XCI/by5sZWZ0LnR5cGU9PT1cIk9iamVjdFBhdHRlcm5cIjohKHY9PT1cImtleVwiJiZtLnR5cGU9PT1cIlRTUHJvcGVydHlTaWduYXR1cmVcInx8bS50eXBlPT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwifHxtLnR5cGU9PT1cIlNlcXVlbmNlRXhwcmVzc2lvblwiJiZ4JiZ4LnR5cGU9PT1cIkZvclN0YXRlbWVudFwiJiYoeC5pbml0PT09bXx8eC51cGRhdGU9PT1tKXx8dj09PVwidmFsdWVcIiYmbS50eXBlPT09XCJQcm9wZXJ0eVwiJiZ4JiZ4LnR5cGU9PT1cIk9iamVjdFBhdHRlcm5cIiYmeC5wcm9wZXJ0aWVzLmluY2x1ZGVzKG0pfHxtLnR5cGU9PT1cIk5HQ2hhaW5lZEV4cHJlc3Npb25cIil9Y2FzZVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6c3dpdGNoKG0udHlwZSl7Y2FzZVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6Y2FzZVwiVW5hcnlFeHByZXNzaW9uXCI6Y2FzZVwiU3ByZWFkRWxlbWVudFwiOmNhc2VcIlNwcmVhZFByb3BlcnR5XCI6Y2FzZVwiQmluYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6Y2FzZVwiTkdQaXBlRXhwcmVzc2lvblwiOmNhc2VcIkV4cG9ydERlZmF1bHREZWNsYXJhdGlvblwiOmNhc2VcIkF3YWl0RXhwcmVzc2lvblwiOmNhc2VcIkpTWFNwcmVhZEF0dHJpYnV0ZVwiOmNhc2VcIlRTVHlwZUFzc2VydGlvblwiOmNhc2VcIlR5cGVDYXN0RXhwcmVzc2lvblwiOmNhc2VcIlRTQXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNOb25OdWxsRXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpyZXR1cm4gdj09PVwiY2FsbGVlXCI7Y2FzZVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cInRlc3RcIjtjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cIm9iamVjdFwiO2RlZmF1bHQ6cmV0dXJuITF9Y2FzZVwiRnVuY3Rpb25FeHByZXNzaW9uXCI6c3dpdGNoKG0udHlwZSl7Y2FzZVwiTmV3RXhwcmVzc2lvblwiOmNhc2VcIkNhbGxFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOnJldHVybiB2PT09XCJjYWxsZWVcIjtjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpyZXR1cm4hMDtkZWZhdWx0OnJldHVybiExfWNhc2VcIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI6c3dpdGNoKG0udHlwZSl7Y2FzZVwiQmluYXJ5RXhwcmVzc2lvblwiOnJldHVybiBtLm9wZXJhdG9yIT09XCJ8PlwifHxvLmV4dHJhJiZvLmV4dHJhLnBhcmVudGhlc2l6ZWQ7Y2FzZVwiTmV3RXhwcmVzc2lvblwiOmNhc2VcIkNhbGxFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOnJldHVybiB2PT09XCJjYWxsZWVcIjtjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIHY9PT1cIm9iamVjdFwiO2Nhc2VcIlRTQXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNTYXRpc2ZpZXNFeHByZXNzaW9uXCI6Y2FzZVwiVFNOb25OdWxsRXhwcmVzc2lvblwiOmNhc2VcIkJpbmRFeHByZXNzaW9uXCI6Y2FzZVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCI6Y2FzZVwiVW5hcnlFeHByZXNzaW9uXCI6Y2FzZVwiTG9naWNhbEV4cHJlc3Npb25cIjpjYXNlXCJBd2FpdEV4cHJlc3Npb25cIjpjYXNlXCJUU1R5cGVBc3NlcnRpb25cIjpyZXR1cm4hMDtjYXNlXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpyZXR1cm4gdj09PVwidGVzdFwiO2RlZmF1bHQ6cmV0dXJuITF9Y2FzZVwiQ2xhc3NFeHByZXNzaW9uXCI6aWYocyhvLmRlY29yYXRvcnMpKXJldHVybiEwO3N3aXRjaChtLnR5cGUpe2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpyZXR1cm4gdj09PVwiY2FsbGVlXCI7ZGVmYXVsdDpyZXR1cm4hMX1jYXNlXCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6e2xldCB4PWYuZ2V0UGFyZW50Tm9kZSgxKTtpZih2PT09XCJvYmplY3RcIiYmbS50eXBlPT09XCJNZW1iZXJFeHByZXNzaW9uXCJ8fHY9PT1cImNhbGxlZVwiJiYobS50eXBlPT09XCJDYWxsRXhwcmVzc2lvblwifHxtLnR5cGU9PT1cIk5ld0V4cHJlc3Npb25cIil8fG0udHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiJiZ4LnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cIiYmeC5vYmplY3Q9PT1tKXJldHVybiEwfWNhc2VcIkNhbGxFeHByZXNzaW9uXCI6Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOmNhc2VcIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiOmNhc2VcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjppZih2PT09XCJjYWxsZWVcIiYmKG0udHlwZT09PVwiQmluZEV4cHJlc3Npb25cInx8bS50eXBlPT09XCJOZXdFeHByZXNzaW9uXCIpKXtsZXQgeD1vO2Zvcig7eDspc3dpdGNoKHgudHlwZSl7Y2FzZVwiQ2FsbEV4cHJlc3Npb25cIjpjYXNlXCJPcHRpb25hbENhbGxFeHByZXNzaW9uXCI6cmV0dXJuITA7Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsTWVtYmVyRXhwcmVzc2lvblwiOmNhc2VcIkJpbmRFeHByZXNzaW9uXCI6eD14Lm9iamVjdDticmVhaztjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjp4PXgudGFnO2JyZWFrO2Nhc2VcIlRTTm9uTnVsbEV4cHJlc3Npb25cIjp4PXguZXhwcmVzc2lvbjticmVhaztkZWZhdWx0OnJldHVybiExfX1yZXR1cm4hMTtjYXNlXCJCaW5kRXhwcmVzc2lvblwiOnJldHVybiB2PT09XCJjYWxsZWVcIiYmKG0udHlwZT09PVwiQmluZEV4cHJlc3Npb25cInx8bS50eXBlPT09XCJOZXdFeHByZXNzaW9uXCIpfHx2PT09XCJvYmplY3RcIiYmRChtKTtjYXNlXCJOR1BpcGVFeHByZXNzaW9uXCI6cmV0dXJuIShtLnR5cGU9PT1cIk5HUm9vdFwifHxtLnR5cGU9PT1cIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCJ8fG0udHlwZT09PVwiT2JqZWN0UHJvcGVydHlcIiYmIShvLmV4dHJhJiZvLmV4dHJhLnBhcmVudGhlc2l6ZWQpfHxtLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwifHxjKG0pJiZtLmFyZ3VtZW50c1t2XT09PW98fHY9PT1cInJpZ2h0XCImJm0udHlwZT09PVwiTkdQaXBlRXhwcmVzc2lvblwifHx2PT09XCJwcm9wZXJ0eVwiJiZtLnR5cGU9PT1cIk1lbWJlckV4cHJlc3Npb25cInx8bS50eXBlPT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwiKTtjYXNlXCJKU1hGcmFnbWVudFwiOmNhc2VcIkpTWEVsZW1lbnRcIjpyZXR1cm4gdj09PVwiY2FsbGVlXCJ8fHY9PT1cImxlZnRcIiYmbS50eXBlPT09XCJCaW5hcnlFeHByZXNzaW9uXCImJm0ub3BlcmF0b3I9PT1cIjxcInx8bS50eXBlIT09XCJBcnJheUV4cHJlc3Npb25cIiYmbS50eXBlIT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZtLnR5cGUhPT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCImJm0udHlwZSE9PVwiQXNzaWdubWVudFBhdHRlcm5cIiYmbS50eXBlIT09XCJCaW5hcnlFeHByZXNzaW9uXCImJm0udHlwZSE9PVwiTmV3RXhwcmVzc2lvblwiJiZtLnR5cGUhPT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiJiZtLnR5cGUhPT1cIkV4cHJlc3Npb25TdGF0ZW1lbnRcIiYmbS50eXBlIT09XCJKc0V4cHJlc3Npb25Sb290XCImJm0udHlwZSE9PVwiSlNYQXR0cmlidXRlXCImJm0udHlwZSE9PVwiSlNYRWxlbWVudFwiJiZtLnR5cGUhPT1cIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiYmbS50eXBlIT09XCJKU1hGcmFnbWVudFwiJiZtLnR5cGUhPT1cIkxvZ2ljYWxFeHByZXNzaW9uXCImJiFjKG0pJiYhRShtKSYmbS50eXBlIT09XCJSZXR1cm5TdGF0ZW1lbnRcIiYmbS50eXBlIT09XCJUaHJvd1N0YXRlbWVudFwiJiZtLnR5cGUhPT1cIlR5cGVDYXN0RXhwcmVzc2lvblwiJiZtLnR5cGUhPT1cIlZhcmlhYmxlRGVjbGFyYXRvclwiJiZtLnR5cGUhPT1cIllpZWxkRXhwcmVzc2lvblwiO2Nhc2VcIlR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIHY9PT1cInJldHVyblR5cGVcIiYmbS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZOKG8pfXJldHVybiExfWZ1bmN0aW9uIEYoZil7cmV0dXJuIGYudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcInx8Zi50eXBlPT09XCJCcmVha1N0YXRlbWVudFwifHxmLnR5cGU9PT1cIkNsYXNzQm9keVwifHxmLnR5cGU9PT1cIkNsYXNzRGVjbGFyYXRpb25cInx8Zi50eXBlPT09XCJDbGFzc01ldGhvZFwifHxmLnR5cGU9PT1cIkNsYXNzUHJvcGVydHlcInx8Zi50eXBlPT09XCJQcm9wZXJ0eURlZmluaXRpb25cInx8Zi50eXBlPT09XCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwifHxmLnR5cGU9PT1cIkNvbnRpbnVlU3RhdGVtZW50XCJ8fGYudHlwZT09PVwiRGVidWdnZXJTdGF0ZW1lbnRcInx8Zi50eXBlPT09XCJEZWNsYXJlQ2xhc3NcInx8Zi50eXBlPT09XCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cInx8Zi50eXBlPT09XCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cInx8Zi50eXBlPT09XCJEZWNsYXJlRnVuY3Rpb25cInx8Zi50eXBlPT09XCJEZWNsYXJlSW50ZXJmYWNlXCJ8fGYudHlwZT09PVwiRGVjbGFyZU1vZHVsZVwifHxmLnR5cGU9PT1cIkRlY2xhcmVNb2R1bGVFeHBvcnRzXCJ8fGYudHlwZT09PVwiRGVjbGFyZVZhcmlhYmxlXCJ8fGYudHlwZT09PVwiRG9XaGlsZVN0YXRlbWVudFwifHxmLnR5cGU9PT1cIkVudW1EZWNsYXJhdGlvblwifHxmLnR5cGU9PT1cIkV4cG9ydEFsbERlY2xhcmF0aW9uXCJ8fGYudHlwZT09PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCJ8fGYudHlwZT09PVwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwifHxmLnR5cGU9PT1cIkV4cHJlc3Npb25TdGF0ZW1lbnRcInx8Zi50eXBlPT09XCJGb3JJblN0YXRlbWVudFwifHxmLnR5cGU9PT1cIkZvck9mU3RhdGVtZW50XCJ8fGYudHlwZT09PVwiRm9yU3RhdGVtZW50XCJ8fGYudHlwZT09PVwiRnVuY3Rpb25EZWNsYXJhdGlvblwifHxmLnR5cGU9PT1cIklmU3RhdGVtZW50XCJ8fGYudHlwZT09PVwiSW1wb3J0RGVjbGFyYXRpb25cInx8Zi50eXBlPT09XCJJbnRlcmZhY2VEZWNsYXJhdGlvblwifHxmLnR5cGU9PT1cIkxhYmVsZWRTdGF0ZW1lbnRcInx8Zi50eXBlPT09XCJNZXRob2REZWZpbml0aW9uXCJ8fGYudHlwZT09PVwiUmV0dXJuU3RhdGVtZW50XCJ8fGYudHlwZT09PVwiU3dpdGNoU3RhdGVtZW50XCJ8fGYudHlwZT09PVwiVGhyb3dTdGF0ZW1lbnRcInx8Zi50eXBlPT09XCJUcnlTdGF0ZW1lbnRcInx8Zi50eXBlPT09XCJUU0RlY2xhcmVGdW5jdGlvblwifHxmLnR5cGU9PT1cIlRTRW51bURlY2xhcmF0aW9uXCJ8fGYudHlwZT09PVwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwifHxmLnR5cGU9PT1cIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cInx8Zi50eXBlPT09XCJUU01vZHVsZURlY2xhcmF0aW9uXCJ8fGYudHlwZT09PVwiVFNOYW1lc3BhY2VFeHBvcnREZWNsYXJhdGlvblwifHxmLnR5cGU9PT1cIlR5cGVBbGlhc1wifHxmLnR5cGU9PT1cIlZhcmlhYmxlRGVjbGFyYXRpb25cInx8Zi50eXBlPT09XCJXaGlsZVN0YXRlbWVudFwifHxmLnR5cGU9PT1cIldpdGhTdGF0ZW1lbnRcIn1mdW5jdGlvbiBTKGYpe2xldCBUPTAsbT1mLmdldFZhbHVlKCk7Zm9yKDttOyl7bGV0IHY9Zi5nZXRQYXJlbnROb2RlKFQrKyk7aWYodiYmdi50eXBlPT09XCJGb3JTdGF0ZW1lbnRcIiYmdi5pbml0PT09bSlyZXR1cm4hMDttPXZ9cmV0dXJuITF9ZnVuY3Rpb24gTihmKXtyZXR1cm4gbChmLFQ9PlQudHlwZT09PVwiT2JqZWN0VHlwZUFubm90YXRpb25cIiYmbChULG09Pm0udHlwZT09PVwiRnVuY3Rpb25UeXBlQW5ub3RhdGlvblwifHx2b2lkIDApfHx2b2lkIDApfWZ1bmN0aW9uIEkoZil7c3dpdGNoKGYudHlwZSl7Y2FzZVwiT2JqZWN0RXhwcmVzc2lvblwiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fWZ1bmN0aW9uIFAoZil7bGV0IFQ9Zi5nZXRWYWx1ZSgpLG09Zi5nZXRQYXJlbnROb2RlKCksdj1mLmdldE5hbWUoKTtzd2l0Y2gobS50eXBlKXtjYXNlXCJOR1BpcGVFeHByZXNzaW9uXCI6aWYodHlwZW9mIHY9PVwibnVtYmVyXCImJm0uYXJndW1lbnRzW3ZdPT09VCYmbS5hcmd1bWVudHMubGVuZ3RoLTE9PT12KXJldHVybiBmLmNhbGxQYXJlbnQoUCk7YnJlYWs7Y2FzZVwiT2JqZWN0UHJvcGVydHlcIjppZih2PT09XCJ2YWx1ZVwiKXtsZXQgbz1mLmdldFBhcmVudE5vZGUoMSk7cmV0dXJuIHQoby5wcm9wZXJ0aWVzKT09PW19YnJlYWs7Y2FzZVwiQmluYXJ5RXhwcmVzc2lvblwiOmNhc2VcIkxvZ2ljYWxFeHByZXNzaW9uXCI6aWYodj09PVwicmlnaHRcIilyZXR1cm4gZi5jYWxsUGFyZW50KFApO2JyZWFrO2Nhc2VcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOmlmKHY9PT1cImFsdGVybmF0ZVwiKXJldHVybiBmLmNhbGxQYXJlbnQoUCk7YnJlYWs7Y2FzZVwiVW5hcnlFeHByZXNzaW9uXCI6aWYobS5wcmVmaXgpcmV0dXJuIGYuY2FsbFBhcmVudChQKTticmVha31yZXR1cm4hMX1mdW5jdGlvbiAkKGYsVCl7bGV0IG09Zi5nZXRWYWx1ZSgpLHY9Zi5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIG0udHlwZT09PVwiRnVuY3Rpb25FeHByZXNzaW9uXCJ8fG0udHlwZT09PVwiQ2xhc3NFeHByZXNzaW9uXCI/di50eXBlPT09XCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cInx8IXcoZixUKTohaShtKXx8di50eXBlIT09XCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIiYmdyhmLFQpPyExOmYuY2FsbChvPT4kKG8sVCksLi4ubihmLG0pKX1yLmV4cG9ydHM9d319KSxGbz10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQtcHJlcHJvY2Vzcy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KHMsYSl7c3dpdGNoKGEucGFyc2VyKXtjYXNlXCJqc29uXCI6Y2FzZVwianNvbjVcIjpjYXNlXCJqc29uLXN0cmluZ2lmeVwiOmNhc2VcIl9fanNfZXhwcmVzc2lvblwiOmNhc2VcIl9fdnVlX2V4cHJlc3Npb25cIjpjYXNlXCJfX3Z1ZV90c19leHByZXNzaW9uXCI6cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxzKSx7fSx7dHlwZTphLnBhcnNlci5zdGFydHNXaXRoKFwiX19cIik/XCJKc0V4cHJlc3Npb25Sb290XCI6XCJKc29uUm9vdFwiLG5vZGU6cyxjb21tZW50czpbXSxyb290TWFya2VyOmEucm9vdE1hcmtlcn0pO2RlZmF1bHQ6cmV0dXJuIHN9fXIuZXhwb3J0cz10fX0pLGNkPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9odG1sLWJpbmRpbmcuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOntqb2luOnQsbGluZTpzLGdyb3VwOmEsc29mdGxpbmU6bixpbmRlbnQ6dX19PXFlKCk7ZnVuY3Rpb24gaShwLGQseSl7bGV0IGc9cC5nZXRWYWx1ZSgpO2lmKGQuX19vbkh0bWxCaW5kaW5nUm9vdCYmcC5nZXROYW1lKCk9PT1udWxsJiZkLl9fb25IdG1sQmluZGluZ1Jvb3QoZyxkKSxnLnR5cGU9PT1cIkZpbGVcIil7aWYoZC5fX2lzVnVlRm9yQmluZGluZ0xlZnQpcmV0dXJuIHAuY2FsbChjPT57bGV0IEQ9dChbXCIsXCIsc10sYy5tYXAoeSxcInBhcmFtc1wiKSkse3BhcmFtczpFfT1jLmdldFZhbHVlKCk7cmV0dXJuIEUubGVuZ3RoPT09MT9EOltcIihcIix1KFtuLGEoRCldKSxuLFwiKVwiXX0sXCJwcm9ncmFtXCIsXCJib2R5XCIsMCk7aWYoZC5fX2lzVnVlQmluZGluZ3MpcmV0dXJuIHAuY2FsbChjPT50KFtcIixcIixzXSxjLm1hcCh5LFwicGFyYW1zXCIpKSxcInByb2dyYW1cIixcImJvZHlcIiwwKX19ZnVuY3Rpb24gbChwKXtzd2l0Y2gocC50eXBlKXtjYXNlXCJNZW1iZXJFeHByZXNzaW9uXCI6c3dpdGNoKHAucHJvcGVydHkudHlwZSl7Y2FzZVwiSWRlbnRpZmllclwiOmNhc2VcIk51bWVyaWNMaXRlcmFsXCI6Y2FzZVwiU3RyaW5nTGl0ZXJhbFwiOnJldHVybiBsKHAub2JqZWN0KX1yZXR1cm4hMTtjYXNlXCJJZGVudGlmaWVyXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ci5leHBvcnRzPXtpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb246bCxwcmludEh0bWxCaW5kaW5nOml9fX0pLHJ1PXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9iaW5hcnlpc2guanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50Q29tbWVudHM6dH09ZXQoKSx7Z2V0TGFzdDpzfT1VZSgpLHtidWlsZGVyczp7am9pbjphLGxpbmU6bixzb2Z0bGluZTp1LGdyb3VwOmksaW5kZW50OmwsYWxpZ246cCxpbmRlbnRJZkJyZWFrOmR9LHV0aWxzOntjbGVhbkRvYzp5LGdldERvY1BhcnRzOmcsaXNDb25jYXQ6Y319PXFlKCkse2hhc0xlYWRpbmdPd25MaW5lQ29tbWVudDpELGlzQmluYXJ5aXNoOkUsaXNKc3hOb2RlOl8sc2hvdWxkRmxhdHRlbjp3LGhhc0NvbW1lbnQ6RixDb21tZW50Q2hlY2tGbGFnczpTLGlzQ2FsbEV4cHJlc3Npb246Tixpc01lbWJlckV4cHJlc3Npb246SSxpc09iamVjdFByb3BlcnR5OlAsaXNFbmFibGVkSGFja1BpcGVsaW5lOiR9PUtlKCksZj0wO2Z1bmN0aW9uIFQobyxoLEMpe2xldCB4PW8uZ2V0VmFsdWUoKSxiPW8uZ2V0UGFyZW50Tm9kZSgpLEI9by5nZXRQYXJlbnROb2RlKDEpLGs9eCE9PWIuYm9keSYmKGIudHlwZT09PVwiSWZTdGF0ZW1lbnRcInx8Yi50eXBlPT09XCJXaGlsZVN0YXRlbWVudFwifHxiLnR5cGU9PT1cIlN3aXRjaFN0YXRlbWVudFwifHxiLnR5cGU9PT1cIkRvV2hpbGVTdGF0ZW1lbnRcIiksTT0kKGgpJiZ4Lm9wZXJhdG9yPT09XCJ8PlwiLFI9bShvLEMsaCwhMSxrKTtpZihrKXJldHVybiBSO2lmKE0pcmV0dXJuIGkoUik7aWYoTihiKSYmYi5jYWxsZWU9PT14fHxiLnR5cGU9PT1cIlVuYXJ5RXhwcmVzc2lvblwifHxJKGIpJiYhYi5jb21wdXRlZClyZXR1cm4gaShbbChbdSwuLi5SXSksdV0pO2xldCBxPWIudHlwZT09PVwiUmV0dXJuU3RhdGVtZW50XCJ8fGIudHlwZT09PVwiVGhyb3dTdGF0ZW1lbnRcInx8Yi50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJkIudHlwZT09PVwiSlNYQXR0cmlidXRlXCJ8fHgub3BlcmF0b3IhPT1cInxcIiYmYi50eXBlPT09XCJKc0V4cHJlc3Npb25Sb290XCJ8fHgudHlwZSE9PVwiTkdQaXBlRXhwcmVzc2lvblwiJiYoYi50eXBlPT09XCJOR1Jvb3RcIiYmaC5wYXJzZXI9PT1cIl9fbmdfYmluZGluZ1wifHxiLnR5cGU9PT1cIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCImJkIudHlwZT09PVwiTkdNaWNyb3N5bnRheFwiJiZCLmJvZHkubGVuZ3RoPT09MSl8fHg9PT1iLmJvZHkmJmIudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cInx8eCE9PWIuYm9keSYmYi50eXBlPT09XCJGb3JTdGF0ZW1lbnRcInx8Yi50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiYmQi50eXBlIT09XCJSZXR1cm5TdGF0ZW1lbnRcIiYmQi50eXBlIT09XCJUaHJvd1N0YXRlbWVudFwiJiYhTihCKXx8Yi50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcIixKPWIudHlwZT09PVwiQXNzaWdubWVudEV4cHJlc3Npb25cInx8Yi50eXBlPT09XCJWYXJpYWJsZURlY2xhcmF0b3JcInx8Yi50eXBlPT09XCJDbGFzc1Byb3BlcnR5XCJ8fGIudHlwZT09PVwiUHJvcGVydHlEZWZpbml0aW9uXCJ8fGIudHlwZT09PVwiVFNBYnN0cmFjdFByb3BlcnR5RGVmaW5pdGlvblwifHxiLnR5cGU9PT1cIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCJ8fFAoYiksTD1FKHgubGVmdCkmJncoeC5vcGVyYXRvcix4LmxlZnQub3BlcmF0b3IpO2lmKHF8fHYoeCkmJiFMfHwhdih4KSYmSilyZXR1cm4gaShSKTtpZihSLmxlbmd0aD09PTApcmV0dXJuXCJcIjtsZXQgUT1fKHgucmlnaHQpLFY9Ui5maW5kSW5kZXgoVz0+dHlwZW9mIFchPVwic3RyaW5nXCImJiFBcnJheS5pc0FycmF5KFcpJiZXLnR5cGU9PT1cImdyb3VwXCIpLGo9Ui5zbGljZSgwLFY9PT0tMT8xOlYrMSksWT1SLnNsaWNlKGoubGVuZ3RoLFE/LTE6dm9pZCAwKSxpZT1TeW1ib2woXCJsb2dpY2FsQ2hhaW4tXCIrICsrZiksZWU9aShbLi4uaixsKFkpXSx7aWQ6aWV9KTtpZighUSlyZXR1cm4gZWU7bGV0IGxlPXMoUik7cmV0dXJuIGkoW2VlLGQobGUse2dyb3VwSWQ6aWV9KV0pfWZ1bmN0aW9uIG0obyxoLEMseCxiKXtsZXQgQj1vLmdldFZhbHVlKCk7aWYoIUUoQikpcmV0dXJuW2koaCgpKV07bGV0IGs9W107dyhCLm9wZXJhdG9yLEIubGVmdC5vcGVyYXRvcik/az1vLmNhbGwoWT0+bShZLGgsQywhMCxiKSxcImxlZnRcIik6ay5wdXNoKGkoaChcImxlZnRcIikpKTtsZXQgTT12KEIpLFI9KEIub3BlcmF0b3I9PT1cInw+XCJ8fEIudHlwZT09PVwiTkdQaXBlRXhwcmVzc2lvblwifHxCLm9wZXJhdG9yPT09XCJ8XCImJkMucGFyc2VyPT09XCJfX3Z1ZV9leHByZXNzaW9uXCIpJiYhRChDLm9yaWdpbmFsVGV4dCxCLnJpZ2h0KSxxPUIudHlwZT09PVwiTkdQaXBlRXhwcmVzc2lvblwiP1wifFwiOkIub3BlcmF0b3IsSj1CLnR5cGU9PT1cIk5HUGlwZUV4cHJlc3Npb25cIiYmQi5hcmd1bWVudHMubGVuZ3RoPjA/aShsKFtuLFwiOiBcIixhKFtuLFwiOiBcIl0sby5tYXAoaCxcImFyZ3VtZW50c1wiKS5tYXAoWT0+cCgyLGkoWSkpKSldKSk6XCJcIixMO2lmKE0pTD1bcSxcIiBcIixoKFwicmlnaHRcIiksSl07ZWxzZXtsZXQgaWU9JChDKSYmcT09PVwifD5cIj9vLmNhbGwoZWU9Pm0oZWUsaCxDLCEwLGIpLFwicmlnaHRcIik6aChcInJpZ2h0XCIpO0w9W1I/bjpcIlwiLHEsUj9cIiBcIjpuLGllLEpdfWxldCBRPW8uZ2V0UGFyZW50Tm9kZSgpLFY9RihCLmxlZnQsUy5UcmFpbGluZ3xTLkxpbmUpLGo9Vnx8IShiJiZCLnR5cGU9PT1cIkxvZ2ljYWxFeHByZXNzaW9uXCIpJiZRLnR5cGUhPT1CLnR5cGUmJkIubGVmdC50eXBlIT09Qi50eXBlJiZCLnJpZ2h0LnR5cGUhPT1CLnR5cGU7aWYoay5wdXNoKFI/XCJcIjpcIiBcIixqP2koTCx7c2hvdWxkQnJlYWs6Vn0pOkwpLHgmJkYoQikpe2xldCBZPXkodChvLGssQykpO3JldHVybiBjKFkpfHxZLnR5cGU9PT1cImZpbGxcIj9nKFkpOltZXX1yZXR1cm4ga31mdW5jdGlvbiB2KG8pe3JldHVybiBvLnR5cGUhPT1cIkxvZ2ljYWxFeHByZXNzaW9uXCI/ITE6ISEoby5yaWdodC50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCImJm8ucmlnaHQucHJvcGVydGllcy5sZW5ndGg+MHx8by5yaWdodC50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cIiYmby5yaWdodC5lbGVtZW50cy5sZW5ndGg+MHx8XyhvLnJpZ2h0KSl9ci5leHBvcnRzPXtwcmludEJpbmFyeWlzaEV4cHJlc3Npb246VCxzaG91bGRJbmxpbmVMb2dpY2FsRXhwcmVzc2lvbjp2fX19KSxwZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvYW5ndWxhci5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7YnVpbGRlcnM6e2pvaW46dCxsaW5lOnMsZ3JvdXA6YX19PXFlKCkse2hhc05vZGU6bixoYXNDb21tZW50OnUsZ2V0Q29tbWVudHM6aX09S2UoKSx7cHJpbnRCaW5hcnlpc2hFeHByZXNzaW9uOmx9PXJ1KCk7ZnVuY3Rpb24gcChnLGMsRCl7bGV0IEU9Zy5nZXRWYWx1ZSgpO2lmKEUudHlwZS5zdGFydHNXaXRoKFwiTkdcIikpc3dpdGNoKEUudHlwZSl7Y2FzZVwiTkdSb290XCI6cmV0dXJuW0QoXCJub2RlXCIpLHUoRS5ub2RlKT9cIiAvL1wiK2koRS5ub2RlKVswXS52YWx1ZS50cmltRW5kKCk6XCJcIl07Y2FzZVwiTkdQaXBlRXhwcmVzc2lvblwiOnJldHVybiBsKGcsYyxEKTtjYXNlXCJOR0NoYWluZWRFeHByZXNzaW9uXCI6cmV0dXJuIGEodChbXCI7XCIsc10sZy5tYXAoXz0+eShfKT9EKCk6W1wiKFwiLEQoKSxcIilcIl0sXCJleHByZXNzaW9uc1wiKSkpO2Nhc2VcIk5HRW1wdHlFeHByZXNzaW9uXCI6cmV0dXJuXCJcIjtjYXNlXCJOR1F1b3RlZEV4cHJlc3Npb25cIjpyZXR1cm5bRS5wcmVmaXgsXCI6IFwiLEUudmFsdWUudHJpbSgpXTtjYXNlXCJOR01pY3Jvc3ludGF4XCI6cmV0dXJuIGcubWFwKChfLHcpPT5bdz09PTA/XCJcIjpkKF8uZ2V0VmFsdWUoKSx3LEUpP1wiIFwiOltcIjtcIixzXSxEKCldLFwiYm9keVwiKTtjYXNlXCJOR01pY3Jvc3ludGF4S2V5XCI6cmV0dXJuL15bJF9hLXpdW1xcdyRdKig/Oi1bJF9hLXpdW1xcdyRdKSokL2kudGVzdChFLm5hbWUpP0UubmFtZTpKU09OLnN0cmluZ2lmeShFLm5hbWUpO2Nhc2VcIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCI6cmV0dXJuW0QoXCJleHByZXNzaW9uXCIpLEUuYWxpYXM9PT1udWxsP1wiXCI6W1wiIGFzIFwiLEQoXCJhbGlhc1wiKV1dO2Nhc2VcIk5HTWljcm9zeW50YXhLZXllZEV4cHJlc3Npb25cIjp7bGV0IF89Zy5nZXROYW1lKCksdz1nLmdldFBhcmVudE5vZGUoKSxGPWQoRSxfLHcpfHwoXz09PTEmJihFLmtleS5uYW1lPT09XCJ0aGVuXCJ8fEUua2V5Lm5hbWU9PT1cImVsc2VcIil8fF89PT0yJiZFLmtleS5uYW1lPT09XCJlbHNlXCImJncuYm9keVtfLTFdLnR5cGU9PT1cIk5HTWljcm9zeW50YXhLZXllZEV4cHJlc3Npb25cIiYmdy5ib2R5W18tMV0ua2V5Lm5hbWU9PT1cInRoZW5cIikmJncuYm9keVswXS50eXBlPT09XCJOR01pY3Jvc3ludGF4RXhwcmVzc2lvblwiO3JldHVybltEKFwia2V5XCIpLEY/XCIgXCI6XCI6IFwiLEQoXCJleHByZXNzaW9uXCIpXX1jYXNlXCJOR01pY3Jvc3ludGF4TGV0XCI6cmV0dXJuW1wibGV0IFwiLEQoXCJrZXlcIiksRS52YWx1ZT09PW51bGw/XCJcIjpbXCIgPSBcIixEKFwidmFsdWVcIildXTtjYXNlXCJOR01pY3Jvc3ludGF4QXNcIjpyZXR1cm5bRChcImtleVwiKSxcIiBhcyBcIixEKFwiYWxpYXNcIildO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIEFuZ3VsYXIgbm9kZSB0eXBlOiAke0pTT04uc3RyaW5naWZ5KEUudHlwZSl9LmApfX1mdW5jdGlvbiBkKGcsYyxEKXtyZXR1cm4gZy50eXBlPT09XCJOR01pY3Jvc3ludGF4S2V5ZWRFeHByZXNzaW9uXCImJmcua2V5Lm5hbWU9PT1cIm9mXCImJmM9PT0xJiZELmJvZHlbMF0udHlwZT09PVwiTkdNaWNyb3N5bnRheExldFwiJiZELmJvZHlbMF0udmFsdWU9PT1udWxsfWZ1bmN0aW9uIHkoZyl7cmV0dXJuIG4oZy5nZXRWYWx1ZSgpLGM9Pntzd2l0Y2goYy50eXBlKXtjYXNlIHZvaWQgMDpyZXR1cm4hMTtjYXNlXCJDYWxsRXhwcmVzc2lvblwiOmNhc2VcIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cIjpjYXNlXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOnJldHVybiEwfX0pfXIuZXhwb3J0cz17cHJpbnRBbmd1bGFyOnB9fX0pLGZkPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9qc3guanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50Q29tbWVudHM6dCxwcmludERhbmdsaW5nQ29tbWVudHM6cyxwcmludENvbW1lbnRzU2VwYXJhdGVseTphfT1ldCgpLHtidWlsZGVyczp7bGluZTpuLGhhcmRsaW5lOnUsc29mdGxpbmU6aSxncm91cDpsLGluZGVudDpwLGNvbmRpdGlvbmFsR3JvdXA6ZCxmaWxsOnksaWZCcmVhazpnLGxpbmVTdWZmaXhCb3VuZGFyeTpjLGpvaW46RH0sdXRpbHM6e3dpbGxCcmVhazpFfX09cWUoKSx7Z2V0TGFzdDpfLGdldFByZWZlcnJlZFF1b3RlOnd9PVVlKCkse2lzSnN4Tm9kZTpGLHJhd1RleHQ6Uyxpc0NhbGxFeHByZXNzaW9uOk4saXNTdHJpbmdMaXRlcmFsOkksaXNCaW5hcnlpc2g6UCxoYXNDb21tZW50OiQsQ29tbWVudENoZWNrRmxhZ3M6ZixoYXNOb2RlSWdub3JlQ29tbWVudDpUfT1LZSgpLG09cXQoKSx7d2lsbFByaW50T3duQ29tbWVudHM6dn09RW8oKSxvPVU9PlU9PT1cIlwifHxVPT09bnx8VT09PXV8fFU9PT1pO2Z1bmN0aW9uIGgoVSxaLHNlKXtsZXQgRGU9VS5nZXRWYWx1ZSgpO2lmKERlLnR5cGU9PT1cIkpTWEVsZW1lbnRcIiYmZGUoRGUpKXJldHVybltzZShcIm9wZW5pbmdFbGVtZW50XCIpLHNlKFwiY2xvc2luZ0VsZW1lbnRcIildO2xldCBnZT1EZS50eXBlPT09XCJKU1hFbGVtZW50XCI/c2UoXCJvcGVuaW5nRWxlbWVudFwiKTpzZShcIm9wZW5pbmdGcmFnbWVudFwiKSxoZT1EZS50eXBlPT09XCJKU1hFbGVtZW50XCI/c2UoXCJjbG9zaW5nRWxlbWVudFwiKTpzZShcImNsb3NpbmdGcmFnbWVudFwiKTtpZihEZS5jaGlsZHJlbi5sZW5ndGg9PT0xJiZEZS5jaGlsZHJlblswXS50eXBlPT09XCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCImJihEZS5jaGlsZHJlblswXS5leHByZXNzaW9uLnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwifHxEZS5jaGlsZHJlblswXS5leHByZXNzaW9uLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwiKSlyZXR1cm5bZ2UsLi4uVS5tYXAoc2UsXCJjaGlsZHJlblwiKSxoZV07RGUuY2hpbGRyZW49RGUuY2hpbGRyZW4ubWFwKEE9PkZlKEEpP3t0eXBlOlwiSlNYVGV4dFwiLHZhbHVlOlwiIFwiLHJhdzpcIiBcIn06QSk7bGV0IHdlPURlLmNoaWxkcmVuLnNvbWUoRiksa2U9RGUuY2hpbGRyZW4uZmlsdGVyKEE9PkEudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKS5sZW5ndGg+MSxSZT1EZS50eXBlPT09XCJKU1hFbGVtZW50XCImJkRlLm9wZW5pbmdFbGVtZW50LmF0dHJpYnV0ZXMubGVuZ3RoPjEsTmU9RShnZSl8fHdlfHxSZXx8a2UsUGU9VS5nZXRQYXJlbnROb2RlKCkucm9vdE1hcmtlcj09PVwibWR4XCIsb2U9Wi5zaW5nbGVRdW90ZT9cInsnICd9XCI6J3tcIiBcIn0nLEg9UGU/XCIgXCI6Zyhbb2UsaV0sXCIgXCIpLGNlPURlLm9wZW5pbmdFbGVtZW50JiZEZS5vcGVuaW5nRWxlbWVudC5uYW1lJiZEZS5vcGVuaW5nRWxlbWVudC5uYW1lLm5hbWU9PT1cImZidFwiLFg9QyhVLFosc2UsSCxjZSkscGU9RGUuY2hpbGRyZW4uc29tZShBPT51ZShBKSk7Zm9yKGxldCBBPVgubGVuZ3RoLTI7QT49MDtBLS0pe2xldCBHPVhbQV09PT1cIlwiJiZYW0ErMV09PT1cIlwiLHJlPVhbQV09PT11JiZYW0ErMV09PT1cIlwiJiZYW0ErMl09PT11LHllPShYW0FdPT09aXx8WFtBXT09PXUpJiZYW0ErMV09PT1cIlwiJiZYW0ErMl09PT1ILEVlPVhbQV09PT1IJiZYW0ErMV09PT1cIlwiJiYoWFtBKzJdPT09aXx8WFtBKzJdPT09dSksQmU9WFtBXT09PUgmJlhbQSsxXT09PVwiXCImJlhbQSsyXT09PUgsdmU9WFtBXT09PWkmJlhbQSsxXT09PVwiXCImJlhbQSsyXT09PXV8fFhbQV09PT11JiZYW0ErMV09PT1cIlwiJiZYW0ErMl09PT1pO3JlJiZwZXx8R3x8eWV8fEJlfHx2ZT9YLnNwbGljZShBLDIpOkVlJiZYLnNwbGljZShBKzEsMil9Zm9yKDtYLmxlbmd0aD4wJiZvKF8oWCkpOylYLnBvcCgpO2Zvcig7WC5sZW5ndGg+MSYmbyhYWzBdKSYmbyhYWzFdKTspWC5zaGlmdCgpLFguc2hpZnQoKTtsZXQgQWU9W107Zm9yKGxldFtBLEddb2YgWC5lbnRyaWVzKCkpe2lmKEc9PT1IKXtpZihBPT09MSYmWFtBLTFdPT09XCJcIil7aWYoWC5sZW5ndGg9PT0yKXtBZS5wdXNoKG9lKTtjb250aW51ZX1BZS5wdXNoKFtvZSx1XSk7Y29udGludWV9ZWxzZSBpZihBPT09WC5sZW5ndGgtMSl7QWUucHVzaChvZSk7Y29udGludWV9ZWxzZSBpZihYW0EtMV09PT1cIlwiJiZYW0EtMl09PT11KXtBZS5wdXNoKG9lKTtjb250aW51ZX19QWUucHVzaChHKSxFKEcpJiYoTmU9ITApfWxldCBDZT1wZT95KEFlKTpsKEFlLHtzaG91bGRCcmVhazohMH0pO2lmKFBlKXJldHVybiBDZTtsZXQgZmU9bChbZ2UscChbdSxDZV0pLHUsaGVdKTtyZXR1cm4gTmU/ZmU6ZChbbChbZ2UsLi4uWCxoZV0pLGZlXSl9ZnVuY3Rpb24gQyhVLFosc2UsRGUsZ2Upe2xldCBoZT1bXTtyZXR1cm4gVS5lYWNoKCh3ZSxrZSxSZSk9PntsZXQgTmU9d2UuZ2V0VmFsdWUoKTtpZihOZS50eXBlPT09XCJKU1hUZXh0XCIpe2xldCBQZT1TKE5lKTtpZih1ZShOZSkpe2xldCBvZT1QZS5zcGxpdChsZSk7aWYob2VbMF09PT1cIlwiKXtpZihoZS5wdXNoKFwiXCIpLG9lLnNoaWZ0KCksL1xcbi8udGVzdChvZVswXSkpe2xldCBjZT1SZVtrZSsxXTtoZS5wdXNoKGIoZ2Usb2VbMV0sTmUsY2UpKX1lbHNlIGhlLnB1c2goRGUpO29lLnNoaWZ0KCl9bGV0IEg7aWYoXyhvZSk9PT1cIlwiJiYob2UucG9wKCksSD1vZS5wb3AoKSksb2UubGVuZ3RoPT09MClyZXR1cm47Zm9yKGxldFtjZSxYXW9mIG9lLmVudHJpZXMoKSljZSUyPT09MT9oZS5wdXNoKG4pOmhlLnB1c2goWCk7aWYoSCE9PXZvaWQgMClpZigvXFxuLy50ZXN0KEgpKXtsZXQgY2U9UmVba2UrMV07aGUucHVzaChiKGdlLF8oaGUpLE5lLGNlKSl9ZWxzZSBoZS5wdXNoKERlKTtlbHNle2xldCBjZT1SZVtrZSsxXTtoZS5wdXNoKHgoZ2UsXyhoZSksTmUsY2UpKX19ZWxzZS9cXG4vLnRlc3QoUGUpP1BlLm1hdGNoKC9cXG4vZykubGVuZ3RoPjEmJmhlLnB1c2goXCJcIix1KTpoZS5wdXNoKFwiXCIsRGUpfWVsc2V7bGV0IFBlPXNlKCk7aGUucHVzaChQZSk7bGV0IG9lPVJlW2tlKzFdO2lmKG9lJiZ1ZShvZSkpe2xldCBjZT1LKFMob2UpKS5zcGxpdChsZSlbMF07aGUucHVzaCh4KGdlLGNlLE5lLG9lKSl9ZWxzZSBoZS5wdXNoKHUpfX0sXCJjaGlsZHJlblwiKSxoZX1mdW5jdGlvbiB4KFUsWixzZSxEZSl7cmV0dXJuIFU/XCJcIjpzZS50eXBlPT09XCJKU1hFbGVtZW50XCImJiFzZS5jbG9zaW5nRWxlbWVudHx8RGUmJkRlLnR5cGU9PT1cIkpTWEVsZW1lbnRcIiYmIURlLmNsb3NpbmdFbGVtZW50P1oubGVuZ3RoPT09MT9pOnU6aX1mdW5jdGlvbiBiKFUsWixzZSxEZSl7cmV0dXJuIFU/dTpaLmxlbmd0aD09PTE/c2UudHlwZT09PVwiSlNYRWxlbWVudFwiJiYhc2UuY2xvc2luZ0VsZW1lbnR8fERlJiZEZS50eXBlPT09XCJKU1hFbGVtZW50XCImJiFEZS5jbG9zaW5nRWxlbWVudD91Omk6dX1mdW5jdGlvbiBCKFUsWixzZSl7bGV0IERlPVUuZ2V0UGFyZW50Tm9kZSgpO2lmKCFEZXx8e0FycmF5RXhwcmVzc2lvbjohMCxKU1hBdHRyaWJ1dGU6ITAsSlNYRWxlbWVudDohMCxKU1hFeHByZXNzaW9uQ29udGFpbmVyOiEwLEpTWEZyYWdtZW50OiEwLEV4cHJlc3Npb25TdGF0ZW1lbnQ6ITAsQ2FsbEV4cHJlc3Npb246ITAsT3B0aW9uYWxDYWxsRXhwcmVzc2lvbjohMCxDb25kaXRpb25hbEV4cHJlc3Npb246ITAsSnNFeHByZXNzaW9uUm9vdDohMH1bRGUudHlwZV0pcmV0dXJuIFo7bGV0IGhlPVUubWF0Y2godm9pZCAwLGtlPT5rZS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiLE4sa2U9PmtlLnR5cGU9PT1cIkpTWEV4cHJlc3Npb25Db250YWluZXJcIiksd2U9bShVLHNlKTtyZXR1cm4gbChbd2U/XCJcIjpnKFwiKFwiKSxwKFtpLFpdKSxpLHdlP1wiXCI6ZyhcIilcIildLHtzaG91bGRCcmVhazpoZX0pfWZ1bmN0aW9uIGsoVSxaLHNlKXtsZXQgRGU9VS5nZXRWYWx1ZSgpLGdlPVtdO2lmKGdlLnB1c2goc2UoXCJuYW1lXCIpKSxEZS52YWx1ZSl7bGV0IGhlO2lmKEkoRGUudmFsdWUpKXtsZXQga2U9UyhEZS52YWx1ZSkuc2xpY2UoMSwtMSkucmVwbGFjZSgvJmFwb3M7L2csXCInXCIpLnJlcGxhY2UoLyZxdW90Oy9nLCdcIicpLHtlc2NhcGVkOlJlLHF1b3RlOk5lLHJlZ2V4OlBlfT13KGtlLFouanN4U2luZ2xlUXVvdGU/XCInXCI6J1wiJyk7a2U9a2UucmVwbGFjZShQZSxSZSk7bGV0e2xlYWRpbmc6b2UsdHJhaWxpbmc6SH09VS5jYWxsKCgpPT5hKFUsWiksXCJ2YWx1ZVwiKTtoZT1bb2UsTmUsa2UsTmUsSF19ZWxzZSBoZT1zZShcInZhbHVlXCIpO2dlLnB1c2goXCI9XCIsaGUpfXJldHVybiBnZX1mdW5jdGlvbiBNKFUsWixzZSl7bGV0IERlPVUuZ2V0VmFsdWUoKSxnZT0oaGUsd2UpPT5oZS50eXBlPT09XCJKU1hFbXB0eUV4cHJlc3Npb25cInx8ISQoaGUpJiYoaGUudHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCJ8fGhlLnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cInx8aGUudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cInx8aGUudHlwZT09PVwiQXdhaXRFeHByZXNzaW9uXCImJihnZShoZS5hcmd1bWVudCxoZSl8fGhlLmFyZ3VtZW50LnR5cGU9PT1cIkpTWEVsZW1lbnRcIil8fE4oaGUpfHxoZS50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8aGUudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCJ8fGhlLnR5cGU9PT1cIlRhZ2dlZFRlbXBsYXRlRXhwcmVzc2lvblwifHxoZS50eXBlPT09XCJEb0V4cHJlc3Npb25cInx8Rih3ZSkmJihoZS50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cInx8UChoZSkpKTtyZXR1cm4gZ2UoRGUuZXhwcmVzc2lvbixVLmdldFBhcmVudE5vZGUoMCkpP2woW1wie1wiLHNlKFwiZXhwcmVzc2lvblwiKSxjLFwifVwiXSk6bChbXCJ7XCIscChbaSxzZShcImV4cHJlc3Npb25cIildKSxpLGMsXCJ9XCJdKX1mdW5jdGlvbiBSKFUsWixzZSl7bGV0IERlPVUuZ2V0VmFsdWUoKSxnZT1EZS5uYW1lJiYkKERlLm5hbWUpfHxEZS50eXBlUGFyYW1ldGVycyYmJChEZS50eXBlUGFyYW1ldGVycyk7aWYoRGUuc2VsZkNsb3NpbmcmJkRlLmF0dHJpYnV0ZXMubGVuZ3RoPT09MCYmIWdlKXJldHVybltcIjxcIixzZShcIm5hbWVcIiksc2UoXCJ0eXBlUGFyYW1ldGVyc1wiKSxcIiAvPlwiXTtpZihEZS5hdHRyaWJ1dGVzJiZEZS5hdHRyaWJ1dGVzLmxlbmd0aD09PTEmJkRlLmF0dHJpYnV0ZXNbMF0udmFsdWUmJkkoRGUuYXR0cmlidXRlc1swXS52YWx1ZSkmJiFEZS5hdHRyaWJ1dGVzWzBdLnZhbHVlLnZhbHVlLmluY2x1ZGVzKGBcbmApJiYhZ2UmJiEkKERlLmF0dHJpYnV0ZXNbMF0pKXJldHVybiBsKFtcIjxcIixzZShcIm5hbWVcIiksc2UoXCJ0eXBlUGFyYW1ldGVyc1wiKSxcIiBcIiwuLi5VLm1hcChzZSxcImF0dHJpYnV0ZXNcIiksRGUuc2VsZkNsb3Npbmc/XCIgLz5cIjpcIj5cIl0pO2xldCBoZT1EZS5hdHRyaWJ1dGVzJiZEZS5hdHRyaWJ1dGVzLnNvbWUoa2U9PmtlLnZhbHVlJiZJKGtlLnZhbHVlKSYma2UudmFsdWUudmFsdWUuaW5jbHVkZXMoYFxuYCkpLHdlPVouc2luZ2xlQXR0cmlidXRlUGVyTGluZSYmRGUuYXR0cmlidXRlcy5sZW5ndGg+MT91Om47cmV0dXJuIGwoW1wiPFwiLHNlKFwibmFtZVwiKSxzZShcInR5cGVQYXJhbWV0ZXJzXCIpLHAoVS5tYXAoKCk9Plt3ZSxzZSgpXSxcImF0dHJpYnV0ZXNcIikpLC4uLnEoRGUsWixnZSldLHtzaG91bGRCcmVhazpoZX0pfWZ1bmN0aW9uIHEoVSxaLHNlKXtyZXR1cm4gVS5zZWxmQ2xvc2luZz9bbixcIi8+XCJdOkooVSxaLHNlKT9bXCI+XCJdOltpLFwiPlwiXX1mdW5jdGlvbiBKKFUsWixzZSl7bGV0IERlPVUuYXR0cmlidXRlcy5sZW5ndGg+MCYmJChfKFUuYXR0cmlidXRlcyksZi5UcmFpbGluZyk7cmV0dXJuIFUuYXR0cmlidXRlcy5sZW5ndGg9PT0wJiYhc2V8fChaLmJyYWNrZXRTYW1lTGluZXx8Wi5qc3hCcmFja2V0U2FtZUxpbmUpJiYoIXNlfHxVLmF0dHJpYnV0ZXMubGVuZ3RoPjApJiYhRGV9ZnVuY3Rpb24gTChVLFosc2Upe2xldCBEZT1VLmdldFZhbHVlKCksZ2U9W107Z2UucHVzaChcIjwvXCIpO2xldCBoZT1zZShcIm5hbWVcIik7cmV0dXJuICQoRGUubmFtZSxmLkxlYWRpbmd8Zi5MaW5lKT9nZS5wdXNoKHAoW3UsaGVdKSx1KTokKERlLm5hbWUsZi5MZWFkaW5nfGYuQmxvY2spP2dlLnB1c2goXCIgXCIsaGUpOmdlLnB1c2goaGUpLGdlLnB1c2goXCI+XCIpLGdlfWZ1bmN0aW9uIFEoVSxaKXtsZXQgc2U9VS5nZXRWYWx1ZSgpLERlPSQoc2UpLGdlPSQoc2UsZi5MaW5lKSxoZT1zZS50eXBlPT09XCJKU1hPcGVuaW5nRnJhZ21lbnRcIjtyZXR1cm5baGU/XCI8XCI6XCI8L1wiLHAoW2dlP3U6RGUmJiFoZT9cIiBcIjpcIlwiLHMoVSxaLCEwKV0pLGdlP3U6XCJcIixcIj5cIl19ZnVuY3Rpb24gVihVLFosc2Upe2xldCBEZT10KFUsaChVLFosc2UpLFopO3JldHVybiBCKFUsRGUsWil9ZnVuY3Rpb24gaihVLFope2xldCBzZT1VLmdldFZhbHVlKCksRGU9JChzZSxmLkxpbmUpO3JldHVybltzKFUsWiwhRGUpLERlP3U6XCJcIl19ZnVuY3Rpb24gWShVLFosc2Upe2xldCBEZT1VLmdldFZhbHVlKCk7cmV0dXJuW1wie1wiLFUuY2FsbChnZT0+e2xldCBoZT1bXCIuLi5cIixzZSgpXSx3ZT1nZS5nZXRWYWx1ZSgpO3JldHVybiEkKHdlKXx8IXYoZ2UpP2hlOltwKFtpLHQoZ2UsaGUsWildKSxpXX0sRGUudHlwZT09PVwiSlNYU3ByZWFkQXR0cmlidXRlXCI/XCJhcmd1bWVudFwiOlwiZXhwcmVzc2lvblwiKSxcIn1cIl19ZnVuY3Rpb24gaWUoVSxaLHNlKXtsZXQgRGU9VS5nZXRWYWx1ZSgpO2lmKERlLnR5cGUuc3RhcnRzV2l0aChcIkpTWFwiKSlzd2l0Y2goRGUudHlwZSl7Y2FzZVwiSlNYQXR0cmlidXRlXCI6cmV0dXJuIGsoVSxaLHNlKTtjYXNlXCJKU1hJZGVudGlmaWVyXCI6cmV0dXJuIFN0cmluZyhEZS5uYW1lKTtjYXNlXCJKU1hOYW1lc3BhY2VkTmFtZVwiOnJldHVybiBEKFwiOlwiLFtzZShcIm5hbWVzcGFjZVwiKSxzZShcIm5hbWVcIildKTtjYXNlXCJKU1hNZW1iZXJFeHByZXNzaW9uXCI6cmV0dXJuIEQoXCIuXCIsW3NlKFwib2JqZWN0XCIpLHNlKFwicHJvcGVydHlcIildKTtjYXNlXCJKU1hTcHJlYWRBdHRyaWJ1dGVcIjpyZXR1cm4gWShVLFosc2UpO2Nhc2VcIkpTWFNwcmVhZENoaWxkXCI6cmV0dXJuIFkoVSxaLHNlKTtjYXNlXCJKU1hFeHByZXNzaW9uQ29udGFpbmVyXCI6cmV0dXJuIE0oVSxaLHNlKTtjYXNlXCJKU1hGcmFnbWVudFwiOmNhc2VcIkpTWEVsZW1lbnRcIjpyZXR1cm4gVihVLFosc2UpO2Nhc2VcIkpTWE9wZW5pbmdFbGVtZW50XCI6cmV0dXJuIFIoVSxaLHNlKTtjYXNlXCJKU1hDbG9zaW5nRWxlbWVudFwiOnJldHVybiBMKFUsWixzZSk7Y2FzZVwiSlNYT3BlbmluZ0ZyYWdtZW50XCI6Y2FzZVwiSlNYQ2xvc2luZ0ZyYWdtZW50XCI6cmV0dXJuIFEoVSxaKTtjYXNlXCJKU1hFbXB0eUV4cHJlc3Npb25cIjpyZXR1cm4gaihVLFopO2Nhc2VcIkpTWFRleHRcIjp0aHJvdyBuZXcgRXJyb3IoXCJKU1hUZXh0IHNob3VsZCBiZSBoYW5kbGVkIGJ5IEpTWEVsZW1lbnRcIik7ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSlNYIG5vZGUgdHlwZTogJHtKU09OLnN0cmluZ2lmeShEZS50eXBlKX0uYCl9fXZhciBlZT1gIFxuXFxyXHRgLGxlPW5ldyBSZWdFeHAoXCIoW1wiK2VlK1wiXSspXCIpLFc9bmV3IFJlZ0V4cChcIlteXCIrZWUrXCJdXCIpLEs9VT0+VS5yZXBsYWNlKG5ldyBSZWdFeHAoXCIoPzpeXCIrbGUuc291cmNlK1wifFwiK2xlLnNvdXJjZStcIiQpXCIpLFwiXCIpO2Z1bmN0aW9uIGRlKFUpe2lmKFUuY2hpbGRyZW4ubGVuZ3RoPT09MClyZXR1cm4hMDtpZihVLmNoaWxkcmVuLmxlbmd0aD4xKXJldHVybiExO2xldCBaPVUuY2hpbGRyZW5bMF07cmV0dXJuIFoudHlwZT09PVwiSlNYVGV4dFwiJiYhdWUoWil9ZnVuY3Rpb24gdWUoVSl7cmV0dXJuIFUudHlwZT09PVwiSlNYVGV4dFwiJiYoVy50ZXN0KFMoVSkpfHwhL1xcbi8udGVzdChTKFUpKSl9ZnVuY3Rpb24gRmUoVSl7cmV0dXJuIFUudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiJiZJKFUuZXhwcmVzc2lvbikmJlUuZXhwcmVzc2lvbi52YWx1ZT09PVwiIFwiJiYhJChVLmV4cHJlc3Npb24pfWZ1bmN0aW9uIHooVSl7bGV0IFo9VS5nZXRWYWx1ZSgpLHNlPVUuZ2V0UGFyZW50Tm9kZSgpO2lmKCFzZXx8IVp8fCFGKFopfHwhRihzZSkpcmV0dXJuITE7bGV0IERlPXNlLmNoaWxkcmVuLmluZGV4T2YoWiksZ2U9bnVsbDtmb3IobGV0IGhlPURlO2hlPjA7aGUtLSl7bGV0IHdlPXNlLmNoaWxkcmVuW2hlLTFdO2lmKCEod2UudHlwZT09PVwiSlNYVGV4dFwiJiYhdWUod2UpKSl7Z2U9d2U7YnJlYWt9fXJldHVybiBnZSYmZ2UudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiJiZnZS5leHByZXNzaW9uLnR5cGU9PT1cIkpTWEVtcHR5RXhwcmVzc2lvblwiJiZUKGdlLmV4cHJlc3Npb24pfXIuZXhwb3J0cz17aGFzSnN4SWdub3JlQ29tbWVudDp6LHByaW50SnN4OmllfX19KSxjdD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvbWlzYy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7aXNOb25FbXB0eUFycmF5OnR9PVVlKCkse2J1aWxkZXJzOntpbmRlbnQ6cyxqb2luOmEsbGluZTpufX09cWUoKSx7aXNGbG93QW5ub3RhdGlvbkNvbW1lbnQ6dX09S2UoKTtmdW5jdGlvbiBpKF8pe2xldCB3PV8uZ2V0VmFsdWUoKTtyZXR1cm4hdy5vcHRpb25hbHx8dy50eXBlPT09XCJJZGVudGlmaWVyXCImJnc9PT1fLmdldFBhcmVudE5vZGUoKS5rZXk/XCJcIjp3LnR5cGU9PT1cIk9wdGlvbmFsQ2FsbEV4cHJlc3Npb25cInx8dy50eXBlPT09XCJPcHRpb25hbE1lbWJlckV4cHJlc3Npb25cIiYmdy5jb21wdXRlZD9cIj8uXCI6XCI/XCJ9ZnVuY3Rpb24gbChfKXtyZXR1cm4gXy5nZXRWYWx1ZSgpLmRlZmluaXRlfHxfLm1hdGNoKHZvaWQgMCwodyxGKT0+Rj09PVwiaWRcIiYmdy50eXBlPT09XCJWYXJpYWJsZURlY2xhcmF0b3JcIiYmdy5kZWZpbml0ZSk/XCIhXCI6XCJcIn1mdW5jdGlvbiBwKF8sdyxGKXtsZXQgUz1fLmdldFZhbHVlKCk7cmV0dXJuIFMudHlwZUFyZ3VtZW50cz9GKFwidHlwZUFyZ3VtZW50c1wiKTpTLnR5cGVQYXJhbWV0ZXJzP0YoXCJ0eXBlUGFyYW1ldGVyc1wiKTpcIlwifWZ1bmN0aW9uIGQoXyx3LEYpe2xldCBTPV8uZ2V0VmFsdWUoKTtpZighUy50eXBlQW5ub3RhdGlvbilyZXR1cm5cIlwiO2xldCBOPV8uZ2V0UGFyZW50Tm9kZSgpLEk9Ti50eXBlPT09XCJEZWNsYXJlRnVuY3Rpb25cIiYmTi5pZD09PVM7cmV0dXJuIHUody5vcmlnaW5hbFRleHQsUy50eXBlQW5ub3RhdGlvbik/W1wiIC8qOiBcIixGKFwidHlwZUFubm90YXRpb25cIiksXCIgKi9cIl06W0k/XCJcIjpcIjogXCIsRihcInR5cGVBbm5vdGF0aW9uXCIpXX1mdW5jdGlvbiB5KF8sdyxGKXtyZXR1cm5bXCI6OlwiLEYoXCJjYWxsZWVcIildfWZ1bmN0aW9uIGcoXyx3LEYpe2xldCBTPV8uZ2V0VmFsdWUoKTtyZXR1cm4gdChTLm1vZGlmaWVycyk/W2EoXCIgXCIsXy5tYXAoRixcIm1vZGlmaWVyc1wiKSksXCIgXCJdOlwiXCJ9ZnVuY3Rpb24gYyhfLHcsRil7cmV0dXJuIF8udHlwZT09PVwiRW1wdHlTdGF0ZW1lbnRcIj9cIjtcIjpfLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCJ8fEY/W1wiIFwiLHddOnMoW24sd10pfWZ1bmN0aW9uIEQoXyx3LEYpe3JldHVybltcIi4uLlwiLEYoXCJhcmd1bWVudFwiKSxkKF8sdyxGKV19ZnVuY3Rpb24gRShfLHcpe2xldCBGPV8uc2xpY2UoMSwtMSk7aWYoRi5pbmNsdWRlcygnXCInKXx8Ri5pbmNsdWRlcyhcIidcIikpcmV0dXJuIF87bGV0IFM9dy5zaW5nbGVRdW90ZT9cIidcIjonXCInO3JldHVybiBTK0YrU31yLmV4cG9ydHM9e3ByaW50T3B0aW9uYWxUb2tlbjppLHByaW50RGVmaW5pdGVUb2tlbjpsLHByaW50RnVuY3Rpb25UeXBlUGFyYW1ldGVyczpwLHByaW50QmluZEV4cHJlc3Npb25DYWxsZWU6eSxwcmludFR5cGVTY3JpcHRNb2RpZmllcnM6ZyxwcmludFR5cGVBbm5vdGF0aW9uOmQscHJpbnRSZXN0U3ByZWFkOkQsYWRqdXN0Q2xhdXNlOmMscHJpbnREaXJlY3RpdmU6RX19fSksZXI9dGUoe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2FycmF5LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntwcmludERhbmdsaW5nQ29tbWVudHM6dH09ZXQoKSx7YnVpbGRlcnM6e2xpbmU6cyxzb2Z0bGluZTphLGhhcmRsaW5lOm4sZ3JvdXA6dSxpbmRlbnQ6aSxpZkJyZWFrOmwsZmlsbDpwfX09cWUoKSx7Z2V0TGFzdDpkLGhhc05ld2xpbmU6eX09VWUoKSx7c2hvdWxkUHJpbnRDb21tYTpnLGhhc0NvbW1lbnQ6YyxDb21tZW50Q2hlY2tGbGFnczpELGlzTmV4dExpbmVFbXB0eTpFLGlzTnVtZXJpY0xpdGVyYWw6Xyxpc1NpZ25lZE51bWVyaWNMaXRlcmFsOnd9PUtlKCkse2xvY1N0YXJ0OkZ9PXV0KCkse3ByaW50T3B0aW9uYWxUb2tlbjpTLHByaW50VHlwZUFubm90YXRpb246Tn09Y3QoKTtmdW5jdGlvbiBJKFQsbSx2KXtsZXQgbz1ULmdldFZhbHVlKCksaD1bXSxDPW8udHlwZT09PVwiVHVwbGVFeHByZXNzaW9uXCI/XCIjW1wiOlwiW1wiLHg9XCJdXCI7aWYoby5lbGVtZW50cy5sZW5ndGg9PT0wKWMobyxELkRhbmdsaW5nKT9oLnB1c2godShbQyx0KFQsbSksYSx4XSkpOmgucHVzaChDLHgpO2Vsc2V7bGV0IGI9ZChvLmVsZW1lbnRzKSxCPSEoYiYmYi50eXBlPT09XCJSZXN0RWxlbWVudFwiKSxrPWI9PT1udWxsLE09U3ltYm9sKFwiYXJyYXlcIiksUj0hbS5fX2luSmVzdEVhY2gmJm8uZWxlbWVudHMubGVuZ3RoPjEmJm8uZWxlbWVudHMuZXZlcnkoKEwsUSxWKT0+e2xldCBqPUwmJkwudHlwZTtpZihqIT09XCJBcnJheUV4cHJlc3Npb25cIiYmaiE9PVwiT2JqZWN0RXhwcmVzc2lvblwiKXJldHVybiExO2xldCBZPVZbUSsxXTtpZihZJiZqIT09WS50eXBlKXJldHVybiExO2xldCBpZT1qPT09XCJBcnJheUV4cHJlc3Npb25cIj9cImVsZW1lbnRzXCI6XCJwcm9wZXJ0aWVzXCI7cmV0dXJuIExbaWVdJiZMW2llXS5sZW5ndGg+MX0pLHE9UChvLG0pLEo9Qj9rP1wiLFwiOmcobSk/cT9sKFwiLFwiLFwiXCIse2dyb3VwSWQ6TX0pOmwoXCIsXCIpOlwiXCI6XCJcIjtoLnB1c2godShbQyxpKFthLHE/ZihULG0sdixKKTpbJChULG0sXCJlbGVtZW50c1wiLHYpLEpdLHQoVCxtLCEwKV0pLGEseF0se3Nob3VsZEJyZWFrOlIsaWQ6TX0pKX1yZXR1cm4gaC5wdXNoKFMoVCksTihULG0sdikpLGh9ZnVuY3Rpb24gUChULG0pe3JldHVybiBULmVsZW1lbnRzLmxlbmd0aD4xJiZULmVsZW1lbnRzLmV2ZXJ5KHY9PnYmJihfKHYpfHx3KHYpJiYhYyh2LmFyZ3VtZW50KSkmJiFjKHYsRC5UcmFpbGluZ3xELkxpbmUsbz0+IXkobS5vcmlnaW5hbFRleHQsRihvKSx7YmFja3dhcmRzOiEwfSkpKX1mdW5jdGlvbiAkKFQsbSx2LG8pe2xldCBoPVtdLEM9W107cmV0dXJuIFQuZWFjaCh4PT57aC5wdXNoKEMsdShvKCkpKSxDPVtcIixcIixzXSx4LmdldFZhbHVlKCkmJkUoeC5nZXRWYWx1ZSgpLG0pJiZDLnB1c2goYSl9LHYpLGh9ZnVuY3Rpb24gZihULG0sdixvKXtsZXQgaD1bXTtyZXR1cm4gVC5lYWNoKChDLHgsYik9PntsZXQgQj14PT09Yi5sZW5ndGgtMTtoLnB1c2goW3YoKSxCP286XCIsXCJdKSxCfHxoLnB1c2goRShDLmdldFZhbHVlKCksbSk/W24sbl06YyhiW3grMV0sRC5MZWFkaW5nfEQuTGluZSk/bjpzKX0sXCJlbGVtZW50c1wiKSxwKGgpfXIuZXhwb3J0cz17cHJpbnRBcnJheTpJLHByaW50QXJyYXlJdGVtczokLGlzQ29uY2lzZWx5UHJpbnRlZEFycmF5OlB9fX0pLEFvPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9jYWxsLWFyZ3VtZW50cy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7cHJpbnREYW5nbGluZ0NvbW1lbnRzOnR9PWV0KCkse2dldExhc3Q6cyxnZXRQZW51bHRpbWF0ZTphfT1VZSgpLHtnZXRGdW5jdGlvblBhcmFtZXRlcnM6bixoYXNDb21tZW50OnUsQ29tbWVudENoZWNrRmxhZ3M6aSxpc0Z1bmN0aW9uQ29tcG9zaXRpb25BcmdzOmwsaXNKc3hOb2RlOnAsaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uOmQsc2hvdWxkUHJpbnRDb21tYTp5LGdldENhbGxBcmd1bWVudHM6ZyxpdGVyYXRlQ2FsbEFyZ3VtZW50c1BhdGg6Yyxpc05leHRMaW5lRW1wdHk6RCxpc0NhbGxFeHByZXNzaW9uOkUsaXNTdHJpbmdMaXRlcmFsOl8saXNPYmplY3RQcm9wZXJ0eTp3LGlzVFNUeXBlRXhwcmVzc2lvbjpGfT1LZSgpLHtidWlsZGVyczp7bGluZTpTLGhhcmRsaW5lOk4sc29mdGxpbmU6SSxncm91cDpQLGluZGVudDokLGNvbmRpdGlvbmFsR3JvdXA6ZixpZkJyZWFrOlQsYnJlYWtQYXJlbnQ6bX0sdXRpbHM6e3dpbGxCcmVhazp2fX09cWUoKSx7QXJnRXhwYW5zaW9uQmFpbG91dDpvfT1RdCgpLHtpc0NvbmNpc2VseVByaW50ZWRBcnJheTpofT1lcigpO2Z1bmN0aW9uIEMocSxKLEwpe2xldCBRPXEuZ2V0VmFsdWUoKSxWPVEudHlwZT09PVwiSW1wb3J0RXhwcmVzc2lvblwiLGo9ZyhRKTtpZihqLmxlbmd0aD09PTApcmV0dXJuW1wiKFwiLHQocSxKLCEwKSxcIilcIl07aWYoayhqKSlyZXR1cm5bXCIoXCIsTChbXCJhcmd1bWVudHNcIiwwXSksXCIsIFwiLEwoW1wiYXJndW1lbnRzXCIsMV0pLFwiKVwiXTtsZXQgWT0hMSxpZT0hMSxlZT1qLmxlbmd0aC0xLGxlPVtdO2MocSwoeixVKT0+e2xldCBaPXouZ2V0Tm9kZSgpLHNlPVtMKCldO1U9PT1lZXx8KEQoWixKKT8oVT09PTAmJihpZT0hMCksWT0hMCxzZS5wdXNoKFwiLFwiLE4sTikpOnNlLnB1c2goXCIsXCIsUykpLGxlLnB1c2goc2UpfSk7bGV0IFc9IShWfHxRLmNhbGxlZSYmUS5jYWxsZWUudHlwZT09PVwiSW1wb3J0XCIpJiZ5KEosXCJhbGxcIik/XCIsXCI6XCJcIjtmdW5jdGlvbiBLKCl7cmV0dXJuIFAoW1wiKFwiLCQoW1MsLi4ubGVdKSxXLFMsXCIpXCJdLHtzaG91bGRCcmVhazohMH0pfWlmKFl8fHEuZ2V0UGFyZW50Tm9kZSgpLnR5cGUhPT1cIkRlY29yYXRvclwiJiZsKGopKXJldHVybiBLKCk7bGV0IGRlPUIoaiksdWU9YihqLEopO2lmKGRlfHx1ZSl7aWYoZGU/bGUuc2xpY2UoMSkuc29tZSh2KTpsZS5zbGljZSgwLC0xKS5zb21lKHYpKXJldHVybiBLKCk7bGV0IHo9W107dHJ5e3EudHJ5KCgpPT57YyhxLChVLFopPT57ZGUmJlo9PT0wJiYoej1bW0woW10se2V4cGFuZEZpcnN0QXJnOiEwfSksbGUubGVuZ3RoPjE/XCIsXCI6XCJcIixpZT9OOlMsaWU/TjpcIlwiXSwuLi5sZS5zbGljZSgxKV0pLHVlJiZaPT09ZWUmJih6PVsuLi5sZS5zbGljZSgwLC0xKSxMKFtdLHtleHBhbmRMYXN0QXJnOiEwfSldKX0pfSl9Y2F0Y2goVSl7aWYoVSBpbnN0YW5jZW9mIG8pcmV0dXJuIEsoKTt0aHJvdyBVfXJldHVybltsZS5zb21lKHYpP206XCJcIixmKFtbXCIoXCIsLi4ueixcIilcIl0sZGU/W1wiKFwiLFAoelswXSx7c2hvdWxkQnJlYWs6ITB9KSwuLi56LnNsaWNlKDEpLFwiKVwiXTpbXCIoXCIsLi4ubGUuc2xpY2UoMCwtMSksUChzKHopLHtzaG91bGRCcmVhazohMH0pLFwiKVwiXSxLKCldKV19bGV0IEZlPVtcIihcIiwkKFtJLC4uLmxlXSksVChXKSxJLFwiKVwiXTtyZXR1cm4gZChxKT9GZTpQKEZlLHtzaG91bGRCcmVhazpsZS5zb21lKHYpfHxZfSl9ZnVuY3Rpb24geChxKXtsZXQgSj1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06ITE7cmV0dXJuIHEudHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwiJiYocS5wcm9wZXJ0aWVzLmxlbmd0aD4wfHx1KHEpKXx8cS50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cIiYmKHEuZWxlbWVudHMubGVuZ3RoPjB8fHUocSkpfHxxLnR5cGU9PT1cIlRTVHlwZUFzc2VydGlvblwiJiZ4KHEuZXhwcmVzc2lvbil8fEYocSkmJngocS5leHByZXNzaW9uKXx8cS50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8cS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiYoIXEucmV0dXJuVHlwZXx8IXEucmV0dXJuVHlwZS50eXBlQW5ub3RhdGlvbnx8cS5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uLnR5cGUhPT1cIlRTVHlwZVJlZmVyZW5jZVwifHxNKHEuYm9keSkpJiYocS5ib2R5LnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCJ8fHEuYm9keS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZ4KHEuYm9keSwhMCl8fHEuYm9keS50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fHEuYm9keS50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cInx8IUomJihFKHEuYm9keSl8fHEuYm9keS50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil8fHAocS5ib2R5KSl8fHEudHlwZT09PVwiRG9FeHByZXNzaW9uXCJ8fHEudHlwZT09PVwiTW9kdWxlRXhwcmVzc2lvblwifWZ1bmN0aW9uIGIocSxKKXtsZXQgTD1zKHEpLFE9YShxKTtyZXR1cm4hdShMLGkuTGVhZGluZykmJiF1KEwsaS5UcmFpbGluZykmJngoTCkmJighUXx8US50eXBlIT09TC50eXBlKSYmKHEubGVuZ3RoIT09Mnx8US50eXBlIT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHxMLnR5cGUhPT1cIkFycmF5RXhwcmVzc2lvblwiKSYmIShxLmxlbmd0aD4xJiZMLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiJiZoKEwsSikpfWZ1bmN0aW9uIEIocSl7aWYocS5sZW5ndGghPT0yKXJldHVybiExO2xldFtKLExdPXE7cmV0dXJuIEoudHlwZT09PVwiTW9kdWxlRXhwcmVzc2lvblwiJiZSKEwpPyEwOiF1KEopJiYoSi50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8Si50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiJiZKLmJvZHkudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIikmJkwudHlwZSE9PVwiRnVuY3Rpb25FeHByZXNzaW9uXCImJkwudHlwZSE9PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiYmTC50eXBlIT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiYmIXgoTCl9ZnVuY3Rpb24gayhxKXtyZXR1cm4gcS5sZW5ndGg9PT0yJiZxWzBdLnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCImJm4ocVswXSkubGVuZ3RoPT09MCYmcVswXS5ib2R5LnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCImJnFbMV0udHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCImJiFxLnNvbWUoSj0+dShKKSl9ZnVuY3Rpb24gTShxKXtyZXR1cm4gcS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiJiYocS5ib2R5LnNvbWUoSj0+Si50eXBlIT09XCJFbXB0eVN0YXRlbWVudFwiKXx8dShxLGkuRGFuZ2xpbmcpKX1mdW5jdGlvbiBSKHEpe3JldHVybiBxLnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cIiYmcS5wcm9wZXJ0aWVzLmxlbmd0aD09PTEmJncocS5wcm9wZXJ0aWVzWzBdKSYmcS5wcm9wZXJ0aWVzWzBdLmtleS50eXBlPT09XCJJZGVudGlmaWVyXCImJnEucHJvcGVydGllc1swXS5rZXkubmFtZT09PVwidHlwZVwiJiZfKHEucHJvcGVydGllc1swXS52YWx1ZSkmJnEucHJvcGVydGllc1swXS52YWx1ZS52YWx1ZT09PVwibW9kdWxlXCJ9ci5leHBvcnRzPUN9fSksU289dGUoe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L21lbWJlci5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7YnVpbGRlcnM6e3NvZnRsaW5lOnQsZ3JvdXA6cyxpbmRlbnQ6YSxsYWJlbDpufX09cWUoKSx7aXNOdW1lcmljTGl0ZXJhbDp1LGlzTWVtYmVyRXhwcmVzc2lvbjppLGlzQ2FsbEV4cHJlc3Npb246bH09S2UoKSx7cHJpbnRPcHRpb25hbFRva2VuOnB9PWN0KCk7ZnVuY3Rpb24gZChnLGMsRCl7bGV0IEU9Zy5nZXRWYWx1ZSgpLF89Zy5nZXRQYXJlbnROb2RlKCksdyxGPTA7ZG8gdz1nLmdldFBhcmVudE5vZGUoRiksRisrO3doaWxlKHcmJihpKHcpfHx3LnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cIikpO2xldCBTPUQoXCJvYmplY3RcIiksTj15KGcsYyxEKSxJPXcmJih3LnR5cGU9PT1cIk5ld0V4cHJlc3Npb25cInx8dy50eXBlPT09XCJCaW5kRXhwcmVzc2lvblwifHx3LnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCImJncubGVmdC50eXBlIT09XCJJZGVudGlmaWVyXCIpfHxFLmNvbXB1dGVkfHxFLm9iamVjdC50eXBlPT09XCJJZGVudGlmaWVyXCImJkUucHJvcGVydHkudHlwZT09PVwiSWRlbnRpZmllclwiJiYhaShfKXx8KF8udHlwZT09PVwiQXNzaWdubWVudEV4cHJlc3Npb25cInx8Xy50eXBlPT09XCJWYXJpYWJsZURlY2xhcmF0b3JcIikmJihsKEUub2JqZWN0KSYmRS5vYmplY3QuYXJndW1lbnRzLmxlbmd0aD4wfHxFLm9iamVjdC50eXBlPT09XCJUU05vbk51bGxFeHByZXNzaW9uXCImJmwoRS5vYmplY3QuZXhwcmVzc2lvbikmJkUub2JqZWN0LmV4cHJlc3Npb24uYXJndW1lbnRzLmxlbmd0aD4wfHxTLmxhYmVsPT09XCJtZW1iZXItY2hhaW5cIik7cmV0dXJuIG4oUy5sYWJlbD09PVwibWVtYmVyLWNoYWluXCI/XCJtZW1iZXItY2hhaW5cIjpcIm1lbWJlclwiLFtTLEk/TjpzKGEoW3QsTl0pKV0pfWZ1bmN0aW9uIHkoZyxjLEQpe2xldCBFPUQoXCJwcm9wZXJ0eVwiKSxfPWcuZ2V0VmFsdWUoKSx3PXAoZyk7cmV0dXJuIF8uY29tcHV0ZWQ/IV8ucHJvcGVydHl8fHUoXy5wcm9wZXJ0eSk/W3csXCJbXCIsRSxcIl1cIl06cyhbdyxcIltcIixhKFt0LEVdKSx0LFwiXVwiXSk6W3csXCIuXCIsRV19ci5leHBvcnRzPXtwcmludE1lbWJlckV4cHJlc3Npb246ZCxwcmludE1lbWJlckxvb2t1cDp5fX19KSxEZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvbWVtYmVyLWNoYWluLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntwcmludENvbW1lbnRzOnR9PWV0KCkse2dldExhc3Q6cyxpc05leHRMaW5lRW1wdHlBZnRlckluZGV4OmEsZ2V0TmV4dE5vblNwYWNlTm9uQ29tbWVudENoYXJhY3RlckluZGV4Om59PVVlKCksdT1xdCgpLHtpc0NhbGxFeHByZXNzaW9uOmksaXNNZW1iZXJFeHByZXNzaW9uOmwsaXNGdW5jdGlvbk9yQXJyb3dFeHByZXNzaW9uOnAsaXNMb25nQ3VycmllZENhbGxFeHByZXNzaW9uOmQsaXNNZW1iZXJpc2g6eSxpc051bWVyaWNMaXRlcmFsOmcsaXNTaW1wbGVDYWxsQXJndW1lbnQ6YyxoYXNDb21tZW50OkQsQ29tbWVudENoZWNrRmxhZ3M6RSxpc05leHRMaW5lRW1wdHk6X309S2UoKSx7bG9jRW5kOnd9PXV0KCkse2J1aWxkZXJzOntqb2luOkYsaGFyZGxpbmU6Uyxncm91cDpOLGluZGVudDpJLGNvbmRpdGlvbmFsR3JvdXA6UCxicmVha1BhcmVudDokLGxhYmVsOmZ9LHV0aWxzOnt3aWxsQnJlYWs6VH19PXFlKCksbT1BbygpLHtwcmludE1lbWJlckxvb2t1cDp2fT1TbygpLHtwcmludE9wdGlvbmFsVG9rZW46byxwcmludEZ1bmN0aW9uVHlwZVBhcmFtZXRlcnM6aCxwcmludEJpbmRFeHByZXNzaW9uQ2FsbGVlOkN9PWN0KCk7ZnVuY3Rpb24geChiLEIsayl7bGV0IE09Yi5nZXRQYXJlbnROb2RlKCksUj0hTXx8TS50eXBlPT09XCJFeHByZXNzaW9uU3RhdGVtZW50XCIscT1bXTtmdW5jdGlvbiBKKE5lKXtsZXR7b3JpZ2luYWxUZXh0OlBlfT1CLG9lPW4oUGUsTmUsdyk7cmV0dXJuIFBlLmNoYXJBdChvZSk9PT1cIilcIj9vZSE9PSExJiZhKFBlLG9lKzEpOl8oTmUsQil9ZnVuY3Rpb24gTChOZSl7bGV0IFBlPU5lLmdldFZhbHVlKCk7aShQZSkmJih5KFBlLmNhbGxlZSl8fGkoUGUuY2FsbGVlKSk/KHEudW5zaGlmdCh7bm9kZTpQZSxwcmludGVkOlt0KE5lLFtvKE5lKSxoKE5lLEIsayksbShOZSxCLGspXSxCKSxKKFBlKT9TOlwiXCJdfSksTmUuY2FsbChvZT0+TChvZSksXCJjYWxsZWVcIikpOnkoUGUpPyhxLnVuc2hpZnQoe25vZGU6UGUsbmVlZHNQYXJlbnM6dShOZSxCKSxwcmludGVkOnQoTmUsbChQZSk/dihOZSxCLGspOkMoTmUsQixrKSxCKX0pLE5lLmNhbGwob2U9Pkwob2UpLFwib2JqZWN0XCIpKTpQZS50eXBlPT09XCJUU05vbk51bGxFeHByZXNzaW9uXCI/KHEudW5zaGlmdCh7bm9kZTpQZSxwcmludGVkOnQoTmUsXCIhXCIsQil9KSxOZS5jYWxsKG9lPT5MKG9lKSxcImV4cHJlc3Npb25cIikpOnEudW5zaGlmdCh7bm9kZTpQZSxwcmludGVkOmsoKX0pfWxldCBRPWIuZ2V0VmFsdWUoKTtxLnVuc2hpZnQoe25vZGU6USxwcmludGVkOltvKGIpLGgoYixCLGspLG0oYixCLGspXX0pLFEuY2FsbGVlJiZiLmNhbGwoTmU9PkwoTmUpLFwiY2FsbGVlXCIpO2xldCBWPVtdLGo9W3FbMF1dLFk9MTtmb3IoO1k8cS5sZW5ndGgmJihxW1ldLm5vZGUudHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwifHxpKHFbWV0ubm9kZSl8fGwocVtZXS5ub2RlKSYmcVtZXS5ub2RlLmNvbXB1dGVkJiZnKHFbWV0ubm9kZS5wcm9wZXJ0eSkpOysrWSlqLnB1c2gocVtZXSk7aWYoIWkocVswXS5ub2RlKSlmb3IoO1krMTxxLmxlbmd0aCYmKHkocVtZXS5ub2RlKSYmeShxW1krMV0ubm9kZSkpOysrWSlqLnB1c2gocVtZXSk7Vi5wdXNoKGopLGo9W107bGV0IGllPSExO2Zvcig7WTxxLmxlbmd0aDsrK1kpe2lmKGllJiZ5KHFbWV0ubm9kZSkpe2lmKHFbWV0ubm9kZS5jb21wdXRlZCYmZyhxW1ldLm5vZGUucHJvcGVydHkpKXtqLnB1c2gocVtZXSk7Y29udGludWV9Vi5wdXNoKGopLGo9W10saWU9ITF9KGkocVtZXS5ub2RlKXx8cVtZXS5ub2RlLnR5cGU9PT1cIkltcG9ydEV4cHJlc3Npb25cIikmJihpZT0hMCksai5wdXNoKHFbWV0pLEQocVtZXS5ub2RlLEUuVHJhaWxpbmcpJiYoVi5wdXNoKGopLGo9W10saWU9ITEpfWoubGVuZ3RoPjAmJlYucHVzaChqKTtmdW5jdGlvbiBlZShOZSl7cmV0dXJuL15bQS1aXXxeWyRfXSskLy50ZXN0KE5lKX1mdW5jdGlvbiBsZShOZSl7cmV0dXJuIE5lLmxlbmd0aDw9Qi50YWJXaWR0aH1mdW5jdGlvbiBXKE5lKXtsZXQgUGU9TmVbMV0ubGVuZ3RoPjAmJk5lWzFdWzBdLm5vZGUuY29tcHV0ZWQ7aWYoTmVbMF0ubGVuZ3RoPT09MSl7bGV0IEg9TmVbMF1bMF0ubm9kZTtyZXR1cm4gSC50eXBlPT09XCJUaGlzRXhwcmVzc2lvblwifHxILnR5cGU9PT1cIklkZW50aWZpZXJcIiYmKGVlKEgubmFtZSl8fFImJmxlKEgubmFtZSl8fFBlKX1sZXQgb2U9cyhOZVswXSkubm9kZTtyZXR1cm4gbChvZSkmJm9lLnByb3BlcnR5LnR5cGU9PT1cIklkZW50aWZpZXJcIiYmKGVlKG9lLnByb3BlcnR5Lm5hbWUpfHxQZSl9bGV0IEs9Vi5sZW5ndGg+PTImJiFEKFZbMV1bMF0ubm9kZSkmJlcoVik7ZnVuY3Rpb24gZGUoTmUpe2xldCBQZT1OZS5tYXAob2U9Pm9lLnByaW50ZWQpO3JldHVybiBOZS5sZW5ndGg+MCYmcyhOZSkubmVlZHNQYXJlbnM/W1wiKFwiLC4uLlBlLFwiKVwiXTpQZX1mdW5jdGlvbiB1ZShOZSl7cmV0dXJuIE5lLmxlbmd0aD09PTA/XCJcIjpJKE4oW1MsRihTLE5lLm1hcChkZSkpXSkpfWxldCBGZT1WLm1hcChkZSksej1GZSxVPUs/MzoyLFo9Vi5mbGF0KCksc2U9Wi5zbGljZSgxLC0xKS5zb21lKE5lPT5EKE5lLm5vZGUsRS5MZWFkaW5nKSl8fFouc2xpY2UoMCwtMSkuc29tZShOZT0+RChOZS5ub2RlLEUuVHJhaWxpbmcpKXx8VltVXSYmRChWW1VdWzBdLm5vZGUsRS5MZWFkaW5nKTtpZihWLmxlbmd0aDw9VSYmIXNlKXJldHVybiBkKGIpP3o6Tih6KTtsZXQgRGU9cyhWW0s/MTowXSkubm9kZSxnZT0haShEZSkmJkooRGUpLGhlPVtkZShWWzBdKSxLP1Yuc2xpY2UoMSwyKS5tYXAoZGUpOlwiXCIsZ2U/UzpcIlwiLHVlKFYuc2xpY2UoSz8yOjEpKV0sd2U9cS5tYXAoTmU9PntsZXR7bm9kZTpQZX09TmU7cmV0dXJuIFBlfSkuZmlsdGVyKGkpO2Z1bmN0aW9uIGtlKCl7bGV0IE5lPXMocyhWKSkubm9kZSxQZT1zKEZlKTtyZXR1cm4gaShOZSkmJlQoUGUpJiZ3ZS5zbGljZSgwLC0xKS5zb21lKG9lPT5vZS5hcmd1bWVudHMuc29tZShwKSl9bGV0IFJlO3JldHVybiBzZXx8d2UubGVuZ3RoPjImJndlLnNvbWUoTmU9PiFOZS5hcmd1bWVudHMuZXZlcnkoUGU9PmMoUGUsMCkpKXx8RmUuc2xpY2UoMCwtMSkuc29tZShUKXx8a2UoKT9SZT1OKGhlKTpSZT1bVCh6KXx8Z2U/JDpcIlwiLFAoW3osaGVdKV0sZihcIm1lbWJlci1jaGFpblwiLFJlKX1yLmV4cG9ydHM9eH19KSx4bz10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvY2FsbC1leHByZXNzaW9uLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7am9pbjp0LGdyb3VwOnN9fT1xZSgpLGE9cXQoKSx7Z2V0Q2FsbEFyZ3VtZW50czpuLGhhc0Zsb3dBbm5vdGF0aW9uQ29tbWVudDp1LGlzQ2FsbEV4cHJlc3Npb246aSxpc01lbWJlcmlzaDpsLGlzU3RyaW5nTGl0ZXJhbDpwLGlzVGVtcGxhdGVPbkl0c093bkxpbmU6ZCxpc1Rlc3RDYWxsOnksaXRlcmF0ZUNhbGxBcmd1bWVudHNQYXRoOmd9PUtlKCksYz1EZCgpLEQ9QW8oKSx7cHJpbnRPcHRpb25hbFRva2VuOkUscHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzOl99PWN0KCk7ZnVuY3Rpb24gdyhTLE4sSSl7bGV0IFA9Uy5nZXRWYWx1ZSgpLCQ9Uy5nZXRQYXJlbnROb2RlKCksZj1QLnR5cGU9PT1cIk5ld0V4cHJlc3Npb25cIixUPVAudHlwZT09PVwiSW1wb3J0RXhwcmVzc2lvblwiLG09RShTKSx2PW4oUCk7aWYodi5sZW5ndGg+MCYmKCFUJiYhZiYmRihQLCQpfHx2Lmxlbmd0aD09PTEmJmQodlswXSxOLm9yaWdpbmFsVGV4dCl8fCFmJiZ5KFAsJCkpKXtsZXQgQz1bXTtyZXR1cm4gZyhTLCgpPT57Qy5wdXNoKEkoKSl9KSxbZj9cIm5ldyBcIjpcIlwiLEkoXCJjYWxsZWVcIiksbSxfKFMsTixJKSxcIihcIix0KFwiLCBcIixDKSxcIilcIl19bGV0IG89KE4ucGFyc2VyPT09XCJiYWJlbFwifHxOLnBhcnNlcj09PVwiYmFiZWwtZmxvd1wiKSYmUC5jYWxsZWUmJlAuY2FsbGVlLnR5cGU9PT1cIklkZW50aWZpZXJcIiYmdShQLmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzKTtpZihvJiYoUC5jYWxsZWUudHJhaWxpbmdDb21tZW50c1swXS5wcmludGVkPSEwKSwhVCYmIWYmJmwoUC5jYWxsZWUpJiYhUy5jYWxsKEM9PmEoQyxOKSxcImNhbGxlZVwiKSlyZXR1cm4gYyhTLE4sSSk7bGV0IGg9W2Y/XCJuZXcgXCI6XCJcIixUP1wiaW1wb3J0XCI6SShcImNhbGxlZVwiKSxtLG8/YC8qOjogJHtQLmNhbGxlZS50cmFpbGluZ0NvbW1lbnRzWzBdLnZhbHVlLnNsaWNlKDIpLnRyaW0oKX0gKi9gOlwiXCIsXyhTLE4sSSksRChTLE4sSSldO3JldHVybiBUfHxpKFAuY2FsbGVlKT9zKGgpOmh9ZnVuY3Rpb24gRihTLE4pe2lmKFMuY2FsbGVlLnR5cGUhPT1cIklkZW50aWZpZXJcIilyZXR1cm4hMTtpZihTLmNhbGxlZS5uYW1lPT09XCJyZXF1aXJlXCIpcmV0dXJuITA7aWYoUy5jYWxsZWUubmFtZT09PVwiZGVmaW5lXCIpe2xldCBJPW4oUyk7cmV0dXJuIE4udHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiJiYoSS5sZW5ndGg9PT0xfHxJLmxlbmd0aD09PTImJklbMF0udHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCJ8fEkubGVuZ3RoPT09MyYmcChJWzBdKSYmSVsxXS50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cIil9cmV0dXJuITF9ci5leHBvcnRzPXtwcmludENhbGxFeHByZXNzaW9uOnd9fX0pLHRyPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9hc3NpZ25tZW50LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3Zhcntpc05vbkVtcHR5QXJyYXk6dCxnZXRTdHJpbmdXaWR0aDpzfT1VZSgpLHtidWlsZGVyczp7bGluZTphLGdyb3VwOm4saW5kZW50OnUsaW5kZW50SWZCcmVhazppLGxpbmVTdWZmaXhCb3VuZGFyeTpsfSx1dGlsczp7Y2xlYW5Eb2M6cCx3aWxsQnJlYWs6ZCxjYW5CcmVhazp5fX09cWUoKSx7aGFzTGVhZGluZ093bkxpbmVDb21tZW50OmcsaXNCaW5hcnlpc2g6Yyxpc1N0cmluZ0xpdGVyYWw6RCxpc0xpdGVyYWw6RSxpc051bWVyaWNMaXRlcmFsOl8saXNDYWxsRXhwcmVzc2lvbjp3LGlzTWVtYmVyRXhwcmVzc2lvbjpGLGdldENhbGxBcmd1bWVudHM6UyxyYXdUZXh0Ok4saGFzQ29tbWVudDpJLGlzU2lnbmVkTnVtZXJpY0xpdGVyYWw6UCxpc09iamVjdFByb3BlcnR5OiR9PUtlKCkse3Nob3VsZElubGluZUxvZ2ljYWxFeHByZXNzaW9uOmZ9PXJ1KCkse3ByaW50Q2FsbEV4cHJlc3Npb246VH09eG8oKTtmdW5jdGlvbiBtKFcsSyxkZSx1ZSxGZSx6KXtsZXQgVT1oKFcsSyxkZSx1ZSx6KSxaPWRlKHose2Fzc2lnbm1lbnRMYXlvdXQ6VX0pO3N3aXRjaChVKXtjYXNlXCJicmVhay1hZnRlci1vcGVyYXRvclwiOnJldHVybiBuKFtuKHVlKSxGZSxuKHUoW2EsWl0pKV0pO2Nhc2VcIm5ldmVyLWJyZWFrLWFmdGVyLW9wZXJhdG9yXCI6cmV0dXJuIG4oW24odWUpLEZlLFwiIFwiLFpdKTtjYXNlXCJmbHVpZFwiOntsZXQgc2U9U3ltYm9sKFwiYXNzaWdubWVudFwiKTtyZXR1cm4gbihbbih1ZSksRmUsbih1KGEpLHtpZDpzZX0pLGwsaShaLHtncm91cElkOnNlfSldKX1jYXNlXCJicmVhay1saHNcIjpyZXR1cm4gbihbdWUsRmUsXCIgXCIsbihaKV0pO2Nhc2VcImNoYWluXCI6cmV0dXJuW24odWUpLEZlLGEsWl07Y2FzZVwiY2hhaW4tdGFpbFwiOnJldHVybltuKHVlKSxGZSx1KFthLFpdKV07Y2FzZVwiY2hhaW4tdGFpbC1hcnJvdy1jaGFpblwiOnJldHVybltuKHVlKSxGZSxaXTtjYXNlXCJvbmx5LWxlZnRcIjpyZXR1cm4gdWV9fWZ1bmN0aW9uIHYoVyxLLGRlKXtsZXQgdWU9Vy5nZXRWYWx1ZSgpO3JldHVybiBtKFcsSyxkZSxkZShcImxlZnRcIiksW1wiIFwiLHVlLm9wZXJhdG9yXSxcInJpZ2h0XCIpfWZ1bmN0aW9uIG8oVyxLLGRlKXtyZXR1cm4gbShXLEssZGUsZGUoXCJpZFwiKSxcIiA9XCIsXCJpbml0XCIpfWZ1bmN0aW9uIGgoVyxLLGRlLHVlLEZlKXtsZXQgej1XLmdldFZhbHVlKCksVT16W0ZlXTtpZighVSlyZXR1cm5cIm9ubHktbGVmdFwiO2xldCBaPSFiKFUpO2lmKFcubWF0Y2goYixCLGhlPT4hWnx8aGUudHlwZSE9PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiJiZoZS50eXBlIT09XCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpKXJldHVybiBaP1UudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIiYmVS5ib2R5LnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCI/XCJjaGFpbi10YWlsLWFycm93LWNoYWluXCI6XCJjaGFpbi10YWlsXCI6XCJjaGFpblwiO2lmKCFaJiZiKFUucmlnaHQpfHxnKEsub3JpZ2luYWxUZXh0LFUpKXJldHVyblwiYnJlYWstYWZ0ZXItb3BlcmF0b3JcIjtpZihVLnR5cGU9PT1cIkNhbGxFeHByZXNzaW9uXCImJlUuY2FsbGVlLm5hbWU9PT1cInJlcXVpcmVcInx8Sy5wYXJzZXI9PT1cImpzb241XCJ8fEsucGFyc2VyPT09XCJqc29uXCIpcmV0dXJuXCJuZXZlci1icmVhay1hZnRlci1vcGVyYXRvclwiO2lmKHgoeil8fGsoeil8fHEoeil8fEooeikmJnkodWUpKXJldHVyblwiYnJlYWstbGhzXCI7bGV0IGdlPWllKHosdWUsSyk7cmV0dXJuIFcuY2FsbCgoKT0+QyhXLEssZGUsZ2UpLEZlKT9cImJyZWFrLWFmdGVyLW9wZXJhdG9yXCI6Z2V8fFUudHlwZT09PVwiVGVtcGxhdGVMaXRlcmFsXCJ8fFUudHlwZT09PVwiVGFnZ2VkVGVtcGxhdGVFeHByZXNzaW9uXCJ8fFUudHlwZT09PVwiQm9vbGVhbkxpdGVyYWxcInx8XyhVKXx8VS50eXBlPT09XCJDbGFzc0V4cHJlc3Npb25cIj9cIm5ldmVyLWJyZWFrLWFmdGVyLW9wZXJhdG9yXCI6XCJmbHVpZFwifWZ1bmN0aW9uIEMoVyxLLGRlLHVlKXtsZXQgRmU9Vy5nZXRWYWx1ZSgpO2lmKGMoRmUpJiYhZihGZSkpcmV0dXJuITA7c3dpdGNoKEZlLnR5cGUpe2Nhc2VcIlN0cmluZ0xpdGVyYWxUeXBlQW5ub3RhdGlvblwiOmNhc2VcIlNlcXVlbmNlRXhwcmVzc2lvblwiOnJldHVybiEwO2Nhc2VcIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiOntsZXR7dGVzdDpafT1GZTtyZXR1cm4gYyhaKSYmIWYoWil9Y2FzZVwiQ2xhc3NFeHByZXNzaW9uXCI6cmV0dXJuIHQoRmUuZGVjb3JhdG9ycyl9aWYodWUpcmV0dXJuITE7bGV0IHo9RmUsVT1bXTtmb3IoOzspaWYoei50eXBlPT09XCJVbmFyeUV4cHJlc3Npb25cIil6PXouYXJndW1lbnQsVS5wdXNoKFwiYXJndW1lbnRcIik7ZWxzZSBpZih6LnR5cGU9PT1cIlRTTm9uTnVsbEV4cHJlc3Npb25cIil6PXouZXhwcmVzc2lvbixVLnB1c2goXCJleHByZXNzaW9uXCIpO2Vsc2UgYnJlYWs7cmV0dXJuISEoRCh6KXx8Vy5jYWxsKCgpPT5WKFcsSyxkZSksLi4uVSkpfWZ1bmN0aW9uIHgoVyl7aWYoQihXKSl7bGV0IEs9Vy5sZWZ0fHxXLmlkO3JldHVybiBLLnR5cGU9PT1cIk9iamVjdFBhdHRlcm5cIiYmSy5wcm9wZXJ0aWVzLmxlbmd0aD4yJiZLLnByb3BlcnRpZXMuc29tZShkZT0+JChkZSkmJighZGUuc2hvcnRoYW5kfHxkZS52YWx1ZSYmZGUudmFsdWUudHlwZT09PVwiQXNzaWdubWVudFBhdHRlcm5cIikpfXJldHVybiExfWZ1bmN0aW9uIGIoVyl7cmV0dXJuIFcudHlwZT09PVwiQXNzaWdubWVudEV4cHJlc3Npb25cIn1mdW5jdGlvbiBCKFcpe3JldHVybiBiKFcpfHxXLnR5cGU9PT1cIlZhcmlhYmxlRGVjbGFyYXRvclwifWZ1bmN0aW9uIGsoVyl7bGV0IEs9TShXKTtpZih0KEspKXtsZXQgZGU9Vy50eXBlPT09XCJUU1R5cGVBbGlhc0RlY2xhcmF0aW9uXCI/XCJjb25zdHJhaW50XCI6XCJib3VuZFwiO2lmKEsubGVuZ3RoPjEmJksuc29tZSh1ZT0+dWVbZGVdfHx1ZS5kZWZhdWx0KSlyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBNKFcpe3JldHVybiBSKFcpJiZXLnR5cGVQYXJhbWV0ZXJzJiZXLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcz9XLnR5cGVQYXJhbWV0ZXJzLnBhcmFtczpudWxsfWZ1bmN0aW9uIFIoVyl7cmV0dXJuIFcudHlwZT09PVwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwifHxXLnR5cGU9PT1cIlR5cGVBbGlhc1wifWZ1bmN0aW9uIHEoVyl7aWYoVy50eXBlIT09XCJWYXJpYWJsZURlY2xhcmF0b3JcIilyZXR1cm4hMTtsZXR7dHlwZUFubm90YXRpb246S309Vy5pZDtpZighS3x8IUsudHlwZUFubm90YXRpb24pcmV0dXJuITE7bGV0IGRlPUwoSy50eXBlQW5ub3RhdGlvbik7cmV0dXJuIHQoZGUpJiZkZS5sZW5ndGg+MSYmZGUuc29tZSh1ZT0+dChMKHVlKSl8fHVlLnR5cGU9PT1cIlRTQ29uZGl0aW9uYWxUeXBlXCIpfWZ1bmN0aW9uIEooVyl7cmV0dXJuIFcudHlwZT09PVwiVmFyaWFibGVEZWNsYXJhdG9yXCImJlcuaW5pdCYmVy5pbml0LnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCJ9ZnVuY3Rpb24gTChXKXtyZXR1cm4gUShXKSYmVy50eXBlUGFyYW1ldGVycyYmVy50eXBlUGFyYW1ldGVycy5wYXJhbXM/Vy50eXBlUGFyYW1ldGVycy5wYXJhbXM6bnVsbH1mdW5jdGlvbiBRKFcpe3JldHVybiBXLnR5cGU9PT1cIlRTVHlwZVJlZmVyZW5jZVwifHxXLnR5cGU9PT1cIkdlbmVyaWNUeXBlQW5ub3RhdGlvblwifWZ1bmN0aW9uIFYoVyxLLGRlKXtsZXQgdWU9YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT12b2lkIDA/YXJndW1lbnRzWzNdOiExLEZlPVcuZ2V0VmFsdWUoKSx6PSgpPT5WKFcsSyxkZSwhMCk7aWYoRmUudHlwZT09PVwiVFNOb25OdWxsRXhwcmVzc2lvblwiKXJldHVybiBXLmNhbGwoeixcImV4cHJlc3Npb25cIik7aWYodyhGZSkpe2lmKFQoVyxLLGRlKS5sYWJlbD09PVwibWVtYmVyLWNoYWluXCIpcmV0dXJuITE7bGV0IFo9UyhGZSk7cmV0dXJuIShaLmxlbmd0aD09PTB8fFoubGVuZ3RoPT09MSYmWShaWzBdLEspKXx8ZWUoRmUsZGUpPyExOlcuY2FsbCh6LFwiY2FsbGVlXCIpfXJldHVybiBGKEZlKT9XLmNhbGwoeixcIm9iamVjdFwiKTp1ZSYmKEZlLnR5cGU9PT1cIklkZW50aWZpZXJcInx8RmUudHlwZT09PVwiVGhpc0V4cHJlc3Npb25cIil9dmFyIGo9LjI1O2Z1bmN0aW9uIFkoVyxLKXtsZXR7cHJpbnRXaWR0aDpkZX09SztpZihJKFcpKXJldHVybiExO2xldCB1ZT1kZSpqO2lmKFcudHlwZT09PVwiVGhpc0V4cHJlc3Npb25cInx8Vy50eXBlPT09XCJJZGVudGlmaWVyXCImJlcubmFtZS5sZW5ndGg8PXVlfHxQKFcpJiYhSShXLmFyZ3VtZW50KSlyZXR1cm4hMDtsZXQgRmU9Vy50eXBlPT09XCJMaXRlcmFsXCImJlwicmVnZXhcImluIFcmJlcucmVnZXgucGF0dGVybnx8Vy50eXBlPT09XCJSZWdFeHBMaXRlcmFsXCImJlcucGF0dGVybjtyZXR1cm4gRmU/RmUubGVuZ3RoPD11ZTpEKFcpP04oVykubGVuZ3RoPD11ZTpXLnR5cGU9PT1cIlRlbXBsYXRlTGl0ZXJhbFwiP1cuZXhwcmVzc2lvbnMubGVuZ3RoPT09MCYmVy5xdWFzaXNbMF0udmFsdWUucmF3Lmxlbmd0aDw9dWUmJiFXLnF1YXNpc1swXS52YWx1ZS5yYXcuaW5jbHVkZXMoYFxuYCk6RShXKX1mdW5jdGlvbiBpZShXLEssZGUpe2lmKCEkKFcpKXJldHVybiExO0s9cChLKTtsZXQgdWU9MztyZXR1cm4gdHlwZW9mIEs9PVwic3RyaW5nXCImJnMoSyk8ZGUudGFiV2lkdGgrdWV9ZnVuY3Rpb24gZWUoVyxLKXtsZXQgZGU9bGUoVyk7aWYodChkZSkpe2lmKGRlLmxlbmd0aD4xKXJldHVybiEwO2lmKGRlLmxlbmd0aD09PTEpe2xldCBGZT1kZVswXTtpZihGZS50eXBlPT09XCJUU1VuaW9uVHlwZVwifHxGZS50eXBlPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fEZlLnR5cGU9PT1cIlRTSW50ZXJzZWN0aW9uVHlwZVwifHxGZS50eXBlPT09XCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwifHxGZS50eXBlPT09XCJUU1R5cGVMaXRlcmFsXCJ8fEZlLnR5cGU9PT1cIk9iamVjdFR5cGVBbm5vdGF0aW9uXCIpcmV0dXJuITB9bGV0IHVlPVcudHlwZVBhcmFtZXRlcnM/XCJ0eXBlUGFyYW1ldGVyc1wiOlwidHlwZUFyZ3VtZW50c1wiO2lmKGQoSyh1ZSkpKXJldHVybiEwfXJldHVybiExfWZ1bmN0aW9uIGxlKFcpe3JldHVybiBXLnR5cGVQYXJhbWV0ZXJzJiZXLnR5cGVQYXJhbWV0ZXJzLnBhcmFtc3x8Vy50eXBlQXJndW1lbnRzJiZXLnR5cGVBcmd1bWVudHMucGFyYW1zfXIuZXhwb3J0cz17cHJpbnRWYXJpYWJsZURlY2xhcmF0b3I6byxwcmludEFzc2lnbm1lbnRFeHByZXNzaW9uOnYscHJpbnRBc3NpZ25tZW50Om0saXNBcnJvd0Z1bmN0aW9uVmFyaWFibGVEZWNsYXJhdG9yOkp9fX0pLExyPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9mdW5jdGlvbi1wYXJhbWV0ZXJzLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntnZXROZXh0Tm9uU3BhY2VOb25Db21tZW50Q2hhcmFjdGVyOnR9PVVlKCkse3ByaW50RGFuZ2xpbmdDb21tZW50czpzfT1ldCgpLHtidWlsZGVyczp7bGluZTphLGhhcmRsaW5lOm4sc29mdGxpbmU6dSxncm91cDppLGluZGVudDpsLGlmQnJlYWs6cH0sdXRpbHM6e3JlbW92ZUxpbmVzOmQsd2lsbEJyZWFrOnl9fT1xZSgpLHtnZXRGdW5jdGlvblBhcmFtZXRlcnM6ZyxpdGVyYXRlRnVuY3Rpb25QYXJhbWV0ZXJzUGF0aDpjLGlzU2ltcGxlVHlwZTpELGlzVGVzdENhbGw6RSxpc1R5cGVBbm5vdGF0aW9uQUZ1bmN0aW9uOl8saXNPYmplY3RUeXBlOncsaXNPYmplY3RUeXBlUHJvcGVydHlBRnVuY3Rpb246RixoYXNSZXN0UGFyYW1ldGVyOlMsc2hvdWxkUHJpbnRDb21tYTpOLGhhc0NvbW1lbnQ6SSxpc05leHRMaW5lRW1wdHk6UH09S2UoKSx7bG9jRW5kOiR9PXV0KCkse0FyZ0V4cGFuc2lvbkJhaWxvdXQ6Zn09UXQoKSx7cHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzOlR9PWN0KCk7ZnVuY3Rpb24gbShDLHgsYixCLGspe2xldCBNPUMuZ2V0VmFsdWUoKSxSPWcoTSkscT1rP1QoQyxiLHgpOlwiXCI7aWYoUi5sZW5ndGg9PT0wKXJldHVybltxLFwiKFwiLHMoQyxiLCEwLGllPT50KGIub3JpZ2luYWxUZXh0LGllLCQpPT09XCIpXCIpLFwiKVwiXTtsZXQgSj1DLmdldFBhcmVudE5vZGUoKSxMPUUoSiksUT12KE0pLFY9W107aWYoYyhDLChpZSxlZSk9PntsZXQgbGU9ZWU9PT1SLmxlbmd0aC0xO2xlJiZNLnJlc3QmJlYucHVzaChcIi4uLlwiKSxWLnB1c2goeCgpKSwhbGUmJihWLnB1c2goXCIsXCIpLEx8fFE/Vi5wdXNoKFwiIFwiKTpQKFJbZWVdLGIpP1YucHVzaChuLG4pOlYucHVzaChhKSl9KSxCKXtpZih5KHEpfHx5KFYpKXRocm93IG5ldyBmO3JldHVybiBpKFtkKHEpLFwiKFwiLGQoViksXCIpXCJdKX1sZXQgaj1SLmV2ZXJ5KGllPT4haWUuZGVjb3JhdG9ycyk7cmV0dXJuIFEmJmo/W3EsXCIoXCIsLi4uVixcIilcIl06TD9bcSxcIihcIiwuLi5WLFwiKVwiXTooRihKKXx8XyhKKXx8Si50eXBlPT09XCJUeXBlQWxpYXNcInx8Si50eXBlPT09XCJVbmlvblR5cGVBbm5vdGF0aW9uXCJ8fEoudHlwZT09PVwiVFNVbmlvblR5cGVcInx8Si50eXBlPT09XCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwifHxKLnR5cGU9PT1cIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIiYmSi5yZXR1cm5UeXBlPT09TSkmJlIubGVuZ3RoPT09MSYmUlswXS5uYW1lPT09bnVsbCYmTS50aGlzIT09UlswXSYmUlswXS50eXBlQW5ub3RhdGlvbiYmTS50eXBlUGFyYW1ldGVycz09PW51bGwmJkQoUlswXS50eXBlQW5ub3RhdGlvbikmJiFNLnJlc3Q/Yi5hcnJvd1BhcmVucz09PVwiYWx3YXlzXCI/W1wiKFwiLC4uLlYsXCIpXCJdOlY6W3EsXCIoXCIsbChbdSwuLi5WXSkscCghUyhNKSYmTihiLFwiYWxsXCIpP1wiLFwiOlwiXCIpLHUsXCIpXCJdfWZ1bmN0aW9uIHYoQyl7aWYoIUMpcmV0dXJuITE7bGV0IHg9ZyhDKTtpZih4Lmxlbmd0aCE9PTEpcmV0dXJuITE7bGV0W2JdPXg7cmV0dXJuIUkoYikmJihiLnR5cGU9PT1cIk9iamVjdFBhdHRlcm5cInx8Yi50eXBlPT09XCJBcnJheVBhdHRlcm5cInx8Yi50eXBlPT09XCJJZGVudGlmaWVyXCImJmIudHlwZUFubm90YXRpb24mJihiLnR5cGVBbm5vdGF0aW9uLnR5cGU9PT1cIlR5cGVBbm5vdGF0aW9uXCJ8fGIudHlwZUFubm90YXRpb24udHlwZT09PVwiVFNUeXBlQW5ub3RhdGlvblwiKSYmdyhiLnR5cGVBbm5vdGF0aW9uLnR5cGVBbm5vdGF0aW9uKXx8Yi50eXBlPT09XCJGdW5jdGlvblR5cGVQYXJhbVwiJiZ3KGIudHlwZUFubm90YXRpb24pfHxiLnR5cGU9PT1cIkFzc2lnbm1lbnRQYXR0ZXJuXCImJihiLmxlZnQudHlwZT09PVwiT2JqZWN0UGF0dGVyblwifHxiLmxlZnQudHlwZT09PVwiQXJyYXlQYXR0ZXJuXCIpJiYoYi5yaWdodC50eXBlPT09XCJJZGVudGlmaWVyXCJ8fGIucmlnaHQudHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwiJiZiLnJpZ2h0LnByb3BlcnRpZXMubGVuZ3RoPT09MHx8Yi5yaWdodC50eXBlPT09XCJBcnJheUV4cHJlc3Npb25cIiYmYi5yaWdodC5lbGVtZW50cy5sZW5ndGg9PT0wKSl9ZnVuY3Rpb24gbyhDKXtsZXQgeDtyZXR1cm4gQy5yZXR1cm5UeXBlPyh4PUMucmV0dXJuVHlwZSx4LnR5cGVBbm5vdGF0aW9uJiYoeD14LnR5cGVBbm5vdGF0aW9uKSk6Qy50eXBlQW5ub3RhdGlvbiYmKHg9Qy50eXBlQW5ub3RhdGlvbikseH1mdW5jdGlvbiBoKEMseCl7bGV0IGI9byhDKTtpZighYilyZXR1cm4hMTtsZXQgQj1DLnR5cGVQYXJhbWV0ZXJzJiZDLnR5cGVQYXJhbWV0ZXJzLnBhcmFtcztpZihCKXtpZihCLmxlbmd0aD4xKXJldHVybiExO2lmKEIubGVuZ3RoPT09MSl7bGV0IGs9QlswXTtpZihrLmNvbnN0cmFpbnR8fGsuZGVmYXVsdClyZXR1cm4hMX19cmV0dXJuIGcoQykubGVuZ3RoPT09MSYmKHcoYil8fHkoeCkpfXIuZXhwb3J0cz17cHJpbnRGdW5jdGlvblBhcmFtZXRlcnM6bSxzaG91bGRIdWdGdW5jdGlvblBhcmFtZXRlcnM6dixzaG91bGRHcm91cEZ1bmN0aW9uUGFyYW1ldGVyczpofX19KSxPcj10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvdHlwZS1hbm5vdGF0aW9uLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntwcmludENvbW1lbnRzOnQscHJpbnREYW5nbGluZ0NvbW1lbnRzOnN9PWV0KCkse2lzTm9uRW1wdHlBcnJheTphfT1VZSgpLHtidWlsZGVyczp7Z3JvdXA6bixqb2luOnUsbGluZTppLHNvZnRsaW5lOmwsaW5kZW50OnAsYWxpZ246ZCxpZkJyZWFrOnl9fT1xZSgpLGc9cXQoKSx7bG9jU3RhcnQ6Y309dXQoKSx7aXNTaW1wbGVUeXBlOkQsaXNPYmplY3RUeXBlOkUsaGFzTGVhZGluZ093bkxpbmVDb21tZW50Ol8saXNPYmplY3RUeXBlUHJvcGVydHlBRnVuY3Rpb246dyxzaG91bGRQcmludENvbW1hOkZ9PUtlKCkse3ByaW50QXNzaWdubWVudDpTfT10cigpLHtwcmludEZ1bmN0aW9uUGFyYW1ldGVyczpOLHNob3VsZEdyb3VwRnVuY3Rpb25QYXJhbWV0ZXJzOkl9PUxyKCkse3ByaW50QXJyYXlJdGVtczpQfT1lcigpO2Z1bmN0aW9uICQoYil7aWYoRChiKXx8RShiKSlyZXR1cm4hMDtpZihiLnR5cGU9PT1cIlVuaW9uVHlwZUFubm90YXRpb25cInx8Yi50eXBlPT09XCJUU1VuaW9uVHlwZVwiKXtsZXQgQj1iLnR5cGVzLmZpbHRlcihNPT5NLnR5cGU9PT1cIlZvaWRUeXBlQW5ub3RhdGlvblwifHxNLnR5cGU9PT1cIlRTVm9pZEtleXdvcmRcInx8TS50eXBlPT09XCJOdWxsTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCJ8fE0udHlwZT09PVwiVFNOdWxsS2V5d29yZFwiKS5sZW5ndGgsaz1iLnR5cGVzLnNvbWUoTT0+TS50eXBlPT09XCJPYmplY3RUeXBlQW5ub3RhdGlvblwifHxNLnR5cGU9PT1cIlRTVHlwZUxpdGVyYWxcInx8TS50eXBlPT09XCJHZW5lcmljVHlwZUFubm90YXRpb25cInx8TS50eXBlPT09XCJUU1R5cGVSZWZlcmVuY2VcIik7aWYoYi50eXBlcy5sZW5ndGgtMT09PUImJmspcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gZihiLEIsayl7bGV0IE09Qi5zZW1pP1wiO1wiOlwiXCIsUj1iLmdldFZhbHVlKCkscT1bXTtyZXR1cm4gcS5wdXNoKFwib3BhcXVlIHR5cGUgXCIsayhcImlkXCIpLGsoXCJ0eXBlUGFyYW1ldGVyc1wiKSksUi5zdXBlcnR5cGUmJnEucHVzaChcIjogXCIsayhcInN1cGVydHlwZVwiKSksUi5pbXBsdHlwZSYmcS5wdXNoKFwiID0gXCIsayhcImltcGx0eXBlXCIpKSxxLnB1c2goTSkscX1mdW5jdGlvbiBUKGIsQixrKXtsZXQgTT1CLnNlbWk/XCI7XCI6XCJcIixSPWIuZ2V0VmFsdWUoKSxxPVtdO1IuZGVjbGFyZSYmcS5wdXNoKFwiZGVjbGFyZSBcIikscS5wdXNoKFwidHlwZSBcIixrKFwiaWRcIiksayhcInR5cGVQYXJhbWV0ZXJzXCIpKTtsZXQgSj1SLnR5cGU9PT1cIlRTVHlwZUFsaWFzRGVjbGFyYXRpb25cIj9cInR5cGVBbm5vdGF0aW9uXCI6XCJyaWdodFwiO3JldHVybltTKGIsQixrLHEsXCIgPVwiLEopLE1dfWZ1bmN0aW9uIG0oYixCLGspe2xldCBNPWIuZ2V0VmFsdWUoKSxSPWIubWFwKGssXCJ0eXBlc1wiKSxxPVtdLEo9ITE7Zm9yKGxldCBMPTA7TDxSLmxlbmd0aDsrK0wpTD09PTA/cS5wdXNoKFJbTF0pOkUoTS50eXBlc1tMLTFdKSYmRShNLnR5cGVzW0xdKT9xLnB1c2goW1wiICYgXCIsSj9wKFJbTF0pOlJbTF1dKTohRShNLnR5cGVzW0wtMV0pJiYhRShNLnR5cGVzW0xdKT9xLnB1c2gocChbXCIgJlwiLGksUltMXV0pKTooTD4xJiYoSj0hMCkscS5wdXNoKFwiICYgXCIsTD4xP3AoUltMXSk6UltMXSkpO3JldHVybiBuKHEpfWZ1bmN0aW9uIHYoYixCLGspe2xldCBNPWIuZ2V0VmFsdWUoKSxSPWIuZ2V0UGFyZW50Tm9kZSgpLHE9Ui50eXBlIT09XCJUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiJiZSLnR5cGUhPT1cIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIiYmUi50eXBlIT09XCJHZW5lcmljVHlwZUFubm90YXRpb25cIiYmUi50eXBlIT09XCJUU1R5cGVSZWZlcmVuY2VcIiYmUi50eXBlIT09XCJUU1R5cGVBc3NlcnRpb25cIiYmUi50eXBlIT09XCJUdXBsZVR5cGVBbm5vdGF0aW9uXCImJlIudHlwZSE9PVwiVFNUdXBsZVR5cGVcIiYmIShSLnR5cGU9PT1cIkZ1bmN0aW9uVHlwZVBhcmFtXCImJiFSLm5hbWUmJmIuZ2V0UGFyZW50Tm9kZSgxKS50aGlzIT09UikmJiEoKFIudHlwZT09PVwiVHlwZUFsaWFzXCJ8fFIudHlwZT09PVwiVmFyaWFibGVEZWNsYXJhdG9yXCJ8fFIudHlwZT09PVwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiKSYmXyhCLm9yaWdpbmFsVGV4dCxNKSksSj0kKE0pLEw9Yi5tYXAoaj0+e2xldCBZPWsoKTtyZXR1cm4gSnx8KFk9ZCgyLFkpKSx0KGosWSxCKX0sXCJ0eXBlc1wiKTtpZihKKXJldHVybiB1KFwiIHwgXCIsTCk7bGV0IFE9cSYmIV8oQi5vcmlnaW5hbFRleHQsTSksVj1beShbUT9pOlwiXCIsXCJ8IFwiXSksdShbaSxcInwgXCJdLEwpXTtyZXR1cm4gZyhiLEIpP24oW3AoViksbF0pOlIudHlwZT09PVwiVHVwbGVUeXBlQW5ub3RhdGlvblwiJiZSLnR5cGVzLmxlbmd0aD4xfHxSLnR5cGU9PT1cIlRTVHVwbGVUeXBlXCImJlIuZWxlbWVudFR5cGVzLmxlbmd0aD4xP24oW3AoW3koW1wiKFwiLGxdKSxWXSksbCx5KFwiKVwiKV0pOm4ocT9wKFYpOlYpfWZ1bmN0aW9uIG8oYixCLGspe2xldCBNPWIuZ2V0VmFsdWUoKSxSPVtdLHE9Yi5nZXRQYXJlbnROb2RlKDApLEo9Yi5nZXRQYXJlbnROb2RlKDEpLEw9Yi5nZXRQYXJlbnROb2RlKDIpLFE9TS50eXBlPT09XCJUU0Z1bmN0aW9uVHlwZVwifHwhKChxLnR5cGU9PT1cIk9iamVjdFR5cGVQcm9wZXJ0eVwifHxxLnR5cGU9PT1cIk9iamVjdFR5cGVJbnRlcm5hbFNsb3RcIikmJiFxLnZhcmlhbmNlJiYhcS5vcHRpb25hbCYmYyhxKT09PWMoTSl8fHEudHlwZT09PVwiT2JqZWN0VHlwZUNhbGxQcm9wZXJ0eVwifHxMJiZMLnR5cGU9PT1cIkRlY2xhcmVGdW5jdGlvblwiKSxWPVEmJihxLnR5cGU9PT1cIlR5cGVBbm5vdGF0aW9uXCJ8fHEudHlwZT09PVwiVFNUeXBlQW5ub3RhdGlvblwiKSxqPVYmJlEmJihxLnR5cGU9PT1cIlR5cGVBbm5vdGF0aW9uXCJ8fHEudHlwZT09PVwiVFNUeXBlQW5ub3RhdGlvblwiKSYmSi50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiO3cocSkmJihRPSEwLFY9ITApLGomJlIucHVzaChcIihcIik7bGV0IFk9TihiLGssQiwhMSwhMCksaWU9TS5yZXR1cm5UeXBlfHxNLnByZWRpY2F0ZXx8TS50eXBlQW5ub3RhdGlvbj9bUT9cIiA9PiBcIjpcIjogXCIsayhcInJldHVyblR5cGVcIiksayhcInByZWRpY2F0ZVwiKSxrKFwidHlwZUFubm90YXRpb25cIildOlwiXCIsZWU9SShNLGllKTtyZXR1cm4gUi5wdXNoKGVlP24oWSk6WSksaWUmJlIucHVzaChpZSksaiYmUi5wdXNoKFwiKVwiKSxuKFIpfWZ1bmN0aW9uIGgoYixCLGspe2xldCBNPWIuZ2V0VmFsdWUoKSxSPU0udHlwZT09PVwiVFNUdXBsZVR5cGVcIj9cImVsZW1lbnRUeXBlc1wiOlwidHlwZXNcIixxPU1bUl0sSj1hKHEpLEw9Sj9sOlwiXCI7cmV0dXJuIG4oW1wiW1wiLHAoW0wsUChiLEIsUixrKV0pLHkoSiYmRihCLFwiYWxsXCIpP1wiLFwiOlwiXCIpLHMoYixCLCEwKSxMLFwiXVwiXSl9ZnVuY3Rpb24gQyhiLEIsayl7bGV0IE09Yi5nZXRWYWx1ZSgpLFI9TS50eXBlPT09XCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCImJk0ub3B0aW9uYWw/XCI/LltcIjpcIltcIjtyZXR1cm5bayhcIm9iamVjdFR5cGVcIiksUixrKFwiaW5kZXhUeXBlXCIpLFwiXVwiXX1mdW5jdGlvbiB4KGIsQixrKXtsZXQgTT1iLmdldFZhbHVlKCk7cmV0dXJuW00ucG9zdGZpeD9cIlwiOmssQihcInR5cGVBbm5vdGF0aW9uXCIpLE0ucG9zdGZpeD9rOlwiXCJdfXIuZXhwb3J0cz17cHJpbnRPcGFxdWVUeXBlOmYscHJpbnRUeXBlQWxpYXM6VCxwcmludEludGVyc2VjdGlvblR5cGU6bSxwcmludFVuaW9uVHlwZTp2LHByaW50RnVuY3Rpb25UeXBlOm8scHJpbnRUdXBsZVR5cGU6aCxwcmludEluZGV4ZWRBY2Nlc3NUeXBlOkMsc2hvdWxkSHVnVHlwZTokLHByaW50SlNEb2NUeXBlOnh9fX0pLGpyPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC90eXBlLXBhcmFtZXRlcnMuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50RGFuZ2xpbmdDb21tZW50czp0fT1ldCgpLHtidWlsZGVyczp7am9pbjpzLGxpbmU6YSxoYXJkbGluZTpuLHNvZnRsaW5lOnUsZ3JvdXA6aSxpbmRlbnQ6bCxpZkJyZWFrOnB9fT1xZSgpLHtpc1Rlc3RDYWxsOmQsaGFzQ29tbWVudDp5LENvbW1lbnRDaGVja0ZsYWdzOmcsaXNUU1hGaWxlOmMsc2hvdWxkUHJpbnRDb21tYTpELGdldEZ1bmN0aW9uUGFyYW1ldGVyczpFLGlzT2JqZWN0VHlwZTpffT1LZSgpLHtjcmVhdGVHcm91cElkTWFwcGVyOnd9PVVlKCkse3Nob3VsZEh1Z1R5cGU6Rn09T3IoKSx7aXNBcnJvd0Z1bmN0aW9uVmFyaWFibGVEZWNsYXJhdG9yOlN9PXRyKCksTj13KFwidHlwZVBhcmFtZXRlcnNcIik7ZnVuY3Rpb24gSShmLFQsbSx2KXtsZXQgbz1mLmdldFZhbHVlKCk7aWYoIW9bdl0pcmV0dXJuXCJcIjtpZighQXJyYXkuaXNBcnJheShvW3ZdKSlyZXR1cm4gbSh2KTtsZXQgaD1mLmdldE5vZGUoMiksQz1oJiZkKGgpLHg9Zi5tYXRjaChrPT4hKGtbdl0ubGVuZ3RoPT09MSYmXyhrW3ZdWzBdKSksdm9pZCAwLChrLE0pPT5NPT09XCJ0eXBlQW5ub3RhdGlvblwiLGs9PmsudHlwZT09PVwiSWRlbnRpZmllclwiLFMpO2lmKG9bdl0ubGVuZ3RoPT09MHx8IXgmJihDfHxvW3ZdLmxlbmd0aD09PTEmJihvW3ZdWzBdLnR5cGU9PT1cIk51bGxhYmxlVHlwZUFubm90YXRpb25cInx8RihvW3ZdWzBdKSkpKXJldHVybltcIjxcIixzKFwiLCBcIixmLm1hcChtLHYpKSxQKGYsVCksXCI+XCJdO2xldCBCPW8udHlwZT09PVwiVFNUeXBlUGFyYW1ldGVySW5zdGFudGlhdGlvblwiP1wiXCI6RShvKS5sZW5ndGg9PT0xJiZjKFQpJiYhb1t2XVswXS5jb25zdHJhaW50JiZmLmdldFBhcmVudE5vZGUoKS50eXBlPT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwiP1wiLFwiOkQoVCxcImFsbFwiKT9wKFwiLFwiKTpcIlwiO3JldHVybiBpKFtcIjxcIixsKFt1LHMoW1wiLFwiLGFdLGYubWFwKG0sdikpXSksQix1LFwiPlwiXSx7aWQ6TihvKX0pfWZ1bmN0aW9uIFAoZixUKXtsZXQgbT1mLmdldFZhbHVlKCk7aWYoIXkobSxnLkRhbmdsaW5nKSlyZXR1cm5cIlwiO2xldCB2PSF5KG0sZy5MaW5lKSxvPXQoZixULHYpO3JldHVybiB2P286W28sbl19ZnVuY3Rpb24gJChmLFQsbSl7bGV0IHY9Zi5nZXRWYWx1ZSgpLG89W10saD1mLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gaC50eXBlPT09XCJUU01hcHBlZFR5cGVcIj8oby5wdXNoKFwiW1wiLG0oXCJuYW1lXCIpKSx2LmNvbnN0cmFpbnQmJm8ucHVzaChcIiBpbiBcIixtKFwiY29uc3RyYWludFwiKSksaC5uYW1lVHlwZSYmby5wdXNoKFwiIGFzIFwiLGYuY2FsbFBhcmVudCgoKT0+bShcIm5hbWVUeXBlXCIpKSksby5wdXNoKFwiXVwiKSxvKToodi52YXJpYW5jZSYmby5wdXNoKG0oXCJ2YXJpYW5jZVwiKSksdi5pbiYmby5wdXNoKFwiaW4gXCIpLHYub3V0JiZvLnB1c2goXCJvdXQgXCIpLG8ucHVzaChtKFwibmFtZVwiKSksdi5ib3VuZCYmby5wdXNoKFwiOiBcIixtKFwiYm91bmRcIikpLHYuY29uc3RyYWludCYmby5wdXNoKFwiIGV4dGVuZHMgXCIsbShcImNvbnN0cmFpbnRcIikpLHYuZGVmYXVsdCYmby5wdXNoKFwiID0gXCIsbShcImRlZmF1bHRcIikpLG8pfXIuZXhwb3J0cz17cHJpbnRUeXBlUGFyYW1ldGVyOiQscHJpbnRUeXBlUGFyYW1ldGVyczpJLGdldFR5cGVQYXJhbWV0ZXJzR3JvdXBJZDpOfX19KSxycj10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvcHJvcGVydHkuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50Q29tbWVudHM6dH09ZXQoKSx7cHJpbnRTdHJpbmc6cyxwcmludE51bWJlcjphfT1VZSgpLHtpc051bWVyaWNMaXRlcmFsOm4saXNTaW1wbGVOdW1iZXI6dSxpc1N0cmluZ0xpdGVyYWw6aSxpc1N0cmluZ1Byb3BTYWZlVG9VbnF1b3RlOmwscmF3VGV4dDpwfT1LZSgpLHtwcmludEFzc2lnbm1lbnQ6ZH09dHIoKSx5PW5ldyBXZWFrTWFwO2Z1bmN0aW9uIGcoRCxFLF8pe2xldCB3PUQuZ2V0Tm9kZSgpO2lmKHcuY29tcHV0ZWQpcmV0dXJuW1wiW1wiLF8oXCJrZXlcIiksXCJdXCJdO2xldCBGPUQuZ2V0UGFyZW50Tm9kZSgpLHtrZXk6U309dztpZihFLnF1b3RlUHJvcHM9PT1cImNvbnNpc3RlbnRcIiYmIXkuaGFzKEYpKXtsZXQgTj0oRi5wcm9wZXJ0aWVzfHxGLmJvZHl8fEYubWVtYmVycykuc29tZShJPT4hSS5jb21wdXRlZCYmSS5rZXkmJmkoSS5rZXkpJiYhbChJLEUpKTt5LnNldChGLE4pfWlmKChTLnR5cGU9PT1cIklkZW50aWZpZXJcInx8bihTKSYmdShhKHAoUykpKSYmU3RyaW5nKFMudmFsdWUpPT09YShwKFMpKSYmIShFLnBhcnNlcj09PVwidHlwZXNjcmlwdFwifHxFLnBhcnNlcj09PVwiYmFiZWwtdHNcIikpJiYoRS5wYXJzZXI9PT1cImpzb25cInx8RS5xdW90ZVByb3BzPT09XCJjb25zaXN0ZW50XCImJnkuZ2V0KEYpKSl7bGV0IE49cyhKU09OLnN0cmluZ2lmeShTLnR5cGU9PT1cIklkZW50aWZpZXJcIj9TLm5hbWU6Uy52YWx1ZS50b1N0cmluZygpKSxFKTtyZXR1cm4gRC5jYWxsKEk9PnQoSSxOLEUpLFwia2V5XCIpfXJldHVybiBsKHcsRSkmJihFLnF1b3RlUHJvcHM9PT1cImFzLW5lZWRlZFwifHxFLnF1b3RlUHJvcHM9PT1cImNvbnNpc3RlbnRcIiYmIXkuZ2V0KEYpKT9ELmNhbGwoTj0+dChOLC9eXFxkLy50ZXN0KFMudmFsdWUpP2EoUy52YWx1ZSk6Uy52YWx1ZSxFKSxcImtleVwiKTpfKFwia2V5XCIpfWZ1bmN0aW9uIGMoRCxFLF8pe3JldHVybiBELmdldFZhbHVlKCkuc2hvcnRoYW5kP18oXCJ2YWx1ZVwiKTpkKEQsRSxfLGcoRCxFLF8pLFwiOlwiLFwidmFsdWVcIil9ci5leHBvcnRzPXtwcmludFByb3BlcnR5OmMscHJpbnRQcm9wZXJ0eUtleTpnfX19KSxxcj10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvZnVuY3Rpb24uanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9WnQoKSx7cHJpbnREYW5nbGluZ0NvbW1lbnRzOnMscHJpbnRDb21tZW50c1NlcGFyYXRlbHk6YX09ZXQoKSxuPWx0KCkse2dldE5leHROb25TcGFjZU5vbkNvbW1lbnRDaGFyYWN0ZXJJbmRleDp1fT1VZSgpLHtidWlsZGVyczp7bGluZTppLHNvZnRsaW5lOmwsZ3JvdXA6cCxpbmRlbnQ6ZCxpZkJyZWFrOnksaGFyZGxpbmU6Zyxqb2luOmMsaW5kZW50SWZCcmVhazpEfSx1dGlsczp7cmVtb3ZlTGluZXM6RSx3aWxsQnJlYWs6X319PXFlKCkse0FyZ0V4cGFuc2lvbkJhaWxvdXQ6d309UXQoKSx7Z2V0RnVuY3Rpb25QYXJhbWV0ZXJzOkYsaGFzTGVhZGluZ093bkxpbmVDb21tZW50OlMsaXNGbG93QW5ub3RhdGlvbkNvbW1lbnQ6Tixpc0pzeE5vZGU6SSxpc1RlbXBsYXRlT25JdHNPd25MaW5lOlAsc2hvdWxkUHJpbnRDb21tYTokLHN0YXJ0c1dpdGhOb0xvb2thaGVhZFRva2VuOmYsaXNCaW5hcnlpc2g6VCxpc0xpbmVDb21tZW50Om0saGFzQ29tbWVudDp2LGdldENvbW1lbnRzOm8sQ29tbWVudENoZWNrRmxhZ3M6aCxpc0NhbGxMaWtlRXhwcmVzc2lvbjpDLGlzQ2FsbEV4cHJlc3Npb246eCxnZXRDYWxsQXJndW1lbnRzOmIsaGFzTmFrZWRMZWZ0U2lkZTpCLGdldExlZnRTaWRlOmt9PUtlKCkse2xvY0VuZDpNfT11dCgpLHtwcmludEZ1bmN0aW9uUGFyYW1ldGVyczpSLHNob3VsZEdyb3VwRnVuY3Rpb25QYXJhbWV0ZXJzOnF9PUxyKCkse3ByaW50UHJvcGVydHlLZXk6Sn09cnIoKSx7cHJpbnRGdW5jdGlvblR5cGVQYXJhbWV0ZXJzOkx9PWN0KCk7ZnVuY3Rpb24gUShVLFosc2UsRGUpe2xldCBnZT1VLmdldFZhbHVlKCksaGU9ITE7aWYoKGdlLnR5cGU9PT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cInx8Z2UudHlwZT09PVwiRnVuY3Rpb25FeHByZXNzaW9uXCIpJiZEZSYmRGUuZXhwYW5kTGFzdEFyZyl7bGV0IFBlPVUuZ2V0UGFyZW50Tm9kZSgpO3goUGUpJiZiKFBlKS5sZW5ndGg+MSYmKGhlPSEwKX1sZXQgd2U9W107Z2UudHlwZT09PVwiVFNEZWNsYXJlRnVuY3Rpb25cIiYmZ2UuZGVjbGFyZSYmd2UucHVzaChcImRlY2xhcmUgXCIpLGdlLmFzeW5jJiZ3ZS5wdXNoKFwiYXN5bmMgXCIpLGdlLmdlbmVyYXRvcj93ZS5wdXNoKFwiZnVuY3Rpb24qIFwiKTp3ZS5wdXNoKFwiZnVuY3Rpb24gXCIpLGdlLmlkJiZ3ZS5wdXNoKFooXCJpZFwiKSk7bGV0IGtlPVIoVSxaLHNlLGhlKSxSZT1LKFUsWixzZSksTmU9cShnZSxSZSk7cmV0dXJuIHdlLnB1c2goTChVLHNlLFopLHAoW05lP3Aoa2UpOmtlLFJlXSksZ2UuYm9keT9cIiBcIjpcIlwiLFooXCJib2R5XCIpKSxzZS5zZW1pJiYoZ2UuZGVjbGFyZXx8IWdlLmJvZHkpJiZ3ZS5wdXNoKFwiO1wiKSx3ZX1mdW5jdGlvbiBWKFUsWixzZSl7bGV0IERlPVUuZ2V0Tm9kZSgpLHtraW5kOmdlfT1EZSxoZT1EZS52YWx1ZXx8RGUsd2U9W107cmV0dXJuIWdlfHxnZT09PVwiaW5pdFwifHxnZT09PVwibWV0aG9kXCJ8fGdlPT09XCJjb25zdHJ1Y3RvclwiP2hlLmFzeW5jJiZ3ZS5wdXNoKFwiYXN5bmMgXCIpOih0Lm9rKGdlPT09XCJnZXRcInx8Z2U9PT1cInNldFwiKSx3ZS5wdXNoKGdlLFwiIFwiKSksaGUuZ2VuZXJhdG9yJiZ3ZS5wdXNoKFwiKlwiKSx3ZS5wdXNoKEooVSxaLHNlKSxEZS5vcHRpb25hbHx8RGUua2V5Lm9wdGlvbmFsP1wiP1wiOlwiXCIpLERlPT09aGU/d2UucHVzaChqKFUsWixzZSkpOmhlLnR5cGU9PT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwiP3dlLnB1c2goVS5jYWxsKGtlPT5qKGtlLFosc2UpLFwidmFsdWVcIikpOndlLnB1c2goc2UoXCJ2YWx1ZVwiKSksd2V9ZnVuY3Rpb24gaihVLFosc2Upe2xldCBEZT1VLmdldE5vZGUoKSxnZT1SKFUsc2UsWiksaGU9SyhVLHNlLFopLHdlPXEoRGUsaGUpLGtlPVtMKFUsWixzZSkscChbd2U/cChnZSk6Z2UsaGVdKV07cmV0dXJuIERlLmJvZHk/a2UucHVzaChcIiBcIixzZShcImJvZHlcIikpOmtlLnB1c2goWi5zZW1pP1wiO1wiOlwiXCIpLGtlfWZ1bmN0aW9uIFkoVSxaLHNlLERlKXtsZXQgZ2U9VS5nZXRWYWx1ZSgpLGhlPVtdO2lmKGdlLmFzeW5jJiZoZS5wdXNoKFwiYXN5bmMgXCIpLFcoVSxaKSloZS5wdXNoKHNlKFtcInBhcmFtc1wiLDBdKSk7ZWxzZXtsZXQga2U9RGUmJihEZS5leHBhbmRMYXN0QXJnfHxEZS5leHBhbmRGaXJzdEFyZyksUmU9SyhVLHNlLFopO2lmKGtlKXtpZihfKFJlKSl0aHJvdyBuZXcgdztSZT1wKEUoUmUpKX1oZS5wdXNoKHAoW1IoVSxzZSxaLGtlLCEwKSxSZV0pKX1sZXQgd2U9cyhVLFosITAsa2U9PntsZXQgUmU9dShaLm9yaWdpbmFsVGV4dCxrZSxNKTtyZXR1cm4gUmUhPT0hMSYmWi5vcmlnaW5hbFRleHQuc2xpY2UoUmUsUmUrMik9PT1cIj0+XCJ9KTtyZXR1cm4gd2UmJmhlLnB1c2goXCIgXCIsd2UpLGhlfWZ1bmN0aW9uIGllKFUsWixzZSxEZSxnZSxoZSl7bGV0IHdlPVUuZ2V0TmFtZSgpLGtlPVUuZ2V0UGFyZW50Tm9kZSgpLFJlPUMoa2UpJiZ3ZT09PVwiY2FsbGVlXCIsTmU9Qm9vbGVhbihaJiZaLmFzc2lnbm1lbnRMYXlvdXQpLFBlPWhlLmJvZHkudHlwZSE9PVwiQmxvY2tTdGF0ZW1lbnRcIiYmaGUuYm9keS50eXBlIT09XCJPYmplY3RFeHByZXNzaW9uXCImJmhlLmJvZHkudHlwZSE9PVwiU2VxdWVuY2VFeHByZXNzaW9uXCIsb2U9UmUmJlBlfHxaJiZaLmFzc2lnbm1lbnRMYXlvdXQ9PT1cImNoYWluLXRhaWwtYXJyb3ctY2hhaW5cIixIPVN5bWJvbChcImFycm93LWNoYWluXCIpO3JldHVybiBoZS5ib2R5LnR5cGU9PT1cIlNlcXVlbmNlRXhwcmVzc2lvblwiJiYoZ2U9cChbXCIoXCIsZChbbCxnZV0pLGwsXCIpXCJdKSkscChbcChkKFtSZXx8TmU/bDpcIlwiLHAoYyhbXCIgPT5cIixpXSxzZSkse3Nob3VsZEJyZWFrOkRlfSldKSx7aWQ6SCxzaG91bGRCcmVhazpvZX0pLFwiID0+XCIsRChQZT9kKFtpLGdlXSk6W1wiIFwiLGdlXSx7Z3JvdXBJZDpIfSksUmU/eShsLFwiXCIse2dyb3VwSWQ6SH0pOlwiXCJdKX1mdW5jdGlvbiBlZShVLFosc2UsRGUpe2xldCBnZT1VLmdldFZhbHVlKCksaGU9W10sd2U9W10sa2U9ITE7aWYoZnVuY3Rpb24gSCgpe2xldCBjZT1ZKFUsWixzZSxEZSk7aWYoaGUubGVuZ3RoPT09MCloZS5wdXNoKGNlKTtlbHNle2xldHtsZWFkaW5nOlgsdHJhaWxpbmc6cGV9PWEoVSxaKTtoZS5wdXNoKFtYLGNlXSksd2UudW5zaGlmdChwZSl9a2U9a2V8fGdlLnJldHVyblR5cGUmJkYoZ2UpLmxlbmd0aD4wfHxnZS50eXBlUGFyYW1ldGVyc3x8RihnZSkuc29tZShYPT5YLnR5cGUhPT1cIklkZW50aWZpZXJcIiksZ2UuYm9keS50eXBlIT09XCJBcnJvd0Z1bmN0aW9uRXhwcmVzc2lvblwifHxEZSYmRGUuZXhwYW5kTGFzdEFyZz93ZS51bnNoaWZ0KHNlKFwiYm9keVwiLERlKSk6KGdlPWdlLmJvZHksVS5jYWxsKEgsXCJib2R5XCIpKX0oKSxoZS5sZW5ndGg+MSlyZXR1cm4gaWUoVSxEZSxoZSxrZSx3ZSxnZSk7bGV0IFJlPWhlO2lmKFJlLnB1c2goXCIgPT5cIiksIVMoWi5vcmlnaW5hbFRleHQsZ2UuYm9keSkmJihnZS5ib2R5LnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwifHxnZS5ib2R5LnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cInx8Z2UuYm9keS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwifHxJKGdlLmJvZHkpfHxQKGdlLmJvZHksWi5vcmlnaW5hbFRleHQpfHxnZS5ib2R5LnR5cGU9PT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCJ8fGdlLmJvZHkudHlwZT09PVwiRG9FeHByZXNzaW9uXCIpKXJldHVybiBwKFsuLi5SZSxcIiBcIix3ZV0pO2lmKGdlLmJvZHkudHlwZT09PVwiU2VxdWVuY2VFeHByZXNzaW9uXCIpcmV0dXJuIHAoWy4uLlJlLHAoW1wiIChcIixkKFtsLHdlXSksbCxcIilcIl0pXSk7bGV0IE5lPShEZSYmRGUuZXhwYW5kTGFzdEFyZ3x8VS5nZXRQYXJlbnROb2RlKCkudHlwZT09PVwiSlNYRXhwcmVzc2lvbkNvbnRhaW5lclwiKSYmIXYoZ2UpLFBlPURlJiZEZS5leHBhbmRMYXN0QXJnJiYkKFosXCJhbGxcIiksb2U9Z2UuYm9keS50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIiYmIWYoZ2UuYm9keSxIPT5ILnR5cGU9PT1cIk9iamVjdEV4cHJlc3Npb25cIik7cmV0dXJuIHAoWy4uLlJlLHAoW2QoW2ksb2U/eShcIlwiLFwiKFwiKTpcIlwiLHdlLG9lP3koXCJcIixcIilcIik6XCJcIl0pLE5lP1t5KFBlP1wiLFwiOlwiXCIpLGxdOlwiXCJdKV0pfWZ1bmN0aW9uIGxlKFUpe2xldCBaPUYoVSk7cmV0dXJuIFoubGVuZ3RoPT09MSYmIVUudHlwZVBhcmFtZXRlcnMmJiF2KFUsaC5EYW5nbGluZykmJlpbMF0udHlwZT09PVwiSWRlbnRpZmllclwiJiYhWlswXS50eXBlQW5ub3RhdGlvbiYmIXYoWlswXSkmJiFaWzBdLm9wdGlvbmFsJiYhVS5wcmVkaWNhdGUmJiFVLnJldHVyblR5cGV9ZnVuY3Rpb24gVyhVLFope2lmKFouYXJyb3dQYXJlbnM9PT1cImFsd2F5c1wiKXJldHVybiExO2lmKFouYXJyb3dQYXJlbnM9PT1cImF2b2lkXCIpe2xldCBzZT1VLmdldFZhbHVlKCk7cmV0dXJuIGxlKHNlKX1yZXR1cm4hMX1mdW5jdGlvbiBLKFUsWixzZSl7bGV0IERlPVUuZ2V0VmFsdWUoKSxnZT1aKFwicmV0dXJuVHlwZVwiKTtpZihEZS5yZXR1cm5UeXBlJiZOKHNlLm9yaWdpbmFsVGV4dCxEZS5yZXR1cm5UeXBlKSlyZXR1cm5bXCIgLyo6IFwiLGdlLFwiICovXCJdO2xldCBoZT1bZ2VdO3JldHVybiBEZS5yZXR1cm5UeXBlJiZEZS5yZXR1cm5UeXBlLnR5cGVBbm5vdGF0aW9uJiZoZS51bnNoaWZ0KFwiOiBcIiksRGUucHJlZGljYXRlJiZoZS5wdXNoKERlLnJldHVyblR5cGU/XCIgXCI6XCI6IFwiLFooXCJwcmVkaWNhdGVcIikpLGhlfWZ1bmN0aW9uIGRlKFUsWixzZSl7bGV0IERlPVUuZ2V0VmFsdWUoKSxnZT1aLnNlbWk/XCI7XCI6XCJcIixoZT1bXTtEZS5hcmd1bWVudCYmKHooWixEZS5hcmd1bWVudCk/aGUucHVzaChbXCIgKFwiLGQoW2csc2UoXCJhcmd1bWVudFwiKV0pLGcsXCIpXCJdKTpUKERlLmFyZ3VtZW50KXx8RGUuYXJndW1lbnQudHlwZT09PVwiU2VxdWVuY2VFeHByZXNzaW9uXCI/aGUucHVzaChwKFt5KFwiIChcIixcIiBcIiksZChbbCxzZShcImFyZ3VtZW50XCIpXSksbCx5KFwiKVwiKV0pKTpoZS5wdXNoKFwiIFwiLHNlKFwiYXJndW1lbnRcIikpKTtsZXQgd2U9byhEZSksa2U9bih3ZSksUmU9a2UmJm0oa2UpO3JldHVybiBSZSYmaGUucHVzaChnZSksdihEZSxoLkRhbmdsaW5nKSYmaGUucHVzaChcIiBcIixzKFUsWiwhMCkpLFJlfHxoZS5wdXNoKGdlKSxoZX1mdW5jdGlvbiB1ZShVLFosc2Upe3JldHVybltcInJldHVyblwiLGRlKFUsWixzZSldfWZ1bmN0aW9uIEZlKFUsWixzZSl7cmV0dXJuW1widGhyb3dcIixkZShVLFosc2UpXX1mdW5jdGlvbiB6KFUsWil7aWYoUyhVLm9yaWdpbmFsVGV4dCxaKSlyZXR1cm4hMDtpZihCKFopKXtsZXQgc2U9WixEZTtmb3IoO0RlPWsoc2UpOylpZihzZT1EZSxTKFUub3JpZ2luYWxUZXh0LHNlKSlyZXR1cm4hMH1yZXR1cm4hMX1yLmV4cG9ydHM9e3ByaW50RnVuY3Rpb246USxwcmludEFycm93RnVuY3Rpb246ZWUscHJpbnRNZXRob2Q6VixwcmludFJldHVyblN0YXRlbWVudDp1ZSxwcmludFRocm93U3RhdGVtZW50OkZlLHByaW50TWV0aG9kSW50ZXJuYWw6aixzaG91bGRQcmludFBhcmFtc1dpdGhvdXRQYXJlbnM6V319fSksbnU9dGUoe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2RlY29yYXRvcnMuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2lzTm9uRW1wdHlBcnJheTp0LGhhc05ld2xpbmU6c309VWUoKSx7YnVpbGRlcnM6e2xpbmU6YSxoYXJkbGluZTpuLGpvaW46dSxicmVha1BhcmVudDppLGdyb3VwOmx9fT1xZSgpLHtsb2NTdGFydDpwLGxvY0VuZDpkfT11dCgpLHtnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbjp5fT1LZSgpO2Z1bmN0aW9uIGcodyxGLFMpe2xldCBOPXcuZ2V0VmFsdWUoKTtyZXR1cm4gbChbdShhLHcubWFwKFMsXCJkZWNvcmF0b3JzXCIpKSxFKE4sRik/bjphXSl9ZnVuY3Rpb24gYyh3LEYsUyl7cmV0dXJuW3Uobix3Lm1hcChTLFwiZGVjbGFyYXRpb25cIixcImRlY29yYXRvcnNcIikpLG5dfWZ1bmN0aW9uIEQodyxGLFMpe2xldCBOPXcuZ2V0VmFsdWUoKSx7ZGVjb3JhdG9yczpJfT1OO2lmKCF0KEkpfHxfKHcuZ2V0UGFyZW50Tm9kZSgpKSlyZXR1cm47bGV0IFA9Ti50eXBlPT09XCJDbGFzc0V4cHJlc3Npb25cInx8Ti50eXBlPT09XCJDbGFzc0RlY2xhcmF0aW9uXCJ8fEUoTixGKTtyZXR1cm5beSh3KT9uOlA/aTpcIlwiLHUoYSx3Lm1hcChTLFwiZGVjb3JhdG9yc1wiKSksYV19ZnVuY3Rpb24gRSh3LEYpe3JldHVybiB3LmRlY29yYXRvcnMuc29tZShTPT5zKEYub3JpZ2luYWxUZXh0LGQoUykpKX1mdW5jdGlvbiBfKHcpe2lmKHcudHlwZSE9PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCImJncudHlwZSE9PVwiRXhwb3J0TmFtZWREZWNsYXJhdGlvblwiJiZ3LnR5cGUhPT1cIkRlY2xhcmVFeHBvcnREZWNsYXJhdGlvblwiKXJldHVybiExO2xldCBGPXcuZGVjbGFyYXRpb24mJncuZGVjbGFyYXRpb24uZGVjb3JhdG9ycztyZXR1cm4gdChGKSYmcCh3KT09PXAoRlswXSl9ci5leHBvcnRzPXtwcmludERlY29yYXRvcnM6RCxwcmludENsYXNzTWVtYmVyRGVjb3JhdG9yczpnLHByaW50RGVjb3JhdG9yc0JlZm9yZUV4cG9ydDpjLGhhc0RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6X319fSksbnI9dGUoe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2NsYXNzLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3Zhcntpc05vbkVtcHR5QXJyYXk6dCxjcmVhdGVHcm91cElkTWFwcGVyOnN9PVVlKCkse3ByaW50Q29tbWVudHM6YSxwcmludERhbmdsaW5nQ29tbWVudHM6bn09ZXQoKSx7YnVpbGRlcnM6e2pvaW46dSxsaW5lOmksaGFyZGxpbmU6bCxzb2Z0bGluZTpwLGdyb3VwOmQsaW5kZW50OnksaWZCcmVhazpnfX09cWUoKSx7aGFzQ29tbWVudDpjLENvbW1lbnRDaGVja0ZsYWdzOkR9PUtlKCkse2dldFR5cGVQYXJhbWV0ZXJzR3JvdXBJZDpFfT1qcigpLHtwcmludE1ldGhvZDpffT1xcigpLHtwcmludE9wdGlvbmFsVG9rZW46dyxwcmludFR5cGVBbm5vdGF0aW9uOkYscHJpbnREZWZpbml0ZVRva2VuOlN9PWN0KCkse3ByaW50UHJvcGVydHlLZXk6Tn09cnIoKSx7cHJpbnRBc3NpZ25tZW50Okl9PXRyKCkse3ByaW50Q2xhc3NNZW1iZXJEZWNvcmF0b3JzOlB9PW51KCk7ZnVuY3Rpb24gJChiLEIsayl7bGV0IE09Yi5nZXRWYWx1ZSgpLFI9W107TS5kZWNsYXJlJiZSLnB1c2goXCJkZWNsYXJlIFwiKSxNLmFic3RyYWN0JiZSLnB1c2goXCJhYnN0cmFjdCBcIiksUi5wdXNoKFwiY2xhc3NcIik7bGV0IHE9TS5pZCYmYyhNLmlkLEQuVHJhaWxpbmcpfHxNLnR5cGVQYXJhbWV0ZXJzJiZjKE0udHlwZVBhcmFtZXRlcnMsRC5UcmFpbGluZyl8fE0uc3VwZXJDbGFzcyYmYyhNLnN1cGVyQ2xhc3MpfHx0KE0uZXh0ZW5kcyl8fHQoTS5taXhpbnMpfHx0KE0uaW1wbGVtZW50cyksSj1bXSxMPVtdO2lmKE0uaWQmJkoucHVzaChcIiBcIixrKFwiaWRcIikpLEoucHVzaChrKFwidHlwZVBhcmFtZXRlcnNcIikpLE0uc3VwZXJDbGFzcyl7bGV0IFE9W2goYixCLGspLGsoXCJzdXBlclR5cGVQYXJhbWV0ZXJzXCIpXSxWPWIuY2FsbChqPT5bXCJleHRlbmRzIFwiLGEoaixRLEIpXSxcInN1cGVyQ2xhc3NcIik7cT9MLnB1c2goaSxkKFYpKTpMLnB1c2goXCIgXCIsVil9ZWxzZSBMLnB1c2gobyhiLEIsayxcImV4dGVuZHNcIikpO2lmKEwucHVzaChvKGIsQixrLFwibWl4aW5zXCIpLG8oYixCLGssXCJpbXBsZW1lbnRzXCIpKSxxKXtsZXQgUTt2KE0pP1E9Wy4uLkoseShMKV06UT15KFsuLi5KLExdKSxSLnB1c2goZChRLHtpZDpmKE0pfSkpfWVsc2UgUi5wdXNoKC4uLkosLi4uTCk7cmV0dXJuIFIucHVzaChcIiBcIixrKFwiYm9keVwiKSksUn12YXIgZj1zKFwiaGVyaXRhZ2VHcm91cFwiKTtmdW5jdGlvbiBUKGIpe3JldHVybiBnKGwsXCJcIix7Z3JvdXBJZDpmKGIpfSl9ZnVuY3Rpb24gbShiKXtyZXR1cm5bXCJzdXBlckNsYXNzXCIsXCJleHRlbmRzXCIsXCJtaXhpbnNcIixcImltcGxlbWVudHNcIl0uZmlsdGVyKEI9PkJvb2xlYW4oYltCXSkpLmxlbmd0aD4xfWZ1bmN0aW9uIHYoYil7cmV0dXJuIGIudHlwZVBhcmFtZXRlcnMmJiFjKGIudHlwZVBhcmFtZXRlcnMsRC5UcmFpbGluZ3xELkxpbmUpJiYhbShiKX1mdW5jdGlvbiBvKGIsQixrLE0pe2xldCBSPWIuZ2V0VmFsdWUoKTtpZighdChSW01dKSlyZXR1cm5cIlwiO2xldCBxPW4oYixCLCEwLEo9PntsZXR7bWFya2VyOkx9PUo7cmV0dXJuIEw9PT1NfSk7cmV0dXJuW3YoUik/ZyhcIiBcIixpLHtncm91cElkOkUoUi50eXBlUGFyYW1ldGVycyl9KTppLHEscSYmbCxNLGQoeShbaSx1KFtcIixcIixpXSxiLm1hcChrLE0pKV0pKV19ZnVuY3Rpb24gaChiLEIsayl7bGV0IE09ayhcInN1cGVyQ2xhc3NcIik7cmV0dXJuIGIuZ2V0UGFyZW50Tm9kZSgpLnR5cGU9PT1cIkFzc2lnbm1lbnRFeHByZXNzaW9uXCI/ZChnKFtcIihcIix5KFtwLE1dKSxwLFwiKVwiXSxNKSk6TX1mdW5jdGlvbiBDKGIsQixrKXtsZXQgTT1iLmdldFZhbHVlKCksUj1bXTtyZXR1cm4gdChNLmRlY29yYXRvcnMpJiZSLnB1c2goUChiLEIsaykpLE0uYWNjZXNzaWJpbGl0eSYmUi5wdXNoKE0uYWNjZXNzaWJpbGl0eStcIiBcIiksTS5yZWFkb25seSYmUi5wdXNoKFwicmVhZG9ubHkgXCIpLE0uZGVjbGFyZSYmUi5wdXNoKFwiZGVjbGFyZSBcIiksTS5zdGF0aWMmJlIucHVzaChcInN0YXRpYyBcIiksKE0udHlwZT09PVwiVFNBYnN0cmFjdE1ldGhvZERlZmluaXRpb25cInx8TS5hYnN0cmFjdCkmJlIucHVzaChcImFic3RyYWN0IFwiKSxNLm92ZXJyaWRlJiZSLnB1c2goXCJvdmVycmlkZSBcIiksUi5wdXNoKF8oYixCLGspKSxSfWZ1bmN0aW9uIHgoYixCLGspe2xldCBNPWIuZ2V0VmFsdWUoKSxSPVtdLHE9Qi5zZW1pP1wiO1wiOlwiXCI7cmV0dXJuIHQoTS5kZWNvcmF0b3JzKSYmUi5wdXNoKFAoYixCLGspKSxNLmFjY2Vzc2liaWxpdHkmJlIucHVzaChNLmFjY2Vzc2liaWxpdHkrXCIgXCIpLE0uZGVjbGFyZSYmUi5wdXNoKFwiZGVjbGFyZSBcIiksTS5zdGF0aWMmJlIucHVzaChcInN0YXRpYyBcIiksKE0udHlwZT09PVwiVFNBYnN0cmFjdFByb3BlcnR5RGVmaW5pdGlvblwifHxNLnR5cGU9PT1cIlRTQWJzdHJhY3RBY2Nlc3NvclByb3BlcnR5XCJ8fE0uYWJzdHJhY3QpJiZSLnB1c2goXCJhYnN0cmFjdCBcIiksTS5vdmVycmlkZSYmUi5wdXNoKFwib3ZlcnJpZGUgXCIpLE0ucmVhZG9ubHkmJlIucHVzaChcInJlYWRvbmx5IFwiKSxNLnZhcmlhbmNlJiZSLnB1c2goayhcInZhcmlhbmNlXCIpKSwoTS50eXBlPT09XCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcInx8TS50eXBlPT09XCJBY2Nlc3NvclByb3BlcnR5XCJ8fE0udHlwZT09PVwiVFNBYnN0cmFjdEFjY2Vzc29yUHJvcGVydHlcIikmJlIucHVzaChcImFjY2Vzc29yIFwiKSxSLnB1c2goTihiLEIsayksdyhiKSxTKGIpLEYoYixCLGspKSxbSShiLEIsayxSLFwiID1cIixcInZhbHVlXCIpLHFdfXIuZXhwb3J0cz17cHJpbnRDbGFzczokLHByaW50Q2xhc3NNZXRob2Q6QyxwcmludENsYXNzUHJvcGVydHk6eCxwcmludEhhcmRsaW5lQWZ0ZXJIZXJpdGFnZTpUfX19KSxibz10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvaW50ZXJmYWNlLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3Zhcntpc05vbkVtcHR5QXJyYXk6dH09VWUoKSx7YnVpbGRlcnM6e2pvaW46cyxsaW5lOmEsZ3JvdXA6bixpbmRlbnQ6dSxpZkJyZWFrOml9fT1xZSgpLHtoYXNDb21tZW50OmwsaWRlbnRpdHk6cCxDb21tZW50Q2hlY2tGbGFnczpkfT1LZSgpLHtnZXRUeXBlUGFyYW1ldGVyc0dyb3VwSWQ6eX09anIoKSx7cHJpbnRUeXBlU2NyaXB0TW9kaWZpZXJzOmd9PWN0KCk7ZnVuY3Rpb24gYyhELEUsXyl7bGV0IHc9RC5nZXRWYWx1ZSgpLEY9W107dy5kZWNsYXJlJiZGLnB1c2goXCJkZWNsYXJlIFwiKSx3LnR5cGU9PT1cIlRTSW50ZXJmYWNlRGVjbGFyYXRpb25cIiYmRi5wdXNoKHcuYWJzdHJhY3Q/XCJhYnN0cmFjdCBcIjpcIlwiLGcoRCxFLF8pKSxGLnB1c2goXCJpbnRlcmZhY2VcIik7bGV0IFM9W10sTj1bXTt3LnR5cGUhPT1cIkludGVyZmFjZVR5cGVBbm5vdGF0aW9uXCImJlMucHVzaChcIiBcIixfKFwiaWRcIiksXyhcInR5cGVQYXJhbWV0ZXJzXCIpKTtsZXQgST13LnR5cGVQYXJhbWV0ZXJzJiYhbCh3LnR5cGVQYXJhbWV0ZXJzLGQuVHJhaWxpbmd8ZC5MaW5lKTtyZXR1cm4gdCh3LmV4dGVuZHMpJiZOLnB1c2goST9pKFwiIFwiLGEse2dyb3VwSWQ6eSh3LnR5cGVQYXJhbWV0ZXJzKX0pOmEsXCJleHRlbmRzIFwiLCh3LmV4dGVuZHMubGVuZ3RoPT09MT9wOnUpKHMoW1wiLFwiLGFdLEQubWFwKF8sXCJleHRlbmRzXCIpKSkpLHcuaWQmJmwody5pZCxkLlRyYWlsaW5nKXx8dCh3LmV4dGVuZHMpP0k/Ri5wdXNoKG4oWy4uLlMsdShOKV0pKTpGLnB1c2gobih1KFsuLi5TLC4uLk5dKSkpOkYucHVzaCguLi5TLC4uLk4pLEYucHVzaChcIiBcIixfKFwiYm9keVwiKSksbihGKX1yLmV4cG9ydHM9e3ByaW50SW50ZXJmYWNlOmN9fX0pLFRvPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9tb2R1bGUuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2lzTm9uRW1wdHlBcnJheTp0fT1VZSgpLHtidWlsZGVyczp7c29mdGxpbmU6cyxncm91cDphLGluZGVudDpuLGpvaW46dSxsaW5lOmksaWZCcmVhazpsLGhhcmRsaW5lOnB9fT1xZSgpLHtwcmludERhbmdsaW5nQ29tbWVudHM6ZH09ZXQoKSx7aGFzQ29tbWVudDp5LENvbW1lbnRDaGVja0ZsYWdzOmcsc2hvdWxkUHJpbnRDb21tYTpjLG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudDpELGlzU3RyaW5nTGl0ZXJhbDpFLHJhd1RleHQ6X309S2UoKSx7bG9jU3RhcnQ6dyxoYXNTYW1lTG9jOkZ9PXV0KCkse2hhc0RlY29yYXRvcnNCZWZvcmVFeHBvcnQ6UyxwcmludERlY29yYXRvcnNCZWZvcmVFeHBvcnQ6Tn09bnUoKTtmdW5jdGlvbiBJKHgsYixCKXtsZXQgaz14LmdldFZhbHVlKCksTT1iLnNlbWk/XCI7XCI6XCJcIixSPVtdLHtpbXBvcnRLaW5kOnF9PWs7cmV0dXJuIFIucHVzaChcImltcG9ydFwiKSxxJiZxIT09XCJ2YWx1ZVwiJiZSLnB1c2goXCIgXCIscSksUi5wdXNoKG0oeCxiLEIpLFQoeCxiLEIpLG8oeCxiLEIpLE0pLFJ9ZnVuY3Rpb24gUCh4LGIsQil7bGV0IGs9eC5nZXRWYWx1ZSgpLE09W107UyhrKSYmTS5wdXNoKE4oeCxiLEIpKTtsZXR7dHlwZTpSLGV4cG9ydEtpbmQ6cSxkZWNsYXJhdGlvbjpKfT1rO3JldHVybiBNLnB1c2goXCJleHBvcnRcIiksKGsuZGVmYXVsdHx8Uj09PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCIpJiZNLnB1c2goXCIgZGVmYXVsdFwiKSx5KGssZy5EYW5nbGluZykmJihNLnB1c2goXCIgXCIsZCh4LGIsITApKSxEKGspJiZNLnB1c2gocCkpLEo/TS5wdXNoKFwiIFwiLEIoXCJkZWNsYXJhdGlvblwiKSk6TS5wdXNoKHE9PT1cInR5cGVcIj9cIiB0eXBlXCI6XCJcIixtKHgsYixCKSxUKHgsYixCKSxvKHgsYixCKSksZihrLGIpJiZNLnB1c2goXCI7XCIpLE19ZnVuY3Rpb24gJCh4LGIsQil7bGV0IGs9eC5nZXRWYWx1ZSgpLE09Yi5zZW1pP1wiO1wiOlwiXCIsUj1bXSx7ZXhwb3J0S2luZDpxLGV4cG9ydGVkOkp9PWs7cmV0dXJuIFIucHVzaChcImV4cG9ydFwiKSxxPT09XCJ0eXBlXCImJlIucHVzaChcIiB0eXBlXCIpLFIucHVzaChcIiAqXCIpLEomJlIucHVzaChcIiBhcyBcIixCKFwiZXhwb3J0ZWRcIikpLFIucHVzaChUKHgsYixCKSxvKHgsYixCKSxNKSxSfWZ1bmN0aW9uIGYoeCxiKXtpZighYi5zZW1pKXJldHVybiExO2xldHt0eXBlOkIsZGVjbGFyYXRpb246a309eCxNPXguZGVmYXVsdHx8Qj09PVwiRXhwb3J0RGVmYXVsdERlY2xhcmF0aW9uXCI7aWYoIWspcmV0dXJuITA7bGV0e3R5cGU6Un09aztyZXR1cm4hIShNJiZSIT09XCJDbGFzc0RlY2xhcmF0aW9uXCImJlIhPT1cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIiYmUiE9PVwiVFNJbnRlcmZhY2VEZWNsYXJhdGlvblwiJiZSIT09XCJEZWNsYXJlQ2xhc3NcIiYmUiE9PVwiRGVjbGFyZUZ1bmN0aW9uXCImJlIhPT1cIlRTRGVjbGFyZUZ1bmN0aW9uXCImJlIhPT1cIkVudW1EZWNsYXJhdGlvblwiKX1mdW5jdGlvbiBUKHgsYixCKXtsZXQgaz14LmdldFZhbHVlKCk7aWYoIWsuc291cmNlKXJldHVyblwiXCI7bGV0IE09W107cmV0dXJuIHYoayxiKXx8TS5wdXNoKFwiIGZyb21cIiksTS5wdXNoKFwiIFwiLEIoXCJzb3VyY2VcIikpLE19ZnVuY3Rpb24gbSh4LGIsQil7bGV0IGs9eC5nZXRWYWx1ZSgpO2lmKHYoayxiKSlyZXR1cm5cIlwiO2xldCBNPVtcIiBcIl07aWYodChrLnNwZWNpZmllcnMpKXtsZXQgUj1bXSxxPVtdO3guZWFjaCgoKT0+e2xldCBKPXguZ2V0VmFsdWUoKS50eXBlO2lmKEo9PT1cIkV4cG9ydE5hbWVzcGFjZVNwZWNpZmllclwifHxKPT09XCJFeHBvcnREZWZhdWx0U3BlY2lmaWVyXCJ8fEo9PT1cIkltcG9ydE5hbWVzcGFjZVNwZWNpZmllclwifHxKPT09XCJJbXBvcnREZWZhdWx0U3BlY2lmaWVyXCIpUi5wdXNoKEIoKSk7ZWxzZSBpZihKPT09XCJFeHBvcnRTcGVjaWZpZXJcInx8Sj09PVwiSW1wb3J0U3BlY2lmaWVyXCIpcS5wdXNoKEIoKSk7ZWxzZSB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3BlY2lmaWVyIHR5cGUgJHtKU09OLnN0cmluZ2lmeShKKX1gKX0sXCJzcGVjaWZpZXJzXCIpLE0ucHVzaCh1KFwiLCBcIixSKSkscS5sZW5ndGg+MCYmKFIubGVuZ3RoPjAmJk0ucHVzaChcIiwgXCIpLHEubGVuZ3RoPjF8fFIubGVuZ3RoPjB8fGsuc3BlY2lmaWVycy5zb21lKEw9PnkoTCkpP00ucHVzaChhKFtcIntcIixuKFtiLmJyYWNrZXRTcGFjaW5nP2k6cyx1KFtcIixcIixpXSxxKV0pLGwoYyhiKT9cIixcIjpcIlwiKSxiLmJyYWNrZXRTcGFjaW5nP2k6cyxcIn1cIl0pKTpNLnB1c2goW1wie1wiLGIuYnJhY2tldFNwYWNpbmc/XCIgXCI6XCJcIiwuLi5xLGIuYnJhY2tldFNwYWNpbmc/XCIgXCI6XCJcIixcIn1cIl0pKX1lbHNlIE0ucHVzaChcInt9XCIpO3JldHVybiBNfWZ1bmN0aW9uIHYoeCxiKXtsZXR7dHlwZTpCLGltcG9ydEtpbmQ6ayxzb3VyY2U6TSxzcGVjaWZpZXJzOlJ9PXg7cmV0dXJuIEIhPT1cIkltcG9ydERlY2xhcmF0aW9uXCJ8fHQoUil8fGs9PT1cInR5cGVcIj8hMTohL3tcXHMqfS8udGVzdChiLm9yaWdpbmFsVGV4dC5zbGljZSh3KHgpLHcoTSkpKX1mdW5jdGlvbiBvKHgsYixCKXtsZXQgaz14LmdldE5vZGUoKTtyZXR1cm4gdChrLmFzc2VydGlvbnMpP1tcIiBhc3NlcnQge1wiLGIuYnJhY2tldFNwYWNpbmc/XCIgXCI6XCJcIix1KFwiLCBcIix4Lm1hcChCLFwiYXNzZXJ0aW9uc1wiKSksYi5icmFja2V0U3BhY2luZz9cIiBcIjpcIlwiLFwifVwiXTpcIlwifWZ1bmN0aW9uIGgoeCxiLEIpe2xldCBrPXguZ2V0Tm9kZSgpLHt0eXBlOk19PWssUj1bXSxxPU09PT1cIkltcG9ydFNwZWNpZmllclwiP2suaW1wb3J0S2luZDprLmV4cG9ydEtpbmQ7cSYmcSE9PVwidmFsdWVcIiYmUi5wdXNoKHEsXCIgXCIpO2xldCBKPU0uc3RhcnRzV2l0aChcIkltcG9ydFwiKSxMPUo/XCJpbXBvcnRlZFwiOlwibG9jYWxcIixRPUo/XCJsb2NhbFwiOlwiZXhwb3J0ZWRcIixWPWtbTF0saj1rW1FdLFk9XCJcIixpZT1cIlwiO3JldHVybiBNPT09XCJFeHBvcnROYW1lc3BhY2VTcGVjaWZpZXJcInx8TT09PVwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI/WT1cIipcIjpWJiYoWT1CKEwpKSxqJiYhQyhrKSYmKGllPUIoUSkpLFIucHVzaChZLFkmJmllP1wiIGFzIFwiOlwiXCIsaWUpLFJ9ZnVuY3Rpb24gQyh4KXtpZih4LnR5cGUhPT1cIkltcG9ydFNwZWNpZmllclwiJiZ4LnR5cGUhPT1cIkV4cG9ydFNwZWNpZmllclwiKXJldHVybiExO2xldHtsb2NhbDpiLFt4LnR5cGU9PT1cIkltcG9ydFNwZWNpZmllclwiP1wiaW1wb3J0ZWRcIjpcImV4cG9ydGVkXCJdOkJ9PXg7aWYoYi50eXBlIT09Qi50eXBlfHwhRihiLEIpKXJldHVybiExO2lmKEUoYikpcmV0dXJuIGIudmFsdWU9PT1CLnZhbHVlJiZfKGIpPT09XyhCKTtzd2l0Y2goYi50eXBlKXtjYXNlXCJJZGVudGlmaWVyXCI6cmV0dXJuIGIubmFtZT09PUIubmFtZTtkZWZhdWx0OnJldHVybiExfX1yLmV4cG9ydHM9e3ByaW50SW1wb3J0RGVjbGFyYXRpb246SSxwcmludEV4cG9ydERlY2xhcmF0aW9uOlAscHJpbnRFeHBvcnRBbGxEZWNsYXJhdGlvbjokLHByaW50TW9kdWxlU3BlY2lmaWVyOmh9fX0pLHV1PXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9vYmplY3QuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50RGFuZ2xpbmdDb21tZW50czp0fT1ldCgpLHtidWlsZGVyczp7bGluZTpzLHNvZnRsaW5lOmEsZ3JvdXA6bixpbmRlbnQ6dSxpZkJyZWFrOmksaGFyZGxpbmU6bH19PXFlKCkse2dldExhc3Q6cCxoYXNOZXdsaW5lSW5SYW5nZTpkLGhhc05ld2xpbmU6eSxpc05vbkVtcHR5QXJyYXk6Z309VWUoKSx7c2hvdWxkUHJpbnRDb21tYTpjLGhhc0NvbW1lbnQ6RCxnZXRDb21tZW50czpFLENvbW1lbnRDaGVja0ZsYWdzOl8saXNOZXh0TGluZUVtcHR5Ond9PUtlKCkse2xvY1N0YXJ0OkYsbG9jRW5kOlN9PXV0KCkse3ByaW50T3B0aW9uYWxUb2tlbjpOLHByaW50VHlwZUFubm90YXRpb246SX09Y3QoKSx7c2hvdWxkSHVnRnVuY3Rpb25QYXJhbWV0ZXJzOlB9PUxyKCkse3Nob3VsZEh1Z1R5cGU6JH09T3IoKSx7cHJpbnRIYXJkbGluZUFmdGVySGVyaXRhZ2U6Zn09bnIoKTtmdW5jdGlvbiBUKG0sdixvKXtsZXQgaD12LnNlbWk/XCI7XCI6XCJcIixDPW0uZ2V0VmFsdWUoKSx4O0MudHlwZT09PVwiVFNUeXBlTGl0ZXJhbFwiP3g9XCJtZW1iZXJzXCI6Qy50eXBlPT09XCJUU0ludGVyZmFjZUJvZHlcIj94PVwiYm9keVwiOng9XCJwcm9wZXJ0aWVzXCI7bGV0IGI9Qy50eXBlPT09XCJPYmplY3RUeXBlQW5ub3RhdGlvblwiLEI9W3hdO2ImJkIucHVzaChcImluZGV4ZXJzXCIsXCJjYWxsUHJvcGVydGllc1wiLFwiaW50ZXJuYWxTbG90c1wiKTtsZXQgaz1CLm1hcChXPT5DW1ddWzBdKS5zb3J0KChXLEspPT5GKFcpLUYoSykpWzBdLE09bS5nZXRQYXJlbnROb2RlKDApLFI9YiYmTSYmKE0udHlwZT09PVwiSW50ZXJmYWNlRGVjbGFyYXRpb25cInx8TS50eXBlPT09XCJEZWNsYXJlSW50ZXJmYWNlXCJ8fE0udHlwZT09PVwiRGVjbGFyZUNsYXNzXCIpJiZtLmdldE5hbWUoKT09PVwiYm9keVwiLHE9Qy50eXBlPT09XCJUU0ludGVyZmFjZUJvZHlcInx8Unx8Qy50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCImJk0udHlwZSE9PVwiRnVuY3Rpb25EZWNsYXJhdGlvblwiJiZNLnR5cGUhPT1cIkZ1bmN0aW9uRXhwcmVzc2lvblwiJiZNLnR5cGUhPT1cIkFycm93RnVuY3Rpb25FeHByZXNzaW9uXCImJk0udHlwZSE9PVwiT2JqZWN0TWV0aG9kXCImJk0udHlwZSE9PVwiQ2xhc3NNZXRob2RcIiYmTS50eXBlIT09XCJDbGFzc1ByaXZhdGVNZXRob2RcIiYmTS50eXBlIT09XCJBc3NpZ25tZW50UGF0dGVyblwiJiZNLnR5cGUhPT1cIkNhdGNoQ2xhdXNlXCImJkMucHJvcGVydGllcy5zb21lKFc9PlcudmFsdWUmJihXLnZhbHVlLnR5cGU9PT1cIk9iamVjdFBhdHRlcm5cInx8Vy52YWx1ZS50eXBlPT09XCJBcnJheVBhdHRlcm5cIikpfHxDLnR5cGUhPT1cIk9iamVjdFBhdHRlcm5cIiYmayYmZCh2Lm9yaWdpbmFsVGV4dCxGKEMpLEYoaykpLEo9Uj9cIjtcIjpDLnR5cGU9PT1cIlRTSW50ZXJmYWNlQm9keVwifHxDLnR5cGU9PT1cIlRTVHlwZUxpdGVyYWxcIj9pKGgsXCI7XCIpOlwiLFwiLEw9Qy50eXBlPT09XCJSZWNvcmRFeHByZXNzaW9uXCI/XCIje1wiOkMuZXhhY3Q/XCJ7fFwiOlwie1wiLFE9Qy5leGFjdD9cInx9XCI6XCJ9XCIsVj1bXTtmb3IobGV0IFcgb2YgQiltLmVhY2goSz0+e2xldCBkZT1LLmdldFZhbHVlKCk7Vi5wdXNoKHtub2RlOmRlLHByaW50ZWQ6bygpLGxvYzpGKGRlKX0pfSxXKTtCLmxlbmd0aD4xJiZWLnNvcnQoKFcsSyk9PlcubG9jLUsubG9jKTtsZXQgaj1bXSxZPVYubWFwKFc9PntsZXQgSz1bLi4uaixuKFcucHJpbnRlZCldO3JldHVybiBqPVtKLHNdLChXLm5vZGUudHlwZT09PVwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwifHxXLm5vZGUudHlwZT09PVwiVFNNZXRob2RTaWduYXR1cmVcInx8Vy5ub2RlLnR5cGU9PT1cIlRTQ29uc3RydWN0U2lnbmF0dXJlRGVjbGFyYXRpb25cIikmJkQoVy5ub2RlLF8uUHJldHRpZXJJZ25vcmUpJiZqLnNoaWZ0KCksdyhXLm5vZGUsdikmJmoucHVzaChsKSxLfSk7aWYoQy5pbmV4YWN0KXtsZXQgVztpZihEKEMsXy5EYW5nbGluZykpe2xldCBLPUQoQyxfLkxpbmUpO1c9W3QobSx2LCEwKSxLfHx5KHYub3JpZ2luYWxUZXh0LFMocChFKEMpKSkpP2w6cyxcIi4uLlwiXX1lbHNlIFc9W1wiLi4uXCJdO1kucHVzaChbLi4uaiwuLi5XXSl9bGV0IGllPXAoQ1t4XSksZWU9IShDLmluZXhhY3R8fGllJiZpZS50eXBlPT09XCJSZXN0RWxlbWVudFwifHxpZSYmKGllLnR5cGU9PT1cIlRTUHJvcGVydHlTaWduYXR1cmVcInx8aWUudHlwZT09PVwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cInx8aWUudHlwZT09PVwiVFNNZXRob2RTaWduYXR1cmVcInx8aWUudHlwZT09PVwiVFNDb25zdHJ1Y3RTaWduYXR1cmVEZWNsYXJhdGlvblwiKSYmRChpZSxfLlByZXR0aWVySWdub3JlKSksbGU7aWYoWS5sZW5ndGg9PT0wKXtpZighRChDLF8uRGFuZ2xpbmcpKXJldHVybltMLFEsSShtLHYsbyldO2xlPW4oW0wsdChtLHYpLGEsUSxOKG0pLEkobSx2LG8pXSl9ZWxzZSBsZT1bUiYmZyhDLnByb3BlcnRpZXMpP2YoTSk6XCJcIixMLHUoW3YuYnJhY2tldFNwYWNpbmc/czphLC4uLlldKSxpKGVlJiYoSiE9PVwiLFwifHxjKHYpKT9KOlwiXCIpLHYuYnJhY2tldFNwYWNpbmc/czphLFEsTihtKSxJKG0sdixvKV07cmV0dXJuIG0ubWF0Y2goVz0+Vy50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCImJiFXLmRlY29yYXRvcnMsKFcsSyxkZSk9PlAoVykmJihLPT09XCJwYXJhbXNcInx8Sz09PVwicGFyYW1ldGVyc1wifHxLPT09XCJ0aGlzXCJ8fEs9PT1cInJlc3RcIikmJmRlPT09MCl8fG0ubWF0Y2goJCwoVyxLKT0+Sz09PVwidHlwZUFubm90YXRpb25cIiwoVyxLKT0+Sz09PVwidHlwZUFubm90YXRpb25cIiwoVyxLLGRlKT0+UChXKSYmKEs9PT1cInBhcmFtc1wifHxLPT09XCJwYXJhbWV0ZXJzXCJ8fEs9PT1cInRoaXNcInx8Sz09PVwicmVzdFwiKSYmZGU9PT0wKXx8IXEmJm0ubWF0Y2goVz0+Vy50eXBlPT09XCJPYmplY3RQYXR0ZXJuXCIsVz0+Vy50eXBlPT09XCJBc3NpZ25tZW50RXhwcmVzc2lvblwifHxXLnR5cGU9PT1cIlZhcmlhYmxlRGVjbGFyYXRvclwiKT9sZTpuKGxlLHtzaG91bGRCcmVhazpxfSl9ci5leHBvcnRzPXtwcmludE9iamVjdDpUfX19KSxtZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvZmxvdy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1adCgpLHtwcmludERhbmdsaW5nQ29tbWVudHM6c309ZXQoKSx7cHJpbnRTdHJpbmc6YSxwcmludE51bWJlcjpufT1VZSgpLHtidWlsZGVyczp7aGFyZGxpbmU6dSxzb2Z0bGluZTppLGdyb3VwOmwsaW5kZW50OnB9fT1xZSgpLHtnZXRQYXJlbnRFeHBvcnREZWNsYXJhdGlvbjpkLGlzRnVuY3Rpb25Ob3RhdGlvbjp5LGlzR2V0dGVyT3JTZXR0ZXI6ZyxyYXdUZXh0OmMsc2hvdWxkUHJpbnRDb21tYTpEfT1LZSgpLHtsb2NTdGFydDpFLGxvY0VuZDpffT11dCgpLHtyZXBsYWNlVGV4dEVuZE9mTGluZTp3fT1ZdCgpLHtwcmludENsYXNzOkZ9PW5yKCkse3ByaW50T3BhcXVlVHlwZTpTLHByaW50VHlwZUFsaWFzOk4scHJpbnRJbnRlcnNlY3Rpb25UeXBlOkkscHJpbnRVbmlvblR5cGU6UCxwcmludEZ1bmN0aW9uVHlwZTokLHByaW50VHVwbGVUeXBlOmYscHJpbnRJbmRleGVkQWNjZXNzVHlwZTpUfT1PcigpLHtwcmludEludGVyZmFjZTptfT1ibygpLHtwcmludFR5cGVQYXJhbWV0ZXI6dixwcmludFR5cGVQYXJhbWV0ZXJzOm99PWpyKCkse3ByaW50RXhwb3J0RGVjbGFyYXRpb246aCxwcmludEV4cG9ydEFsbERlY2xhcmF0aW9uOkN9PVRvKCkse3ByaW50QXJyYXlJdGVtczp4fT1lcigpLHtwcmludE9iamVjdDpifT11dSgpLHtwcmludFByb3BlcnR5S2V5OkJ9PXJyKCkse3ByaW50T3B0aW9uYWxUb2tlbjprLHByaW50VHlwZUFubm90YXRpb246TSxwcmludFJlc3RTcHJlYWQ6Un09Y3QoKTtmdW5jdGlvbiBxKEwsUSxWKXtsZXQgaj1MLmdldFZhbHVlKCksWT1RLnNlbWk/XCI7XCI6XCJcIixpZT1bXTtzd2l0Y2goai50eXBlKXtjYXNlXCJEZWNsYXJlQ2xhc3NcIjpyZXR1cm4gSihMLEYoTCxRLFYpKTtjYXNlXCJEZWNsYXJlRnVuY3Rpb25cIjpyZXR1cm4gSihMLFtcImZ1bmN0aW9uIFwiLFYoXCJpZFwiKSxqLnByZWRpY2F0ZT9cIiBcIjpcIlwiLFYoXCJwcmVkaWNhdGVcIiksWV0pO2Nhc2VcIkRlY2xhcmVNb2R1bGVcIjpyZXR1cm4gSihMLFtcIm1vZHVsZSBcIixWKFwiaWRcIiksXCIgXCIsVihcImJvZHlcIildKTtjYXNlXCJEZWNsYXJlTW9kdWxlRXhwb3J0c1wiOnJldHVybiBKKEwsW1wibW9kdWxlLmV4cG9ydHNcIixcIjogXCIsVihcInR5cGVBbm5vdGF0aW9uXCIpLFldKTtjYXNlXCJEZWNsYXJlVmFyaWFibGVcIjpyZXR1cm4gSihMLFtcInZhciBcIixWKFwiaWRcIiksWV0pO2Nhc2VcIkRlY2xhcmVPcGFxdWVUeXBlXCI6cmV0dXJuIEooTCxTKEwsUSxWKSk7Y2FzZVwiRGVjbGFyZUludGVyZmFjZVwiOnJldHVybiBKKEwsbShMLFEsVikpO2Nhc2VcIkRlY2xhcmVUeXBlQWxpYXNcIjpyZXR1cm4gSihMLE4oTCxRLFYpKTtjYXNlXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIjpyZXR1cm4gSihMLGgoTCxRLFYpKTtjYXNlXCJEZWNsYXJlRXhwb3J0QWxsRGVjbGFyYXRpb25cIjpyZXR1cm4gSihMLEMoTCxRLFYpKTtjYXNlXCJPcGFxdWVUeXBlXCI6cmV0dXJuIFMoTCxRLFYpO2Nhc2VcIlR5cGVBbGlhc1wiOnJldHVybiBOKEwsUSxWKTtjYXNlXCJJbnRlcnNlY3Rpb25UeXBlQW5ub3RhdGlvblwiOnJldHVybiBJKEwsUSxWKTtjYXNlXCJVbmlvblR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIFAoTCxRLFYpO2Nhc2VcIkZ1bmN0aW9uVHlwZUFubm90YXRpb25cIjpyZXR1cm4gJChMLFEsVik7Y2FzZVwiVHVwbGVUeXBlQW5ub3RhdGlvblwiOnJldHVybiBmKEwsUSxWKTtjYXNlXCJHZW5lcmljVHlwZUFubm90YXRpb25cIjpyZXR1cm5bVihcImlkXCIpLG8oTCxRLFYsXCJ0eXBlUGFyYW1ldGVyc1wiKV07Y2FzZVwiSW5kZXhlZEFjY2Vzc1R5cGVcIjpjYXNlXCJPcHRpb25hbEluZGV4ZWRBY2Nlc3NUeXBlXCI6cmV0dXJuIFQoTCxRLFYpO2Nhc2VcIlR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIFYoXCJ0eXBlQW5ub3RhdGlvblwiKTtjYXNlXCJUeXBlUGFyYW1ldGVyXCI6cmV0dXJuIHYoTCxRLFYpO2Nhc2VcIlR5cGVvZlR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuW1widHlwZW9mIFwiLFYoXCJhcmd1bWVudFwiKV07Y2FzZVwiRXhpc3RzVHlwZUFubm90YXRpb25cIjpyZXR1cm5cIipcIjtjYXNlXCJFbXB0eVR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJlbXB0eVwiO2Nhc2VcIk1peGVkVHlwZUFubm90YXRpb25cIjpyZXR1cm5cIm1peGVkXCI7Y2FzZVwiQXJyYXlUeXBlQW5ub3RhdGlvblwiOnJldHVybltWKFwiZWxlbWVudFR5cGVcIiksXCJbXVwiXTtjYXNlXCJCb29sZWFuTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIFN0cmluZyhqLnZhbHVlKTtjYXNlXCJFbnVtRGVjbGFyYXRpb25cIjpyZXR1cm5bXCJlbnVtIFwiLFYoXCJpZFwiKSxcIiBcIixWKFwiYm9keVwiKV07Y2FzZVwiRW51bUJvb2xlYW5Cb2R5XCI6Y2FzZVwiRW51bU51bWJlckJvZHlcIjpjYXNlXCJFbnVtU3RyaW5nQm9keVwiOmNhc2VcIkVudW1TeW1ib2xCb2R5XCI6e2lmKGoudHlwZT09PVwiRW51bVN5bWJvbEJvZHlcInx8ai5leHBsaWNpdFR5cGUpe2xldCBlZT1udWxsO3N3aXRjaChqLnR5cGUpe2Nhc2VcIkVudW1Cb29sZWFuQm9keVwiOmVlPVwiYm9vbGVhblwiO2JyZWFrO2Nhc2VcIkVudW1OdW1iZXJCb2R5XCI6ZWU9XCJudW1iZXJcIjticmVhaztjYXNlXCJFbnVtU3RyaW5nQm9keVwiOmVlPVwic3RyaW5nXCI7YnJlYWs7Y2FzZVwiRW51bVN5bWJvbEJvZHlcIjplZT1cInN5bWJvbFwiO2JyZWFrfWllLnB1c2goXCJvZiBcIixlZSxcIiBcIil9aWYoai5tZW1iZXJzLmxlbmd0aD09PTAmJiFqLmhhc1Vua25vd25NZW1iZXJzKWllLnB1c2gobChbXCJ7XCIscyhMLFEpLGksXCJ9XCJdKSk7ZWxzZXtsZXQgZWU9ai5tZW1iZXJzLmxlbmd0aD4wP1t1LHgoTCxRLFwibWVtYmVyc1wiLFYpLGouaGFzVW5rbm93bk1lbWJlcnN8fEQoUSk/XCIsXCI6XCJcIl06W107aWUucHVzaChsKFtcIntcIixwKFsuLi5lZSwuLi5qLmhhc1Vua25vd25NZW1iZXJzP1t1LFwiLi4uXCJdOltdXSkscyhMLFEsITApLHUsXCJ9XCJdKSl9cmV0dXJuIGllfWNhc2VcIkVudW1Cb29sZWFuTWVtYmVyXCI6Y2FzZVwiRW51bU51bWJlck1lbWJlclwiOmNhc2VcIkVudW1TdHJpbmdNZW1iZXJcIjpyZXR1cm5bVihcImlkXCIpLFwiID0gXCIsdHlwZW9mIGouaW5pdD09XCJvYmplY3RcIj9WKFwiaW5pdFwiKTpTdHJpbmcoai5pbml0KV07Y2FzZVwiRW51bURlZmF1bHRlZE1lbWJlclwiOnJldHVybiBWKFwiaWRcIik7Y2FzZVwiRnVuY3Rpb25UeXBlUGFyYW1cIjp7bGV0IGVlPWoubmFtZT9WKFwibmFtZVwiKTpMLmdldFBhcmVudE5vZGUoKS50aGlzPT09aj9cInRoaXNcIjpcIlwiO3JldHVybltlZSxrKEwpLGVlP1wiOiBcIjpcIlwiLFYoXCJ0eXBlQW5ub3RhdGlvblwiKV19Y2FzZVwiSW50ZXJmYWNlRGVjbGFyYXRpb25cIjpjYXNlXCJJbnRlcmZhY2VUeXBlQW5ub3RhdGlvblwiOnJldHVybiBtKEwsUSxWKTtjYXNlXCJDbGFzc0ltcGxlbWVudHNcIjpjYXNlXCJJbnRlcmZhY2VFeHRlbmRzXCI6cmV0dXJuW1YoXCJpZFwiKSxWKFwidHlwZVBhcmFtZXRlcnNcIildO2Nhc2VcIk51bGxhYmxlVHlwZUFubm90YXRpb25cIjpyZXR1cm5bXCI/XCIsVihcInR5cGVBbm5vdGF0aW9uXCIpXTtjYXNlXCJWYXJpYW5jZVwiOntsZXR7a2luZDplZX09ajtyZXR1cm4gdC5vayhlZT09PVwicGx1c1wifHxlZT09PVwibWludXNcIiksZWU9PT1cInBsdXNcIj9cIitcIjpcIi1cIn1jYXNlXCJPYmplY3RUeXBlQ2FsbFByb3BlcnR5XCI6cmV0dXJuIGouc3RhdGljJiZpZS5wdXNoKFwic3RhdGljIFwiKSxpZS5wdXNoKFYoXCJ2YWx1ZVwiKSksaWU7Y2FzZVwiT2JqZWN0VHlwZUluZGV4ZXJcIjpyZXR1cm5bai5zdGF0aWM/XCJzdGF0aWMgXCI6XCJcIixqLnZhcmlhbmNlP1YoXCJ2YXJpYW5jZVwiKTpcIlwiLFwiW1wiLFYoXCJpZFwiKSxqLmlkP1wiOiBcIjpcIlwiLFYoXCJrZXlcIiksXCJdOiBcIixWKFwidmFsdWVcIildO2Nhc2VcIk9iamVjdFR5cGVQcm9wZXJ0eVwiOntsZXQgZWU9XCJcIjtyZXR1cm4gai5wcm90bz9lZT1cInByb3RvIFwiOmouc3RhdGljJiYoZWU9XCJzdGF0aWMgXCIpLFtlZSxnKGopP2oua2luZCtcIiBcIjpcIlwiLGoudmFyaWFuY2U/VihcInZhcmlhbmNlXCIpOlwiXCIsQihMLFEsViksayhMKSx5KGopP1wiXCI6XCI6IFwiLFYoXCJ2YWx1ZVwiKV19Y2FzZVwiT2JqZWN0VHlwZUFubm90YXRpb25cIjpyZXR1cm4gYihMLFEsVik7Y2FzZVwiT2JqZWN0VHlwZUludGVybmFsU2xvdFwiOnJldHVybltqLnN0YXRpYz9cInN0YXRpYyBcIjpcIlwiLFwiW1tcIixWKFwiaWRcIiksXCJdXVwiLGsoTCksai5tZXRob2Q/XCJcIjpcIjogXCIsVihcInZhbHVlXCIpXTtjYXNlXCJPYmplY3RUeXBlU3ByZWFkUHJvcGVydHlcIjpyZXR1cm4gUihMLFEsVik7Y2FzZVwiUXVhbGlmaWVkVHlwZW9mSWRlbnRpZmllclwiOmNhc2VcIlF1YWxpZmllZFR5cGVJZGVudGlmaWVyXCI6cmV0dXJuW1YoXCJxdWFsaWZpY2F0aW9uXCIpLFwiLlwiLFYoXCJpZFwiKV07Y2FzZVwiU3RyaW5nTGl0ZXJhbFR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIHcoYShjKGopLFEpKTtjYXNlXCJOdW1iZXJMaXRlcmFsVHlwZUFubm90YXRpb25cIjp0LnN0cmljdEVxdWFsKHR5cGVvZiBqLnZhbHVlLFwibnVtYmVyXCIpO2Nhc2VcIkJpZ0ludExpdGVyYWxUeXBlQW5ub3RhdGlvblwiOnJldHVybiBqLmV4dHJhP24oai5leHRyYS5yYXcpOm4oai5yYXcpO2Nhc2VcIlR5cGVDYXN0RXhwcmVzc2lvblwiOnJldHVybltcIihcIixWKFwiZXhwcmVzc2lvblwiKSxNKEwsUSxWKSxcIilcIl07Y2FzZVwiVHlwZVBhcmFtZXRlckRlY2xhcmF0aW9uXCI6Y2FzZVwiVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjp7bGV0IGVlPW8oTCxRLFYsXCJwYXJhbXNcIik7aWYoUS5wYXJzZXI9PT1cImZsb3dcIil7bGV0IGxlPUUoaiksVz1fKGopLEs9US5vcmlnaW5hbFRleHQubGFzdEluZGV4T2YoXCIvKlwiLGxlKSxkZT1RLm9yaWdpbmFsVGV4dC5pbmRleE9mKFwiKi9cIixXKTtpZihLIT09LTEmJmRlIT09LTEpe2xldCB1ZT1RLm9yaWdpbmFsVGV4dC5zbGljZShLKzIsZGUpLnRyaW0oKTtpZih1ZS5zdGFydHNXaXRoKFwiOjpcIikmJiF1ZS5pbmNsdWRlcyhcIi8qXCIpJiYhdWUuaW5jbHVkZXMoXCIqL1wiKSlyZXR1cm5bXCIvKjo6IFwiLGVlLFwiICovXCJdfX1yZXR1cm4gZWV9Y2FzZVwiSW5mZXJyZWRQcmVkaWNhdGVcIjpyZXR1cm5cIiVjaGVja3NcIjtjYXNlXCJEZWNsYXJlZFByZWRpY2F0ZVwiOnJldHVybltcIiVjaGVja3MoXCIsVihcInZhbHVlXCIpLFwiKVwiXTtjYXNlXCJBbnlUeXBlQW5ub3RhdGlvblwiOnJldHVyblwiYW55XCI7Y2FzZVwiQm9vbGVhblR5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJib29sZWFuXCI7Y2FzZVwiQmlnSW50VHlwZUFubm90YXRpb25cIjpyZXR1cm5cImJpZ2ludFwiO2Nhc2VcIk51bGxMaXRlcmFsVHlwZUFubm90YXRpb25cIjpyZXR1cm5cIm51bGxcIjtjYXNlXCJOdW1iZXJUeXBlQW5ub3RhdGlvblwiOnJldHVyblwibnVtYmVyXCI7Y2FzZVwiU3ltYm9sVHlwZUFubm90YXRpb25cIjpyZXR1cm5cInN5bWJvbFwiO2Nhc2VcIlN0cmluZ1R5cGVBbm5vdGF0aW9uXCI6cmV0dXJuXCJzdHJpbmdcIjtjYXNlXCJWb2lkVHlwZUFubm90YXRpb25cIjpyZXR1cm5cInZvaWRcIjtjYXNlXCJUaGlzVHlwZUFubm90YXRpb25cIjpyZXR1cm5cInRoaXNcIjtjYXNlXCJOb2RlXCI6Y2FzZVwiUHJpbnRhYmxlXCI6Y2FzZVwiU291cmNlTG9jYXRpb25cIjpjYXNlXCJQb3NpdGlvblwiOmNhc2VcIlN0YXRlbWVudFwiOmNhc2VcIkZ1bmN0aW9uXCI6Y2FzZVwiUGF0dGVyblwiOmNhc2VcIkV4cHJlc3Npb25cIjpjYXNlXCJEZWNsYXJhdGlvblwiOmNhc2VcIlNwZWNpZmllclwiOmNhc2VcIk5hbWVkU3BlY2lmaWVyXCI6Y2FzZVwiQ29tbWVudFwiOmNhc2VcIk1lbWJlclR5cGVBbm5vdGF0aW9uXCI6Y2FzZVwiVHlwZVwiOnRocm93IG5ldyBFcnJvcihcInVucHJpbnRhYmxlIHR5cGU6IFwiK0pTT04uc3RyaW5naWZ5KGoudHlwZSkpfX1mdW5jdGlvbiBKKEwsUSl7bGV0IFY9ZChMKTtyZXR1cm4gVj8odC5zdHJpY3RFcXVhbChWLnR5cGUsXCJEZWNsYXJlRXhwb3J0RGVjbGFyYXRpb25cIiksUSk6W1wiZGVjbGFyZSBcIixRXX1yLmV4cG9ydHM9e3ByaW50RmxvdzpxfX19KSxkZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvdXRpbHMvaXMtdHMta2V5d29yZC10eXBlLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO2Z1bmN0aW9uIHQocyl7bGV0e3R5cGU6YX09cztyZXR1cm4gYS5zdGFydHNXaXRoKFwiVFNcIikmJmEuZW5kc1dpdGgoXCJLZXl3b3JkXCIpfXIuZXhwb3J0cz10fX0pLEJvPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC90ZXJuYXJ5LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntoYXNOZXdsaW5lSW5SYW5nZTp0fT1VZSgpLHtpc0pzeE5vZGU6cyxnZXRDb21tZW50czphLGlzQ2FsbEV4cHJlc3Npb246bixpc01lbWJlckV4cHJlc3Npb246dSxpc1RTVHlwZUV4cHJlc3Npb246aX09S2UoKSx7bG9jU3RhcnQ6bCxsb2NFbmQ6cH09dXQoKSxkPU90KCkse2J1aWxkZXJzOntsaW5lOnksc29mdGxpbmU6Zyxncm91cDpjLGluZGVudDpELGFsaWduOkUsaWZCcmVhazpfLGRlZGVudDp3LGJyZWFrUGFyZW50OkZ9fT1xZSgpO2Z1bmN0aW9uIFMoZil7bGV0IFQ9W2ZdO2ZvcihsZXQgbT0wO208VC5sZW5ndGg7bSsrKXtsZXQgdj1UW21dO2ZvcihsZXQgbyBvZltcInRlc3RcIixcImNvbnNlcXVlbnRcIixcImFsdGVybmF0ZVwiXSl7bGV0IGg9dltvXTtpZihzKGgpKXJldHVybiEwO2gudHlwZT09PVwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCImJlQucHVzaChoKX19cmV0dXJuITF9ZnVuY3Rpb24gTihmLFQsbSl7bGV0IHY9Zi5nZXRWYWx1ZSgpLG89di50eXBlPT09XCJDb25kaXRpb25hbEV4cHJlc3Npb25cIixoPW8/XCJhbHRlcm5hdGVcIjpcImZhbHNlVHlwZVwiLEM9Zi5nZXRQYXJlbnROb2RlKCkseD1vP20oXCJ0ZXN0XCIpOlttKFwiY2hlY2tUeXBlXCIpLFwiIFwiLFwiZXh0ZW5kc1wiLFwiIFwiLG0oXCJleHRlbmRzVHlwZVwiKV07cmV0dXJuIEMudHlwZT09PXYudHlwZSYmQ1toXT09PXY/RSgyLHgpOnh9dmFyIEk9bmV3IE1hcChbW1wiQXNzaWdubWVudEV4cHJlc3Npb25cIixcInJpZ2h0XCJdLFtcIlZhcmlhYmxlRGVjbGFyYXRvclwiLFwiaW5pdFwiXSxbXCJSZXR1cm5TdGF0ZW1lbnRcIixcImFyZ3VtZW50XCJdLFtcIlRocm93U3RhdGVtZW50XCIsXCJhcmd1bWVudFwiXSxbXCJVbmFyeUV4cHJlc3Npb25cIixcImFyZ3VtZW50XCJdLFtcIllpZWxkRXhwcmVzc2lvblwiLFwiYXJndW1lbnRcIl1dKTtmdW5jdGlvbiBQKGYpe2xldCBUPWYuZ2V0VmFsdWUoKTtpZihULnR5cGUhPT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiKXJldHVybiExO2xldCBtLHY9VDtmb3IobGV0IG89MDshbTtvKyspe2xldCBoPWYuZ2V0UGFyZW50Tm9kZShvKTtpZihuKGgpJiZoLmNhbGxlZT09PXZ8fHUoaCkmJmgub2JqZWN0PT09dnx8aC50eXBlPT09XCJUU05vbk51bGxFeHByZXNzaW9uXCImJmguZXhwcmVzc2lvbj09PXYpe3Y9aDtjb250aW51ZX1oLnR5cGU9PT1cIk5ld0V4cHJlc3Npb25cIiYmaC5jYWxsZWU9PT12fHxpKGgpJiZoLmV4cHJlc3Npb249PT12PyhtPWYuZ2V0UGFyZW50Tm9kZShvKzEpLHY9aCk6bT1ofXJldHVybiB2PT09VD8hMTptW0kuZ2V0KG0udHlwZSldPT09dn1mdW5jdGlvbiAkKGYsVCxtKXtsZXQgdj1mLmdldFZhbHVlKCksbz12LnR5cGU9PT1cIkNvbmRpdGlvbmFsRXhwcmVzc2lvblwiLGg9bz9cImNvbnNlcXVlbnRcIjpcInRydWVUeXBlXCIsQz1vP1wiYWx0ZXJuYXRlXCI6XCJmYWxzZVR5cGVcIix4PW8/W1widGVzdFwiXTpbXCJjaGVja1R5cGVcIixcImV4dGVuZHNUeXBlXCJdLGI9dltoXSxCPXZbQ10saz1bXSxNPSExLFI9Zi5nZXRQYXJlbnROb2RlKCkscT1SLnR5cGU9PT12LnR5cGUmJnguc29tZSh1ZT0+Ult1ZV09PT12KSxKPVIudHlwZT09PXYudHlwZSYmIXEsTCxRLFY9MDtkbyBRPUx8fHYsTD1mLmdldFBhcmVudE5vZGUoViksVisrO3doaWxlKEwmJkwudHlwZT09PXYudHlwZSYmeC5ldmVyeSh1ZT0+TFt1ZV0hPT1RKSk7bGV0IGo9THx8UixZPVE7aWYobyYmKHModlt4WzBdXSl8fHMoYil8fHMoQil8fFMoWSkpKXtNPSEwLEo9ITA7bGV0IHVlPXo9PltfKFwiKFwiKSxEKFtnLHpdKSxnLF8oXCIpXCIpXSxGZT16PT56LnR5cGU9PT1cIk51bGxMaXRlcmFsXCJ8fHoudHlwZT09PVwiTGl0ZXJhbFwiJiZ6LnZhbHVlPT09bnVsbHx8ei50eXBlPT09XCJJZGVudGlmaWVyXCImJnoubmFtZT09PVwidW5kZWZpbmVkXCI7ay5wdXNoKFwiID8gXCIsRmUoYik/bShoKTp1ZShtKGgpKSxcIiA6IFwiLEIudHlwZT09PXYudHlwZXx8RmUoQik/bShDKTp1ZShtKEMpKSl9ZWxzZXtsZXQgdWU9W3ksXCI/IFwiLGIudHlwZT09PXYudHlwZT9fKFwiXCIsXCIoXCIpOlwiXCIsRSgyLG0oaCkpLGIudHlwZT09PXYudHlwZT9fKFwiXCIsXCIpXCIpOlwiXCIseSxcIjogXCIsQi50eXBlPT09di50eXBlP20oQyk6RSgyLG0oQykpXTtrLnB1c2goUi50eXBlIT09di50eXBlfHxSW0NdPT09dnx8cT91ZTpULnVzZVRhYnM/dyhEKHVlKSk6RShNYXRoLm1heCgwLFQudGFiV2lkdGgtMiksdWUpKX1sZXQgZWU9Wy4uLngubWFwKHVlPT5hKHZbdWVdKSksYShiKSxhKEIpXS5mbGF0KCkuc29tZSh1ZT0+ZCh1ZSkmJnQoVC5vcmlnaW5hbFRleHQsbCh1ZSkscCh1ZSkpKSxsZT11ZT0+Uj09PWo/Yyh1ZSx7c2hvdWxkQnJlYWs6ZWV9KTplZT9bdWUsRl06dWUsVz0hTSYmKHUoUil8fFIudHlwZT09PVwiTkdQaXBlRXhwcmVzc2lvblwiJiZSLmxlZnQ9PT12KSYmIVIuY29tcHV0ZWQsSz1QKGYpLGRlPWxlKFtOKGYsVCxtKSxKP2s6RChrKSxvJiZXJiYhSz9nOlwiXCJdKTtyZXR1cm4gcXx8Sz9jKFtEKFtnLGRlXSksZ10pOmRlfXIuZXhwb3J0cz17cHJpbnRUZXJuYXJ5OiR9fX0pLE5vPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9zdGF0ZW1lbnQuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOntoYXJkbGluZTp0fX09cWUoKSxzPXF0KCkse2dldExlZnRTaWRlUGF0aE5hbWU6YSxoYXNOYWtlZExlZnRTaWRlOm4saXNKc3hOb2RlOnUsaXNUaGVPbmx5SnN4RWxlbWVudEluTWFya2Rvd246aSxoYXNDb21tZW50OmwsQ29tbWVudENoZWNrRmxhZ3M6cCxpc05leHRMaW5lRW1wdHk6ZH09S2UoKSx7c2hvdWxkUHJpbnRQYXJhbXNXaXRob3V0UGFyZW5zOnl9PXFyKCk7ZnVuY3Rpb24gZyhOLEksUCwkKXtsZXQgZj1OLmdldFZhbHVlKCksVD1bXSxtPWYudHlwZT09PVwiQ2xhc3NCb2R5XCIsdj1jKGZbJF0pO3JldHVybiBOLmVhY2goKG8saCxDKT0+e2xldCB4PW8uZ2V0VmFsdWUoKTtpZih4LnR5cGU9PT1cIkVtcHR5U3RhdGVtZW50XCIpcmV0dXJuO2xldCBiPVAoKTshSS5zZW1pJiYhbSYmIWkoSSxvKSYmRChvLEkpP2woeCxwLkxlYWRpbmcpP1QucHVzaChQKFtdLHtuZWVkc1NlbWk6ITB9KSk6VC5wdXNoKFwiO1wiLGIpOlQucHVzaChiKSwhSS5zZW1pJiZtJiZGKHgpJiZTKHgsQ1toKzFdKSYmVC5wdXNoKFwiO1wiKSx4IT09diYmKFQucHVzaCh0KSxkKHgsSSkmJlQucHVzaCh0KSl9LCQpLFR9ZnVuY3Rpb24gYyhOKXtmb3IobGV0IEk9Ti5sZW5ndGgtMTtJPj0wO0ktLSl7bGV0IFA9TltJXTtpZihQLnR5cGUhPT1cIkVtcHR5U3RhdGVtZW50XCIpcmV0dXJuIFB9fWZ1bmN0aW9uIEQoTixJKXtyZXR1cm4gTi5nZXROb2RlKCkudHlwZSE9PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiPyExOk4uY2FsbCgkPT5FKCQsSSksXCJleHByZXNzaW9uXCIpfWZ1bmN0aW9uIEUoTixJKXtsZXQgUD1OLmdldFZhbHVlKCk7c3dpdGNoKFAudHlwZSl7Y2FzZVwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpjYXNlXCJUeXBlQ2FzdEV4cHJlc3Npb25cIjpjYXNlXCJBcnJheUV4cHJlc3Npb25cIjpjYXNlXCJBcnJheVBhdHRlcm5cIjpjYXNlXCJUZW1wbGF0ZUxpdGVyYWxcIjpjYXNlXCJUZW1wbGF0ZUVsZW1lbnRcIjpjYXNlXCJSZWdFeHBMaXRlcmFsXCI6cmV0dXJuITA7Y2FzZVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjp7aWYoIXkoTixJKSlyZXR1cm4hMDticmVha31jYXNlXCJVbmFyeUV4cHJlc3Npb25cIjp7bGV0e3ByZWZpeDokLG9wZXJhdG9yOmZ9PVA7aWYoJCYmKGY9PT1cIitcInx8Zj09PVwiLVwiKSlyZXR1cm4hMDticmVha31jYXNlXCJCaW5kRXhwcmVzc2lvblwiOntpZighUC5vYmplY3QpcmV0dXJuITA7YnJlYWt9Y2FzZVwiTGl0ZXJhbFwiOntpZihQLnJlZ2V4KXJldHVybiEwO2JyZWFrfWRlZmF1bHQ6aWYodShQKSlyZXR1cm4hMH1yZXR1cm4gcyhOLEkpPyEwOm4oUCk/Ti5jYWxsKCQ9PkUoJCxJKSwuLi5hKE4sUCkpOiExfWZ1bmN0aW9uIF8oTixJLFApe3JldHVybiBnKE4sSSxQLFwiYm9keVwiKX1mdW5jdGlvbiB3KE4sSSxQKXtyZXR1cm4gZyhOLEksUCxcImNvbnNlcXVlbnRcIil9dmFyIEY9Tj0+e2xldHt0eXBlOkl9PU47cmV0dXJuIEk9PT1cIkNsYXNzUHJvcGVydHlcInx8ST09PVwiUHJvcGVydHlEZWZpbml0aW9uXCJ8fEk9PT1cIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCJ8fEk9PT1cIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwifHxJPT09XCJBY2Nlc3NvclByb3BlcnR5XCJ8fEk9PT1cIlRTQWJzdHJhY3RQcm9wZXJ0eURlZmluaXRpb25cInx8ST09PVwiVFNBYnN0cmFjdEFjY2Vzc29yUHJvcGVydHlcIn07ZnVuY3Rpb24gUyhOLEkpe2xldHt0eXBlOlAsbmFtZTokfT1OLmtleTtpZighTi5jb21wdXRlZCYmUD09PVwiSWRlbnRpZmllclwiJiYoJD09PVwic3RhdGljXCJ8fCQ9PT1cImdldFwifHwkPT09XCJzZXRcInx8JD09PVwiYWNjZXNzb3JcIikmJiFOLnZhbHVlJiYhTi50eXBlQW5ub3RhdGlvbilyZXR1cm4hMDtpZighSXx8SS5zdGF0aWN8fEkuYWNjZXNzaWJpbGl0eSlyZXR1cm4hMTtpZighSS5jb21wdXRlZCl7bGV0IGY9SS5rZXkmJkkua2V5Lm5hbWU7aWYoZj09PVwiaW5cInx8Zj09PVwiaW5zdGFuY2VvZlwiKXJldHVybiEwfWlmKEYoSSkmJkkudmFyaWFuY2UmJiFJLnN0YXRpYyYmIUkuZGVjbGFyZSlyZXR1cm4hMDtzd2l0Y2goSS50eXBlKXtjYXNlXCJDbGFzc1Byb3BlcnR5XCI6Y2FzZVwiUHJvcGVydHlEZWZpbml0aW9uXCI6Y2FzZVwiVFNBYnN0cmFjdFByb3BlcnR5RGVmaW5pdGlvblwiOnJldHVybiBJLmNvbXB1dGVkO2Nhc2VcIk1ldGhvZERlZmluaXRpb25cIjpjYXNlXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiOmNhc2VcIkNsYXNzTWV0aG9kXCI6Y2FzZVwiQ2xhc3NQcml2YXRlTWV0aG9kXCI6e2lmKChJLnZhbHVlP0kudmFsdWUuYXN5bmM6SS5hc3luYyl8fEkua2luZD09PVwiZ2V0XCJ8fEkua2luZD09PVwic2V0XCIpcmV0dXJuITE7bGV0IFQ9SS52YWx1ZT9JLnZhbHVlLmdlbmVyYXRvcjpJLmdlbmVyYXRvcjtyZXR1cm4hIShJLmNvbXB1dGVkfHxUKX1jYXNlXCJUU0luZGV4U2lnbmF0dXJlXCI6cmV0dXJuITB9cmV0dXJuITF9ci5leHBvcnRzPXtwcmludEJvZHk6XyxwcmludFN3aXRjaENhc2VDb25zZXF1ZW50Ond9fX0pLHdvPXRlKHtcInNyYy9sYW5ndWFnZS1qcy9wcmludC9ibG9jay5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7cHJpbnREYW5nbGluZ0NvbW1lbnRzOnR9PWV0KCkse2lzTm9uRW1wdHlBcnJheTpzfT1VZSgpLHtidWlsZGVyczp7aGFyZGxpbmU6YSxpbmRlbnQ6bn19PXFlKCkse2hhc0NvbW1lbnQ6dSxDb21tZW50Q2hlY2tGbGFnczppLGlzTmV4dExpbmVFbXB0eTpsfT1LZSgpLHtwcmludEhhcmRsaW5lQWZ0ZXJIZXJpdGFnZTpwfT1ucigpLHtwcmludEJvZHk6ZH09Tm8oKTtmdW5jdGlvbiB5KGMsRCxFKXtsZXQgXz1jLmdldFZhbHVlKCksdz1bXTtpZihfLnR5cGU9PT1cIlN0YXRpY0Jsb2NrXCImJncucHVzaChcInN0YXRpYyBcIiksXy50eXBlPT09XCJDbGFzc0JvZHlcIiYmcyhfLmJvZHkpKXtsZXQgUz1jLmdldFBhcmVudE5vZGUoKTt3LnB1c2gocChTKSl9dy5wdXNoKFwie1wiKTtsZXQgRj1nKGMsRCxFKTtpZihGKXcucHVzaChuKFthLEZdKSxhKTtlbHNle2xldCBTPWMuZ2V0UGFyZW50Tm9kZSgpLE49Yy5nZXRQYXJlbnROb2RlKDEpO1MudHlwZT09PVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cInx8Uy50eXBlPT09XCJGdW5jdGlvbkV4cHJlc3Npb25cInx8Uy50eXBlPT09XCJGdW5jdGlvbkRlY2xhcmF0aW9uXCJ8fFMudHlwZT09PVwiT2JqZWN0TWV0aG9kXCJ8fFMudHlwZT09PVwiQ2xhc3NNZXRob2RcInx8Uy50eXBlPT09XCJDbGFzc1ByaXZhdGVNZXRob2RcInx8Uy50eXBlPT09XCJGb3JTdGF0ZW1lbnRcInx8Uy50eXBlPT09XCJXaGlsZVN0YXRlbWVudFwifHxTLnR5cGU9PT1cIkRvV2hpbGVTdGF0ZW1lbnRcInx8Uy50eXBlPT09XCJEb0V4cHJlc3Npb25cInx8Uy50eXBlPT09XCJDYXRjaENsYXVzZVwiJiYhTi5maW5hbGl6ZXJ8fFMudHlwZT09PVwiVFNNb2R1bGVEZWNsYXJhdGlvblwifHxTLnR5cGU9PT1cIlRTRGVjbGFyZUZ1bmN0aW9uXCJ8fF8udHlwZT09PVwiU3RhdGljQmxvY2tcInx8Xy50eXBlPT09XCJDbGFzc0JvZHlcInx8dy5wdXNoKGEpfXJldHVybiB3LnB1c2goXCJ9XCIpLHd9ZnVuY3Rpb24gZyhjLEQsRSl7bGV0IF89Yy5nZXRWYWx1ZSgpLHc9cyhfLmRpcmVjdGl2ZXMpLEY9Xy5ib2R5LnNvbWUoST0+SS50eXBlIT09XCJFbXB0eVN0YXRlbWVudFwiKSxTPXUoXyxpLkRhbmdsaW5nKTtpZighdyYmIUYmJiFTKXJldHVyblwiXCI7bGV0IE49W107aWYodyYmYy5lYWNoKChJLFAsJCk9PntOLnB1c2goRSgpKSwoUDwkLmxlbmd0aC0xfHxGfHxTKSYmKE4ucHVzaChhKSxsKEkuZ2V0VmFsdWUoKSxEKSYmTi5wdXNoKGEpKX0sXCJkaXJlY3RpdmVzXCIpLEYmJk4ucHVzaChkKGMsRCxFKSksUyYmTi5wdXNoKHQoYyxELCEwKSksXy50eXBlPT09XCJQcm9ncmFtXCIpe2xldCBJPWMuZ2V0UGFyZW50Tm9kZSgpOyghSXx8SS50eXBlIT09XCJNb2R1bGVFeHByZXNzaW9uXCIpJiZOLnB1c2goYSl9cmV0dXJuIE59ci5leHBvcnRzPXtwcmludEJsb2NrOnkscHJpbnRCbG9ja0JvZHk6Z319fSksZ2Q9dGUoe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L3R5cGVzY3JpcHQuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50RGFuZ2xpbmdDb21tZW50czp0fT1ldCgpLHtoYXNOZXdsaW5lSW5SYW5nZTpzfT1VZSgpLHtidWlsZGVyczp7am9pbjphLGxpbmU6bixoYXJkbGluZTp1LHNvZnRsaW5lOmksZ3JvdXA6bCxpbmRlbnQ6cCxjb25kaXRpb25hbEdyb3VwOmQsaWZCcmVhazp5fX09cWUoKSx7aXNTdHJpbmdMaXRlcmFsOmcsZ2V0VHlwZVNjcmlwdE1hcHBlZFR5cGVNb2RpZmllcjpjLHNob3VsZFByaW50Q29tbWE6RCxpc0NhbGxFeHByZXNzaW9uOkUsaXNNZW1iZXJFeHByZXNzaW9uOl99PUtlKCksdz1kZCgpLHtsb2NTdGFydDpGLGxvY0VuZDpTfT11dCgpLHtwcmludE9wdGlvbmFsVG9rZW46TixwcmludFR5cGVTY3JpcHRNb2RpZmllcnM6SX09Y3QoKSx7cHJpbnRUZXJuYXJ5OlB9PUJvKCkse3ByaW50RnVuY3Rpb25QYXJhbWV0ZXJzOiQsc2hvdWxkR3JvdXBGdW5jdGlvblBhcmFtZXRlcnM6Zn09THIoKSx7cHJpbnRUZW1wbGF0ZUxpdGVyYWw6VH09anQoKSx7cHJpbnRBcnJheUl0ZW1zOm19PWVyKCkse3ByaW50T2JqZWN0OnZ9PXV1KCkse3ByaW50Q2xhc3NQcm9wZXJ0eTpvLHByaW50Q2xhc3NNZXRob2Q6aH09bnIoKSx7cHJpbnRUeXBlUGFyYW1ldGVyOkMscHJpbnRUeXBlUGFyYW1ldGVyczp4fT1qcigpLHtwcmludFByb3BlcnR5S2V5OmJ9PXJyKCkse3ByaW50RnVuY3Rpb246QixwcmludE1ldGhvZEludGVybmFsOmt9PXFyKCkse3ByaW50SW50ZXJmYWNlOk19PWJvKCkse3ByaW50QmxvY2s6Un09d28oKSx7cHJpbnRUeXBlQWxpYXM6cSxwcmludEludGVyc2VjdGlvblR5cGU6SixwcmludFVuaW9uVHlwZTpMLHByaW50RnVuY3Rpb25UeXBlOlEscHJpbnRUdXBsZVR5cGU6VixwcmludEluZGV4ZWRBY2Nlc3NUeXBlOmoscHJpbnRKU0RvY1R5cGU6WX09T3IoKTtmdW5jdGlvbiBpZShlZSxsZSxXKXtsZXQgSz1lZS5nZXRWYWx1ZSgpO2lmKCFLLnR5cGUuc3RhcnRzV2l0aChcIlRTXCIpKXJldHVybjtpZih3KEspKXJldHVybiBLLnR5cGUuc2xpY2UoMiwtNykudG9Mb3dlckNhc2UoKTtsZXQgZGU9bGUuc2VtaT9cIjtcIjpcIlwiLHVlPVtdO3N3aXRjaChLLnR5cGUpe2Nhc2VcIlRTVGhpc1R5cGVcIjpyZXR1cm5cInRoaXNcIjtjYXNlXCJUU1R5cGVBc3NlcnRpb25cIjp7bGV0IEZlPSEoSy5leHByZXNzaW9uLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwifHxLLmV4cHJlc3Npb24udHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwiKSx6PWwoW1wiPFwiLHAoW2ksVyhcInR5cGVBbm5vdGF0aW9uXCIpXSksaSxcIj5cIl0pLFU9W3koXCIoXCIpLHAoW2ksVyhcImV4cHJlc3Npb25cIildKSxpLHkoXCIpXCIpXTtyZXR1cm4gRmU/ZChbW3osVyhcImV4cHJlc3Npb25cIildLFt6LGwoVSx7c2hvdWxkQnJlYWs6ITB9KV0sW3osVyhcImV4cHJlc3Npb25cIildXSk6bChbeixXKFwiZXhwcmVzc2lvblwiKV0pfWNhc2VcIlRTRGVjbGFyZUZ1bmN0aW9uXCI6cmV0dXJuIEIoZWUsVyxsZSk7Y2FzZVwiVFNFeHBvcnRBc3NpZ25tZW50XCI6cmV0dXJuW1wiZXhwb3J0ID0gXCIsVyhcImV4cHJlc3Npb25cIiksZGVdO2Nhc2VcIlRTTW9kdWxlQmxvY2tcIjpyZXR1cm4gUihlZSxsZSxXKTtjYXNlXCJUU0ludGVyZmFjZUJvZHlcIjpjYXNlXCJUU1R5cGVMaXRlcmFsXCI6cmV0dXJuIHYoZWUsbGUsVyk7Y2FzZVwiVFNUeXBlQWxpYXNEZWNsYXJhdGlvblwiOnJldHVybiBxKGVlLGxlLFcpO2Nhc2VcIlRTUXVhbGlmaWVkTmFtZVwiOnJldHVybiBhKFwiLlwiLFtXKFwibGVmdFwiKSxXKFwicmlnaHRcIildKTtjYXNlXCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwiOmNhc2VcIlRTRGVjbGFyZU1ldGhvZFwiOnJldHVybiBoKGVlLGxlLFcpO2Nhc2VcIlRTQWJzdHJhY3RBY2Nlc3NvclByb3BlcnR5XCI6Y2FzZVwiVFNBYnN0cmFjdFByb3BlcnR5RGVmaW5pdGlvblwiOnJldHVybiBvKGVlLGxlLFcpO2Nhc2VcIlRTSW50ZXJmYWNlSGVyaXRhZ2VcIjpjYXNlXCJUU0V4cHJlc3Npb25XaXRoVHlwZUFyZ3VtZW50c1wiOnJldHVybiB1ZS5wdXNoKFcoXCJleHByZXNzaW9uXCIpKSxLLnR5cGVQYXJhbWV0ZXJzJiZ1ZS5wdXNoKFcoXCJ0eXBlUGFyYW1ldGVyc1wiKSksdWU7Y2FzZVwiVFNUZW1wbGF0ZUxpdGVyYWxUeXBlXCI6cmV0dXJuIFQoZWUsVyxsZSk7Y2FzZVwiVFNOYW1lZFR1cGxlTWVtYmVyXCI6cmV0dXJuW1coXCJsYWJlbFwiKSxLLm9wdGlvbmFsP1wiP1wiOlwiXCIsXCI6IFwiLFcoXCJlbGVtZW50VHlwZVwiKV07Y2FzZVwiVFNSZXN0VHlwZVwiOnJldHVybltcIi4uLlwiLFcoXCJ0eXBlQW5ub3RhdGlvblwiKV07Y2FzZVwiVFNPcHRpb25hbFR5cGVcIjpyZXR1cm5bVyhcInR5cGVBbm5vdGF0aW9uXCIpLFwiP1wiXTtjYXNlXCJUU0ludGVyZmFjZURlY2xhcmF0aW9uXCI6cmV0dXJuIE0oZWUsbGUsVyk7Y2FzZVwiVFNDbGFzc0ltcGxlbWVudHNcIjpyZXR1cm5bVyhcImV4cHJlc3Npb25cIiksVyhcInR5cGVQYXJhbWV0ZXJzXCIpXTtjYXNlXCJUU1R5cGVQYXJhbWV0ZXJEZWNsYXJhdGlvblwiOmNhc2VcIlRTVHlwZVBhcmFtZXRlckluc3RhbnRpYXRpb25cIjpyZXR1cm4geChlZSxsZSxXLFwicGFyYW1zXCIpO2Nhc2VcIlRTVHlwZVBhcmFtZXRlclwiOnJldHVybiBDKGVlLGxlLFcpO2Nhc2VcIlRTU2F0aXNmaWVzRXhwcmVzc2lvblwiOmNhc2VcIlRTQXNFeHByZXNzaW9uXCI6e2xldCBGZT1LLnR5cGU9PT1cIlRTQXNFeHByZXNzaW9uXCI/XCJhc1wiOlwic2F0aXNmaWVzXCI7dWUucHVzaChXKFwiZXhwcmVzc2lvblwiKSxgICR7RmV9IGAsVyhcInR5cGVBbm5vdGF0aW9uXCIpKTtsZXQgej1lZS5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIEUoeikmJnouY2FsbGVlPT09S3x8Xyh6KSYmei5vYmplY3Q9PT1LP2woW3AoW2ksLi4udWVdKSxpXSk6dWV9Y2FzZVwiVFNBcnJheVR5cGVcIjpyZXR1cm5bVyhcImVsZW1lbnRUeXBlXCIpLFwiW11cIl07Y2FzZVwiVFNQcm9wZXJ0eVNpZ25hdHVyZVwiOnJldHVybiBLLnJlYWRvbmx5JiZ1ZS5wdXNoKFwicmVhZG9ubHkgXCIpLHVlLnB1c2goYihlZSxsZSxXKSxOKGVlKSksSy50eXBlQW5ub3RhdGlvbiYmdWUucHVzaChcIjogXCIsVyhcInR5cGVBbm5vdGF0aW9uXCIpKSxLLmluaXRpYWxpemVyJiZ1ZS5wdXNoKFwiID0gXCIsVyhcImluaXRpYWxpemVyXCIpKSx1ZTtjYXNlXCJUU1BhcmFtZXRlclByb3BlcnR5XCI6cmV0dXJuIEsuYWNjZXNzaWJpbGl0eSYmdWUucHVzaChLLmFjY2Vzc2liaWxpdHkrXCIgXCIpLEsuZXhwb3J0JiZ1ZS5wdXNoKFwiZXhwb3J0IFwiKSxLLnN0YXRpYyYmdWUucHVzaChcInN0YXRpYyBcIiksSy5vdmVycmlkZSYmdWUucHVzaChcIm92ZXJyaWRlIFwiKSxLLnJlYWRvbmx5JiZ1ZS5wdXNoKFwicmVhZG9ubHkgXCIpLHVlLnB1c2goVyhcInBhcmFtZXRlclwiKSksdWU7Y2FzZVwiVFNUeXBlUXVlcnlcIjpyZXR1cm5bXCJ0eXBlb2YgXCIsVyhcImV4cHJOYW1lXCIpLFcoXCJ0eXBlUGFyYW1ldGVyc1wiKV07Y2FzZVwiVFNJbmRleFNpZ25hdHVyZVwiOntsZXQgRmU9ZWUuZ2V0UGFyZW50Tm9kZSgpLHo9Sy5wYXJhbWV0ZXJzLmxlbmd0aD4xP3koRChsZSk/XCIsXCI6XCJcIik6XCJcIixVPWwoW3AoW2ksYShbXCIsIFwiLGldLGVlLm1hcChXLFwicGFyYW1ldGVyc1wiKSldKSx6LGldKTtyZXR1cm5bSy5leHBvcnQ/XCJleHBvcnQgXCI6XCJcIixLLmFjY2Vzc2liaWxpdHk/W0suYWNjZXNzaWJpbGl0eSxcIiBcIl06XCJcIixLLnN0YXRpYz9cInN0YXRpYyBcIjpcIlwiLEsucmVhZG9ubHk/XCJyZWFkb25seSBcIjpcIlwiLEsuZGVjbGFyZT9cImRlY2xhcmUgXCI6XCJcIixcIltcIixLLnBhcmFtZXRlcnM/VTpcIlwiLEsudHlwZUFubm90YXRpb24/XCJdOiBcIjpcIl1cIixLLnR5cGVBbm5vdGF0aW9uP1coXCJ0eXBlQW5ub3RhdGlvblwiKTpcIlwiLEZlLnR5cGU9PT1cIkNsYXNzQm9keVwiP2RlOlwiXCJdfWNhc2VcIlRTVHlwZVByZWRpY2F0ZVwiOnJldHVybltLLmFzc2VydHM/XCJhc3NlcnRzIFwiOlwiXCIsVyhcInBhcmFtZXRlck5hbWVcIiksSy50eXBlQW5ub3RhdGlvbj9bXCIgaXMgXCIsVyhcInR5cGVBbm5vdGF0aW9uXCIpXTpcIlwiXTtjYXNlXCJUU05vbk51bGxFeHByZXNzaW9uXCI6cmV0dXJuW1coXCJleHByZXNzaW9uXCIpLFwiIVwiXTtjYXNlXCJUU0ltcG9ydFR5cGVcIjpyZXR1cm5bSy5pc1R5cGVPZj9cInR5cGVvZiBcIjpcIlwiLFwiaW1wb3J0KFwiLFcoSy5wYXJhbWV0ZXI/XCJwYXJhbWV0ZXJcIjpcImFyZ3VtZW50XCIpLFwiKVwiLEsucXVhbGlmaWVyP1tcIi5cIixXKFwicXVhbGlmaWVyXCIpXTpcIlwiLHgoZWUsbGUsVyxcInR5cGVQYXJhbWV0ZXJzXCIpXTtjYXNlXCJUU0xpdGVyYWxUeXBlXCI6cmV0dXJuIFcoXCJsaXRlcmFsXCIpO2Nhc2VcIlRTSW5kZXhlZEFjY2Vzc1R5cGVcIjpyZXR1cm4gaihlZSxsZSxXKTtjYXNlXCJUU0NvbnN0cnVjdFNpZ25hdHVyZURlY2xhcmF0aW9uXCI6Y2FzZVwiVFNDYWxsU2lnbmF0dXJlRGVjbGFyYXRpb25cIjpjYXNlXCJUU0NvbnN0cnVjdG9yVHlwZVwiOntpZihLLnR5cGU9PT1cIlRTQ29uc3RydWN0b3JUeXBlXCImJksuYWJzdHJhY3QmJnVlLnB1c2goXCJhYnN0cmFjdCBcIiksSy50eXBlIT09XCJUU0NhbGxTaWduYXR1cmVEZWNsYXJhdGlvblwiJiZ1ZS5wdXNoKFwibmV3IFwiKSx1ZS5wdXNoKGwoJChlZSxXLGxlLCExLCEwKSkpLEsucmV0dXJuVHlwZXx8Sy50eXBlQW5ub3RhdGlvbil7bGV0IEZlPUsudHlwZT09PVwiVFNDb25zdHJ1Y3RvclR5cGVcIjt1ZS5wdXNoKEZlP1wiID0+IFwiOlwiOiBcIixXKFwicmV0dXJuVHlwZVwiKSxXKFwidHlwZUFubm90YXRpb25cIikpfXJldHVybiB1ZX1jYXNlXCJUU1R5cGVPcGVyYXRvclwiOnJldHVybltLLm9wZXJhdG9yLFwiIFwiLFcoXCJ0eXBlQW5ub3RhdGlvblwiKV07Y2FzZVwiVFNNYXBwZWRUeXBlXCI6e2xldCBGZT1zKGxlLm9yaWdpbmFsVGV4dCxGKEspLFMoSykpO3JldHVybiBsKFtcIntcIixwKFtsZS5icmFja2V0U3BhY2luZz9uOmksSy5yZWFkb25seT9bYyhLLnJlYWRvbmx5LFwicmVhZG9ubHlcIiksXCIgXCJdOlwiXCIsSShlZSxsZSxXKSxXKFwidHlwZVBhcmFtZXRlclwiKSxLLm9wdGlvbmFsP2MoSy5vcHRpb25hbCxcIj9cIik6XCJcIixLLnR5cGVBbm5vdGF0aW9uP1wiOiBcIjpcIlwiLFcoXCJ0eXBlQW5ub3RhdGlvblwiKSx5KGRlKV0pLHQoZWUsbGUsITApLGxlLmJyYWNrZXRTcGFjaW5nP246aSxcIn1cIl0se3Nob3VsZEJyZWFrOkZlfSl9Y2FzZVwiVFNNZXRob2RTaWduYXR1cmVcIjp7bGV0IEZlPUsua2luZCYmSy5raW5kIT09XCJtZXRob2RcIj9gJHtLLmtpbmR9IGA6XCJcIjt1ZS5wdXNoKEsuYWNjZXNzaWJpbGl0eT9bSy5hY2Nlc3NpYmlsaXR5LFwiIFwiXTpcIlwiLEZlLEsuZXhwb3J0P1wiZXhwb3J0IFwiOlwiXCIsSy5zdGF0aWM/XCJzdGF0aWMgXCI6XCJcIixLLnJlYWRvbmx5P1wicmVhZG9ubHkgXCI6XCJcIixLLmFic3RyYWN0P1wiYWJzdHJhY3QgXCI6XCJcIixLLmRlY2xhcmU/XCJkZWNsYXJlIFwiOlwiXCIsSy5jb21wdXRlZD9cIltcIjpcIlwiLFcoXCJrZXlcIiksSy5jb21wdXRlZD9cIl1cIjpcIlwiLE4oZWUpKTtsZXQgej0kKGVlLFcsbGUsITEsITApLFU9Sy5yZXR1cm5UeXBlP1wicmV0dXJuVHlwZVwiOlwidHlwZUFubm90YXRpb25cIixaPUtbVV0sc2U9Wj9XKFUpOlwiXCIsRGU9ZihLLHNlKTtyZXR1cm4gdWUucHVzaChEZT9sKHopOnopLFomJnVlLnB1c2goXCI6IFwiLGwoc2UpKSxsKHVlKX1jYXNlXCJUU05hbWVzcGFjZUV4cG9ydERlY2xhcmF0aW9uXCI6cmV0dXJuIHVlLnB1c2goXCJleHBvcnQgYXMgbmFtZXNwYWNlIFwiLFcoXCJpZFwiKSksbGUuc2VtaSYmdWUucHVzaChcIjtcIiksbCh1ZSk7Y2FzZVwiVFNFbnVtRGVjbGFyYXRpb25cIjpyZXR1cm4gSy5kZWNsYXJlJiZ1ZS5wdXNoKFwiZGVjbGFyZSBcIiksSy5tb2RpZmllcnMmJnVlLnB1c2goSShlZSxsZSxXKSksSy5jb25zdCYmdWUucHVzaChcImNvbnN0IFwiKSx1ZS5wdXNoKFwiZW51bSBcIixXKFwiaWRcIiksXCIgXCIpLEsubWVtYmVycy5sZW5ndGg9PT0wP3VlLnB1c2gobChbXCJ7XCIsdChlZSxsZSksaSxcIn1cIl0pKTp1ZS5wdXNoKGwoW1wie1wiLHAoW3UsbShlZSxsZSxcIm1lbWJlcnNcIixXKSxEKGxlLFwiZXM1XCIpP1wiLFwiOlwiXCJdKSx0KGVlLGxlLCEwKSx1LFwifVwiXSkpLHVlO2Nhc2VcIlRTRW51bU1lbWJlclwiOnJldHVybiBLLmNvbXB1dGVkP3VlLnB1c2goXCJbXCIsVyhcImlkXCIpLFwiXVwiKTp1ZS5wdXNoKFcoXCJpZFwiKSksSy5pbml0aWFsaXplciYmdWUucHVzaChcIiA9IFwiLFcoXCJpbml0aWFsaXplclwiKSksdWU7Y2FzZVwiVFNJbXBvcnRFcXVhbHNEZWNsYXJhdGlvblwiOnJldHVybiBLLmlzRXhwb3J0JiZ1ZS5wdXNoKFwiZXhwb3J0IFwiKSx1ZS5wdXNoKFwiaW1wb3J0IFwiKSxLLmltcG9ydEtpbmQmJksuaW1wb3J0S2luZCE9PVwidmFsdWVcIiYmdWUucHVzaChLLmltcG9ydEtpbmQsXCIgXCIpLHVlLnB1c2goVyhcImlkXCIpLFwiID0gXCIsVyhcIm1vZHVsZVJlZmVyZW5jZVwiKSksbGUuc2VtaSYmdWUucHVzaChcIjtcIiksbCh1ZSk7Y2FzZVwiVFNFeHRlcm5hbE1vZHVsZVJlZmVyZW5jZVwiOnJldHVybltcInJlcXVpcmUoXCIsVyhcImV4cHJlc3Npb25cIiksXCIpXCJdO2Nhc2VcIlRTTW9kdWxlRGVjbGFyYXRpb25cIjp7bGV0IEZlPWVlLmdldFBhcmVudE5vZGUoKSx6PWcoSy5pZCksVT1GZS50eXBlPT09XCJUU01vZHVsZURlY2xhcmF0aW9uXCIsWj1LLmJvZHkmJksuYm9keS50eXBlPT09XCJUU01vZHVsZURlY2xhcmF0aW9uXCI7aWYoVSl1ZS5wdXNoKFwiLlwiKTtlbHNle0suZGVjbGFyZSYmdWUucHVzaChcImRlY2xhcmUgXCIpLHVlLnB1c2goSShlZSxsZSxXKSk7bGV0IHNlPWxlLm9yaWdpbmFsVGV4dC5zbGljZShGKEspLEYoSy5pZCkpO0suaWQudHlwZT09PVwiSWRlbnRpZmllclwiJiZLLmlkLm5hbWU9PT1cImdsb2JhbFwiJiYhL25hbWVzcGFjZXxtb2R1bGUvLnRlc3Qoc2UpfHx1ZS5wdXNoKHp8fC8oPzpefFxccyltb2R1bGUoPzpcXHN8JCkvLnRlc3Qoc2UpP1wibW9kdWxlIFwiOlwibmFtZXNwYWNlIFwiKX1yZXR1cm4gdWUucHVzaChXKFwiaWRcIikpLFo/dWUucHVzaChXKFwiYm9keVwiKSk6Sy5ib2R5P3VlLnB1c2goXCIgXCIsbChXKFwiYm9keVwiKSkpOnVlLnB1c2goZGUpLHVlfWNhc2VcIlRTQ29uZGl0aW9uYWxUeXBlXCI6cmV0dXJuIFAoZWUsbGUsVyk7Y2FzZVwiVFNJbmZlclR5cGVcIjpyZXR1cm5bXCJpbmZlclwiLFwiIFwiLFcoXCJ0eXBlUGFyYW1ldGVyXCIpXTtjYXNlXCJUU0ludGVyc2VjdGlvblR5cGVcIjpyZXR1cm4gSihlZSxsZSxXKTtjYXNlXCJUU1VuaW9uVHlwZVwiOnJldHVybiBMKGVlLGxlLFcpO2Nhc2VcIlRTRnVuY3Rpb25UeXBlXCI6cmV0dXJuIFEoZWUsbGUsVyk7Y2FzZVwiVFNUdXBsZVR5cGVcIjpyZXR1cm4gVihlZSxsZSxXKTtjYXNlXCJUU1R5cGVSZWZlcmVuY2VcIjpyZXR1cm5bVyhcInR5cGVOYW1lXCIpLHgoZWUsbGUsVyxcInR5cGVQYXJhbWV0ZXJzXCIpXTtjYXNlXCJUU1R5cGVBbm5vdGF0aW9uXCI6cmV0dXJuIFcoXCJ0eXBlQW5ub3RhdGlvblwiKTtjYXNlXCJUU0VtcHR5Qm9keUZ1bmN0aW9uRXhwcmVzc2lvblwiOnJldHVybiBrKGVlLGxlLFcpO2Nhc2VcIlRTSlNEb2NBbGxUeXBlXCI6cmV0dXJuXCIqXCI7Y2FzZVwiVFNKU0RvY1Vua25vd25UeXBlXCI6cmV0dXJuXCI/XCI7Y2FzZVwiVFNKU0RvY051bGxhYmxlVHlwZVwiOnJldHVybiBZKGVlLFcsXCI/XCIpO2Nhc2VcIlRTSlNEb2NOb25OdWxsYWJsZVR5cGVcIjpyZXR1cm4gWShlZSxXLFwiIVwiKTtjYXNlXCJUU0luc3RhbnRpYXRpb25FeHByZXNzaW9uXCI6cmV0dXJuW1coXCJleHByZXNzaW9uXCIpLFcoXCJ0eXBlUGFyYW1ldGVyc1wiKV07ZGVmYXVsdDp0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gVHlwZVNjcmlwdCBub2RlIHR5cGU6ICR7SlNPTi5zdHJpbmdpZnkoSy50eXBlKX0uYCl9fXIuZXhwb3J0cz17cHJpbnRUeXBlc2NyaXB0OmllfX19KSx5ZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnQvY29tbWVudC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7aGFzTmV3bGluZTp0fT1VZSgpLHtidWlsZGVyczp7am9pbjpzLGhhcmRsaW5lOmF9LHV0aWxzOntyZXBsYWNlVGV4dEVuZE9mTGluZTpufX09cWUoKSx7aXNMaW5lQ29tbWVudDp1fT1LZSgpLHtsb2NTdGFydDppLGxvY0VuZDpsfT11dCgpLHA9T3QoKTtmdW5jdGlvbiBkKGMsRCl7bGV0IEU9Yy5nZXRWYWx1ZSgpO2lmKHUoRSkpcmV0dXJuIEQub3JpZ2luYWxUZXh0LnNsaWNlKGkoRSksbChFKSkudHJpbUVuZCgpO2lmKHAoRSkpe2lmKHkoRSkpe2xldCBGPWcoRSk7cmV0dXJuIEUudHJhaWxpbmcmJiF0KEQub3JpZ2luYWxUZXh0LGkoRSkse2JhY2t3YXJkczohMH0pP1thLEZdOkZ9bGV0IF89bChFKSx3PUQub3JpZ2luYWxUZXh0LnNsaWNlKF8tMyxfKT09PVwiKi0vXCI7cmV0dXJuW1wiLypcIixuKEUudmFsdWUpLHc/XCIqLS9cIjpcIiovXCJdfXRocm93IG5ldyBFcnJvcihcIk5vdCBhIGNvbW1lbnQ6IFwiK0pTT04uc3RyaW5naWZ5KEUpKX1mdW5jdGlvbiB5KGMpe2xldCBEPWAqJHtjLnZhbHVlfSpgLnNwbGl0KGBcbmApO3JldHVybiBELmxlbmd0aD4xJiZELmV2ZXJ5KEU9PkUudHJpbSgpWzBdPT09XCIqXCIpfWZ1bmN0aW9uIGcoYyl7bGV0IEQ9Yy52YWx1ZS5zcGxpdChgXG5gKTtyZXR1cm5bXCIvKlwiLHMoYSxELm1hcCgoRSxfKT0+Xz09PTA/RS50cmltRW5kKCk6XCIgXCIrKF88RC5sZW5ndGgtMT9FLnRyaW0oKTpFLnRyaW1TdGFydCgpKSkpLFwiKi9cIl19ci5leHBvcnRzPXtwcmludENvbW1lbnQ6ZH19fSksaGQ9dGUoe1wic3JjL2xhbmd1YWdlLWpzL3ByaW50L2xpdGVyYWwuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50U3RyaW5nOnQscHJpbnROdW1iZXI6c309VWUoKSx7cmVwbGFjZVRleHRFbmRPZkxpbmU6YX09WXQoKSx7cHJpbnREaXJlY3RpdmU6bn09Y3QoKTtmdW5jdGlvbiB1KGQseSl7bGV0IGc9ZC5nZXROb2RlKCk7c3dpdGNoKGcudHlwZSl7Y2FzZVwiUmVnRXhwTGl0ZXJhbFwiOnJldHVybiBwKGcpO2Nhc2VcIkJpZ0ludExpdGVyYWxcIjpyZXR1cm4gbChnLmJpZ2ludHx8Zy5leHRyYS5yYXcpO2Nhc2VcIk51bWVyaWNMaXRlcmFsXCI6cmV0dXJuIHMoZy5leHRyYS5yYXcpO2Nhc2VcIlN0cmluZ0xpdGVyYWxcIjpyZXR1cm4gYSh0KGcuZXh0cmEucmF3LHkpKTtjYXNlXCJOdWxsTGl0ZXJhbFwiOnJldHVyblwibnVsbFwiO2Nhc2VcIkJvb2xlYW5MaXRlcmFsXCI6cmV0dXJuIFN0cmluZyhnLnZhbHVlKTtjYXNlXCJEZWNpbWFsTGl0ZXJhbFwiOnJldHVybiBzKGcudmFsdWUpK1wibVwiO2Nhc2VcIkxpdGVyYWxcIjp7aWYoZy5yZWdleClyZXR1cm4gcChnLnJlZ2V4KTtpZihnLmJpZ2ludClyZXR1cm4gbChnLnJhdyk7aWYoZy5kZWNpbWFsKXJldHVybiBzKGcuZGVjaW1hbCkrXCJtXCI7bGV0e3ZhbHVlOmN9PWc7cmV0dXJuIHR5cGVvZiBjPT1cIm51bWJlclwiP3MoZy5yYXcpOnR5cGVvZiBjPT1cInN0cmluZ1wiP2koZCk/bihnLnJhdyx5KTphKHQoZy5yYXcseSkpOlN0cmluZyhjKX19fWZ1bmN0aW9uIGkoZCl7aWYoZC5nZXROYW1lKCkhPT1cImV4cHJlc3Npb25cIilyZXR1cm47bGV0IHk9ZC5nZXRQYXJlbnROb2RlKCk7cmV0dXJuIHkudHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwiJiZ5LmRpcmVjdGl2ZX1mdW5jdGlvbiBsKGQpe3JldHVybiBkLnRvTG93ZXJDYXNlKCl9ZnVuY3Rpb24gcChkKXtsZXR7cGF0dGVybjp5LGZsYWdzOmd9PWQ7cmV0dXJuIGc9Wy4uLmddLnNvcnQoKS5qb2luKFwiXCIpLGAvJHt5fS8ke2d9YH1yLmV4cG9ydHM9e3ByaW50TGl0ZXJhbDp1fX19KSx2ZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnRlci1lc3RyZWUuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye3ByaW50RGFuZ2xpbmdDb21tZW50czp0fT1ldCgpLHtoYXNOZXdsaW5lOnN9PVVlKCkse2J1aWxkZXJzOntqb2luOmEsbGluZTpuLGhhcmRsaW5lOnUsc29mdGxpbmU6aSxncm91cDpsLGluZGVudDpwfSx1dGlsczp7cmVwbGFjZVRleHRFbmRPZkxpbmU6ZH19PXFlKCkseT10ZCgpLGc9cmQoKSx7aW5zZXJ0UHJhZ21hOmN9PUNvKCksRD1FbygpLEU9cXQoKSxfPUZvKCkse2hhc0Zsb3dTaG9ydGhhbmRBbm5vdGF0aW9uQ29tbWVudDp3LGhhc0NvbW1lbnQ6RixDb21tZW50Q2hlY2tGbGFnczpTLGlzVGhlT25seUpzeEVsZW1lbnRJbk1hcmtkb3duOk4saXNMaW5lQ29tbWVudDpJLGlzTmV4dExpbmVFbXB0eTpQLG5lZWRzSGFyZGxpbmVBZnRlckRhbmdsaW5nQ29tbWVudDokLGhhc0lnbm9yZUNvbW1lbnQ6Zixpc0NhbGxFeHByZXNzaW9uOlQsaXNNZW1iZXJFeHByZXNzaW9uOm0sbWFya2VyRm9ySWZXaXRob3V0QmxvY2tBbmRTYW1lTGluZUNvbW1lbnQ6dn09S2UoKSx7bG9jU3RhcnQ6byxsb2NFbmQ6aH09dXQoKSxDPU90KCkse3ByaW50SHRtbEJpbmRpbmc6eCxpc1Z1ZUV2ZW50QmluZGluZ0V4cHJlc3Npb246Yn09Y2QoKSx7cHJpbnRBbmd1bGFyOkJ9PXBkKCkse3ByaW50SnN4OmssaGFzSnN4SWdub3JlQ29tbWVudDpNfT1mZCgpLHtwcmludEZsb3c6Un09bWQoKSx7cHJpbnRUeXBlc2NyaXB0OnF9PWdkKCkse3ByaW50T3B0aW9uYWxUb2tlbjpKLHByaW50QmluZEV4cHJlc3Npb25DYWxsZWU6TCxwcmludFR5cGVBbm5vdGF0aW9uOlEsYWRqdXN0Q2xhdXNlOlYscHJpbnRSZXN0U3ByZWFkOmoscHJpbnREZWZpbml0ZVRva2VuOlkscHJpbnREaXJlY3RpdmU6aWV9PWN0KCkse3ByaW50SW1wb3J0RGVjbGFyYXRpb246ZWUscHJpbnRFeHBvcnREZWNsYXJhdGlvbjpsZSxwcmludEV4cG9ydEFsbERlY2xhcmF0aW9uOlcscHJpbnRNb2R1bGVTcGVjaWZpZXI6S309VG8oKSx7cHJpbnRUZXJuYXJ5OmRlfT1CbygpLHtwcmludFRlbXBsYXRlTGl0ZXJhbDp1ZX09anQoKSx7cHJpbnRBcnJheTpGZX09ZXIoKSx7cHJpbnRPYmplY3Q6en09dXUoKSx7cHJpbnRDbGFzczpVLHByaW50Q2xhc3NNZXRob2Q6WixwcmludENsYXNzUHJvcGVydHk6c2V9PW5yKCkse3ByaW50UHJvcGVydHk6RGV9PXJyKCkse3ByaW50RnVuY3Rpb246Z2UscHJpbnRBcnJvd0Z1bmN0aW9uOmhlLHByaW50TWV0aG9kOndlLHByaW50UmV0dXJuU3RhdGVtZW50OmtlLHByaW50VGhyb3dTdGF0ZW1lbnQ6UmV9PXFyKCkse3ByaW50Q2FsbEV4cHJlc3Npb246TmV9PXhvKCkse3ByaW50VmFyaWFibGVEZWNsYXJhdG9yOlBlLHByaW50QXNzaWdubWVudEV4cHJlc3Npb246b2V9PXRyKCkse3ByaW50QmluYXJ5aXNoRXhwcmVzc2lvbjpIfT1ydSgpLHtwcmludFN3aXRjaENhc2VDb25zZXF1ZW50OmNlfT1ObygpLHtwcmludE1lbWJlckV4cHJlc3Npb246WH09U28oKSx7cHJpbnRCbG9jazpwZSxwcmludEJsb2NrQm9keTpBZX09d28oKSx7cHJpbnRDb21tZW50OkNlfT15ZCgpLHtwcmludExpdGVyYWw6ZmV9PWhkKCkse3ByaW50RGVjb3JhdG9yczpBfT1udSgpO2Z1bmN0aW9uIEcoRWUsQmUsdmUsemUpe2xldCBiZT1yZShFZSxCZSx2ZSx6ZSk7aWYoIWJlKXJldHVyblwiXCI7bGV0IFllPUVlLmdldFZhbHVlKCkse3R5cGU6U2V9PVllO2lmKFNlPT09XCJDbGFzc01ldGhvZFwifHxTZT09PVwiQ2xhc3NQcml2YXRlTWV0aG9kXCJ8fFNlPT09XCJDbGFzc1Byb3BlcnR5XCJ8fFNlPT09XCJDbGFzc0FjY2Vzc29yUHJvcGVydHlcInx8U2U9PT1cIkFjY2Vzc29yUHJvcGVydHlcInx8U2U9PT1cIlRTQWJzdHJhY3RBY2Nlc3NvclByb3BlcnR5XCJ8fFNlPT09XCJQcm9wZXJ0eURlZmluaXRpb25cInx8U2U9PT1cIlRTQWJzdHJhY3RQcm9wZXJ0eURlZmluaXRpb25cInx8U2U9PT1cIkNsYXNzUHJpdmF0ZVByb3BlcnR5XCJ8fFNlPT09XCJNZXRob2REZWZpbml0aW9uXCJ8fFNlPT09XCJUU0Fic3RyYWN0TWV0aG9kRGVmaW5pdGlvblwifHxTZT09PVwiVFNEZWNsYXJlTWV0aG9kXCIpcmV0dXJuIGJlO2xldCBJZT1bYmVdLE9lPUEoRWUsQmUsdmUpLEplPVllLnR5cGU9PT1cIkNsYXNzRXhwcmVzc2lvblwiJiZPZTtpZihPZSYmKEllPVsuLi5PZSxiZV0sIUplKSlyZXR1cm4gbChJZSk7aWYoIUUoRWUsQmUpKXJldHVybiB6ZSYmemUubmVlZHNTZW1pJiZJZS51bnNoaWZ0KFwiO1wiKSxJZS5sZW5ndGg9PT0xJiZJZVswXT09PWJlP2JlOkllO2lmKEplJiYoSWU9W3AoW24sLi4uSWVdKV0pLEllLnVuc2hpZnQoXCIoXCIpLHplJiZ6ZS5uZWVkc1NlbWkmJkllLnVuc2hpZnQoXCI7XCIpLHcoWWUpKXtsZXRbamVdPVllLnRyYWlsaW5nQ29tbWVudHM7SWUucHVzaChcIiAvKlwiLGplLnZhbHVlLnRyaW1TdGFydCgpLFwiKi9cIiksamUucHJpbnRlZD0hMH1yZXR1cm4gSmUmJkllLnB1c2gobiksSWUucHVzaChcIilcIiksSWV9ZnVuY3Rpb24gcmUoRWUsQmUsdmUsemUpe2xldCBiZT1FZS5nZXRWYWx1ZSgpLFllPUJlLnNlbWk/XCI7XCI6XCJcIjtpZighYmUpcmV0dXJuXCJcIjtpZih0eXBlb2YgYmU9PVwic3RyaW5nXCIpcmV0dXJuIGJlO2ZvcihsZXQgSWUgb2ZbZmUseCxCLGssUixxXSl7bGV0IE9lPUllKEVlLEJlLHZlKTtpZih0eXBlb2YgT2U8XCJ1XCIpcmV0dXJuIE9lfWxldCBTZT1bXTtzd2l0Y2goYmUudHlwZSl7Y2FzZVwiSnNFeHByZXNzaW9uUm9vdFwiOnJldHVybiB2ZShcIm5vZGVcIik7Y2FzZVwiSnNvblJvb3RcIjpyZXR1cm5bdmUoXCJub2RlXCIpLHVdO2Nhc2VcIkZpbGVcIjpyZXR1cm4gYmUucHJvZ3JhbSYmYmUucHJvZ3JhbS5pbnRlcnByZXRlciYmU2UucHVzaCh2ZShbXCJwcm9ncmFtXCIsXCJpbnRlcnByZXRlclwiXSkpLFNlLnB1c2godmUoXCJwcm9ncmFtXCIpKSxTZTtjYXNlXCJQcm9ncmFtXCI6cmV0dXJuIEFlKEVlLEJlLHZlKTtjYXNlXCJFbXB0eVN0YXRlbWVudFwiOnJldHVyblwiXCI7Y2FzZVwiRXhwcmVzc2lvblN0YXRlbWVudFwiOntpZihCZS5wYXJzZXI9PT1cIl9fdnVlX2V2ZW50X2JpbmRpbmdcInx8QmUucGFyc2VyPT09XCJfX3Z1ZV90c19ldmVudF9iaW5kaW5nXCIpe2xldCBPZT1FZS5nZXRQYXJlbnROb2RlKCk7aWYoT2UudHlwZT09PVwiUHJvZ3JhbVwiJiZPZS5ib2R5Lmxlbmd0aD09PTEmJk9lLmJvZHlbMF09PT1iZSlyZXR1cm5bdmUoXCJleHByZXNzaW9uXCIpLGIoYmUuZXhwcmVzc2lvbik/XCI7XCI6XCJcIl19bGV0IEllPXQoRWUsQmUsITAsT2U9PntsZXR7bWFya2VyOkplfT1PZTtyZXR1cm4gSmU9PT12fSk7cmV0dXJuW3ZlKFwiZXhwcmVzc2lvblwiKSxOKEJlLEVlKT9cIlwiOlllLEllP1tcIiBcIixJZV06XCJcIl19Y2FzZVwiUGFyZW50aGVzaXplZEV4cHJlc3Npb25cIjpyZXR1cm4hRihiZS5leHByZXNzaW9uKSYmKGJlLmV4cHJlc3Npb24udHlwZT09PVwiT2JqZWN0RXhwcmVzc2lvblwifHxiZS5leHByZXNzaW9uLnR5cGU9PT1cIkFycmF5RXhwcmVzc2lvblwiKT9bXCIoXCIsdmUoXCJleHByZXNzaW9uXCIpLFwiKVwiXTpsKFtcIihcIixwKFtpLHZlKFwiZXhwcmVzc2lvblwiKV0pLGksXCIpXCJdKTtjYXNlXCJBc3NpZ25tZW50RXhwcmVzc2lvblwiOnJldHVybiBvZShFZSxCZSx2ZSk7Y2FzZVwiVmFyaWFibGVEZWNsYXJhdG9yXCI6cmV0dXJuIFBlKEVlLEJlLHZlKTtjYXNlXCJCaW5hcnlFeHByZXNzaW9uXCI6Y2FzZVwiTG9naWNhbEV4cHJlc3Npb25cIjpyZXR1cm4gSChFZSxCZSx2ZSk7Y2FzZVwiQXNzaWdubWVudFBhdHRlcm5cIjpyZXR1cm5bdmUoXCJsZWZ0XCIpLFwiID0gXCIsdmUoXCJyaWdodFwiKV07Y2FzZVwiT3B0aW9uYWxNZW1iZXJFeHByZXNzaW9uXCI6Y2FzZVwiTWVtYmVyRXhwcmVzc2lvblwiOnJldHVybiBYKEVlLEJlLHZlKTtjYXNlXCJNZXRhUHJvcGVydHlcIjpyZXR1cm5bdmUoXCJtZXRhXCIpLFwiLlwiLHZlKFwicHJvcGVydHlcIildO2Nhc2VcIkJpbmRFeHByZXNzaW9uXCI6cmV0dXJuIGJlLm9iamVjdCYmU2UucHVzaCh2ZShcIm9iamVjdFwiKSksU2UucHVzaChsKHAoW2ksTChFZSxCZSx2ZSldKSkpLFNlO2Nhc2VcIklkZW50aWZpZXJcIjpyZXR1cm5bYmUubmFtZSxKKEVlKSxZKEVlKSxRKEVlLEJlLHZlKV07Y2FzZVwiVjhJbnRyaW5zaWNJZGVudGlmaWVyXCI6cmV0dXJuW1wiJVwiLGJlLm5hbWVdO2Nhc2VcIlNwcmVhZEVsZW1lbnRcIjpjYXNlXCJTcHJlYWRFbGVtZW50UGF0dGVyblwiOmNhc2VcIlNwcmVhZFByb3BlcnR5XCI6Y2FzZVwiU3ByZWFkUHJvcGVydHlQYXR0ZXJuXCI6Y2FzZVwiUmVzdEVsZW1lbnRcIjpyZXR1cm4gaihFZSxCZSx2ZSk7Y2FzZVwiRnVuY3Rpb25EZWNsYXJhdGlvblwiOmNhc2VcIkZ1bmN0aW9uRXhwcmVzc2lvblwiOnJldHVybiBnZShFZSx2ZSxCZSx6ZSk7Y2FzZVwiQXJyb3dGdW5jdGlvbkV4cHJlc3Npb25cIjpyZXR1cm4gaGUoRWUsQmUsdmUsemUpO2Nhc2VcIllpZWxkRXhwcmVzc2lvblwiOnJldHVybiBTZS5wdXNoKFwieWllbGRcIiksYmUuZGVsZWdhdGUmJlNlLnB1c2goXCIqXCIpLGJlLmFyZ3VtZW50JiZTZS5wdXNoKFwiIFwiLHZlKFwiYXJndW1lbnRcIikpLFNlO2Nhc2VcIkF3YWl0RXhwcmVzc2lvblwiOntpZihTZS5wdXNoKFwiYXdhaXRcIiksYmUuYXJndW1lbnQpe1NlLnB1c2goXCIgXCIsdmUoXCJhcmd1bWVudFwiKSk7bGV0IEllPUVlLmdldFBhcmVudE5vZGUoKTtpZihUKEllKSYmSWUuY2FsbGVlPT09YmV8fG0oSWUpJiZJZS5vYmplY3Q9PT1iZSl7U2U9W3AoW2ksLi4uU2VdKSxpXTtsZXQgT2U9RWUuZmluZEFuY2VzdG9yKEplPT5KZS50eXBlPT09XCJBd2FpdEV4cHJlc3Npb25cInx8SmUudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIik7aWYoIU9lfHxPZS50eXBlIT09XCJBd2FpdEV4cHJlc3Npb25cIilyZXR1cm4gbChTZSl9fXJldHVybiBTZX1jYXNlXCJFeHBvcnREZWZhdWx0RGVjbGFyYXRpb25cIjpjYXNlXCJFeHBvcnROYW1lZERlY2xhcmF0aW9uXCI6cmV0dXJuIGxlKEVlLEJlLHZlKTtjYXNlXCJFeHBvcnRBbGxEZWNsYXJhdGlvblwiOnJldHVybiBXKEVlLEJlLHZlKTtjYXNlXCJJbXBvcnREZWNsYXJhdGlvblwiOnJldHVybiBlZShFZSxCZSx2ZSk7Y2FzZVwiSW1wb3J0U3BlY2lmaWVyXCI6Y2FzZVwiRXhwb3J0U3BlY2lmaWVyXCI6Y2FzZVwiSW1wb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6Y2FzZVwiRXhwb3J0TmFtZXNwYWNlU3BlY2lmaWVyXCI6Y2FzZVwiSW1wb3J0RGVmYXVsdFNwZWNpZmllclwiOmNhc2VcIkV4cG9ydERlZmF1bHRTcGVjaWZpZXJcIjpyZXR1cm4gSyhFZSxCZSx2ZSk7Y2FzZVwiSW1wb3J0QXR0cmlidXRlXCI6cmV0dXJuW3ZlKFwia2V5XCIpLFwiOiBcIix2ZShcInZhbHVlXCIpXTtjYXNlXCJJbXBvcnRcIjpyZXR1cm5cImltcG9ydFwiO2Nhc2VcIkJsb2NrU3RhdGVtZW50XCI6Y2FzZVwiU3RhdGljQmxvY2tcIjpjYXNlXCJDbGFzc0JvZHlcIjpyZXR1cm4gcGUoRWUsQmUsdmUpO2Nhc2VcIlRocm93U3RhdGVtZW50XCI6cmV0dXJuIFJlKEVlLEJlLHZlKTtjYXNlXCJSZXR1cm5TdGF0ZW1lbnRcIjpyZXR1cm4ga2UoRWUsQmUsdmUpO2Nhc2VcIk5ld0V4cHJlc3Npb25cIjpjYXNlXCJJbXBvcnRFeHByZXNzaW9uXCI6Y2FzZVwiT3B0aW9uYWxDYWxsRXhwcmVzc2lvblwiOmNhc2VcIkNhbGxFeHByZXNzaW9uXCI6cmV0dXJuIE5lKEVlLEJlLHZlKTtjYXNlXCJPYmplY3RFeHByZXNzaW9uXCI6Y2FzZVwiT2JqZWN0UGF0dGVyblwiOmNhc2VcIlJlY29yZEV4cHJlc3Npb25cIjpyZXR1cm4geihFZSxCZSx2ZSk7Y2FzZVwiT2JqZWN0UHJvcGVydHlcIjpjYXNlXCJQcm9wZXJ0eVwiOnJldHVybiBiZS5tZXRob2R8fGJlLmtpbmQ9PT1cImdldFwifHxiZS5raW5kPT09XCJzZXRcIj93ZShFZSxCZSx2ZSk6RGUoRWUsQmUsdmUpO2Nhc2VcIk9iamVjdE1ldGhvZFwiOnJldHVybiB3ZShFZSxCZSx2ZSk7Y2FzZVwiRGVjb3JhdG9yXCI6cmV0dXJuW1wiQFwiLHZlKFwiZXhwcmVzc2lvblwiKV07Y2FzZVwiQXJyYXlFeHByZXNzaW9uXCI6Y2FzZVwiQXJyYXlQYXR0ZXJuXCI6Y2FzZVwiVHVwbGVFeHByZXNzaW9uXCI6cmV0dXJuIEZlKEVlLEJlLHZlKTtjYXNlXCJTZXF1ZW5jZUV4cHJlc3Npb25cIjp7bGV0IEllPUVlLmdldFBhcmVudE5vZGUoMCk7aWYoSWUudHlwZT09PVwiRXhwcmVzc2lvblN0YXRlbWVudFwifHxJZS50eXBlPT09XCJGb3JTdGF0ZW1lbnRcIil7bGV0IE9lPVtdO3JldHVybiBFZS5lYWNoKChKZSxUZSk9PntUZT09PTA/T2UucHVzaCh2ZSgpKTpPZS5wdXNoKFwiLFwiLHAoW24sdmUoKV0pKX0sXCJleHByZXNzaW9uc1wiKSxsKE9lKX1yZXR1cm4gbChhKFtcIixcIixuXSxFZS5tYXAodmUsXCJleHByZXNzaW9uc1wiKSkpfWNhc2VcIlRoaXNFeHByZXNzaW9uXCI6cmV0dXJuXCJ0aGlzXCI7Y2FzZVwiU3VwZXJcIjpyZXR1cm5cInN1cGVyXCI7Y2FzZVwiRGlyZWN0aXZlXCI6cmV0dXJuW3ZlKFwidmFsdWVcIiksWWVdO2Nhc2VcIkRpcmVjdGl2ZUxpdGVyYWxcIjpyZXR1cm4gaWUoYmUuZXh0cmEucmF3LEJlKTtjYXNlXCJVbmFyeUV4cHJlc3Npb25cIjpyZXR1cm4gU2UucHVzaChiZS5vcGVyYXRvciksL1thLXpdJC8udGVzdChiZS5vcGVyYXRvcikmJlNlLnB1c2goXCIgXCIpLEYoYmUuYXJndW1lbnQpP1NlLnB1c2gobChbXCIoXCIscChbaSx2ZShcImFyZ3VtZW50XCIpXSksaSxcIilcIl0pKTpTZS5wdXNoKHZlKFwiYXJndW1lbnRcIikpLFNlO2Nhc2VcIlVwZGF0ZUV4cHJlc3Npb25cIjpyZXR1cm4gU2UucHVzaCh2ZShcImFyZ3VtZW50XCIpLGJlLm9wZXJhdG9yKSxiZS5wcmVmaXgmJlNlLnJldmVyc2UoKSxTZTtjYXNlXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIjpyZXR1cm4gZGUoRWUsQmUsdmUpO2Nhc2VcIlZhcmlhYmxlRGVjbGFyYXRpb25cIjp7bGV0IEllPUVlLm1hcCh2ZSxcImRlY2xhcmF0aW9uc1wiKSxPZT1FZS5nZXRQYXJlbnROb2RlKCksSmU9T2UudHlwZT09PVwiRm9yU3RhdGVtZW50XCJ8fE9lLnR5cGU9PT1cIkZvckluU3RhdGVtZW50XCJ8fE9lLnR5cGU9PT1cIkZvck9mU3RhdGVtZW50XCIsVGU9YmUuZGVjbGFyYXRpb25zLnNvbWUoTWU9Pk1lLmluaXQpLGplO3JldHVybiBJZS5sZW5ndGg9PT0xJiYhRihiZS5kZWNsYXJhdGlvbnNbMF0pP2plPUllWzBdOkllLmxlbmd0aD4wJiYoamU9cChJZVswXSkpLFNlPVtiZS5kZWNsYXJlP1wiZGVjbGFyZSBcIjpcIlwiLGJlLmtpbmQsamU/W1wiIFwiLGplXTpcIlwiLHAoSWUuc2xpY2UoMSkubWFwKE1lPT5bXCIsXCIsVGUmJiFKZT91Om4sTWVdKSldLEplJiZPZS5ib2R5IT09YmV8fFNlLnB1c2goWWUpLGwoU2UpfWNhc2VcIldpdGhTdGF0ZW1lbnRcIjpyZXR1cm4gbChbXCJ3aXRoIChcIix2ZShcIm9iamVjdFwiKSxcIilcIixWKGJlLmJvZHksdmUoXCJib2R5XCIpKV0pO2Nhc2VcIklmU3RhdGVtZW50XCI6e2xldCBJZT1WKGJlLmNvbnNlcXVlbnQsdmUoXCJjb25zZXF1ZW50XCIpKSxPZT1sKFtcImlmIChcIixsKFtwKFtpLHZlKFwidGVzdFwiKV0pLGldKSxcIilcIixJZV0pO2lmKFNlLnB1c2goT2UpLGJlLmFsdGVybmF0ZSl7bGV0IEplPUYoYmUuY29uc2VxdWVudCxTLlRyYWlsaW5nfFMuTGluZSl8fCQoYmUpLFRlPWJlLmNvbnNlcXVlbnQudHlwZT09PVwiQmxvY2tTdGF0ZW1lbnRcIiYmIUplO1NlLnB1c2goVGU/XCIgXCI6dSksRihiZSxTLkRhbmdsaW5nKSYmU2UucHVzaCh0KEVlLEJlLCEwKSxKZT91OlwiIFwiKSxTZS5wdXNoKFwiZWxzZVwiLGwoVihiZS5hbHRlcm5hdGUsdmUoXCJhbHRlcm5hdGVcIiksYmUuYWx0ZXJuYXRlLnR5cGU9PT1cIklmU3RhdGVtZW50XCIpKSl9cmV0dXJuIFNlfWNhc2VcIkZvclN0YXRlbWVudFwiOntsZXQgSWU9VihiZS5ib2R5LHZlKFwiYm9keVwiKSksT2U9dChFZSxCZSwhMCksSmU9T2U/W09lLGldOlwiXCI7cmV0dXJuIWJlLmluaXQmJiFiZS50ZXN0JiYhYmUudXBkYXRlP1tKZSxsKFtcImZvciAoOzspXCIsSWVdKV06W0plLGwoW1wiZm9yIChcIixsKFtwKFtpLHZlKFwiaW5pdFwiKSxcIjtcIixuLHZlKFwidGVzdFwiKSxcIjtcIixuLHZlKFwidXBkYXRlXCIpXSksaV0pLFwiKVwiLEllXSldfWNhc2VcIldoaWxlU3RhdGVtZW50XCI6cmV0dXJuIGwoW1wid2hpbGUgKFwiLGwoW3AoW2ksdmUoXCJ0ZXN0XCIpXSksaV0pLFwiKVwiLFYoYmUuYm9keSx2ZShcImJvZHlcIikpXSk7Y2FzZVwiRm9ySW5TdGF0ZW1lbnRcIjpyZXR1cm4gbChbXCJmb3IgKFwiLHZlKFwibGVmdFwiKSxcIiBpbiBcIix2ZShcInJpZ2h0XCIpLFwiKVwiLFYoYmUuYm9keSx2ZShcImJvZHlcIikpXSk7Y2FzZVwiRm9yT2ZTdGF0ZW1lbnRcIjpyZXR1cm4gbChbXCJmb3JcIixiZS5hd2FpdD9cIiBhd2FpdFwiOlwiXCIsXCIgKFwiLHZlKFwibGVmdFwiKSxcIiBvZiBcIix2ZShcInJpZ2h0XCIpLFwiKVwiLFYoYmUuYm9keSx2ZShcImJvZHlcIikpXSk7Y2FzZVwiRG9XaGlsZVN0YXRlbWVudFwiOntsZXQgSWU9VihiZS5ib2R5LHZlKFwiYm9keVwiKSk7cmV0dXJuIFNlPVtsKFtcImRvXCIsSWVdKV0sYmUuYm9keS50eXBlPT09XCJCbG9ja1N0YXRlbWVudFwiP1NlLnB1c2goXCIgXCIpOlNlLnB1c2godSksU2UucHVzaChcIndoaWxlIChcIixsKFtwKFtpLHZlKFwidGVzdFwiKV0pLGldKSxcIilcIixZZSksU2V9Y2FzZVwiRG9FeHByZXNzaW9uXCI6cmV0dXJuW2JlLmFzeW5jP1wiYXN5bmMgXCI6XCJcIixcImRvIFwiLHZlKFwiYm9keVwiKV07Y2FzZVwiQnJlYWtTdGF0ZW1lbnRcIjpyZXR1cm4gU2UucHVzaChcImJyZWFrXCIpLGJlLmxhYmVsJiZTZS5wdXNoKFwiIFwiLHZlKFwibGFiZWxcIikpLFNlLnB1c2goWWUpLFNlO2Nhc2VcIkNvbnRpbnVlU3RhdGVtZW50XCI6cmV0dXJuIFNlLnB1c2goXCJjb250aW51ZVwiKSxiZS5sYWJlbCYmU2UucHVzaChcIiBcIix2ZShcImxhYmVsXCIpKSxTZS5wdXNoKFllKSxTZTtjYXNlXCJMYWJlbGVkU3RhdGVtZW50XCI6cmV0dXJuIGJlLmJvZHkudHlwZT09PVwiRW1wdHlTdGF0ZW1lbnRcIj9bdmUoXCJsYWJlbFwiKSxcIjo7XCJdOlt2ZShcImxhYmVsXCIpLFwiOiBcIix2ZShcImJvZHlcIildO2Nhc2VcIlRyeVN0YXRlbWVudFwiOnJldHVybltcInRyeSBcIix2ZShcImJsb2NrXCIpLGJlLmhhbmRsZXI/W1wiIFwiLHZlKFwiaGFuZGxlclwiKV06XCJcIixiZS5maW5hbGl6ZXI/W1wiIGZpbmFsbHkgXCIsdmUoXCJmaW5hbGl6ZXJcIildOlwiXCJdO2Nhc2VcIkNhdGNoQ2xhdXNlXCI6aWYoYmUucGFyYW0pe2xldCBJZT1GKGJlLnBhcmFtLEplPT4hQyhKZSl8fEplLmxlYWRpbmcmJnMoQmUub3JpZ2luYWxUZXh0LGgoSmUpKXx8SmUudHJhaWxpbmcmJnMoQmUub3JpZ2luYWxUZXh0LG8oSmUpLHtiYWNrd2FyZHM6ITB9KSksT2U9dmUoXCJwYXJhbVwiKTtyZXR1cm5bXCJjYXRjaCBcIixJZT9bXCIoXCIscChbaSxPZV0pLGksXCIpIFwiXTpbXCIoXCIsT2UsXCIpIFwiXSx2ZShcImJvZHlcIildfXJldHVybltcImNhdGNoIFwiLHZlKFwiYm9keVwiKV07Y2FzZVwiU3dpdGNoU3RhdGVtZW50XCI6cmV0dXJuW2woW1wic3dpdGNoIChcIixwKFtpLHZlKFwiZGlzY3JpbWluYW50XCIpXSksaSxcIilcIl0pLFwiIHtcIixiZS5jYXNlcy5sZW5ndGg+MD9wKFt1LGEodSxFZS5tYXAoKEllLE9lLEplKT0+e2xldCBUZT1JZS5nZXRWYWx1ZSgpO3JldHVyblt2ZSgpLE9lIT09SmUubGVuZ3RoLTEmJlAoVGUsQmUpP3U6XCJcIl19LFwiY2FzZXNcIikpXSk6XCJcIix1LFwifVwiXTtjYXNlXCJTd2l0Y2hDYXNlXCI6e2JlLnRlc3Q/U2UucHVzaChcImNhc2UgXCIsdmUoXCJ0ZXN0XCIpLFwiOlwiKTpTZS5wdXNoKFwiZGVmYXVsdDpcIiksRihiZSxTLkRhbmdsaW5nKSYmU2UucHVzaChcIiBcIix0KEVlLEJlLCEwKSk7bGV0IEllPWJlLmNvbnNlcXVlbnQuZmlsdGVyKE9lPT5PZS50eXBlIT09XCJFbXB0eVN0YXRlbWVudFwiKTtpZihJZS5sZW5ndGg+MCl7bGV0IE9lPWNlKEVlLEJlLHZlKTtTZS5wdXNoKEllLmxlbmd0aD09PTEmJkllWzBdLnR5cGU9PT1cIkJsb2NrU3RhdGVtZW50XCI/W1wiIFwiLE9lXTpwKFt1LE9lXSkpfXJldHVybiBTZX1jYXNlXCJEZWJ1Z2dlclN0YXRlbWVudFwiOnJldHVybltcImRlYnVnZ2VyXCIsWWVdO2Nhc2VcIkNsYXNzRGVjbGFyYXRpb25cIjpjYXNlXCJDbGFzc0V4cHJlc3Npb25cIjpyZXR1cm4gVShFZSxCZSx2ZSk7Y2FzZVwiQ2xhc3NNZXRob2RcIjpjYXNlXCJDbGFzc1ByaXZhdGVNZXRob2RcIjpjYXNlXCJNZXRob2REZWZpbml0aW9uXCI6cmV0dXJuIFooRWUsQmUsdmUpO2Nhc2VcIkNsYXNzUHJvcGVydHlcIjpjYXNlXCJQcm9wZXJ0eURlZmluaXRpb25cIjpjYXNlXCJDbGFzc1ByaXZhdGVQcm9wZXJ0eVwiOmNhc2VcIkNsYXNzQWNjZXNzb3JQcm9wZXJ0eVwiOmNhc2VcIkFjY2Vzc29yUHJvcGVydHlcIjpyZXR1cm4gc2UoRWUsQmUsdmUpO2Nhc2VcIlRlbXBsYXRlRWxlbWVudFwiOnJldHVybiBkKGJlLnZhbHVlLnJhdyk7Y2FzZVwiVGVtcGxhdGVMaXRlcmFsXCI6cmV0dXJuIHVlKEVlLHZlLEJlKTtjYXNlXCJUYWdnZWRUZW1wbGF0ZUV4cHJlc3Npb25cIjpyZXR1cm5bdmUoXCJ0YWdcIiksdmUoXCJ0eXBlUGFyYW1ldGVyc1wiKSx2ZShcInF1YXNpXCIpXTtjYXNlXCJQcml2YXRlSWRlbnRpZmllclwiOnJldHVybltcIiNcIix2ZShcIm5hbWVcIildO2Nhc2VcIlByaXZhdGVOYW1lXCI6cmV0dXJuW1wiI1wiLHZlKFwiaWRcIildO2Nhc2VcIkludGVycHJldGVyRGlyZWN0aXZlXCI6cmV0dXJuIFNlLnB1c2goXCIjIVwiLGJlLnZhbHVlLHUpLFAoYmUsQmUpJiZTZS5wdXNoKHUpLFNlO2Nhc2VcIlRvcGljUmVmZXJlbmNlXCI6cmV0dXJuXCIlXCI7Y2FzZVwiQXJndW1lbnRQbGFjZWhvbGRlclwiOnJldHVyblwiP1wiO2Nhc2VcIk1vZHVsZUV4cHJlc3Npb25cIjp7U2UucHVzaChcIm1vZHVsZSB7XCIpO2xldCBJZT12ZShcImJvZHlcIik7cmV0dXJuIEllJiZTZS5wdXNoKHAoW3UsSWVdKSx1KSxTZS5wdXNoKFwifVwiKSxTZX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihcInVua25vd24gdHlwZTogXCIrSlNPTi5zdHJpbmdpZnkoYmUudHlwZSkpfX1mdW5jdGlvbiB5ZShFZSl7cmV0dXJuIEVlLnR5cGUmJiFDKEVlKSYmIUkoRWUpJiZFZS50eXBlIT09XCJFbXB0eVN0YXRlbWVudFwiJiZFZS50eXBlIT09XCJUZW1wbGF0ZUVsZW1lbnRcIiYmRWUudHlwZSE9PVwiSW1wb3J0XCImJkVlLnR5cGUhPT1cIlRTRW1wdHlCb2R5RnVuY3Rpb25FeHByZXNzaW9uXCJ9ci5leHBvcnRzPXtwcmVwcm9jZXNzOl8scHJpbnQ6RyxlbWJlZDp5LGluc2VydFByYWdtYTpjLG1hc3NhZ2VBc3ROb2RlOmcsaGFzUHJldHRpZXJJZ25vcmUoRWUpe3JldHVybiBmKEVlKXx8TShFZSl9LHdpbGxQcmludE93bkNvbW1lbnRzOkQud2lsbFByaW50T3duQ29tbWVudHMsY2FuQXR0YWNoQ29tbWVudDp5ZSxwcmludENvbW1lbnQ6Q2UsaXNCbG9ja0NvbW1lbnQ6QyxoYW5kbGVDb21tZW50czp7YXZvaWRBc3RNdXRhdGlvbjohMCxvd25MaW5lOkQuaGFuZGxlT3duTGluZUNvbW1lbnQsZW5kT2ZMaW5lOkQuaGFuZGxlRW5kT2ZMaW5lQ29tbWVudCxyZW1haW5pbmc6RC5oYW5kbGVSZW1haW5pbmdDb21tZW50fSxnZXRDb21tZW50Q2hpbGROb2RlczpELmdldENvbW1lbnRDaGlsZE5vZGVzfX19KSxDZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvcHJpbnRlci1lc3RyZWUtanNvbi5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7YnVpbGRlcnM6e2hhcmRsaW5lOnQsaW5kZW50OnMsam9pbjphfX09cWUoKSxuPUZvKCk7ZnVuY3Rpb24gdShkLHksZyl7bGV0IGM9ZC5nZXRWYWx1ZSgpO3N3aXRjaChjLnR5cGUpe2Nhc2VcIkpzb25Sb290XCI6cmV0dXJuW2coXCJub2RlXCIpLHRdO2Nhc2VcIkFycmF5RXhwcmVzc2lvblwiOntpZihjLmVsZW1lbnRzLmxlbmd0aD09PTApcmV0dXJuXCJbXVwiO2xldCBEPWQubWFwKCgpPT5kLmdldFZhbHVlKCk9PT1udWxsP1wibnVsbFwiOmcoKSxcImVsZW1lbnRzXCIpO3JldHVybltcIltcIixzKFt0LGEoW1wiLFwiLHRdLEQpXSksdCxcIl1cIl19Y2FzZVwiT2JqZWN0RXhwcmVzc2lvblwiOnJldHVybiBjLnByb3BlcnRpZXMubGVuZ3RoPT09MD9cInt9XCI6W1wie1wiLHMoW3QsYShbXCIsXCIsdF0sZC5tYXAoZyxcInByb3BlcnRpZXNcIikpXSksdCxcIn1cIl07Y2FzZVwiT2JqZWN0UHJvcGVydHlcIjpyZXR1cm5bZyhcImtleVwiKSxcIjogXCIsZyhcInZhbHVlXCIpXTtjYXNlXCJVbmFyeUV4cHJlc3Npb25cIjpyZXR1cm5bYy5vcGVyYXRvcj09PVwiK1wiP1wiXCI6Yy5vcGVyYXRvcixnKFwiYXJndW1lbnRcIildO2Nhc2VcIk51bGxMaXRlcmFsXCI6cmV0dXJuXCJudWxsXCI7Y2FzZVwiQm9vbGVhbkxpdGVyYWxcIjpyZXR1cm4gYy52YWx1ZT9cInRydWVcIjpcImZhbHNlXCI7Y2FzZVwiU3RyaW5nTGl0ZXJhbFwiOnJldHVybiBKU09OLnN0cmluZ2lmeShjLnZhbHVlKTtjYXNlXCJOdW1lcmljTGl0ZXJhbFwiOnJldHVybiBpKGQpP0pTT04uc3RyaW5naWZ5KFN0cmluZyhjLnZhbHVlKSk6SlNPTi5zdHJpbmdpZnkoYy52YWx1ZSk7Y2FzZVwiSWRlbnRpZmllclwiOnJldHVybiBpKGQpP0pTT04uc3RyaW5naWZ5KGMubmFtZSk6Yy5uYW1lO2Nhc2VcIlRlbXBsYXRlTGl0ZXJhbFwiOnJldHVybiBnKFtcInF1YXNpc1wiLDBdKTtjYXNlXCJUZW1wbGF0ZUVsZW1lbnRcIjpyZXR1cm4gSlNPTi5zdHJpbmdpZnkoYy52YWx1ZS5jb29rZWQpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biB0eXBlOiBcIitKU09OLnN0cmluZ2lmeShjLnR5cGUpKX19ZnVuY3Rpb24gaShkKXtyZXR1cm4gZC5nZXROYW1lKCk9PT1cImtleVwiJiZkLmdldFBhcmVudE5vZGUoKS50eXBlPT09XCJPYmplY3RQcm9wZXJ0eVwifXZhciBsPW5ldyBTZXQoW1wic3RhcnRcIixcImVuZFwiLFwiZXh0cmFcIixcImxvY1wiLFwiY29tbWVudHNcIixcImxlYWRpbmdDb21tZW50c1wiLFwidHJhaWxpbmdDb21tZW50c1wiLFwiaW5uZXJDb21tZW50c1wiLFwiZXJyb3JzXCIsXCJyYW5nZVwiLFwidG9rZW5zXCJdKTtmdW5jdGlvbiBwKGQseSl7bGV0e3R5cGU6Z309ZDtpZihnPT09XCJPYmplY3RQcm9wZXJ0eVwiKXtsZXR7a2V5OmN9PWQ7Yy50eXBlPT09XCJJZGVudGlmaWVyXCI/eS5rZXk9e3R5cGU6XCJTdHJpbmdMaXRlcmFsXCIsdmFsdWU6Yy5uYW1lfTpjLnR5cGU9PT1cIk51bWVyaWNMaXRlcmFsXCImJih5LmtleT17dHlwZTpcIlN0cmluZ0xpdGVyYWxcIix2YWx1ZTpTdHJpbmcoYy52YWx1ZSl9KTtyZXR1cm59aWYoZz09PVwiVW5hcnlFeHByZXNzaW9uXCImJmQub3BlcmF0b3I9PT1cIitcIilyZXR1cm4geS5hcmd1bWVudDtpZihnPT09XCJBcnJheUV4cHJlc3Npb25cIil7Zm9yKGxldFtjLERdb2YgZC5lbGVtZW50cy5lbnRyaWVzKCkpRD09PW51bGwmJnkuZWxlbWVudHMuc3BsaWNlKGMsMCx7dHlwZTpcIk51bGxMaXRlcmFsXCJ9KTtyZXR1cm59aWYoZz09PVwiVGVtcGxhdGVMaXRlcmFsXCIpcmV0dXJue3R5cGU6XCJTdHJpbmdMaXRlcmFsXCIsdmFsdWU6ZC5xdWFzaXNbMF0udmFsdWUuY29va2VkfX1wLmlnbm9yZWRQcm9wZXJ0aWVzPWwsci5leHBvcnRzPXtwcmVwcm9jZXNzOm4scHJpbnQ6dSxtYXNzYWdlQXN0Tm9kZTpwfX19KSxNdD10ZSh7XCJzcmMvY29tbW9uL2NvbW1vbi1vcHRpb25zLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PVwiQ29tbW9uXCI7ci5leHBvcnRzPXticmFja2V0U3BhY2luZzp7c2luY2U6XCIwLjAuMFwiLGNhdGVnb3J5OnQsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiEwLGRlc2NyaXB0aW9uOlwiUHJpbnQgc3BhY2VzIGJldHdlZW4gYnJhY2tldHMuXCIsb3Bwb3NpdGVEZXNjcmlwdGlvbjpcIkRvIG5vdCBwcmludCBzcGFjZXMgYmV0d2VlbiBicmFja2V0cy5cIn0sc2luZ2xlUXVvdGU6e3NpbmNlOlwiMC4wLjBcIixjYXRlZ29yeTp0LHR5cGU6XCJib29sZWFuXCIsZGVmYXVsdDohMSxkZXNjcmlwdGlvbjpcIlVzZSBzaW5nbGUgcXVvdGVzIGluc3RlYWQgb2YgZG91YmxlIHF1b3Rlcy5cIn0scHJvc2VXcmFwOntzaW5jZTpcIjEuOC4yXCIsY2F0ZWdvcnk6dCx0eXBlOlwiY2hvaWNlXCIsZGVmYXVsdDpbe3NpbmNlOlwiMS44LjJcIix2YWx1ZTohMH0se3NpbmNlOlwiMS45LjBcIix2YWx1ZTpcInByZXNlcnZlXCJ9XSxkZXNjcmlwdGlvbjpcIkhvdyB0byB3cmFwIHByb3NlLlwiLGNob2ljZXM6W3tzaW5jZTpcIjEuOS4wXCIsdmFsdWU6XCJhbHdheXNcIixkZXNjcmlwdGlvbjpcIldyYXAgcHJvc2UgaWYgaXQgZXhjZWVkcyB0aGUgcHJpbnQgd2lkdGguXCJ9LHtzaW5jZTpcIjEuOS4wXCIsdmFsdWU6XCJuZXZlclwiLGRlc2NyaXB0aW9uOlwiRG8gbm90IHdyYXAgcHJvc2UuXCJ9LHtzaW5jZTpcIjEuOS4wXCIsdmFsdWU6XCJwcmVzZXJ2ZVwiLGRlc2NyaXB0aW9uOlwiV3JhcCBwcm9zZSBhcy1pcy5cIn1dfSxicmFja2V0U2FtZUxpbmU6e3NpbmNlOlwiMi40LjBcIixjYXRlZ29yeTp0LHR5cGU6XCJib29sZWFuXCIsZGVmYXVsdDohMSxkZXNjcmlwdGlvbjpcIlB1dCA+IG9mIG9wZW5pbmcgdGFncyBvbiB0aGUgbGFzdCBsaW5lIGluc3RlYWQgb2Ygb24gYSBuZXcgbGluZS5cIn0sc2luZ2xlQXR0cmlidXRlUGVyTGluZTp7c2luY2U6XCIyLjYuMFwiLGNhdGVnb3J5OnQsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiExLGRlc2NyaXB0aW9uOlwiRW5mb3JjZSBzaW5nbGUgYXR0cmlidXRlIHBlciBsaW5lIGluIEhUTUwsIFZ1ZSBhbmQgSlNYLlwifX19fSksRWQ9dGUoe1wic3JjL2xhbmd1YWdlLWpzL29wdGlvbnMuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9TXQoKSxzPVwiSmF2YVNjcmlwdFwiO3IuZXhwb3J0cz17YXJyb3dQYXJlbnM6e3NpbmNlOlwiMS45LjBcIixjYXRlZ29yeTpzLHR5cGU6XCJjaG9pY2VcIixkZWZhdWx0Olt7c2luY2U6XCIxLjkuMFwiLHZhbHVlOlwiYXZvaWRcIn0se3NpbmNlOlwiMi4wLjBcIix2YWx1ZTpcImFsd2F5c1wifV0sZGVzY3JpcHRpb246XCJJbmNsdWRlIHBhcmVudGhlc2VzIGFyb3VuZCBhIHNvbGUgYXJyb3cgZnVuY3Rpb24gcGFyYW1ldGVyLlwiLGNob2ljZXM6W3t2YWx1ZTpcImFsd2F5c1wiLGRlc2NyaXB0aW9uOlwiQWx3YXlzIGluY2x1ZGUgcGFyZW5zLiBFeGFtcGxlOiBgKHgpID0+IHhgXCJ9LHt2YWx1ZTpcImF2b2lkXCIsZGVzY3JpcHRpb246XCJPbWl0IHBhcmVucyB3aGVuIHBvc3NpYmxlLiBFeGFtcGxlOiBgeCA9PiB4YFwifV19LGJyYWNrZXRTYW1lTGluZTp0LmJyYWNrZXRTYW1lTGluZSxicmFja2V0U3BhY2luZzp0LmJyYWNrZXRTcGFjaW5nLGpzeEJyYWNrZXRTYW1lTGluZTp7c2luY2U6XCIwLjE3LjBcIixjYXRlZ29yeTpzLHR5cGU6XCJib29sZWFuXCIsZGVzY3JpcHRpb246XCJQdXQgPiBvbiB0aGUgbGFzdCBsaW5lIGluc3RlYWQgb2YgYXQgYSBuZXcgbGluZS5cIixkZXByZWNhdGVkOlwiMi40LjBcIn0sc2VtaTp7c2luY2U6XCIxLjAuMFwiLGNhdGVnb3J5OnMsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiEwLGRlc2NyaXB0aW9uOlwiUHJpbnQgc2VtaWNvbG9ucy5cIixvcHBvc2l0ZURlc2NyaXB0aW9uOlwiRG8gbm90IHByaW50IHNlbWljb2xvbnMsIGV4Y2VwdCBhdCB0aGUgYmVnaW5uaW5nIG9mIGxpbmVzIHdoaWNoIG1heSBuZWVkIHRoZW0uXCJ9LHNpbmdsZVF1b3RlOnQuc2luZ2xlUXVvdGUsanN4U2luZ2xlUXVvdGU6e3NpbmNlOlwiMS4xNS4wXCIsY2F0ZWdvcnk6cyx0eXBlOlwiYm9vbGVhblwiLGRlZmF1bHQ6ITEsZGVzY3JpcHRpb246XCJVc2Ugc2luZ2xlIHF1b3RlcyBpbiBKU1guXCJ9LHF1b3RlUHJvcHM6e3NpbmNlOlwiMS4xNy4wXCIsY2F0ZWdvcnk6cyx0eXBlOlwiY2hvaWNlXCIsZGVmYXVsdDpcImFzLW5lZWRlZFwiLGRlc2NyaXB0aW9uOlwiQ2hhbmdlIHdoZW4gcHJvcGVydGllcyBpbiBvYmplY3RzIGFyZSBxdW90ZWQuXCIsY2hvaWNlczpbe3ZhbHVlOlwiYXMtbmVlZGVkXCIsZGVzY3JpcHRpb246XCJPbmx5IGFkZCBxdW90ZXMgYXJvdW5kIG9iamVjdCBwcm9wZXJ0aWVzIHdoZXJlIHJlcXVpcmVkLlwifSx7dmFsdWU6XCJjb25zaXN0ZW50XCIsZGVzY3JpcHRpb246XCJJZiBhdCBsZWFzdCBvbmUgcHJvcGVydHkgaW4gYW4gb2JqZWN0IHJlcXVpcmVzIHF1b3RlcywgcXVvdGUgYWxsIHByb3BlcnRpZXMuXCJ9LHt2YWx1ZTpcInByZXNlcnZlXCIsZGVzY3JpcHRpb246XCJSZXNwZWN0IHRoZSBpbnB1dCB1c2Ugb2YgcXVvdGVzIGluIG9iamVjdCBwcm9wZXJ0aWVzLlwifV19LHRyYWlsaW5nQ29tbWE6e3NpbmNlOlwiMC4wLjBcIixjYXRlZ29yeTpzLHR5cGU6XCJjaG9pY2VcIixkZWZhdWx0Olt7c2luY2U6XCIwLjAuMFwiLHZhbHVlOiExfSx7c2luY2U6XCIwLjE5LjBcIix2YWx1ZTpcIm5vbmVcIn0se3NpbmNlOlwiMi4wLjBcIix2YWx1ZTpcImVzNVwifV0sZGVzY3JpcHRpb246XCJQcmludCB0cmFpbGluZyBjb21tYXMgd2hlcmV2ZXIgcG9zc2libGUgd2hlbiBtdWx0aS1saW5lLlwiLGNob2ljZXM6W3t2YWx1ZTpcImVzNVwiLGRlc2NyaXB0aW9uOlwiVHJhaWxpbmcgY29tbWFzIHdoZXJlIHZhbGlkIGluIEVTNSAob2JqZWN0cywgYXJyYXlzLCBldGMuKVwifSx7dmFsdWU6XCJub25lXCIsZGVzY3JpcHRpb246XCJObyB0cmFpbGluZyBjb21tYXMuXCJ9LHt2YWx1ZTpcImFsbFwiLGRlc2NyaXB0aW9uOlwiVHJhaWxpbmcgY29tbWFzIHdoZXJldmVyIHBvc3NpYmxlIChpbmNsdWRpbmcgZnVuY3Rpb24gYXJndW1lbnRzKS5cIn1dfSxzaW5nbGVBdHRyaWJ1dGVQZXJMaW5lOnQuc2luZ2xlQXR0cmlidXRlUGVyTGluZX19fSksRmQ9dGUoe1wic3JjL2xhbmd1YWdlLWpzL3BhcnNlL3BhcnNlcnMuanNcIigpe25lKCl9fSksTG49dGUoe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL0phdmFTY3JpcHQuanNvblwiKGUscil7ci5leHBvcnRzPXtuYW1lOlwiSmF2YVNjcmlwdFwiLHR5cGU6XCJwcm9ncmFtbWluZ1wiLHRtU2NvcGU6XCJzb3VyY2UuanNcIixhY2VNb2RlOlwiamF2YXNjcmlwdFwiLGNvZGVtaXJyb3JNb2RlOlwiamF2YXNjcmlwdFwiLGNvZGVtaXJyb3JNaW1lVHlwZTpcInRleHQvamF2YXNjcmlwdFwiLGNvbG9yOlwiI2YxZTA1YVwiLGFsaWFzZXM6W1wianNcIixcIm5vZGVcIl0sZXh0ZW5zaW9uczpbXCIuanNcIixcIi5fanNcIixcIi5ib25lc1wiLFwiLmNqc1wiLFwiLmVzXCIsXCIuZXM2XCIsXCIuZnJhZ1wiLFwiLmdzXCIsXCIuamFrZVwiLFwiLmphdmFzY3JpcHRcIixcIi5qc2JcIixcIi5qc2NhZFwiLFwiLmpzZmxcIixcIi5qc2xpYlwiLFwiLmpzbVwiLFwiLmpzcHJlXCIsXCIuanNzXCIsXCIuanN4XCIsXCIubWpzXCIsXCIubmpzXCIsXCIucGFjXCIsXCIuc2pzXCIsXCIuc3Nqc1wiLFwiLnhzanNcIixcIi54c2pzbGliXCJdLGZpbGVuYW1lczpbXCJKYWtlZmlsZVwiXSxpbnRlcnByZXRlcnM6W1wiY2hha3JhXCIsXCJkOFwiLFwiZ2pzXCIsXCJqc1wiLFwibm9kZVwiLFwibm9kZWpzXCIsXCJxanNcIixcInJoaW5vXCIsXCJ2OFwiLFwidjgtc2hlbGxcIl0sbGFuZ3VhZ2VJZDoxODN9fX0pLEFkPXRlKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9UeXBlU2NyaXB0Lmpzb25cIihlLHIpe3IuZXhwb3J0cz17bmFtZTpcIlR5cGVTY3JpcHRcIix0eXBlOlwicHJvZ3JhbW1pbmdcIixjb2xvcjpcIiMzMTc4YzZcIixhbGlhc2VzOltcInRzXCJdLGludGVycHJldGVyczpbXCJkZW5vXCIsXCJ0cy1ub2RlXCJdLGV4dGVuc2lvbnM6W1wiLnRzXCIsXCIuY3RzXCIsXCIubXRzXCJdLHRtU2NvcGU6XCJzb3VyY2UudHNcIixhY2VNb2RlOlwidHlwZXNjcmlwdFwiLGNvZGVtaXJyb3JNb2RlOlwiamF2YXNjcmlwdFwiLGNvZGVtaXJyb3JNaW1lVHlwZTpcImFwcGxpY2F0aW9uL3R5cGVzY3JpcHRcIixsYW5ndWFnZUlkOjM3OH19fSksU2Q9dGUoe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL1RTWC5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e25hbWU6XCJUU1hcIix0eXBlOlwicHJvZ3JhbW1pbmdcIixjb2xvcjpcIiMzMTc4YzZcIixncm91cDpcIlR5cGVTY3JpcHRcIixleHRlbnNpb25zOltcIi50c3hcIl0sdG1TY29wZTpcInNvdXJjZS50c3hcIixhY2VNb2RlOlwiamF2YXNjcmlwdFwiLGNvZGVtaXJyb3JNb2RlOlwianN4XCIsY29kZW1pcnJvck1pbWVUeXBlOlwidGV4dC9qc3hcIixsYW5ndWFnZUlkOjk0OTAxOTI0fX19KSx3YT10ZSh7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvSlNPTi5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e25hbWU6XCJKU09OXCIsdHlwZTpcImRhdGFcIixjb2xvcjpcIiMyOTI5MjlcIix0bVNjb3BlOlwic291cmNlLmpzb25cIixhY2VNb2RlOlwianNvblwiLGNvZGVtaXJyb3JNb2RlOlwiamF2YXNjcmlwdFwiLGNvZGVtaXJyb3JNaW1lVHlwZTpcImFwcGxpY2F0aW9uL2pzb25cIixhbGlhc2VzOltcImdlb2pzb25cIixcImpzb25sXCIsXCJ0b3BvanNvblwiXSxleHRlbnNpb25zOltcIi5qc29uXCIsXCIuNERGb3JtXCIsXCIuNERQcm9qZWN0XCIsXCIuYXZzY1wiLFwiLmdlb2pzb25cIixcIi5nbHRmXCIsXCIuaGFyXCIsXCIuaWNlXCIsXCIuSlNPTi10bUxhbmd1YWdlXCIsXCIuanNvbmxcIixcIi5tY21ldGFcIixcIi50ZnN0YXRlXCIsXCIudGZzdGF0ZS5iYWNrdXBcIixcIi50b3BvanNvblwiLFwiLndlYmFwcFwiLFwiLndlYm1hbmlmZXN0XCIsXCIueXlcIixcIi55eXBcIl0sZmlsZW5hbWVzOltcIi5hcmNjb25maWdcIixcIi5hdXRvLWNoYW5nZWxvZ1wiLFwiLmM4cmNcIixcIi5odG1saGludHJjXCIsXCIuaW1nYm90Y29uZmlnXCIsXCIubnljcmNcIixcIi50ZXJuLWNvbmZpZ1wiLFwiLnRlcm4tcHJvamVjdFwiLFwiLndhdGNobWFuY29uZmlnXCIsXCJQaXBmaWxlLmxvY2tcIixcImNvbXBvc2VyLmxvY2tcIixcIm1jbW9kLmluZm9cIl0sbGFuZ3VhZ2VJZDoxNzR9fX0pLHhkPXRlKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9KU09OIHdpdGggQ29tbWVudHMuanNvblwiKGUscil7ci5leHBvcnRzPXtuYW1lOlwiSlNPTiB3aXRoIENvbW1lbnRzXCIsdHlwZTpcImRhdGFcIixjb2xvcjpcIiMyOTI5MjlcIixncm91cDpcIkpTT05cIix0bVNjb3BlOlwic291cmNlLmpzXCIsYWNlTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTW9kZTpcImphdmFzY3JpcHRcIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L2phdmFzY3JpcHRcIixhbGlhc2VzOltcImpzb25jXCJdLGV4dGVuc2lvbnM6W1wiLmpzb25jXCIsXCIuY29kZS1zbmlwcGV0c1wiLFwiLnN1YmxpbWUtYnVpbGRcIixcIi5zdWJsaW1lLWNvbW1hbmRzXCIsXCIuc3VibGltZS1jb21wbGV0aW9uc1wiLFwiLnN1YmxpbWUta2V5bWFwXCIsXCIuc3VibGltZS1tYWNyb1wiLFwiLnN1YmxpbWUtbWVudVwiLFwiLnN1YmxpbWUtbW91c2VtYXBcIixcIi5zdWJsaW1lLXByb2plY3RcIixcIi5zdWJsaW1lLXNldHRpbmdzXCIsXCIuc3VibGltZS10aGVtZVwiLFwiLnN1YmxpbWUtd29ya3NwYWNlXCIsXCIuc3VibGltZV9tZXRyaWNzXCIsXCIuc3VibGltZV9zZXNzaW9uXCJdLGZpbGVuYW1lczpbXCIuYmFiZWxyY1wiLFwiLmRldmNvbnRhaW5lci5qc29uXCIsXCIuZXNsaW50cmMuanNvblwiLFwiLmpzY3NyY1wiLFwiLmpzaGludHJjXCIsXCIuanNsaW50cmNcIixcImFwaS1leHRyYWN0b3IuanNvblwiLFwiZGV2Y29udGFpbmVyLmpzb25cIixcImpzY29uZmlnLmpzb25cIixcImxhbmd1YWdlLWNvbmZpZ3VyYXRpb24uanNvblwiLFwidHNjb25maWcuanNvblwiLFwidHNsaW50Lmpzb25cIl0sbGFuZ3VhZ2VJZDo0MjN9fX0pLGJkPXRlKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9KU09ONS5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e25hbWU6XCJKU09ONVwiLHR5cGU6XCJkYXRhXCIsY29sb3I6XCIjMjY3Q0I5XCIsZXh0ZW5zaW9uczpbXCIuanNvbjVcIl0sdG1TY29wZTpcInNvdXJjZS5qc1wiLGFjZU1vZGU6XCJqYXZhc2NyaXB0XCIsY29kZW1pcnJvck1vZGU6XCJqYXZhc2NyaXB0XCIsY29kZW1pcnJvck1pbWVUeXBlOlwiYXBwbGljYXRpb24vanNvblwiLGxhbmd1YWdlSWQ6MTc1fX19KSxUZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtanMvaW5kZXguanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9X3QoKSxzPXZkKCksYT1DZCgpLG49RWQoKSx1PUZkKCksaT1bdChMbigpLHA9Pih7c2luY2U6XCIwLjAuMFwiLHBhcnNlcnM6W1wiYmFiZWxcIixcImFjb3JuXCIsXCJlc3ByZWVcIixcIm1lcml5YWhcIixcImJhYmVsLWZsb3dcIixcImJhYmVsLXRzXCIsXCJmbG93XCIsXCJ0eXBlc2NyaXB0XCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImphdmFzY3JpcHRcIixcIm1vbmdvXCJdLGludGVycHJldGVyczpbLi4ucC5pbnRlcnByZXRlcnMsXCJ6eFwiXSxleHRlbnNpb25zOlsuLi5wLmV4dGVuc2lvbnMuZmlsdGVyKGQ9PmQhPT1cIi5qc3hcIiksXCIud3hzXCJdfSkpLHQoTG4oKSwoKT0+KHtuYW1lOlwiRmxvd1wiLHNpbmNlOlwiMC4wLjBcIixwYXJzZXJzOltcImZsb3dcIixcImJhYmVsLWZsb3dcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wiamF2YXNjcmlwdFwiXSxhbGlhc2VzOltdLGZpbGVuYW1lczpbXSxleHRlbnNpb25zOltcIi5qcy5mbG93XCJdfSkpLHQoTG4oKSwoKT0+KHtuYW1lOlwiSlNYXCIsc2luY2U6XCIwLjAuMFwiLHBhcnNlcnM6W1wiYmFiZWxcIixcImJhYmVsLWZsb3dcIixcImJhYmVsLXRzXCIsXCJmbG93XCIsXCJ0eXBlc2NyaXB0XCIsXCJlc3ByZWVcIixcIm1lcml5YWhcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wiamF2YXNjcmlwdHJlYWN0XCJdLGFsaWFzZXM6dm9pZCAwLGZpbGVuYW1lczp2b2lkIDAsZXh0ZW5zaW9uczpbXCIuanN4XCJdLGdyb3VwOlwiSmF2YVNjcmlwdFwiLGludGVycHJldGVyczp2b2lkIDAsdG1TY29wZTpcInNvdXJjZS5qcy5qc3hcIixhY2VNb2RlOlwiamF2YXNjcmlwdFwiLGNvZGVtaXJyb3JNb2RlOlwianN4XCIsY29kZW1pcnJvck1pbWVUeXBlOlwidGV4dC9qc3hcIixjb2xvcjp2b2lkIDB9KSksdChBZCgpLCgpPT4oe3NpbmNlOlwiMS40LjBcIixwYXJzZXJzOltcInR5cGVzY3JpcHRcIixcImJhYmVsLXRzXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcInR5cGVzY3JpcHRcIl19KSksdChTZCgpLCgpPT4oe3NpbmNlOlwiMS40LjBcIixwYXJzZXJzOltcInR5cGVzY3JpcHRcIixcImJhYmVsLXRzXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcInR5cGVzY3JpcHRyZWFjdFwiXX0pKSx0KHdhKCksKCk9Pih7bmFtZTpcIkpTT04uc3RyaW5naWZ5XCIsc2luY2U6XCIxLjEzLjBcIixwYXJzZXJzOltcImpzb24tc3RyaW5naWZ5XCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImpzb25cIl0sZXh0ZW5zaW9uczpbXCIuaW1wb3J0bWFwXCJdLGZpbGVuYW1lczpbXCJwYWNrYWdlLmpzb25cIixcInBhY2thZ2UtbG9jay5qc29uXCIsXCJjb21wb3Nlci5qc29uXCJdfSkpLHQod2EoKSxwPT4oe3NpbmNlOlwiMS41LjBcIixwYXJzZXJzOltcImpzb25cIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wianNvblwiXSxleHRlbnNpb25zOnAuZXh0ZW5zaW9ucy5maWx0ZXIoZD0+ZCE9PVwiLmpzb25sXCIpfSkpLHQoeGQoKSxwPT4oe3NpbmNlOlwiMS41LjBcIixwYXJzZXJzOltcImpzb25cIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wianNvbmNcIl0sZmlsZW5hbWVzOlsuLi5wLmZpbGVuYW1lcyxcIi5lc2xpbnRyY1wiLFwiLnN3Y3JjXCJdfSkpLHQoYmQoKSwoKT0+KHtzaW5jZTpcIjEuMTMuMFwiLHBhcnNlcnM6W1wianNvbjVcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wianNvbjVcIl19KSldLGw9e2VzdHJlZTpzLFwiZXN0cmVlLWpzb25cIjphfTtyLmV4cG9ydHM9e2xhbmd1YWdlczppLG9wdGlvbnM6bixwcmludGVyczpsLHBhcnNlcnM6dX19fSksQmQ9dGUoe1wic3JjL2xhbmd1YWdlLWNzcy9jbGVhbi5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7aXNGcm9udE1hdHRlck5vZGU6dH09VWUoKSxzPWx0KCksYT1uZXcgU2V0KFtcInJhd1wiLFwicmF3c1wiLFwic291cmNlSW5kZXhcIixcInNvdXJjZVwiLFwiYmVmb3JlXCIsXCJhZnRlclwiLFwidHJhaWxpbmdDb21tYVwiXSk7ZnVuY3Rpb24gbihpLGwscCl7aWYodChpKSYmaS5sYW5nPT09XCJ5YW1sXCImJmRlbGV0ZSBsLnZhbHVlLGkudHlwZT09PVwiY3NzLWNvbW1lbnRcIiYmcC50eXBlPT09XCJjc3Mtcm9vdFwiJiZwLm5vZGVzLmxlbmd0aD4wJiYoKHAubm9kZXNbMF09PT1pfHx0KHAubm9kZXNbMF0pJiZwLm5vZGVzWzFdPT09aSkmJihkZWxldGUgbC50ZXh0LC9eXFwqXFxzKkAoPzpmb3JtYXR8cHJldHRpZXIpXFxzKiQvLnRlc3QoaS50ZXh0KSl8fHAudHlwZT09PVwiY3NzLXJvb3RcIiYmcyhwLm5vZGVzKT09PWkpKXJldHVybiBudWxsO2lmKGkudHlwZT09PVwidmFsdWUtcm9vdFwiJiZkZWxldGUgbC50ZXh0LChpLnR5cGU9PT1cIm1lZGlhLXF1ZXJ5XCJ8fGkudHlwZT09PVwibWVkaWEtcXVlcnktbGlzdFwifHxpLnR5cGU9PT1cIm1lZGlhLWZlYXR1cmUtZXhwcmVzc2lvblwiKSYmZGVsZXRlIGwudmFsdWUsaS50eXBlPT09XCJjc3MtcnVsZVwiJiZkZWxldGUgbC5wYXJhbXMsaS50eXBlPT09XCJzZWxlY3Rvci1jb21iaW5hdG9yXCImJihsLnZhbHVlPWwudmFsdWUucmVwbGFjZSgvXFxzKy9nLFwiIFwiKSksaS50eXBlPT09XCJtZWRpYS1mZWF0dXJlXCImJihsLnZhbHVlPWwudmFsdWUucmVwbGFjZSgvIC9nLFwiXCIpKSwoaS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJihpLmlzQ29sb3ImJmkuaXNIZXh8fFtcImluaXRpYWxcIixcImluaGVyaXRcIixcInVuc2V0XCIsXCJyZXZlcnRcIl0uaW5jbHVkZXMobC52YWx1ZS5yZXBsYWNlKCkudG9Mb3dlckNhc2UoKSkpfHxpLnR5cGU9PT1cIm1lZGlhLWZlYXR1cmVcInx8aS50eXBlPT09XCJzZWxlY3Rvci1yb290LWludmFsaWRcInx8aS50eXBlPT09XCJzZWxlY3Rvci1wc2V1ZG9cIikmJihsLnZhbHVlPWwudmFsdWUudG9Mb3dlckNhc2UoKSksaS50eXBlPT09XCJjc3MtZGVjbFwiJiYobC5wcm9wPWwucHJvcC50b0xvd2VyQ2FzZSgpKSwoaS50eXBlPT09XCJjc3MtYXRydWxlXCJ8fGkudHlwZT09PVwiY3NzLWltcG9ydFwiKSYmKGwubmFtZT1sLm5hbWUudG9Mb3dlckNhc2UoKSksaS50eXBlPT09XCJ2YWx1ZS1udW1iZXJcIiYmKGwudW5pdD1sLnVuaXQudG9Mb3dlckNhc2UoKSksKGkudHlwZT09PVwibWVkaWEtZmVhdHVyZVwifHxpLnR5cGU9PT1cIm1lZGlhLWtleXdvcmRcInx8aS50eXBlPT09XCJtZWRpYS10eXBlXCJ8fGkudHlwZT09PVwibWVkaWEtdW5rbm93blwifHxpLnR5cGU9PT1cIm1lZGlhLXVybFwifHxpLnR5cGU9PT1cIm1lZGlhLXZhbHVlXCJ8fGkudHlwZT09PVwic2VsZWN0b3ItYXR0cmlidXRlXCJ8fGkudHlwZT09PVwic2VsZWN0b3Itc3RyaW5nXCJ8fGkudHlwZT09PVwic2VsZWN0b3ItY2xhc3NcInx8aS50eXBlPT09XCJzZWxlY3Rvci1jb21iaW5hdG9yXCJ8fGkudHlwZT09PVwidmFsdWUtc3RyaW5nXCIpJiZsLnZhbHVlJiYobC52YWx1ZT11KGwudmFsdWUpKSxpLnR5cGU9PT1cInNlbGVjdG9yLWF0dHJpYnV0ZVwiJiYobC5hdHRyaWJ1dGU9bC5hdHRyaWJ1dGUudHJpbSgpLGwubmFtZXNwYWNlJiZ0eXBlb2YgbC5uYW1lc3BhY2U9PVwic3RyaW5nXCImJihsLm5hbWVzcGFjZT1sLm5hbWVzcGFjZS50cmltKCksbC5uYW1lc3BhY2UubGVuZ3RoPT09MCYmKGwubmFtZXNwYWNlPSEwKSksbC52YWx1ZSYmKGwudmFsdWU9bC52YWx1ZS50cmltKCkucmVwbGFjZSgvXltcIiddfFtcIiddJC9nLFwiXCIpLGRlbGV0ZSBsLnF1b3RlZCkpLChpLnR5cGU9PT1cIm1lZGlhLXZhbHVlXCJ8fGkudHlwZT09PVwibWVkaWEtdHlwZVwifHxpLnR5cGU9PT1cInZhbHVlLW51bWJlclwifHxpLnR5cGU9PT1cInNlbGVjdG9yLXJvb3QtaW52YWxpZFwifHxpLnR5cGU9PT1cInNlbGVjdG9yLWNsYXNzXCJ8fGkudHlwZT09PVwic2VsZWN0b3ItY29tYmluYXRvclwifHxpLnR5cGU9PT1cInNlbGVjdG9yLXRhZ1wiKSYmbC52YWx1ZSYmKGwudmFsdWU9bC52YWx1ZS5yZXBsYWNlKC8oW1xcZCsuRWUtXSspKFtBLVphLXpdKikvZywoZCx5LGcpPT57bGV0IGM9TnVtYmVyKHkpO3JldHVybiBOdW1iZXIuaXNOYU4oYyk/ZDpjK2cudG9Mb3dlckNhc2UoKX0pKSxpLnR5cGU9PT1cInNlbGVjdG9yLXRhZ1wiKXtsZXQgZD1pLnZhbHVlLnRvTG93ZXJDYXNlKCk7W1wiZnJvbVwiLFwidG9cIl0uaW5jbHVkZXMoZCkmJihsLnZhbHVlPWQpfWlmKGkudHlwZT09PVwiY3NzLWF0cnVsZVwiJiZpLm5hbWUudG9Mb3dlckNhc2UoKT09PVwic3VwcG9ydHNcIiYmZGVsZXRlIGwudmFsdWUsaS50eXBlPT09XCJzZWxlY3Rvci11bmtub3duXCImJmRlbGV0ZSBsLnZhbHVlLGkudHlwZT09PVwidmFsdWUtY29tbWFfZ3JvdXBcIil7bGV0IGQ9aS5ncm91cHMuZmluZEluZGV4KHk9PnkudHlwZT09PVwidmFsdWUtbnVtYmVyXCImJnkudW5pdD09PVwiLi4uXCIpO2QhPT0tMSYmKGwuZ3JvdXBzW2RdLnVuaXQ9XCJcIixsLmdyb3Vwcy5zcGxpY2UoZCsxLDAse3R5cGU6XCJ2YWx1ZS13b3JkXCIsdmFsdWU6XCIuLi5cIixpc0NvbG9yOiExLGlzSGV4OiExfSkpfWlmKGkudHlwZT09PVwidmFsdWUtY29tbWFfZ3JvdXBcIiYmaS5ncm91cHMuc29tZShkPT5kLnR5cGU9PT1cInZhbHVlLWF0d29yZFwiJiZkLnZhbHVlLmVuZHNXaXRoKFwiW1wiKXx8ZC50eXBlPT09XCJ2YWx1ZS13b3JkXCImJmQudmFsdWUuc3RhcnRzV2l0aChcIl1cIikpKXJldHVybnt0eXBlOlwidmFsdWUtYXR3b3JkXCIsdmFsdWU6aS5ncm91cHMubWFwKGQ9PmQudmFsdWUpLmpvaW4oXCJcIiksZ3JvdXA6e29wZW46bnVsbCxjbG9zZTpudWxsLGdyb3VwczpbXSx0eXBlOlwidmFsdWUtcGFyZW5fZ3JvdXBcIn19fW4uaWdub3JlZFByb3BlcnRpZXM9YTtmdW5jdGlvbiB1KGkpe3JldHVybiBpLnJlcGxhY2UoLycvZywnXCInKS5yZXBsYWNlKC9cXFxcKFteXFxkQS1GYS1mXSkvZyxcIiQxXCIpfXIuZXhwb3J0cz1ufX0pLHN1PXRlKHtcInNyYy91dGlscy9mcm9udC1tYXR0ZXIvcHJpbnQuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOntoYXJkbGluZTp0LG1hcmtBc1Jvb3Q6c319PXFlKCk7ZnVuY3Rpb24gYShuLHUpe2lmKG4ubGFuZz09PVwieWFtbFwiKXtsZXQgaT1uLnZhbHVlLnRyaW0oKSxsPWk/dShpLHtwYXJzZXI6XCJ5YW1sXCJ9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KTpcIlwiO3JldHVybiBzKFtuLnN0YXJ0RGVsaW1pdGVyLHQsbCxsP3Q6XCJcIixuLmVuZERlbGltaXRlcl0pfX1yLmV4cG9ydHM9YX19KSxOZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtY3NzL2VtYmVkLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7aGFyZGxpbmU6dH19PXFlKCkscz1zdSgpO2Z1bmN0aW9uIGEobix1LGkpe2xldCBsPW4uZ2V0VmFsdWUoKTtpZihsLnR5cGU9PT1cImZyb250LW1hdHRlclwiKXtsZXQgcD1zKGwsaSk7cmV0dXJuIHA/W3AsdF06XCJcIn19ci5leHBvcnRzPWF9fSksX289dGUoe1wic3JjL3V0aWxzL2Zyb250LW1hdHRlci9wYXJzZS5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1uZXcgUmVnRXhwKFwiXig/PHN0YXJ0RGVsaW1pdGVyPi17M318XFxcXCt7M30pKD88bGFuZ3VhZ2U+W15cXFxcbl0qKVxcXFxuKD86fCg/PHZhbHVlPi4qPylcXFxcbikoPzxlbmREZWxpbWl0ZXI+XFxcXGs8c3RhcnREZWxpbWl0ZXI+fFxcXFwuezN9KVteXFxcXFNcXFxcbl0qKD86XFxcXG58JClcIixcInNcIik7ZnVuY3Rpb24gcyhhKXtsZXQgbj1hLm1hdGNoKHQpO2lmKCFuKXJldHVybntjb250ZW50OmF9O2xldHtzdGFydERlbGltaXRlcjp1LGxhbmd1YWdlOmksdmFsdWU6bD1cIlwiLGVuZERlbGltaXRlcjpwfT1uLmdyb3VwcyxkPWkudHJpbSgpfHxcInlhbWxcIjtpZih1PT09XCIrKytcIiYmKGQ9XCJ0b21sXCIpLGQhPT1cInlhbWxcIiYmdSE9PXApcmV0dXJue2NvbnRlbnQ6YX07bGV0W3ldPW47cmV0dXJue2Zyb250TWF0dGVyOnt0eXBlOlwiZnJvbnQtbWF0dGVyXCIsbGFuZzpkLHZhbHVlOmwsc3RhcnREZWxpbWl0ZXI6dSxlbmREZWxpbWl0ZXI6cCxyYXc6eS5yZXBsYWNlKC9cXG4kLyxcIlwiKX0sY29udGVudDp5LnJlcGxhY2UoL1teXFxuXS9nLFwiIFwiKSthLnNsaWNlKHkubGVuZ3RoKX19ci5leHBvcnRzPXN9fSksd2Q9dGUoe1wic3JjL2xhbmd1YWdlLWNzcy9wcmFnbWEuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9Q28oKSxzPV9vKCk7ZnVuY3Rpb24gYSh1KXtyZXR1cm4gdC5oYXNQcmFnbWEocyh1KS5jb250ZW50KX1mdW5jdGlvbiBuKHUpe2xldHtmcm9udE1hdHRlcjppLGNvbnRlbnQ6bH09cyh1KTtyZXR1cm4oaT9pLnJhdytgXG5cbmA6XCJcIikrdC5pbnNlcnRQcmFnbWEobCl9ci5leHBvcnRzPXtoYXNQcmFnbWE6YSxpbnNlcnRQcmFnbWE6bn19fSksX2Q9dGUoe1wic3JjL2xhbmd1YWdlLWNzcy91dGlscy9pbmRleC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1uZXcgU2V0KFtcInJlZFwiLFwiZ3JlZW5cIixcImJsdWVcIixcImFscGhhXCIsXCJhXCIsXCJyZ2JcIixcImh1ZVwiLFwiaFwiLFwic2F0dXJhdGlvblwiLFwic1wiLFwibGlnaHRuZXNzXCIsXCJsXCIsXCJ3aGl0ZW5lc3NcIixcIndcIixcImJsYWNrbmVzc1wiLFwiYlwiLFwidGludFwiLFwic2hhZGVcIixcImJsZW5kXCIsXCJibGVuZGFcIixcImNvbnRyYXN0XCIsXCJoc2xcIixcImhzbGFcIixcImh3YlwiLFwiaHdiYVwiXSk7ZnVuY3Rpb24gcyh6LFUpe2xldCBaPUFycmF5LmlzQXJyYXkoVSk/VTpbVV0sc2U9LTEsRGU7Zm9yKDtEZT16LmdldFBhcmVudE5vZGUoKytzZSk7KWlmKFouaW5jbHVkZXMoRGUudHlwZSkpcmV0dXJuIHNlO3JldHVybi0xfWZ1bmN0aW9uIGEoeixVKXtsZXQgWj1zKHosVSk7cmV0dXJuIFo9PT0tMT9udWxsOnouZ2V0UGFyZW50Tm9kZShaKX1mdW5jdGlvbiBuKHope3ZhciBVO2xldCBaPWEoeixcImNzcy1kZWNsXCIpO3JldHVybiBaPT1udWxsfHwoVT1aLnByb3ApPT09bnVsbHx8VT09PXZvaWQgMD92b2lkIDA6VS50b0xvd2VyQ2FzZSgpfXZhciB1PW5ldyBTZXQoW1wiaW5pdGlhbFwiLFwiaW5oZXJpdFwiLFwidW5zZXRcIixcInJldmVydFwiXSk7ZnVuY3Rpb24gaSh6KXtyZXR1cm4gdS5oYXMoei50b0xvd2VyQ2FzZSgpKX1mdW5jdGlvbiBsKHosVSl7bGV0IFo9YSh6LFwiY3NzLWF0cnVsZVwiKTtyZXR1cm4oWj09bnVsbD92b2lkIDA6Wi5uYW1lKSYmWi5uYW1lLnRvTG93ZXJDYXNlKCkuZW5kc1dpdGgoXCJrZXlmcmFtZXNcIikmJltcImZyb21cIixcInRvXCJdLmluY2x1ZGVzKFUudG9Mb3dlckNhc2UoKSl9ZnVuY3Rpb24gcCh6KXtyZXR1cm4gei5pbmNsdWRlcyhcIiRcIil8fHouaW5jbHVkZXMoXCJAXCIpfHx6LmluY2x1ZGVzKFwiI1wiKXx8ei5zdGFydHNXaXRoKFwiJVwiKXx8ei5zdGFydHNXaXRoKFwiLS1cIil8fHouc3RhcnRzV2l0aChcIjotLVwiKXx8ei5pbmNsdWRlcyhcIihcIikmJnouaW5jbHVkZXMoXCIpXCIpP3o6ei50b0xvd2VyQ2FzZSgpfWZ1bmN0aW9uIGQoeixVKXt2YXIgWjtsZXQgc2U9YSh6LFwidmFsdWUtZnVuY1wiKTtyZXR1cm4oc2U9PW51bGx8fChaPXNlLnZhbHVlKT09PW51bGx8fFo9PT12b2lkIDA/dm9pZCAwOloudG9Mb3dlckNhc2UoKSk9PT1VfWZ1bmN0aW9uIHkoeil7dmFyIFU7bGV0IFo9YSh6LFwiY3NzLXJ1bGVcIiksc2U9Wj09bnVsbHx8KFU9Wi5yYXdzKT09PW51bGx8fFU9PT12b2lkIDA/dm9pZCAwOlUuc2VsZWN0b3I7cmV0dXJuIHNlJiYoc2Uuc3RhcnRzV2l0aChcIjppbXBvcnRcIil8fHNlLnN0YXJ0c1dpdGgoXCI6ZXhwb3J0XCIpKX1mdW5jdGlvbiBnKHosVSl7bGV0IFo9QXJyYXkuaXNBcnJheShVKT9VOltVXSxzZT1hKHosXCJjc3MtYXRydWxlXCIpO3JldHVybiBzZSYmWi5pbmNsdWRlcyhzZS5uYW1lLnRvTG93ZXJDYXNlKCkpfWZ1bmN0aW9uIGMoeil7bGV0IFU9ei5nZXRWYWx1ZSgpLFo9YSh6LFwiY3NzLWF0cnVsZVwiKTtyZXR1cm4oWj09bnVsbD92b2lkIDA6Wi5uYW1lKT09PVwiaW1wb3J0XCImJlUuZ3JvdXBzWzBdLnZhbHVlPT09XCJ1cmxcIiYmVS5ncm91cHMubGVuZ3RoPT09Mn1mdW5jdGlvbiBEKHope3JldHVybiB6LnR5cGU9PT1cInZhbHVlLWZ1bmNcIiYmei52YWx1ZS50b0xvd2VyQ2FzZSgpPT09XCJ1cmxcIn1mdW5jdGlvbiBFKHosVSl7dmFyIFo7bGV0IHNlPShaPXouZ2V0UGFyZW50Tm9kZSgpKT09PW51bGx8fFo9PT12b2lkIDA/dm9pZCAwOloubm9kZXM7cmV0dXJuIHNlJiZzZS5pbmRleE9mKFUpPT09c2UubGVuZ3RoLTF9ZnVuY3Rpb24gXyh6KXtsZXR7c2VsZWN0b3I6VX09ejtyZXR1cm4gVT90eXBlb2YgVT09XCJzdHJpbmdcIiYmL15ALis6LiokLy50ZXN0KFUpfHxVLnZhbHVlJiYvXkAuKzouKiQvLnRlc3QoVS52YWx1ZSk6ITF9ZnVuY3Rpb24gdyh6KXtyZXR1cm4gei50eXBlPT09XCJ2YWx1ZS13b3JkXCImJltcImZyb21cIixcInRocm91Z2hcIixcImVuZFwiXS5pbmNsdWRlcyh6LnZhbHVlKX1mdW5jdGlvbiBGKHope3JldHVybiB6LnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmW1wiYW5kXCIsXCJvclwiLFwibm90XCJdLmluY2x1ZGVzKHoudmFsdWUpfWZ1bmN0aW9uIFMoeil7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtd29yZFwiJiZ6LnZhbHVlPT09XCJpblwifWZ1bmN0aW9uIE4oeil7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtb3BlcmF0b3JcIiYmei52YWx1ZT09PVwiKlwifWZ1bmN0aW9uIEkoeil7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtb3BlcmF0b3JcIiYmei52YWx1ZT09PVwiL1wifWZ1bmN0aW9uIFAoeil7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtb3BlcmF0b3JcIiYmei52YWx1ZT09PVwiK1wifWZ1bmN0aW9uICQoeil7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtb3BlcmF0b3JcIiYmei52YWx1ZT09PVwiLVwifWZ1bmN0aW9uIGYoeil7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtb3BlcmF0b3JcIiYmei52YWx1ZT09PVwiJVwifWZ1bmN0aW9uIFQoeil7cmV0dXJuIE4oeil8fEkoeil8fFAoeil8fCQoeil8fGYoeil9ZnVuY3Rpb24gbSh6KXtyZXR1cm4gei50eXBlPT09XCJ2YWx1ZS13b3JkXCImJltcIj09XCIsXCIhPVwiXS5pbmNsdWRlcyh6LnZhbHVlKX1mdW5jdGlvbiB2KHope3JldHVybiB6LnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmW1wiPFwiLFwiPlwiLFwiPD1cIixcIj49XCJdLmluY2x1ZGVzKHoudmFsdWUpfWZ1bmN0aW9uIG8oeil7cmV0dXJuIHoudHlwZT09PVwiY3NzLWF0cnVsZVwiJiZbXCJpZlwiLFwiZWxzZVwiLFwiZm9yXCIsXCJlYWNoXCIsXCJ3aGlsZVwiXS5pbmNsdWRlcyh6Lm5hbWUpfWZ1bmN0aW9uIGgoeil7dmFyIFU7cmV0dXJuKChVPXoucmF3cyk9PT1udWxsfHxVPT09dm9pZCAwP3ZvaWQgMDpVLnBhcmFtcykmJi9eXFwoXFxzKlxcKSQvLnRlc3Qoei5yYXdzLnBhcmFtcyl9ZnVuY3Rpb24gQyh6KXtyZXR1cm4gei5uYW1lLnN0YXJ0c1dpdGgoXCJwcmV0dGllci1wbGFjZWhvbGRlclwiKX1mdW5jdGlvbiB4KHope3JldHVybiB6LnByb3Auc3RhcnRzV2l0aChcIkBwcmV0dGllci1wbGFjZWhvbGRlclwiKX1mdW5jdGlvbiBiKHosVSl7cmV0dXJuIHoudmFsdWU9PT1cIiQkXCImJnoudHlwZT09PVwidmFsdWUtZnVuY1wiJiYoVT09bnVsbD92b2lkIDA6VS50eXBlKT09PVwidmFsdWUtd29yZFwiJiYhVS5yYXdzLmJlZm9yZX1mdW5jdGlvbiBCKHope3ZhciBVLFo7cmV0dXJuKChVPXoudmFsdWUpPT09bnVsbHx8VT09PXZvaWQgMD92b2lkIDA6VS50eXBlKT09PVwidmFsdWUtcm9vdFwiJiYoKFo9ei52YWx1ZS5ncm91cCk9PT1udWxsfHxaPT09dm9pZCAwP3ZvaWQgMDpaLnR5cGUpPT09XCJ2YWx1ZS12YWx1ZVwiJiZ6LnByb3AudG9Mb3dlckNhc2UoKT09PVwiY29tcG9zZXNcIn1mdW5jdGlvbiBrKHope3ZhciBVLFosc2U7cmV0dXJuKChVPXoudmFsdWUpPT09bnVsbHx8VT09PXZvaWQgMHx8KFo9VS5ncm91cCk9PT1udWxsfHxaPT09dm9pZCAwfHwoc2U9Wi5ncm91cCk9PT1udWxsfHxzZT09PXZvaWQgMD92b2lkIDA6c2UudHlwZSk9PT1cInZhbHVlLXBhcmVuX2dyb3VwXCImJnoudmFsdWUuZ3JvdXAuZ3JvdXAub3BlbiE9PW51bGwmJnoudmFsdWUuZ3JvdXAuZ3JvdXAuY2xvc2UhPT1udWxsfWZ1bmN0aW9uIE0oeil7dmFyIFU7cmV0dXJuKChVPXoucmF3cyk9PT1udWxsfHxVPT09dm9pZCAwP3ZvaWQgMDpVLmJlZm9yZSk9PT1cIlwifWZ1bmN0aW9uIFIoeil7dmFyIFUsWjtyZXR1cm4gei50eXBlPT09XCJ2YWx1ZS1jb21tYV9ncm91cFwiJiYoKFU9ei5ncm91cHMpPT09bnVsbHx8VT09PXZvaWQgMHx8KFo9VVsxXSk9PT1udWxsfHxaPT09dm9pZCAwP3ZvaWQgMDpaLnR5cGUpPT09XCJ2YWx1ZS1jb2xvblwifWZ1bmN0aW9uIHEoeil7dmFyIFU7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtcGFyZW5fZ3JvdXBcIiYmKChVPXouZ3JvdXBzKT09PW51bGx8fFU9PT12b2lkIDA/dm9pZCAwOlVbMF0pJiZSKHouZ3JvdXBzWzBdKX1mdW5jdGlvbiBKKHope3ZhciBVO2xldCBaPXouZ2V0VmFsdWUoKTtpZihaLmdyb3Vwcy5sZW5ndGg9PT0wKXJldHVybiExO2xldCBzZT16LmdldFBhcmVudE5vZGUoMSk7aWYoIXEoWikmJiEoc2UmJnEoc2UpKSlyZXR1cm4hMTtsZXQgRGU9YSh6LFwiY3NzLWRlY2xcIik7cmV0dXJuISEoRGUhPW51bGwmJihVPURlLnByb3ApIT09bnVsbCYmVSE9PXZvaWQgMCYmVS5zdGFydHNXaXRoKFwiJFwiKXx8cShzZSl8fHNlLnR5cGU9PT1cInZhbHVlLWZ1bmNcIil9ZnVuY3Rpb24gTCh6KXtyZXR1cm4gei50eXBlPT09XCJ2YWx1ZS1jb21tZW50XCImJnouaW5saW5lfWZ1bmN0aW9uIFEoeil7cmV0dXJuIHoudHlwZT09PVwidmFsdWUtd29yZFwiJiZ6LnZhbHVlPT09XCIjXCJ9ZnVuY3Rpb24gVih6KXtyZXR1cm4gei50eXBlPT09XCJ2YWx1ZS13b3JkXCImJnoudmFsdWU9PT1cIntcIn1mdW5jdGlvbiBqKHope3JldHVybiB6LnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmei52YWx1ZT09PVwifVwifWZ1bmN0aW9uIFkoeil7cmV0dXJuW1widmFsdWUtd29yZFwiLFwidmFsdWUtYXR3b3JkXCJdLmluY2x1ZGVzKHoudHlwZSl9ZnVuY3Rpb24gaWUoeil7cmV0dXJuKHo9PW51bGw/dm9pZCAwOnoudHlwZSk9PT1cInZhbHVlLWNvbG9uXCJ9ZnVuY3Rpb24gZWUoeixVKXtpZighUihVKSlyZXR1cm4hMTtsZXR7Z3JvdXBzOlp9PVUsc2U9Wi5pbmRleE9mKHopO3JldHVybiBzZT09PS0xPyExOmllKFpbc2UrMV0pfWZ1bmN0aW9uIGxlKHope3JldHVybiB6LnZhbHVlJiZbXCJub3RcIixcImFuZFwiLFwib3JcIl0uaW5jbHVkZXMoei52YWx1ZS50b0xvd2VyQ2FzZSgpKX1mdW5jdGlvbiBXKHope3JldHVybiB6LnR5cGUhPT1cInZhbHVlLWZ1bmNcIj8hMTp0Lmhhcyh6LnZhbHVlLnRvTG93ZXJDYXNlKCkpfWZ1bmN0aW9uIEsoeil7cmV0dXJuL1xcL1xcLy8udGVzdCh6LnNwbGl0KC9bXFxuXFxyXS8pLnBvcCgpKX1mdW5jdGlvbiBkZSh6KXtyZXR1cm4oej09bnVsbD92b2lkIDA6ei50eXBlKT09PVwidmFsdWUtYXR3b3JkXCImJnoudmFsdWUuc3RhcnRzV2l0aChcInByZXR0aWVyLXBsYWNlaG9sZGVyLVwiKX1mdW5jdGlvbiB1ZSh6LFUpe3ZhciBaLHNlO2lmKCgoWj16Lm9wZW4pPT09bnVsbHx8Wj09PXZvaWQgMD92b2lkIDA6Wi52YWx1ZSkhPT1cIihcInx8KChzZT16LmNsb3NlKT09PW51bGx8fHNlPT09dm9pZCAwP3ZvaWQgMDpzZS52YWx1ZSkhPT1cIilcInx8ei5ncm91cHMuc29tZShEZT0+RGUudHlwZSE9PVwidmFsdWUtY29tbWFfZ3JvdXBcIikpcmV0dXJuITE7aWYoVS50eXBlPT09XCJ2YWx1ZS1jb21tYV9ncm91cFwiKXtsZXQgRGU9VS5ncm91cHMuaW5kZXhPZih6KS0xLGdlPVUuZ3JvdXBzW0RlXTtpZigoZ2U9PW51bGw/dm9pZCAwOmdlLnR5cGUpPT09XCJ2YWx1ZS13b3JkXCImJmdlLnZhbHVlPT09XCJ3aXRoXCIpcmV0dXJuITB9cmV0dXJuITF9ZnVuY3Rpb24gRmUoeil7dmFyIFUsWjtyZXR1cm4gei50eXBlPT09XCJ2YWx1ZS1wYXJlbl9ncm91cFwiJiYoKFU9ei5vcGVuKT09PW51bGx8fFU9PT12b2lkIDA/dm9pZCAwOlUudmFsdWUpPT09XCIoXCImJigoWj16LmNsb3NlKT09PW51bGx8fFo9PT12b2lkIDA/dm9pZCAwOloudmFsdWUpPT09XCIpXCJ9ci5leHBvcnRzPXtnZXRBbmNlc3RvckNvdW50ZXI6cyxnZXRBbmNlc3Rvck5vZGU6YSxnZXRQcm9wT2ZEZWNsTm9kZTpuLG1heWJlVG9Mb3dlckNhc2U6cCxpbnNpZGVWYWx1ZUZ1bmN0aW9uTm9kZTpkLGluc2lkZUlDU1NSdWxlTm9kZTp5LGluc2lkZUF0UnVsZU5vZGU6ZyxpbnNpZGVVUkxGdW5jdGlvbkluSW1wb3J0QXRSdWxlTm9kZTpjLGlzS2V5ZnJhbWVBdFJ1bGVLZXl3b3JkczpsLGlzV2lkZUtleXdvcmRzOmksaXNMYXN0Tm9kZTpFLGlzU0NTU0NvbnRyb2xEaXJlY3RpdmVOb2RlOm8saXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGU6Xyxpc1JlbGF0aW9uYWxPcGVyYXRvck5vZGU6dixpc0VxdWFsaXR5T3BlcmF0b3JOb2RlOm0saXNNdWx0aXBsaWNhdGlvbk5vZGU6Tixpc0RpdmlzaW9uTm9kZTpJLGlzQWRkaXRpb25Ob2RlOlAsaXNTdWJ0cmFjdGlvbk5vZGU6JCxpc01vZHVsb05vZGU6Zixpc01hdGhPcGVyYXRvck5vZGU6VCxpc0VhY2hLZXl3b3JkTm9kZTpTLGlzRm9yS2V5d29yZE5vZGU6dyxpc1VSTEZ1bmN0aW9uTm9kZTpELGlzSWZFbHNlS2V5d29yZE5vZGU6RixoYXNDb21wb3Nlc05vZGU6QixoYXNQYXJlbnNBcm91bmROb2RlOmssaGFzRW1wdHlSYXdCZWZvcmU6TSxpc0RldGFjaGVkUnVsZXNldENhbGxOb2RlOmgsaXNUZW1wbGF0ZVBsYWNlaG9sZGVyTm9kZTpDLGlzVGVtcGxhdGVQcm9wTm9kZTp4LGlzUG9zdGNzc1NpbXBsZVZhck5vZGU6Yixpc0tleVZhbHVlUGFpck5vZGU6Uixpc0tleVZhbHVlUGFpckluUGFyZW5Hcm91cE5vZGU6cSxpc0tleUluVmFsdWVQYWlyTm9kZTplZSxpc1NDU1NNYXBJdGVtTm9kZTpKLGlzSW5saW5lVmFsdWVDb21tZW50Tm9kZTpMLGlzSGFzaE5vZGU6USxpc0xlZnRDdXJseUJyYWNlTm9kZTpWLGlzUmlnaHRDdXJseUJyYWNlTm9kZTpqLGlzV29yZE5vZGU6WSxpc0NvbG9uTm9kZTppZSxpc01lZGlhQW5kU3VwcG9ydHNLZXl3b3JkczpsZSxpc0NvbG9yQWRqdXN0ZXJGdW5jTm9kZTpXLGxhc3RMaW5lSGFzSW5saW5lQ29tbWVudDpLLGlzQXRXb3JkUGxhY2Vob2xkZXJOb2RlOmRlLGlzQ29uZmlndXJhdGlvbk5vZGU6dWUsaXNQYXJlbkdyb3VwTm9kZTpGZX19fSksUGQ9dGUoe1wic3JjL3V0aWxzL2xpbmUtY29sdW1uLXRvLWluZGV4LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpLHIuZXhwb3J0cz1mdW5jdGlvbih0LHMpe2xldCBhPTA7Zm9yKGxldCBuPTA7bjx0LmxpbmUtMTsrK24pYT1zLmluZGV4T2YoYFxuYCxhKSsxO3JldHVybiBhK3QuY29sdW1ufX19KSxJZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtY3NzL2xvYy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7c2tpcEV2ZXJ5dGhpbmdCdXROZXdMaW5lOnR9PVByKCkscz1sdCgpLGE9UGQoKTtmdW5jdGlvbiBuKGMsRCl7cmV0dXJuIHR5cGVvZiBjLnNvdXJjZUluZGV4PT1cIm51bWJlclwiP2Muc291cmNlSW5kZXg6Yy5zb3VyY2U/YShjLnNvdXJjZS5zdGFydCxEKS0xOm51bGx9ZnVuY3Rpb24gdShjLEQpe2lmKGMudHlwZT09PVwiY3NzLWNvbW1lbnRcIiYmYy5pbmxpbmUpcmV0dXJuIHQoRCxjLnNvdXJjZS5zdGFydE9mZnNldCk7bGV0IEU9Yy5ub2RlcyYmcyhjLm5vZGVzKTtyZXR1cm4gRSYmYy5zb3VyY2UmJiFjLnNvdXJjZS5lbmQmJihjPUUpLGMuc291cmNlJiZjLnNvdXJjZS5lbmQ/YShjLnNvdXJjZS5lbmQsRCk6bnVsbH1mdW5jdGlvbiBpKGMsRCl7Yy5zb3VyY2UmJihjLnNvdXJjZS5zdGFydE9mZnNldD1uKGMsRCksYy5zb3VyY2UuZW5kT2Zmc2V0PXUoYyxEKSk7Zm9yKGxldCBFIGluIGMpe2xldCBfPWNbRV07RT09PVwic291cmNlXCJ8fCFffHx0eXBlb2YgXyE9XCJvYmplY3RcInx8KF8udHlwZT09PVwidmFsdWUtcm9vdFwifHxfLnR5cGU9PT1cInZhbHVlLXVua25vd25cIj9sKF8scChjKSxfLnRleHR8fF8udmFsdWUpOmkoXyxEKSl9fWZ1bmN0aW9uIGwoYyxELEUpe2Muc291cmNlJiYoYy5zb3VyY2Uuc3RhcnRPZmZzZXQ9bihjLEUpK0QsYy5zb3VyY2UuZW5kT2Zmc2V0PXUoYyxFKStEKTtmb3IobGV0IF8gaW4gYyl7bGV0IHc9Y1tfXTtfPT09XCJzb3VyY2VcInx8IXd8fHR5cGVvZiB3IT1cIm9iamVjdFwifHxsKHcsRCxFKX19ZnVuY3Rpb24gcChjKXtsZXQgRD1jLnNvdXJjZS5zdGFydE9mZnNldDtyZXR1cm4gdHlwZW9mIGMucHJvcD09XCJzdHJpbmdcIiYmKEQrPWMucHJvcC5sZW5ndGgpLGMudHlwZT09PVwiY3NzLWF0cnVsZVwiJiZ0eXBlb2YgYy5uYW1lPT1cInN0cmluZ1wiJiYoRCs9MStjLm5hbWUubGVuZ3RoK2MucmF3cy5hZnRlck5hbWUubWF0Y2goL15cXHMqOj9cXHMqLylbMF0ubGVuZ3RoKSxjLnR5cGUhPT1cImNzcy1hdHJ1bGVcIiYmYy5yYXdzJiZ0eXBlb2YgYy5yYXdzLmJldHdlZW49PVwic3RyaW5nXCImJihEKz1jLnJhd3MuYmV0d2Vlbi5sZW5ndGgpLER9ZnVuY3Rpb24gZChjKXtsZXQgRD1cImluaXRpYWxcIixFPVwiaW5pdGlhbFwiLF8sdz0hMSxGPVtdO2ZvcihsZXQgUz0wO1M8Yy5sZW5ndGg7UysrKXtsZXQgTj1jW1NdO3N3aXRjaChEKXtjYXNlXCJpbml0aWFsXCI6aWYoTj09PVwiJ1wiKXtEPVwic2luZ2xlLXF1b3Rlc1wiO2NvbnRpbnVlfWlmKE49PT0nXCInKXtEPVwiZG91YmxlLXF1b3Rlc1wiO2NvbnRpbnVlfWlmKChOPT09XCJ1XCJ8fE49PT1cIlVcIikmJmMuc2xpY2UoUyxTKzQpLnRvTG93ZXJDYXNlKCk9PT1cInVybChcIil7RD1cInVybFwiLFMrPTM7Y29udGludWV9aWYoTj09PVwiKlwiJiZjW1MtMV09PT1cIi9cIil7RD1cImNvbW1lbnQtYmxvY2tcIjtjb250aW51ZX1pZihOPT09XCIvXCImJmNbUy0xXT09PVwiL1wiKXtEPVwiY29tbWVudC1pbmxpbmVcIixfPVMtMTtjb250aW51ZX1jb250aW51ZTtjYXNlXCJzaW5nbGUtcXVvdGVzXCI6aWYoTj09PVwiJ1wiJiZjW1MtMV0hPT1cIlxcXFxcIiYmKEQ9RSxFPVwiaW5pdGlhbFwiKSxOPT09YFxuYHx8Tj09PVwiXFxyXCIpcmV0dXJuIGM7Y29udGludWU7Y2FzZVwiZG91YmxlLXF1b3Rlc1wiOmlmKE49PT0nXCInJiZjW1MtMV0hPT1cIlxcXFxcIiYmKEQ9RSxFPVwiaW5pdGlhbFwiKSxOPT09YFxuYHx8Tj09PVwiXFxyXCIpcmV0dXJuIGM7Y29udGludWU7Y2FzZVwidXJsXCI6aWYoTj09PVwiKVwiJiYoRD1cImluaXRpYWxcIiksTj09PWBcbmB8fE49PT1cIlxcclwiKXJldHVybiBjO2lmKE49PT1cIidcIil7RD1cInNpbmdsZS1xdW90ZXNcIixFPVwidXJsXCI7Y29udGludWV9aWYoTj09PSdcIicpe0Q9XCJkb3VibGUtcXVvdGVzXCIsRT1cInVybFwiO2NvbnRpbnVlfWNvbnRpbnVlO2Nhc2VcImNvbW1lbnQtYmxvY2tcIjpOPT09XCIvXCImJmNbUy0xXT09PVwiKlwiJiYoRD1cImluaXRpYWxcIik7Y29udGludWU7Y2FzZVwiY29tbWVudC1pbmxpbmVcIjooTj09PSdcIid8fE49PT1cIidcInx8Tj09PVwiKlwiKSYmKHc9ITApLChOPT09YFxuYHx8Tj09PVwiXFxyXCIpJiYodyYmRi5wdXNoKFtfLFNdKSxEPVwiaW5pdGlhbFwiLHc9ITEpO2NvbnRpbnVlfX1mb3IobGV0W1MsTl1vZiBGKWM9Yy5zbGljZSgwLFMpK2Muc2xpY2UoUyxOKS5yZXBsYWNlKC9bXCInKl0vZyxcIiBcIikrYy5zbGljZShOKTtyZXR1cm4gY31mdW5jdGlvbiB5KGMpe3JldHVybiBjLnNvdXJjZS5zdGFydE9mZnNldH1mdW5jdGlvbiBnKGMpe3JldHVybiBjLnNvdXJjZS5lbmRPZmZzZXR9ci5leHBvcnRzPXtsb2NTdGFydDp5LGxvY0VuZDpnLGNhbGN1bGF0ZUxvYzppLHJlcGxhY2VRdW90ZXNJbklubGluZUNvbW1lbnRzOmR9fX0pLGtkPXRlKHtcInNyYy9sYW5ndWFnZS1jc3MvdXRpbHMvaXMtbGVzcy1wYXJzZXIuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7ZnVuY3Rpb24gdChzKXtyZXR1cm4gcy5wYXJzZXI9PT1cImNzc1wifHxzLnBhcnNlcj09PVwibGVzc1wifXIuZXhwb3J0cz10fX0pLExkPXRlKHtcInNyYy9sYW5ndWFnZS1jc3MvdXRpbHMvaXMtc2Nzcy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KHMsYSl7cmV0dXJuIHM9PT1cImxlc3NcInx8cz09PVwic2Nzc1wiP3M9PT1cInNjc3NcIjovKD86XFx3XFxzKjpcXHMqW146fV0rfCMpe3xAaW1wb3J0W15cXG5dKyg/OnVybHwsKS8udGVzdChhKX1yLmV4cG9ydHM9dH19KSxPZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtY3NzL3V0aWxzL2Nzcy11bml0cy5ldmFsdWF0ZS5qc1wiKGUscil7ci5leHBvcnRzPXtlbTpcImVtXCIscmVtOlwicmVtXCIsZXg6XCJleFwiLHJleDpcInJleFwiLGNhcDpcImNhcFwiLHJjYXA6XCJyY2FwXCIsY2g6XCJjaFwiLHJjaDpcInJjaFwiLGljOlwiaWNcIixyaWM6XCJyaWNcIixsaDpcImxoXCIscmxoOlwicmxoXCIsdnc6XCJ2d1wiLHN2dzpcInN2d1wiLGx2dzpcImx2d1wiLGR2dzpcImR2d1wiLHZoOlwidmhcIixzdmg6XCJzdmhcIixsdmg6XCJsdmhcIixkdmg6XCJkdmhcIix2aTpcInZpXCIsc3ZpOlwic3ZpXCIsbHZpOlwibHZpXCIsZHZpOlwiZHZpXCIsdmI6XCJ2YlwiLHN2YjpcInN2YlwiLGx2YjpcImx2YlwiLGR2YjpcImR2YlwiLHZtaW46XCJ2bWluXCIsc3ZtaW46XCJzdm1pblwiLGx2bWluOlwibHZtaW5cIixkdm1pbjpcImR2bWluXCIsdm1heDpcInZtYXhcIixzdm1heDpcInN2bWF4XCIsbHZtYXg6XCJsdm1heFwiLGR2bWF4OlwiZHZtYXhcIixjbTpcImNtXCIsbW06XCJtbVwiLHE6XCJRXCIsaW46XCJpblwiLHB0OlwicHRcIixwYzpcInBjXCIscHg6XCJweFwiLGRlZzpcImRlZ1wiLGdyYWQ6XCJncmFkXCIscmFkOlwicmFkXCIsdHVybjpcInR1cm5cIixzOlwic1wiLG1zOlwibXNcIixoejpcIkh6XCIsa2h6Olwia0h6XCIsZHBpOlwiZHBpXCIsZHBjbTpcImRwY21cIixkcHB4OlwiZHBweFwiLHg6XCJ4XCJ9fX0pLGpkPXRlKHtcInNyYy9sYW5ndWFnZS1jc3MvdXRpbHMvcHJpbnQtdW5pdC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1PZCgpO2Z1bmN0aW9uIHMoYSl7bGV0IG49YS50b0xvd2VyQ2FzZSgpO3JldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodCxuKT90W25dOmF9ci5leHBvcnRzPXN9fSkscWQ9dGUoe1wic3JjL2xhbmd1YWdlLWNzcy9wcmludGVyLXBvc3Rjc3MuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9bHQoKSx7cHJpbnROdW1iZXI6cyxwcmludFN0cmluZzphLGhhc05ld2xpbmU6bixpc0Zyb250TWF0dGVyTm9kZTp1LGlzTmV4dExpbmVFbXB0eTppLGlzTm9uRW1wdHlBcnJheTpsfT1VZSgpLHtidWlsZGVyczp7am9pbjpwLGxpbmU6ZCxoYXJkbGluZTp5LHNvZnRsaW5lOmcsZ3JvdXA6YyxmaWxsOkQsaW5kZW50OkUsZGVkZW50Ol8saWZCcmVhazp3LGJyZWFrUGFyZW50OkZ9LHV0aWxzOntyZW1vdmVMaW5lczpTLGdldERvY1BhcnRzOk59fT1xZSgpLEk9QmQoKSxQPU5kKCkse2luc2VydFByYWdtYTokfT13ZCgpLHtnZXRBbmNlc3Rvck5vZGU6ZixnZXRQcm9wT2ZEZWNsTm9kZTpULG1heWJlVG9Mb3dlckNhc2U6bSxpbnNpZGVWYWx1ZUZ1bmN0aW9uTm9kZTp2LGluc2lkZUlDU1NSdWxlTm9kZTpvLGluc2lkZUF0UnVsZU5vZGU6aCxpbnNpZGVVUkxGdW5jdGlvbkluSW1wb3J0QXRSdWxlTm9kZTpDLGlzS2V5ZnJhbWVBdFJ1bGVLZXl3b3Jkczp4LGlzV2lkZUtleXdvcmRzOmIsaXNMYXN0Tm9kZTpCLGlzU0NTU0NvbnRyb2xEaXJlY3RpdmVOb2RlOmssaXNEZXRhY2hlZFJ1bGVzZXREZWNsYXJhdGlvbk5vZGU6TSxpc1JlbGF0aW9uYWxPcGVyYXRvck5vZGU6Uixpc0VxdWFsaXR5T3BlcmF0b3JOb2RlOnEsaXNNdWx0aXBsaWNhdGlvbk5vZGU6Sixpc0RpdmlzaW9uTm9kZTpMLGlzQWRkaXRpb25Ob2RlOlEsaXNTdWJ0cmFjdGlvbk5vZGU6Vixpc01hdGhPcGVyYXRvck5vZGU6aixpc0VhY2hLZXl3b3JkTm9kZTpZLGlzRm9yS2V5d29yZE5vZGU6aWUsaXNVUkxGdW5jdGlvbk5vZGU6ZWUsaXNJZkVsc2VLZXl3b3JkTm9kZTpsZSxoYXNDb21wb3Nlc05vZGU6VyxoYXNQYXJlbnNBcm91bmROb2RlOkssaGFzRW1wdHlSYXdCZWZvcmU6ZGUsaXNLZXlWYWx1ZVBhaXJOb2RlOnVlLGlzS2V5SW5WYWx1ZVBhaXJOb2RlOkZlLGlzRGV0YWNoZWRSdWxlc2V0Q2FsbE5vZGU6eixpc1RlbXBsYXRlUGxhY2Vob2xkZXJOb2RlOlUsaXNUZW1wbGF0ZVByb3BOb2RlOlosaXNQb3N0Y3NzU2ltcGxlVmFyTm9kZTpzZSxpc1NDU1NNYXBJdGVtTm9kZTpEZSxpc0lubGluZVZhbHVlQ29tbWVudE5vZGU6Z2UsaXNIYXNoTm9kZTpoZSxpc0xlZnRDdXJseUJyYWNlTm9kZTp3ZSxpc1JpZ2h0Q3VybHlCcmFjZU5vZGU6a2UsaXNXb3JkTm9kZTpSZSxpc0NvbG9uTm9kZTpOZSxpc01lZGlhQW5kU3VwcG9ydHNLZXl3b3JkczpQZSxpc0NvbG9yQWRqdXN0ZXJGdW5jTm9kZTpvZSxsYXN0TGluZUhhc0lubGluZUNvbW1lbnQ6SCxpc0F0V29yZFBsYWNlaG9sZGVyTm9kZTpjZSxpc0NvbmZpZ3VyYXRpb25Ob2RlOlgsaXNQYXJlbkdyb3VwTm9kZTpwZX09X2QoKSx7bG9jU3RhcnQ6QWUsbG9jRW5kOkNlfT1JZCgpLGZlPWtkKCksQT1MZCgpLEc9amQoKTtmdW5jdGlvbiByZShUZSl7cmV0dXJuIFRlLnRyYWlsaW5nQ29tbWE9PT1cImVzNVwifHxUZS50cmFpbGluZ0NvbW1hPT09XCJhbGxcIn1mdW5jdGlvbiB5ZShUZSxqZSxNZSl7bGV0IGFlPVRlLmdldFZhbHVlKCk7aWYoIWFlKXJldHVyblwiXCI7aWYodHlwZW9mIGFlPT1cInN0cmluZ1wiKXJldHVybiBhZTtzd2l0Y2goYWUudHlwZSl7Y2FzZVwiZnJvbnQtbWF0dGVyXCI6cmV0dXJuW2FlLnJhdyx5XTtjYXNlXCJjc3Mtcm9vdFwiOntsZXQgVmU9RWUoVGUsamUsTWUpLFdlPWFlLnJhd3MuYWZ0ZXIudHJpbSgpO3JldHVybiBXZS5zdGFydHNXaXRoKFwiO1wiKSYmKFdlPVdlLnNsaWNlKDEpLnRyaW0oKSksW1ZlLFdlP2AgJHtXZX1gOlwiXCIsTihWZSkubGVuZ3RoPjA/eTpcIlwiXX1jYXNlXCJjc3MtY29tbWVudFwiOntsZXQgVmU9YWUuaW5saW5lfHxhZS5yYXdzLmlubGluZSxXZT1qZS5vcmlnaW5hbFRleHQuc2xpY2UoQWUoYWUpLENlKGFlKSk7cmV0dXJuIFZlP1dlLnRyaW1FbmQoKTpXZX1jYXNlXCJjc3MtcnVsZVwiOnJldHVybltNZShcInNlbGVjdG9yXCIpLGFlLmltcG9ydGFudD9cIiAhaW1wb3J0YW50XCI6XCJcIixhZS5ub2Rlcz9bYWUuc2VsZWN0b3ImJmFlLnNlbGVjdG9yLnR5cGU9PT1cInNlbGVjdG9yLXVua25vd25cIiYmSChhZS5zZWxlY3Rvci52YWx1ZSk/ZDpcIiBcIixcIntcIixhZS5ub2Rlcy5sZW5ndGg+MD9FKFt5LEVlKFRlLGplLE1lKV0pOlwiXCIseSxcIn1cIixNKGFlKT9cIjtcIjpcIlwiXTpcIjtcIl07Y2FzZVwiY3NzLWRlY2xcIjp7bGV0IFZlPVRlLmdldFBhcmVudE5vZGUoKSx7YmV0d2VlbjpXZX09YWUucmF3cyxYZT1XZS50cmltKCksc3Q9WGU9PT1cIjpcIixPPVcoYWUpP1MoTWUoXCJ2YWx1ZVwiKSk6TWUoXCJ2YWx1ZVwiKTtyZXR1cm4hc3QmJkgoWGUpJiYoTz1FKFt5LF8oTyldKSksW2FlLnJhd3MuYmVmb3JlLnJlcGxhY2UoL1tcXHM7XS9nLFwiXCIpLFZlLnR5cGU9PT1cImNzcy1hdHJ1bGVcIiYmVmUudmFyaWFibGV8fG8oVGUpP2FlLnByb3A6bShhZS5wcm9wKSxYZS5zdGFydHNXaXRoKFwiLy9cIik/XCIgXCI6XCJcIixYZSxhZS5leHRlbmQ/XCJcIjpcIiBcIixmZShqZSkmJmFlLmV4dGVuZCYmYWUuc2VsZWN0b3I/W1wiZXh0ZW5kKFwiLE1lKFwic2VsZWN0b3JcIiksXCIpXCJdOlwiXCIsTyxhZS5yYXdzLmltcG9ydGFudD9hZS5yYXdzLmltcG9ydGFudC5yZXBsYWNlKC9cXHMqIVxccyppbXBvcnRhbnQvaSxcIiAhaW1wb3J0YW50XCIpOmFlLmltcG9ydGFudD9cIiAhaW1wb3J0YW50XCI6XCJcIixhZS5yYXdzLnNjc3NEZWZhdWx0P2FlLnJhd3Muc2Nzc0RlZmF1bHQucmVwbGFjZSgvXFxzKiFkZWZhdWx0L2ksXCIgIWRlZmF1bHRcIik6YWUuc2Nzc0RlZmF1bHQ/XCIgIWRlZmF1bHRcIjpcIlwiLGFlLnJhd3Muc2Nzc0dsb2JhbD9hZS5yYXdzLnNjc3NHbG9iYWwucmVwbGFjZSgvXFxzKiFnbG9iYWwvaSxcIiAhZ2xvYmFsXCIpOmFlLnNjc3NHbG9iYWw/XCIgIWdsb2JhbFwiOlwiXCIsYWUubm9kZXM/W1wiIHtcIixFKFtnLEVlKFRlLGplLE1lKV0pLGcsXCJ9XCJdOlooYWUpJiYhVmUucmF3cy5zZW1pY29sb24mJmplLm9yaWdpbmFsVGV4dFtDZShhZSktMV0hPT1cIjtcIj9cIlwiOmplLl9faXNIVE1MU3R5bGVBdHRyaWJ1dGUmJkIoVGUsYWUpP3coXCI7XCIpOlwiO1wiXX1jYXNlXCJjc3MtYXRydWxlXCI6e2xldCBWZT1UZS5nZXRQYXJlbnROb2RlKCksV2U9VShhZSkmJiFWZS5yYXdzLnNlbWljb2xvbiYmamUub3JpZ2luYWxUZXh0W0NlKGFlKS0xXSE9PVwiO1wiO2lmKGZlKGplKSl7aWYoYWUubWl4aW4pcmV0dXJuW01lKFwic2VsZWN0b3JcIiksYWUuaW1wb3J0YW50P1wiICFpbXBvcnRhbnRcIjpcIlwiLFdlP1wiXCI6XCI7XCJdO2lmKGFlLmZ1bmN0aW9uKXJldHVyblthZS5uYW1lLE1lKFwicGFyYW1zXCIpLFdlP1wiXCI6XCI7XCJdO2lmKGFlLnZhcmlhYmxlKXJldHVybltcIkBcIixhZS5uYW1lLFwiOiBcIixhZS52YWx1ZT9NZShcInZhbHVlXCIpOlwiXCIsYWUucmF3cy5iZXR3ZWVuLnRyaW0oKT9hZS5yYXdzLmJldHdlZW4udHJpbSgpK1wiIFwiOlwiXCIsYWUubm9kZXM/W1wie1wiLEUoW2FlLm5vZGVzLmxlbmd0aD4wP2c6XCJcIixFZShUZSxqZSxNZSldKSxnLFwifVwiXTpcIlwiLFdlP1wiXCI6XCI7XCJdfXJldHVybltcIkBcIix6KGFlKXx8YWUubmFtZS5lbmRzV2l0aChcIjpcIik/YWUubmFtZTptKGFlLm5hbWUpLGFlLnBhcmFtcz9beihhZSk/XCJcIjpVKGFlKT9hZS5yYXdzLmFmdGVyTmFtZT09PVwiXCI/XCJcIjphZS5uYW1lLmVuZHNXaXRoKFwiOlwiKT9cIiBcIjovXlxccypcXG5cXHMqXFxuLy50ZXN0KGFlLnJhd3MuYWZ0ZXJOYW1lKT9beSx5XTovXlxccypcXG4vLnRlc3QoYWUucmF3cy5hZnRlck5hbWUpP3k6XCIgXCI6XCIgXCIsTWUoXCJwYXJhbXNcIildOlwiXCIsYWUuc2VsZWN0b3I/RShbXCIgXCIsTWUoXCJzZWxlY3RvclwiKV0pOlwiXCIsYWUudmFsdWU/YyhbXCIgXCIsTWUoXCJ2YWx1ZVwiKSxrKGFlKT9LKGFlKT9cIiBcIjpkOlwiXCJdKTphZS5uYW1lPT09XCJlbHNlXCI/XCIgXCI6XCJcIixhZS5ub2Rlcz9bayhhZSk/XCJcIjphZS5zZWxlY3RvciYmIWFlLnNlbGVjdG9yLm5vZGVzJiZ0eXBlb2YgYWUuc2VsZWN0b3IudmFsdWU9PVwic3RyaW5nXCImJkgoYWUuc2VsZWN0b3IudmFsdWUpfHwhYWUuc2VsZWN0b3ImJnR5cGVvZiBhZS5wYXJhbXM9PVwic3RyaW5nXCImJkgoYWUucGFyYW1zKT9kOlwiIFwiLFwie1wiLEUoW2FlLm5vZGVzLmxlbmd0aD4wP2c6XCJcIixFZShUZSxqZSxNZSldKSxnLFwifVwiXTpXZT9cIlwiOlwiO1wiXX1jYXNlXCJtZWRpYS1xdWVyeS1saXN0XCI6e2xldCBWZT1bXTtyZXR1cm4gVGUuZWFjaChXZT0+e2xldCBYZT1XZS5nZXRWYWx1ZSgpO1hlLnR5cGU9PT1cIm1lZGlhLXF1ZXJ5XCImJlhlLnZhbHVlPT09XCJcInx8VmUucHVzaChNZSgpKX0sXCJub2Rlc1wiKSxjKEUocChkLFZlKSkpfWNhc2VcIm1lZGlhLXF1ZXJ5XCI6cmV0dXJuW3AoXCIgXCIsVGUubWFwKE1lLFwibm9kZXNcIikpLEIoVGUsYWUpP1wiXCI6XCIsXCJdO2Nhc2VcIm1lZGlhLXR5cGVcIjpyZXR1cm4gT2UoU2UoYWUudmFsdWUsamUpKTtjYXNlXCJtZWRpYS1mZWF0dXJlLWV4cHJlc3Npb25cIjpyZXR1cm4gYWUubm9kZXM/W1wiKFwiLC4uLlRlLm1hcChNZSxcIm5vZGVzXCIpLFwiKVwiXTphZS52YWx1ZTtjYXNlXCJtZWRpYS1mZWF0dXJlXCI6cmV0dXJuIG0oU2UoYWUudmFsdWUucmVwbGFjZSgvICsvZyxcIiBcIiksamUpKTtjYXNlXCJtZWRpYS1jb2xvblwiOnJldHVyblthZS52YWx1ZSxcIiBcIl07Y2FzZVwibWVkaWEtdmFsdWVcIjpyZXR1cm4gT2UoU2UoYWUudmFsdWUsamUpKTtjYXNlXCJtZWRpYS1rZXl3b3JkXCI6cmV0dXJuIFNlKGFlLnZhbHVlLGplKTtjYXNlXCJtZWRpYS11cmxcIjpyZXR1cm4gU2UoYWUudmFsdWUucmVwbGFjZSgvXnVybFxcKFxccysvZ2ksXCJ1cmwoXCIpLnJlcGxhY2UoL1xccytcXCkkL2csXCIpXCIpLGplKTtjYXNlXCJtZWRpYS11bmtub3duXCI6cmV0dXJuIGFlLnZhbHVlO2Nhc2VcInNlbGVjdG9yLXJvb3RcIjpyZXR1cm4gYyhbaChUZSxcImN1c3RvbS1zZWxlY3RvclwiKT9bZihUZSxcImNzcy1hdHJ1bGVcIikuY3VzdG9tU2VsZWN0b3IsZF06XCJcIixwKFtcIixcIixoKFRlLFtcImV4dGVuZFwiLFwiY3VzdG9tLXNlbGVjdG9yXCIsXCJuZXN0XCJdKT9kOnldLFRlLm1hcChNZSxcIm5vZGVzXCIpKV0pO2Nhc2VcInNlbGVjdG9yLXNlbGVjdG9yXCI6cmV0dXJuIGMoRShUZS5tYXAoTWUsXCJub2Rlc1wiKSkpO2Nhc2VcInNlbGVjdG9yLWNvbW1lbnRcIjpyZXR1cm4gYWUudmFsdWU7Y2FzZVwic2VsZWN0b3Itc3RyaW5nXCI6cmV0dXJuIFNlKGFlLnZhbHVlLGplKTtjYXNlXCJzZWxlY3Rvci10YWdcIjp7bGV0IFZlPVRlLmdldFBhcmVudE5vZGUoKSxXZT1WZSYmVmUubm9kZXMuaW5kZXhPZihhZSksWGU9V2UmJlZlLm5vZGVzW1dlLTFdO3JldHVyblthZS5uYW1lc3BhY2U/W2FlLm5hbWVzcGFjZT09PSEwP1wiXCI6YWUubmFtZXNwYWNlLnRyaW0oKSxcInxcIl06XCJcIixYZS50eXBlPT09XCJzZWxlY3Rvci1uZXN0aW5nXCI/YWUudmFsdWU6T2UoeChUZSxhZS52YWx1ZSk/YWUudmFsdWUudG9Mb3dlckNhc2UoKTphZS52YWx1ZSldfWNhc2VcInNlbGVjdG9yLWlkXCI6cmV0dXJuW1wiI1wiLGFlLnZhbHVlXTtjYXNlXCJzZWxlY3Rvci1jbGFzc1wiOnJldHVybltcIi5cIixPZShTZShhZS52YWx1ZSxqZSkpXTtjYXNlXCJzZWxlY3Rvci1hdHRyaWJ1dGVcIjp7dmFyIG50O3JldHVybltcIltcIixhZS5uYW1lc3BhY2U/W2FlLm5hbWVzcGFjZT09PSEwP1wiXCI6YWUubmFtZXNwYWNlLnRyaW0oKSxcInxcIl06XCJcIixhZS5hdHRyaWJ1dGUudHJpbSgpLChudD1hZS5vcGVyYXRvcikhPT1udWxsJiZudCE9PXZvaWQgMD9udDpcIlwiLGFlLnZhbHVlP0llKFNlKGFlLnZhbHVlLnRyaW0oKSxqZSksamUpOlwiXCIsYWUuaW5zZW5zaXRpdmU/XCIgaVwiOlwiXCIsXCJdXCJdfWNhc2VcInNlbGVjdG9yLWNvbWJpbmF0b3JcIjp7aWYoYWUudmFsdWU9PT1cIitcInx8YWUudmFsdWU9PT1cIj5cInx8YWUudmFsdWU9PT1cIn5cInx8YWUudmFsdWU9PT1cIj4+PlwiKXtsZXQgWGU9VGUuZ2V0UGFyZW50Tm9kZSgpO3JldHVybltYZS50eXBlPT09XCJzZWxlY3Rvci1zZWxlY3RvclwiJiZYZS5ub2Rlc1swXT09PWFlP1wiXCI6ZCxhZS52YWx1ZSxCKFRlLGFlKT9cIlwiOlwiIFwiXX1sZXQgVmU9YWUudmFsdWUudHJpbSgpLnN0YXJ0c1dpdGgoXCIoXCIpP2Q6XCJcIixXZT1PZShTZShhZS52YWx1ZS50cmltKCksamUpKXx8ZDtyZXR1cm5bVmUsV2VdfWNhc2VcInNlbGVjdG9yLXVuaXZlcnNhbFwiOnJldHVyblthZS5uYW1lc3BhY2U/W2FlLm5hbWVzcGFjZT09PSEwP1wiXCI6YWUubmFtZXNwYWNlLnRyaW0oKSxcInxcIl06XCJcIixhZS52YWx1ZV07Y2FzZVwic2VsZWN0b3ItcHNldWRvXCI6cmV0dXJuW20oYWUudmFsdWUpLGwoYWUubm9kZXMpP2MoW1wiKFwiLEUoW2cscChbXCIsXCIsZF0sVGUubWFwKE1lLFwibm9kZXNcIikpXSksZyxcIilcIl0pOlwiXCJdO2Nhc2VcInNlbGVjdG9yLW5lc3RpbmdcIjpyZXR1cm4gYWUudmFsdWU7Y2FzZVwic2VsZWN0b3ItdW5rbm93blwiOntsZXQgVmU9ZihUZSxcImNzcy1ydWxlXCIpO2lmKFZlJiZWZS5pc1NDU1NOZXN0ZXJQcm9wZXJ0eSlyZXR1cm4gT2UoU2UobShhZS52YWx1ZSksamUpKTtsZXQgV2U9VGUuZ2V0UGFyZW50Tm9kZSgpO2lmKFdlLnJhd3MmJldlLnJhd3Muc2VsZWN0b3Ipe2xldCBzdD1BZShXZSksTz1zdCtXZS5yYXdzLnNlbGVjdG9yLmxlbmd0aDtyZXR1cm4gamUub3JpZ2luYWxUZXh0LnNsaWNlKHN0LE8pLnRyaW0oKX1sZXQgWGU9VGUuZ2V0UGFyZW50Tm9kZSgxKTtpZihXZS50eXBlPT09XCJ2YWx1ZS1wYXJlbl9ncm91cFwiJiZYZSYmWGUudHlwZT09PVwidmFsdWUtZnVuY1wiJiZYZS52YWx1ZT09PVwic2VsZWN0b3JcIil7bGV0IHN0PUNlKFdlLm9wZW4pKzEsTz1BZShXZS5jbG9zZSksbWU9amUub3JpZ2luYWxUZXh0LnNsaWNlKHN0LE8pLnRyaW0oKTtyZXR1cm4gSChtZSk/W0YsbWVdOm1lfXJldHVybiBhZS52YWx1ZX1jYXNlXCJ2YWx1ZS12YWx1ZVwiOmNhc2VcInZhbHVlLXJvb3RcIjpyZXR1cm4gTWUoXCJncm91cFwiKTtjYXNlXCJ2YWx1ZS1jb21tZW50XCI6cmV0dXJuIGplLm9yaWdpbmFsVGV4dC5zbGljZShBZShhZSksQ2UoYWUpKTtjYXNlXCJ2YWx1ZS1jb21tYV9ncm91cFwiOntsZXQgVmU9VGUuZ2V0UGFyZW50Tm9kZSgpLFdlPVRlLmdldFBhcmVudE5vZGUoMSksWGU9VChUZSksc3Q9WGUmJlZlLnR5cGU9PT1cInZhbHVlLXZhbHVlXCImJihYZT09PVwiZ3JpZFwifHxYZS5zdGFydHNXaXRoKFwiZ3JpZC10ZW1wbGF0ZVwiKSksTz1mKFRlLFwiY3NzLWF0cnVsZVwiKSxtZT1PJiZrKE8pLF9lPWFlLmdyb3Vwcy5zb21lKGF0PT5nZShhdCkpLEhlPVRlLm1hcChNZSxcImdyb3Vwc1wiKSxHZT1bXSxpdD12KFRlLFwidXJsXCIpLFFlPSExLHJ0PSExO2ZvcihsZXQgYXQ9MDthdDxhZS5ncm91cHMubGVuZ3RoOysrYXQpe3ZhciB0dDtHZS5wdXNoKEhlW2F0XSk7bGV0IFplPWFlLmdyb3Vwc1thdC0xXSxMZT1hZS5ncm91cHNbYXRdLCRlPWFlLmdyb3Vwc1thdCsxXSxzcj1hZS5ncm91cHNbYXQrMl07aWYoaXQpeygkZSYmUSgkZSl8fFEoTGUpKSYmR2UucHVzaChcIiBcIik7Y29udGludWV9aWYoaChUZSxcImZvcndhcmRcIikmJkxlLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmTGUudmFsdWUmJlplIT09dm9pZCAwJiZaZS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJlplLnZhbHVlPT09XCJhc1wiJiYkZS50eXBlPT09XCJ2YWx1ZS1vcGVyYXRvclwiJiYkZS52YWx1ZT09PVwiKlwifHwhJGV8fExlLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmTGUudmFsdWUuZW5kc1dpdGgoXCItXCIpJiZjZSgkZSkpY29udGludWU7aWYoTGUudHlwZT09PVwidmFsdWUtc3RyaW5nXCImJkxlLnF1b3RlZCl7bGV0ICRyPUxlLnZhbHVlLmxhc3RJbmRleE9mKFwiI3tcIiksVnI9TGUudmFsdWUubGFzdEluZGV4T2YoXCJ9XCIpOyRyIT09LTEmJlZyIT09LTE/UWU9JHI+VnI6JHIhPT0tMT9RZT0hMDpWciE9PS0xJiYoUWU9ITEpfWlmKFFlfHxOZShMZSl8fE5lKCRlKXx8TGUudHlwZT09PVwidmFsdWUtYXR3b3JkXCImJihMZS52YWx1ZT09PVwiXCJ8fExlLnZhbHVlLmVuZHNXaXRoKFwiW1wiKSl8fCRlLnR5cGU9PT1cInZhbHVlLXdvcmRcIiYmJGUudmFsdWUuc3RhcnRzV2l0aChcIl1cIil8fExlLnZhbHVlPT09XCJ+XCJ8fExlLnZhbHVlJiZMZS52YWx1ZS5pbmNsdWRlcyhcIlxcXFxcIikmJiRlJiYkZS50eXBlIT09XCJ2YWx1ZS1jb21tZW50XCJ8fFplJiZaZS52YWx1ZSYmWmUudmFsdWUuaW5kZXhPZihcIlxcXFxcIik9PT1aZS52YWx1ZS5sZW5ndGgtMSYmTGUudHlwZT09PVwidmFsdWUtb3BlcmF0b3JcIiYmTGUudmFsdWU9PT1cIi9cInx8TGUudmFsdWU9PT1cIlxcXFxcInx8c2UoTGUsJGUpfHxoZShMZSl8fHdlKExlKXx8a2UoJGUpfHx3ZSgkZSkmJmRlKCRlKXx8a2UoTGUpJiZkZSgkZSl8fExlLnZhbHVlPT09XCItLVwiJiZoZSgkZSkpY29udGludWU7bGV0IFJyPWooTGUpLG91PWooJGUpO2lmKChSciYmaGUoJGUpfHxvdSYma2UoTGUpKSYmZGUoJGUpfHwhWmUmJkwoTGUpfHx2KFRlLFwiY2FsY1wiKSYmKFEoTGUpfHxRKCRlKXx8VihMZSl8fFYoJGUpKSYmZGUoJGUpKWNvbnRpbnVlO2xldCBxbz0oUShMZSl8fFYoTGUpKSYmYXQ9PT0wJiYoJGUudHlwZT09PVwidmFsdWUtbnVtYmVyXCJ8fCRlLmlzSGV4KSYmV2UmJm9lKFdlKSYmIWRlKCRlKSxsdT1zciYmc3IudHlwZT09PVwidmFsdWUtZnVuY1wifHxzciYmUmUoc3IpfHxMZS50eXBlPT09XCJ2YWx1ZS1mdW5jXCJ8fFJlKExlKSxjdT0kZS50eXBlPT09XCJ2YWx1ZS1mdW5jXCJ8fFJlKCRlKXx8WmUmJlplLnR5cGU9PT1cInZhbHVlLWZ1bmNcInx8WmUmJlJlKFplKTtpZighKCEoSigkZSl8fEooTGUpKSYmIXYoVGUsXCJjYWxjXCIpJiYhcW8mJihMKCRlKSYmIWx1fHxMKExlKSYmIWN1fHxRKCRlKSYmIWx1fHxRKExlKSYmIWN1fHxWKCRlKXx8VihMZSkpJiYoZGUoJGUpfHxSciYmKCFaZXx8WmUmJmooWmUpKSkpJiYhKChqZS5wYXJzZXI9PT1cInNjc3NcInx8amUucGFyc2VyPT09XCJsZXNzXCIpJiZSciYmTGUudmFsdWU9PT1cIi1cIiYmcGUoJGUpJiZDZShMZSk9PT1BZSgkZS5vcGVuKSYmJGUub3Blbi52YWx1ZT09PVwiKFwiKSl7aWYoZ2UoTGUpKXtpZihWZS50eXBlPT09XCJ2YWx1ZS1wYXJlbl9ncm91cFwiKXtHZS5wdXNoKF8oeSkpO2NvbnRpbnVlfUdlLnB1c2goeSk7Y29udGludWV9aWYobWUmJihxKCRlKXx8UigkZSl8fGxlKCRlKXx8WShMZSl8fGllKExlKSkpe0dlLnB1c2goXCIgXCIpO2NvbnRpbnVlfWlmKE8mJk8ubmFtZS50b0xvd2VyQ2FzZSgpPT09XCJuYW1lc3BhY2VcIil7R2UucHVzaChcIiBcIik7Y29udGludWV9aWYoc3Qpe0xlLnNvdXJjZSYmJGUuc291cmNlJiZMZS5zb3VyY2Uuc3RhcnQubGluZSE9PSRlLnNvdXJjZS5zdGFydC5saW5lPyhHZS5wdXNoKHkpLHJ0PSEwKTpHZS5wdXNoKFwiIFwiKTtjb250aW51ZX1pZihvdSl7R2UucHVzaChcIiBcIik7Y29udGludWV9aWYoISgkZSYmJGUudmFsdWU9PT1cIi4uLlwiKSYmIShjZShMZSkmJmNlKCRlKSYmQ2UoTGUpPT09QWUoJGUpKSl7aWYoY2UoTGUpJiZwZSgkZSkmJkNlKExlKT09PUFlKCRlLm9wZW4pKXtHZS5wdXNoKGcpO2NvbnRpbnVlfWlmKExlLnZhbHVlPT09XCJ3aXRoXCImJnBlKCRlKSl7R2UucHVzaChcIiBcIik7Y29udGludWV9KHR0PUxlLnZhbHVlKSE9PW51bGwmJnR0IT09dm9pZCAwJiZ0dC5lbmRzV2l0aChcIiNcIikmJiRlLnZhbHVlPT09XCJ7XCImJnBlKCRlLmdyb3VwKXx8R2UucHVzaChkKX19fXJldHVybiBfZSYmR2UucHVzaChGKSxydCYmR2UudW5zaGlmdCh5KSxtZT9jKEUoR2UpKTpDKFRlKT9jKEQoR2UpKTpjKEUoRChHZSkpKX1jYXNlXCJ2YWx1ZS1wYXJlbl9ncm91cFwiOntsZXQgVmU9VGUuZ2V0UGFyZW50Tm9kZSgpO2lmKFZlJiZlZShWZSkmJihhZS5ncm91cHMubGVuZ3RoPT09MXx8YWUuZ3JvdXBzLmxlbmd0aD4wJiZhZS5ncm91cHNbMF0udHlwZT09PVwidmFsdWUtY29tbWFfZ3JvdXBcIiYmYWUuZ3JvdXBzWzBdLmdyb3Vwcy5sZW5ndGg+MCYmYWUuZ3JvdXBzWzBdLmdyb3Vwc1swXS50eXBlPT09XCJ2YWx1ZS13b3JkXCImJmFlLmdyb3Vwc1swXS5ncm91cHNbMF0udmFsdWUuc3RhcnRzV2l0aChcImRhdGE6XCIpKSlyZXR1cm5bYWUub3Blbj9NZShcIm9wZW5cIik6XCJcIixwKFwiLFwiLFRlLm1hcChNZSxcImdyb3Vwc1wiKSksYWUuY2xvc2U/TWUoXCJjbG9zZVwiKTpcIlwiXTtpZighYWUub3Blbil7bGV0IGl0PVRlLm1hcChNZSxcImdyb3Vwc1wiKSxRZT1bXTtmb3IobGV0IHJ0PTA7cnQ8aXQubGVuZ3RoO3J0KyspcnQhPT0wJiZRZS5wdXNoKFtcIixcIixkXSksUWUucHVzaChpdFtydF0pO3JldHVybiBjKEUoRChRZSkpKX1sZXQgV2U9RGUoVGUpLFhlPXQoYWUuZ3JvdXBzKSxzdD1YZSYmWGUudHlwZT09PVwidmFsdWUtY29tbWVudFwiLE89RmUoYWUsVmUpLG1lPVgoYWUsVmUpLF9lPW1lfHxXZSYmIU8sSGU9bWV8fE8sR2U9YyhbYWUub3Blbj9NZShcIm9wZW5cIik6XCJcIixFKFtnLHAoW2RdLFRlLm1hcCgoaXQsUWUpPT57bGV0IHJ0PWl0LmdldFZhbHVlKCksYXQ9UWU9PT1hZS5ncm91cHMubGVuZ3RoLTEsWmU9W01lKCksYXQ/XCJcIjpcIixcIl07aWYodWUocnQpJiZydC50eXBlPT09XCJ2YWx1ZS1jb21tYV9ncm91cFwiJiZydC5ncm91cHMmJnJ0Lmdyb3Vwc1swXS50eXBlIT09XCJ2YWx1ZS1wYXJlbl9ncm91cFwiJiZydC5ncm91cHNbMl0mJnJ0Lmdyb3Vwc1syXS50eXBlPT09XCJ2YWx1ZS1wYXJlbl9ncm91cFwiKXtsZXQgTGU9TihaZVswXS5jb250ZW50cy5jb250ZW50cyk7TGVbMV09YyhMZVsxXSksWmU9W2MoXyhaZSkpXX1pZighYXQmJnJ0LnR5cGU9PT1cInZhbHVlLWNvbW1hX2dyb3VwXCImJmwocnQuZ3JvdXBzKSl7bGV0IExlPXQocnQuZ3JvdXBzKTshTGUuc291cmNlJiZMZS5jbG9zZSYmKExlPUxlLmNsb3NlKSxMZS5zb3VyY2UmJmkoamUub3JpZ2luYWxUZXh0LExlLENlKSYmWmUucHVzaCh5KX1yZXR1cm4gWmV9LFwiZ3JvdXBzXCIpKV0pLHcoIXN0JiZBKGplLnBhcnNlcixqZS5vcmlnaW5hbFRleHQpJiZXZSYmcmUoamUpP1wiLFwiOlwiXCIpLGcsYWUuY2xvc2U/TWUoXCJjbG9zZVwiKTpcIlwiXSx7c2hvdWxkQnJlYWs6X2V9KTtyZXR1cm4gSGU/XyhHZSk6R2V9Y2FzZVwidmFsdWUtZnVuY1wiOnJldHVyblthZS52YWx1ZSxoKFRlLFwic3VwcG9ydHNcIikmJlBlKGFlKT9cIiBcIjpcIlwiLE1lKFwiZ3JvdXBcIildO2Nhc2VcInZhbHVlLXBhcmVuXCI6cmV0dXJuIGFlLnZhbHVlO2Nhc2VcInZhbHVlLW51bWJlclwiOnJldHVybltKZShhZS52YWx1ZSksRyhhZS51bml0KV07Y2FzZVwidmFsdWUtb3BlcmF0b3JcIjpyZXR1cm4gYWUudmFsdWU7Y2FzZVwidmFsdWUtd29yZFwiOnJldHVybiBhZS5pc0NvbG9yJiZhZS5pc0hleHx8YihhZS52YWx1ZSk/YWUudmFsdWUudG9Mb3dlckNhc2UoKTphZS52YWx1ZTtjYXNlXCJ2YWx1ZS1jb2xvblwiOntsZXQgVmU9VGUuZ2V0UGFyZW50Tm9kZSgpLFdlPVZlJiZWZS5ncm91cHMuaW5kZXhPZihhZSksWGU9V2UmJlZlLmdyb3Vwc1tXZS0xXTtyZXR1cm5bYWUudmFsdWUsWGUmJnR5cGVvZiBYZS52YWx1ZT09XCJzdHJpbmdcIiYmdChYZS52YWx1ZSk9PT1cIlxcXFxcInx8dihUZSxcInVybFwiKT9cIlwiOmRdfWNhc2VcInZhbHVlLWNvbW1hXCI6cmV0dXJuW2FlLnZhbHVlLFwiIFwiXTtjYXNlXCJ2YWx1ZS1zdHJpbmdcIjpyZXR1cm4gYShhZS5yYXdzLnF1b3RlK2FlLnZhbHVlK2FlLnJhd3MucXVvdGUsamUpO2Nhc2VcInZhbHVlLWF0d29yZFwiOnJldHVybltcIkBcIixhZS52YWx1ZV07Y2FzZVwidmFsdWUtdW5pY29kZS1yYW5nZVwiOnJldHVybiBhZS52YWx1ZTtjYXNlXCJ2YWx1ZS11bmtub3duXCI6cmV0dXJuIGFlLnZhbHVlO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHBvc3Rjc3MgdHlwZSAke0pTT04uc3RyaW5naWZ5KGFlLnR5cGUpfWApfX1mdW5jdGlvbiBFZShUZSxqZSxNZSl7bGV0IGFlPVtdO3JldHVybiBUZS5lYWNoKChudCx0dCxWZSk9PntsZXQgV2U9VmVbdHQtMV07aWYoV2UmJldlLnR5cGU9PT1cImNzcy1jb21tZW50XCImJldlLnRleHQudHJpbSgpPT09XCJwcmV0dGllci1pZ25vcmVcIil7bGV0IFhlPW50LmdldFZhbHVlKCk7YWUucHVzaChqZS5vcmlnaW5hbFRleHQuc2xpY2UoQWUoWGUpLENlKFhlKSkpfWVsc2UgYWUucHVzaChNZSgpKTt0dCE9PVZlLmxlbmd0aC0xJiYoVmVbdHQrMV0udHlwZT09PVwiY3NzLWNvbW1lbnRcIiYmIW4oamUub3JpZ2luYWxUZXh0LEFlKFZlW3R0KzFdKSx7YmFja3dhcmRzOiEwfSkmJiF1KFZlW3R0XSl8fFZlW3R0KzFdLnR5cGU9PT1cImNzcy1hdHJ1bGVcIiYmVmVbdHQrMV0ubmFtZT09PVwiZWxzZVwiJiZWZVt0dF0udHlwZSE9PVwiY3NzLWNvbW1lbnRcIj9hZS5wdXNoKFwiIFwiKTooYWUucHVzaChqZS5fX2lzSFRNTFN0eWxlQXR0cmlidXRlP2Q6eSksaShqZS5vcmlnaW5hbFRleHQsbnQuZ2V0VmFsdWUoKSxDZSkmJiF1KFZlW3R0XSkmJmFlLnB1c2goeSkpKX0sXCJub2Rlc1wiKSxhZX12YXIgQmU9LyhbXCInXSkoPzooPyFcXDEpW15cXFxcXXxcXFxcLikqXFwxL2dzLHZlPS8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbRWVdWystXT9cXGQrKT8vZyx6ZT0vW0EtWmEtel0rL2csYmU9L1skQF0/W0EtWl9hLXpcXHUwMDgwLVxcdUZGRkZdW1xcd1xcdTAwODAtXFx1RkZGRi1dKi9nLFllPW5ldyBSZWdFeHAoQmUuc291cmNlK2B8KCR7YmUuc291cmNlfSk/KCR7dmUuc291cmNlfSkoJHt6ZS5zb3VyY2V9KT9gLFwiZ1wiKTtmdW5jdGlvbiBTZShUZSxqZSl7cmV0dXJuIFRlLnJlcGxhY2UoQmUsTWU9PmEoTWUsamUpKX1mdW5jdGlvbiBJZShUZSxqZSl7bGV0IE1lPWplLnNpbmdsZVF1b3RlP1wiJ1wiOidcIic7cmV0dXJuIFRlLmluY2x1ZGVzKCdcIicpfHxUZS5pbmNsdWRlcyhcIidcIik/VGU6TWUrVGUrTWV9ZnVuY3Rpb24gT2UoVGUpe3JldHVybiBUZS5yZXBsYWNlKFllLChqZSxNZSxhZSxudCx0dCk9PiFhZSYmbnQ/SmUobnQpK20odHR8fFwiXCIpOmplKX1mdW5jdGlvbiBKZShUZSl7cmV0dXJuIHMoVGUpLnJlcGxhY2UoL1xcLjAoPz0kfGUpLyxcIlwiKX1yLmV4cG9ydHM9e3ByaW50OnllLGVtYmVkOlAsaW5zZXJ0UHJhZ21hOiQsbWFzc2FnZUFzdE5vZGU6SX19fSksTWQ9dGUoe1wic3JjL2xhbmd1YWdlLWNzcy9vcHRpb25zLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PU10KCk7ci5leHBvcnRzPXtzaW5nbGVRdW90ZTp0LnNpbmdsZVF1b3RlfX19KSxSZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtY3NzL3BhcnNlcnMuanNcIigpe25lKCl9fSksJGQ9dGUoe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL0NTUy5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e25hbWU6XCJDU1NcIix0eXBlOlwibWFya3VwXCIsdG1TY29wZTpcInNvdXJjZS5jc3NcIixhY2VNb2RlOlwiY3NzXCIsY29kZW1pcnJvck1vZGU6XCJjc3NcIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L2Nzc1wiLGNvbG9yOlwiIzU2M2Q3Y1wiLGV4dGVuc2lvbnM6W1wiLmNzc1wiXSxsYW5ndWFnZUlkOjUwfX19KSxWZD10ZSh7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvUG9zdENTUy5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e25hbWU6XCJQb3N0Q1NTXCIsdHlwZTpcIm1hcmt1cFwiLGNvbG9yOlwiI2RjM2EwY1wiLHRtU2NvcGU6XCJzb3VyY2UucG9zdGNzc1wiLGdyb3VwOlwiQ1NTXCIsZXh0ZW5zaW9uczpbXCIucGNzc1wiLFwiLnBvc3Rjc3NcIl0sYWNlTW9kZTpcInRleHRcIixsYW5ndWFnZUlkOjI2Mjc2NDQzN319fSksV2Q9dGUoe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL0xlc3MuanNvblwiKGUscil7ci5leHBvcnRzPXtuYW1lOlwiTGVzc1wiLHR5cGU6XCJtYXJrdXBcIixjb2xvcjpcIiMxZDM2NWRcIixhbGlhc2VzOltcImxlc3MtY3NzXCJdLGV4dGVuc2lvbnM6W1wiLmxlc3NcIl0sdG1TY29wZTpcInNvdXJjZS5jc3MubGVzc1wiLGFjZU1vZGU6XCJsZXNzXCIsY29kZW1pcnJvck1vZGU6XCJjc3NcIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L2Nzc1wiLGxhbmd1YWdlSWQ6MTk4fX19KSxIZD10ZSh7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvU0NTUy5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e25hbWU6XCJTQ1NTXCIsdHlwZTpcIm1hcmt1cFwiLGNvbG9yOlwiI2M2NTM4Y1wiLHRtU2NvcGU6XCJzb3VyY2UuY3NzLnNjc3NcIixhY2VNb2RlOlwic2Nzc1wiLGNvZGVtaXJyb3JNb2RlOlwiY3NzXCIsY29kZW1pcnJvck1pbWVUeXBlOlwidGV4dC94LXNjc3NcIixleHRlbnNpb25zOltcIi5zY3NzXCJdLGxhbmd1YWdlSWQ6MzI5fX19KSxHZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtY3NzL2luZGV4LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PV90KCkscz1xZCgpLGE9TWQoKSxuPVJkKCksdT1bdCgkZCgpLGw9Pih7c2luY2U6XCIxLjQuMFwiLHBhcnNlcnM6W1wiY3NzXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImNzc1wiXSxleHRlbnNpb25zOlsuLi5sLmV4dGVuc2lvbnMsXCIud3hzc1wiXX0pKSx0KFZkKCksKCk9Pih7c2luY2U6XCIxLjQuMFwiLHBhcnNlcnM6W1wiY3NzXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcInBvc3Rjc3NcIl19KSksdChXZCgpLCgpPT4oe3NpbmNlOlwiMS40LjBcIixwYXJzZXJzOltcImxlc3NcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wibGVzc1wiXX0pKSx0KEhkKCksKCk9Pih7c2luY2U6XCIxLjQuMFwiLHBhcnNlcnM6W1wic2Nzc1wiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJzY3NzXCJdfSkpXSxpPXtwb3N0Y3NzOnN9O3IuZXhwb3J0cz17bGFuZ3VhZ2VzOnUsb3B0aW9uczphLHByaW50ZXJzOmkscGFyc2VyczpufX19KSxVZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtaGFuZGxlYmFycy9sb2MuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7ZnVuY3Rpb24gdChhKXtyZXR1cm4gYS5sb2Muc3RhcnQub2Zmc2V0fWZ1bmN0aW9uIHMoYSl7cmV0dXJuIGEubG9jLmVuZC5vZmZzZXR9ci5leHBvcnRzPXtsb2NTdGFydDp0LGxvY0VuZDpzfX19KSxKZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtaGFuZGxlYmFycy9jbGVhbi5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KHMsYSl7aWYocy50eXBlPT09XCJUZXh0Tm9kZVwiKXtsZXQgbj1zLmNoYXJzLnRyaW0oKTtpZighbilyZXR1cm4gbnVsbDthLmNoYXJzPW4ucmVwbGFjZSgvW1xcdFxcblxcZlxcciBdKy9nLFwiIFwiKX1zLnR5cGU9PT1cIkF0dHJOb2RlXCImJnMubmFtZS50b0xvd2VyQ2FzZSgpPT09XCJjbGFzc1wiJiZkZWxldGUgYS52YWx1ZX10Lmlnbm9yZWRQcm9wZXJ0aWVzPW5ldyBTZXQoW1wibG9jXCIsXCJzZWxmQ2xvc2luZ1wiXSksci5leHBvcnRzPXR9fSksemQ9dGUoe1widmVuZG9ycy9odG1sLXZvaWQtZWxlbWVudHMuanNvblwiKGUscil7ci5leHBvcnRzPXtodG1sVm9pZEVsZW1lbnRzOltcImFyZWFcIixcImJhc2VcIixcImJhc2Vmb250XCIsXCJiZ3NvdW5kXCIsXCJiclwiLFwiY29sXCIsXCJjb21tYW5kXCIsXCJlbWJlZFwiLFwiZnJhbWVcIixcImhyXCIsXCJpbWFnZVwiLFwiaW1nXCIsXCJpbnB1dFwiLFwiaXNpbmRleFwiLFwia2V5Z2VuXCIsXCJsaW5rXCIsXCJtZW51aXRlbVwiLFwibWV0YVwiLFwibmV4dGlkXCIsXCJwYXJhbVwiLFwic291cmNlXCIsXCJ0cmFja1wiLFwid2JyXCJdfX19KSxYZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtaGFuZGxlYmFycy91dGlscy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7aHRtbFZvaWRFbGVtZW50czp0fT16ZCgpLHM9bHQoKTtmdW5jdGlvbiBhKFMpe2xldCBOPVMuZ2V0VmFsdWUoKSxJPVMuZ2V0UGFyZW50Tm9kZSgwKTtyZXR1cm4hISh5KFMsW1wiRWxlbWVudE5vZGVcIl0pJiZzKEkuY2hpbGRyZW4pPT09Tnx8eShTLFtcIkJsb2NrXCJdKSYmcyhJLmJvZHkpPT09Til9ZnVuY3Rpb24gbihTKXtyZXR1cm4gUy50b1VwcGVyQ2FzZSgpPT09U31mdW5jdGlvbiB1KFMpe3JldHVybiBkKFMsW1wiRWxlbWVudE5vZGVcIl0pJiZ0eXBlb2YgUy50YWc9PVwic3RyaW5nXCImJiFTLnRhZy5zdGFydHNXaXRoKFwiOlwiKSYmKG4oUy50YWdbMF0pfHxTLnRhZy5pbmNsdWRlcyhcIi5cIikpfXZhciBpPW5ldyBTZXQodCk7ZnVuY3Rpb24gbChTKXtyZXR1cm4gaS5oYXMoUy50YWcpfHxTLnNlbGZDbG9zaW5nPT09ITB8fHUoUykmJlMuY2hpbGRyZW4uZXZlcnkoTj0+cChOKSl9ZnVuY3Rpb24gcChTKXtyZXR1cm4gZChTLFtcIlRleHROb2RlXCJdKSYmIS9cXFMvLnRlc3QoUy5jaGFycyl9ZnVuY3Rpb24gZChTLE4pe3JldHVybiBTJiZOLmluY2x1ZGVzKFMudHlwZSl9ZnVuY3Rpb24geShTLE4pe2xldCBJPVMuZ2V0UGFyZW50Tm9kZSgwKTtyZXR1cm4gZChJLE4pfWZ1bmN0aW9uIGcoUyxOKXtsZXQgST1FKFMpO3JldHVybiBkKEksTil9ZnVuY3Rpb24gYyhTLE4pe2xldCBJPV8oUyk7cmV0dXJuIGQoSSxOKX1mdW5jdGlvbiBEKFMsTil7dmFyIEksUCwkLGY7bGV0IFQ9Uy5nZXRWYWx1ZSgpLG09KEk9Uy5nZXRQYXJlbnROb2RlKDApKSE9PW51bGwmJkkhPT12b2lkIDA/STp7fSx2PShQPSgkPShmPW0uY2hpbGRyZW4pIT09bnVsbCYmZiE9PXZvaWQgMD9mOm0uYm9keSkhPT1udWxsJiYkIT09dm9pZCAwPyQ6bS5wYXJ0cykhPT1udWxsJiZQIT09dm9pZCAwP1A6W10sbz12LmluZGV4T2YoVCk7cmV0dXJuIG8hPT0tMSYmdltvK05dfWZ1bmN0aW9uIEUoUyl7bGV0IE49YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOjE7cmV0dXJuIEQoUywtTil9ZnVuY3Rpb24gXyhTKXtyZXR1cm4gRChTLDEpfWZ1bmN0aW9uIHcoUyl7cmV0dXJuIGQoUyxbXCJNdXN0YWNoZUNvbW1lbnRTdGF0ZW1lbnRcIl0pJiZ0eXBlb2YgUy52YWx1ZT09XCJzdHJpbmdcIiYmUy52YWx1ZS50cmltKCk9PT1cInByZXR0aWVyLWlnbm9yZVwifWZ1bmN0aW9uIEYoUyl7bGV0IE49Uy5nZXRWYWx1ZSgpLEk9RShTLDIpO3JldHVybiB3KE4pfHx3KEkpfXIuZXhwb3J0cz17Z2V0TmV4dE5vZGU6XyxnZXRQcmV2aW91c05vZGU6RSxoYXNQcmV0dGllcklnbm9yZTpGLGlzTGFzdE5vZGVPZlNpYmxpbmdzOmEsaXNOZXh0Tm9kZU9mU29tZVR5cGU6Yyxpc05vZGVPZlNvbWVUeXBlOmQsaXNQYXJlbnRPZlNvbWVUeXBlOnksaXNQcmV2aW91c05vZGVPZlNvbWVUeXBlOmcsaXNWb2lkOmwsaXNXaGl0ZXNwYWNlTm9kZTpwfX19KSxLZD10ZSh7XCJzcmMvbGFuZ3VhZ2UtaGFuZGxlYmFycy9wcmludGVyLWdsaW1tZXIuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOntkZWRlbnQ6dCxmaWxsOnMsZ3JvdXA6YSxoYXJkbGluZTpuLGlmQnJlYWs6dSxpbmRlbnQ6aSxqb2luOmwsbGluZTpwLHNvZnRsaW5lOmR9LHV0aWxzOntnZXREb2NQYXJ0czp5LHJlcGxhY2VUZXh0RW5kT2ZMaW5lOmd9fT1xZSgpLHtnZXRQcmVmZXJyZWRRdW90ZTpjLGlzTm9uRW1wdHlBcnJheTpEfT1VZSgpLHtsb2NTdGFydDpFLGxvY0VuZDpffT1VZCgpLHc9SmQoKSx7Z2V0TmV4dE5vZGU6RixnZXRQcmV2aW91c05vZGU6UyxoYXNQcmV0dGllcklnbm9yZTpOLGlzTGFzdE5vZGVPZlNpYmxpbmdzOkksaXNOZXh0Tm9kZU9mU29tZVR5cGU6UCxpc05vZGVPZlNvbWVUeXBlOiQsaXNQYXJlbnRPZlNvbWVUeXBlOmYsaXNQcmV2aW91c05vZGVPZlNvbWVUeXBlOlQsaXNWb2lkOm0saXNXaGl0ZXNwYWNlTm9kZTp2fT1YZCgpLG89MjtmdW5jdGlvbiBoKEgsY2UsWCl7bGV0IHBlPUguZ2V0VmFsdWUoKTtpZighcGUpcmV0dXJuXCJcIjtpZihOKEgpKXJldHVybiBjZS5vcmlnaW5hbFRleHQuc2xpY2UoRShwZSksXyhwZSkpO2xldCBBZT1jZS5zaW5nbGVRdW90ZT9cIidcIjonXCInO3N3aXRjaChwZS50eXBlKXtjYXNlXCJCbG9ja1wiOmNhc2VcIlByb2dyYW1cIjpjYXNlXCJUZW1wbGF0ZVwiOnJldHVybiBhKEgubWFwKFgsXCJib2R5XCIpKTtjYXNlXCJFbGVtZW50Tm9kZVwiOntsZXQgQ2U9YSh4KEgsWCkpLGZlPWNlLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk9PT1cImlnbm9yZVwiJiZQKEgsW1wiRWxlbWVudE5vZGVcIl0pP2Q6XCJcIjtpZihtKHBlKSlyZXR1cm5bQ2UsZmVdO2xldCBBPVtcIjwvXCIscGUudGFnLFwiPlwiXTtyZXR1cm4gcGUuY2hpbGRyZW4ubGVuZ3RoPT09MD9bQ2UsaShBKSxmZV06Y2UuaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eT09PVwiaWdub3JlXCI/W0NlLGkoYihILGNlLFgpKSxuLGkoQSksZmVdOltDZSxpKGEoYihILGNlLFgpKSksaShBKSxmZV19Y2FzZVwiQmxvY2tTdGF0ZW1lbnRcIjp7bGV0IENlPUguZ2V0UGFyZW50Tm9kZSgxKTtyZXR1cm4gQ2UmJkNlLmludmVyc2UmJkNlLmludmVyc2UuYm9keS5sZW5ndGg9PT0xJiZDZS5pbnZlcnNlLmJvZHlbMF09PT1wZSYmQ2UuaW52ZXJzZS5ib2R5WzBdLnBhdGgucGFydHNbMF09PT1DZS5wYXRoLnBhcnRzWzBdP1tpZShILFgsQ2UuaW52ZXJzZS5ib2R5WzBdLnBhdGgucGFydHNbMF0pLGRlKEgsWCxjZSksdWUoSCxYLGNlKV06W2ooSCxYKSxhKFtkZShILFgsY2UpLHVlKEgsWCxjZSksZWUoSCxYLGNlKV0pXX1jYXNlXCJFbGVtZW50TW9kaWZpZXJTdGF0ZW1lbnRcIjpyZXR1cm4gYShbXCJ7e1wiLFJlKEgsWCksXCJ9fVwiXSk7Y2FzZVwiTXVzdGFjaGVTdGF0ZW1lbnRcIjpyZXR1cm4gYShbayhwZSksUmUoSCxYKSxNKHBlKV0pO2Nhc2VcIlN1YkV4cHJlc3Npb25cIjpyZXR1cm4gYShbXCIoXCIsa2UoSCxYKSxkLFwiKVwiXSk7Y2FzZVwiQXR0ck5vZGVcIjp7bGV0IENlPXBlLnZhbHVlLnR5cGU9PT1cIlRleHROb2RlXCI7aWYoQ2UmJnBlLnZhbHVlLmNoYXJzPT09XCJcIiYmRShwZS52YWx1ZSk9PT1fKHBlLnZhbHVlKSlyZXR1cm4gcGUubmFtZTtsZXQgQT1DZT9jKHBlLnZhbHVlLmNoYXJzLEFlKS5xdW90ZTpwZS52YWx1ZS50eXBlPT09XCJDb25jYXRTdGF0ZW1lbnRcIj9jKHBlLnZhbHVlLnBhcnRzLmZpbHRlcihyZT0+cmUudHlwZT09PVwiVGV4dE5vZGVcIikubWFwKHJlPT5yZS5jaGFycykuam9pbihcIlwiKSxBZSkucXVvdGU6XCJcIixHPVgoXCJ2YWx1ZVwiKTtyZXR1cm5bcGUubmFtZSxcIj1cIixBLHBlLm5hbWU9PT1cImNsYXNzXCImJkE/YShpKEcpKTpHLEFdfWNhc2VcIkNvbmNhdFN0YXRlbWVudFwiOnJldHVybiBILm1hcChYLFwicGFydHNcIik7Y2FzZVwiSGFzaFwiOnJldHVybiBsKHAsSC5tYXAoWCxcInBhaXJzXCIpKTtjYXNlXCJIYXNoUGFpclwiOnJldHVybltwZS5rZXksXCI9XCIsWChcInZhbHVlXCIpXTtjYXNlXCJUZXh0Tm9kZVwiOntsZXQgQ2U9cGUuY2hhcnMucmVwbGFjZSgve3svZyxcIlxcXFx7e1wiKSxmZT1VKEgpO2lmKGZlKXtpZihmZT09PVwiY2xhc3NcIil7bGV0IFllPUNlLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpLFNlPSExLEllPSExO3JldHVybiBmKEgsW1wiQ29uY2F0U3RhdGVtZW50XCJdKSYmKFQoSCxbXCJNdXN0YWNoZVN0YXRlbWVudFwiXSkmJi9eXFxzLy50ZXN0KENlKSYmKFNlPSEwKSxQKEgsW1wiTXVzdGFjaGVTdGF0ZW1lbnRcIl0pJiYvXFxzJC8udGVzdChDZSkmJlllIT09XCJcIiYmKEllPSEwKSksW1NlP3A6XCJcIixZZSxJZT9wOlwiXCJdfXJldHVybiBnKENlKX1sZXQgRz0vXltcXHRcXG5cXGZcXHIgXSokLy50ZXN0KENlKSxyZT0hUyhIKSx5ZT0hRihIKTtpZihjZS5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5IT09XCJpZ25vcmVcIil7bGV0IFllPS9eW1xcdFxcblxcZlxcciBdKi8sU2U9L1tcXHRcXG5cXGZcXHIgXSokLyxJZT15ZSYmZihILFtcIlRlbXBsYXRlXCJdKSxPZT1yZSYmZihILFtcIlRlbXBsYXRlXCJdKTtpZihHKXtpZihPZXx8SWUpcmV0dXJuXCJcIjtsZXQgYWU9W3BdLG50PVooQ2UpO3JldHVybiBudCYmKGFlPWdlKG50KSksSShIKSYmKGFlPWFlLm1hcCh0dD0+dCh0dCkpKSxhZX1sZXRbSmVdPUNlLm1hdGNoKFllKSxbVGVdPUNlLm1hdGNoKFNlKSxqZT1bXTtpZihKZSl7amU9W3BdO2xldCBhZT1aKEplKTthZSYmKGplPWdlKGFlKSksQ2U9Q2UucmVwbGFjZShZZSxcIlwiKX1sZXQgTWU9W107aWYoVGUpe2lmKCFJZSl7TWU9W3BdO2xldCBhZT1aKFRlKTthZSYmKE1lPWdlKGFlKSksSShIKSYmKE1lPU1lLm1hcChudD0+dChudCkpKX1DZT1DZS5yZXBsYWNlKFNlLFwiXCIpfXJldHVyblsuLi5qZSxzKEZlKENlKSksLi4uTWVdfWxldCBFZT1aKENlKSxCZT1zZShDZSksdmU9RGUoQ2UpO2lmKChyZXx8eWUpJiZHJiZmKEgsW1wiQmxvY2tcIixcIkVsZW1lbnROb2RlXCIsXCJUZW1wbGF0ZVwiXSkpcmV0dXJuXCJcIjtHJiZFZT8oQmU9TWF0aC5taW4oRWUsbyksdmU9MCk6KFAoSCxbXCJCbG9ja1N0YXRlbWVudFwiLFwiRWxlbWVudE5vZGVcIl0pJiYodmU9TWF0aC5tYXgodmUsMSkpLFQoSCxbXCJCbG9ja1N0YXRlbWVudFwiLFwiRWxlbWVudE5vZGVcIl0pJiYoQmU9TWF0aC5tYXgoQmUsMSkpKTtsZXQgemU9XCJcIixiZT1cIlwiO3JldHVybiB2ZT09PTAmJlAoSCxbXCJNdXN0YWNoZVN0YXRlbWVudFwiXSkmJihiZT1cIiBcIiksQmU9PT0wJiZUKEgsW1wiTXVzdGFjaGVTdGF0ZW1lbnRcIl0pJiYoemU9XCIgXCIpLHJlJiYoQmU9MCx6ZT1cIlwiKSx5ZSYmKHZlPTAsYmU9XCJcIiksQ2U9Q2UucmVwbGFjZSgvXltcXHRcXG5cXGZcXHIgXSsvZyx6ZSkucmVwbGFjZSgvW1xcdFxcblxcZlxcciBdKyQvLGJlKSxbLi4uZ2UoQmUpLHMoRmUoQ2UpKSwuLi5nZSh2ZSldfWNhc2VcIk11c3RhY2hlQ29tbWVudFN0YXRlbWVudFwiOntsZXQgQ2U9RShwZSksZmU9XyhwZSksQT1jZS5vcmlnaW5hbFRleHQuY2hhckF0KENlKzIpPT09XCJ+XCIsRz1jZS5vcmlnaW5hbFRleHQuY2hhckF0KGZlLTMpPT09XCJ+XCIscmU9cGUudmFsdWUuaW5jbHVkZXMoXCJ9fVwiKT9cIi0tXCI6XCJcIjtyZXR1cm5bXCJ7e1wiLEE/XCJ+XCI6XCJcIixcIiFcIixyZSxwZS52YWx1ZSxyZSxHP1wiflwiOlwiXCIsXCJ9fVwiXX1jYXNlXCJQYXRoRXhwcmVzc2lvblwiOnJldHVybiBwZS5vcmlnaW5hbDtjYXNlXCJCb29sZWFuTGl0ZXJhbFwiOnJldHVybiBTdHJpbmcocGUudmFsdWUpO2Nhc2VcIkNvbW1lbnRTdGF0ZW1lbnRcIjpyZXR1cm5bXCI8IS0tXCIscGUudmFsdWUsXCItLT5cIl07Y2FzZVwiU3RyaW5nTGl0ZXJhbFwiOntpZih3ZShIKSl7bGV0IENlPWNlLnNpbmdsZVF1b3RlPydcIic6XCInXCI7cmV0dXJuIGhlKHBlLnZhbHVlLENlKX1yZXR1cm4gaGUocGUudmFsdWUsQWUpfWNhc2VcIk51bWJlckxpdGVyYWxcIjpyZXR1cm4gU3RyaW5nKHBlLnZhbHVlKTtjYXNlXCJVbmRlZmluZWRMaXRlcmFsXCI6cmV0dXJuXCJ1bmRlZmluZWRcIjtjYXNlXCJOdWxsTGl0ZXJhbFwiOnJldHVyblwibnVsbFwiO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBnbGltbWVyIHR5cGU6IFwiK0pTT04uc3RyaW5naWZ5KHBlLnR5cGUpKX19ZnVuY3Rpb24gQyhILGNlKXtyZXR1cm4gRShIKS1FKGNlKX1mdW5jdGlvbiB4KEgsY2Upe2xldCBYPUguZ2V0VmFsdWUoKSxwZT1bXCJhdHRyaWJ1dGVzXCIsXCJtb2RpZmllcnNcIixcImNvbW1lbnRzXCJdLmZpbHRlcihDZT0+RChYW0NlXSkpLEFlPXBlLmZsYXRNYXAoQ2U9PlhbQ2VdKS5zb3J0KEMpO2ZvcihsZXQgQ2Ugb2YgcGUpSC5lYWNoKGZlPT57bGV0IEE9QWUuaW5kZXhPZihmZS5nZXRWYWx1ZSgpKTtBZS5zcGxpY2UoQSwxLFtwLGNlKCldKX0sQ2UpO3JldHVybiBEKFguYmxvY2tQYXJhbXMpJiZBZS5wdXNoKHAsb2UoWCkpLFtcIjxcIixYLnRhZyxpKEFlKSxCKFgpXX1mdW5jdGlvbiBiKEgsY2UsWCl7bGV0IEFlPUguZ2V0VmFsdWUoKS5jaGlsZHJlbi5ldmVyeShDZT0+dihDZSkpO3JldHVybiBjZS5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5PT09XCJpZ25vcmVcIiYmQWU/XCJcIjpILm1hcCgoQ2UsZmUpPT57bGV0IEE9WCgpO3JldHVybiBmZT09PTAmJmNlLmh0bWxXaGl0ZXNwYWNlU2Vuc2l0aXZpdHk9PT1cImlnbm9yZVwiP1tkLEFdOkF9LFwiY2hpbGRyZW5cIil9ZnVuY3Rpb24gQihIKXtyZXR1cm4gbShIKT91KFtkLFwiLz5cIl0sW1wiIC8+XCIsZF0pOnUoW2QsXCI+XCJdLFwiPlwiKX1mdW5jdGlvbiBrKEgpe2xldCBjZT1ILmVzY2FwZWQ9PT0hMT9cInt7e1wiOlwie3tcIixYPUguc3RyaXAmJkguc3RyaXAub3Blbj9cIn5cIjpcIlwiO3JldHVybltjZSxYXX1mdW5jdGlvbiBNKEgpe2xldCBjZT1ILmVzY2FwZWQ9PT0hMT9cIn19fVwiOlwifX1cIjtyZXR1cm5bSC5zdHJpcCYmSC5zdHJpcC5jbG9zZT9cIn5cIjpcIlwiLGNlXX1mdW5jdGlvbiBSKEgpe2xldCBjZT1rKEgpLFg9SC5vcGVuU3RyaXAub3Blbj9cIn5cIjpcIlwiO3JldHVybltjZSxYLFwiI1wiXX1mdW5jdGlvbiBxKEgpe2xldCBjZT1NKEgpO3JldHVybltILm9wZW5TdHJpcC5jbG9zZT9cIn5cIjpcIlwiLGNlXX1mdW5jdGlvbiBKKEgpe2xldCBjZT1rKEgpLFg9SC5jbG9zZVN0cmlwLm9wZW4/XCJ+XCI6XCJcIjtyZXR1cm5bY2UsWCxcIi9cIl19ZnVuY3Rpb24gTChIKXtsZXQgY2U9TShIKTtyZXR1cm5bSC5jbG9zZVN0cmlwLmNsb3NlP1wiflwiOlwiXCIsY2VdfWZ1bmN0aW9uIFEoSCl7bGV0IGNlPWsoSCksWD1ILmludmVyc2VTdHJpcC5vcGVuP1wiflwiOlwiXCI7cmV0dXJuW2NlLFhdfWZ1bmN0aW9uIFYoSCl7bGV0IGNlPU0oSCk7cmV0dXJuW0guaW52ZXJzZVN0cmlwLmNsb3NlP1wiflwiOlwiXCIsY2VdfWZ1bmN0aW9uIGooSCxjZSl7bGV0IFg9SC5nZXRWYWx1ZSgpLHBlPVIoWCksQWU9cShYKSxDZT1bTmUoSCxjZSldLGZlPVBlKEgsY2UpO2lmKGZlJiZDZS5wdXNoKHAsZmUpLEQoWC5wcm9ncmFtLmJsb2NrUGFyYW1zKSl7bGV0IEE9b2UoWC5wcm9ncmFtKTtDZS5wdXNoKHAsQSl9cmV0dXJuIGEoW3BlLGkoQ2UpLGQsQWVdKX1mdW5jdGlvbiBZKEgsY2Upe3JldHVybltjZS5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5PT09XCJpZ25vcmVcIj9uOlwiXCIsUShIKSxcImVsc2VcIixWKEgpXX1mdW5jdGlvbiBpZShILGNlLFgpe2xldCBwZT1ILmdldFZhbHVlKCksQWU9W107RChwZS5wcm9ncmFtLmJsb2NrUGFyYW1zKSYmKEFlPVtwLG9lKHBlLnByb2dyYW0pXSk7bGV0IENlPUguZ2V0UGFyZW50Tm9kZSgxKTtyZXR1cm4gYShbUShDZSksaShhKFthKFtcImVsc2VcIixwLFhdKSxwLFBlKEgsY2UpXSkpLGkoQWUpLGQsVihDZSldKX1mdW5jdGlvbiBlZShILGNlLFgpe2xldCBwZT1ILmdldFZhbHVlKCk7cmV0dXJuIFguaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eT09PVwiaWdub3JlXCI/W2xlKHBlKT9kOm4sSihwZSksY2UoXCJwYXRoXCIpLEwocGUpXTpbSihwZSksY2UoXCJwYXRoXCIpLEwocGUpXX1mdW5jdGlvbiBsZShIKXtyZXR1cm4gJChILFtcIkJsb2NrU3RhdGVtZW50XCJdKSYmSC5wcm9ncmFtLmJvZHkuZXZlcnkoY2U9PnYoY2UpKX1mdW5jdGlvbiBXKEgpe3JldHVybiBLKEgpJiZILmludmVyc2UuYm9keS5sZW5ndGg9PT0xJiYkKEguaW52ZXJzZS5ib2R5WzBdLFtcIkJsb2NrU3RhdGVtZW50XCJdKSYmSC5pbnZlcnNlLmJvZHlbMF0ucGF0aC5wYXJ0c1swXT09PUgucGF0aC5wYXJ0c1swXX1mdW5jdGlvbiBLKEgpe3JldHVybiAkKEgsW1wiQmxvY2tTdGF0ZW1lbnRcIl0pJiZILmludmVyc2V9ZnVuY3Rpb24gZGUoSCxjZSxYKXtsZXQgcGU9SC5nZXRWYWx1ZSgpO2lmKGxlKHBlKSlyZXR1cm5cIlwiO2xldCBBZT1jZShcInByb2dyYW1cIik7cmV0dXJuIFguaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eT09PVwiaWdub3JlXCI/aShbbixBZV0pOmkoQWUpfWZ1bmN0aW9uIHVlKEgsY2UsWCl7bGV0IHBlPUguZ2V0VmFsdWUoKSxBZT1jZShcImludmVyc2VcIiksQ2U9WC5odG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5PT09XCJpZ25vcmVcIj9bbixBZV06QWU7cmV0dXJuIFcocGUpP0NlOksocGUpP1tZKHBlLFgpLGkoQ2UpXTpcIlwifWZ1bmN0aW9uIEZlKEgpe3JldHVybiB5KGwocCx6KEgpKSl9ZnVuY3Rpb24geihIKXtyZXR1cm4gSC5zcGxpdCgvW1xcdFxcblxcZlxcciBdKy8pfWZ1bmN0aW9uIFUoSCl7Zm9yKGxldCBjZT0wO2NlPDI7Y2UrKyl7bGV0IFg9SC5nZXRQYXJlbnROb2RlKGNlKTtpZihYJiZYLnR5cGU9PT1cIkF0dHJOb2RlXCIpcmV0dXJuIFgubmFtZS50b0xvd2VyQ2FzZSgpfX1mdW5jdGlvbiBaKEgpe3JldHVybiBIPXR5cGVvZiBIPT1cInN0cmluZ1wiP0g6XCJcIixILnNwbGl0KGBcbmApLmxlbmd0aC0xfWZ1bmN0aW9uIHNlKEgpe0g9dHlwZW9mIEg9PVwic3RyaW5nXCI/SDpcIlwiO2xldCBjZT0oSC5tYXRjaCgvXihbXlxcU1xcblxccl0qW1xcblxccl0pKy9nKXx8W10pWzBdfHxcIlwiO3JldHVybiBaKGNlKX1mdW5jdGlvbiBEZShIKXtIPXR5cGVvZiBIPT1cInN0cmluZ1wiP0g6XCJcIjtsZXQgY2U9KEgubWF0Y2goLyhbXFxuXFxyXVteXFxTXFxuXFxyXSopKyQvZyl8fFtdKVswXXx8XCJcIjtyZXR1cm4gWihjZSl9ZnVuY3Rpb24gZ2UoKXtsZXQgSD1hcmd1bWVudHMubGVuZ3RoPjAmJmFyZ3VtZW50c1swXSE9PXZvaWQgMD9hcmd1bWVudHNbMF06MDtyZXR1cm4gQXJyYXkuZnJvbSh7bGVuZ3RoOk1hdGgubWluKEgsbyl9KS5maWxsKG4pfWZ1bmN0aW9uIGhlKEgsY2Upe2xldHtxdW90ZTpYLHJlZ2V4OnBlfT1jKEgsY2UpO3JldHVybltYLEgucmVwbGFjZShwZSxgXFxcXCR7WH1gKSxYXX1mdW5jdGlvbiB3ZShIKXtsZXQgY2U9MCxYPUguZ2V0UGFyZW50Tm9kZShjZSk7Zm9yKDtYJiYkKFgsW1wiU3ViRXhwcmVzc2lvblwiXSk7KWNlKyssWD1ILmdldFBhcmVudE5vZGUoY2UpO3JldHVybiEhKFgmJiQoSC5nZXRQYXJlbnROb2RlKGNlKzEpLFtcIkNvbmNhdFN0YXRlbWVudFwiXSkmJiQoSC5nZXRQYXJlbnROb2RlKGNlKzIpLFtcIkF0dHJOb2RlXCJdKSl9ZnVuY3Rpb24ga2UoSCxjZSl7bGV0IFg9TmUoSCxjZSkscGU9UGUoSCxjZSk7cmV0dXJuIHBlP2koW1gscCxhKHBlKV0pOlh9ZnVuY3Rpb24gUmUoSCxjZSl7bGV0IFg9TmUoSCxjZSkscGU9UGUoSCxjZSk7cmV0dXJuIHBlP1tpKFtYLHAscGVdKSxkXTpYfWZ1bmN0aW9uIE5lKEgsY2Upe3JldHVybiBjZShcInBhdGhcIil9ZnVuY3Rpb24gUGUoSCxjZSl7bGV0IFg9SC5nZXRWYWx1ZSgpLHBlPVtdO2lmKFgucGFyYW1zLmxlbmd0aD4wKXtsZXQgQWU9SC5tYXAoY2UsXCJwYXJhbXNcIik7cGUucHVzaCguLi5BZSl9aWYoWC5oYXNoJiZYLmhhc2gucGFpcnMubGVuZ3RoPjApe2xldCBBZT1jZShcImhhc2hcIik7cGUucHVzaChBZSl9cmV0dXJuIHBlLmxlbmd0aD09PTA/XCJcIjpsKHAscGUpfWZ1bmN0aW9uIG9lKEgpe3JldHVybltcImFzIHxcIixILmJsb2NrUGFyYW1zLmpvaW4oXCIgXCIpLFwifFwiXX1yLmV4cG9ydHM9e3ByaW50OmgsbWFzc2FnZUFzdE5vZGU6d319fSksWWQ9dGUoe1wic3JjL2xhbmd1YWdlLWhhbmRsZWJhcnMvcGFyc2Vycy5qc1wiKCl7bmUoKX19KSxRZD10ZSh7XCJub2RlX21vZHVsZXMvbGluZ3Vpc3QtbGFuZ3VhZ2VzL2RhdGEvSGFuZGxlYmFycy5qc29uXCIoZSxyKXtyLmV4cG9ydHM9e25hbWU6XCJIYW5kbGViYXJzXCIsdHlwZTpcIm1hcmt1cFwiLGNvbG9yOlwiI2Y3OTMxZVwiLGFsaWFzZXM6W1wiaGJzXCIsXCJodG1sYmFyc1wiXSxleHRlbnNpb25zOltcIi5oYW5kbGViYXJzXCIsXCIuaGJzXCJdLHRtU2NvcGU6XCJ0ZXh0Lmh0bWwuaGFuZGxlYmFyc1wiLGFjZU1vZGU6XCJoYW5kbGViYXJzXCIsbGFuZ3VhZ2VJZDoxNTV9fX0pLFpkPXRlKHtcInNyYy9sYW5ndWFnZS1oYW5kbGViYXJzL2luZGV4LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PV90KCkscz1LZCgpLGE9WWQoKSxuPVt0KFFkKCksKCk9Pih7c2luY2U6XCIyLjMuMFwiLHBhcnNlcnM6W1wiZ2xpbW1lclwiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJoYW5kbGViYXJzXCJdfSkpXSx1PXtnbGltbWVyOnN9O3IuZXhwb3J0cz17bGFuZ3VhZ2VzOm4scHJpbnRlcnM6dSxwYXJzZXJzOmF9fX0pLGVnPXRlKHtcInNyYy9sYW5ndWFnZS1ncmFwaHFsL3ByYWdtYS5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KGEpe3JldHVybi9eXFxzKiNbXlxcU1xcbl0qQCg/OmZvcm1hdHxwcmV0dGllcilcXHMqKD86XFxufCQpLy50ZXN0KGEpfWZ1bmN0aW9uIHMoYSl7cmV0dXJuYCMgQGZvcm1hdFxuXG5gK2F9ci5leHBvcnRzPXtoYXNQcmFnbWE6dCxpbnNlcnRQcmFnbWE6c319fSksdGc9dGUoe1wic3JjL2xhbmd1YWdlLWdyYXBocWwvbG9jLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO2Z1bmN0aW9uIHQoYSl7cmV0dXJuIHR5cGVvZiBhLnN0YXJ0PT1cIm51bWJlclwiP2Euc3RhcnQ6YS5sb2MmJmEubG9jLnN0YXJ0fWZ1bmN0aW9uIHMoYSl7cmV0dXJuIHR5cGVvZiBhLmVuZD09XCJudW1iZXJcIj9hLmVuZDphLmxvYyYmYS5sb2MuZW5kfXIuZXhwb3J0cz17bG9jU3RhcnQ6dCxsb2NFbmQ6c319fSkscmc9dGUoe1wic3JjL2xhbmd1YWdlLWdyYXBocWwvcHJpbnRlci1ncmFwaHFsLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7am9pbjp0LGhhcmRsaW5lOnMsbGluZTphLHNvZnRsaW5lOm4sZ3JvdXA6dSxpbmRlbnQ6aSxpZkJyZWFrOmx9fT1xZSgpLHtpc05leHRMaW5lRW1wdHk6cCxpc05vbkVtcHR5QXJyYXk6ZH09VWUoKSx7aW5zZXJ0UHJhZ21hOnl9PWVnKCkse2xvY1N0YXJ0OmcsbG9jRW5kOmN9PXRnKCk7ZnVuY3Rpb24gRChQLCQsZil7bGV0IFQ9UC5nZXRWYWx1ZSgpO2lmKCFUKXJldHVyblwiXCI7aWYodHlwZW9mIFQ9PVwic3RyaW5nXCIpcmV0dXJuIFQ7c3dpdGNoKFQua2luZCl7Y2FzZVwiRG9jdW1lbnRcIjp7bGV0IG09W107cmV0dXJuIFAuZWFjaCgodixvLGgpPT57bS5wdXNoKGYoKSksbyE9PWgubGVuZ3RoLTEmJihtLnB1c2gocykscCgkLm9yaWdpbmFsVGV4dCx2LmdldFZhbHVlKCksYykmJm0ucHVzaChzKSl9LFwiZGVmaW5pdGlvbnNcIiksWy4uLm0sc119Y2FzZVwiT3BlcmF0aW9uRGVmaW5pdGlvblwiOntsZXQgbT0kLm9yaWdpbmFsVGV4dFtnKFQpXSE9PVwie1wiLHY9Qm9vbGVhbihULm5hbWUpO3JldHVyblttP1Qub3BlcmF0aW9uOlwiXCIsbSYmdj9bXCIgXCIsZihcIm5hbWVcIildOlwiXCIsbSYmIXYmJmQoVC52YXJpYWJsZURlZmluaXRpb25zKT9cIiBcIjpcIlwiLGQoVC52YXJpYWJsZURlZmluaXRpb25zKT91KFtcIihcIixpKFtuLHQoW2woXCJcIixcIiwgXCIpLG5dLFAubWFwKGYsXCJ2YXJpYWJsZURlZmluaXRpb25zXCIpKV0pLG4sXCIpXCJdKTpcIlwiLEUoUCxmLFQpLFQuc2VsZWN0aW9uU2V0PyFtJiYhdj9cIlwiOlwiIFwiOlwiXCIsZihcInNlbGVjdGlvblNldFwiKV19Y2FzZVwiRnJhZ21lbnREZWZpbml0aW9uXCI6cmV0dXJuW1wiZnJhZ21lbnQgXCIsZihcIm5hbWVcIiksZChULnZhcmlhYmxlRGVmaW5pdGlvbnMpP3UoW1wiKFwiLGkoW24sdChbbChcIlwiLFwiLCBcIiksbl0sUC5tYXAoZixcInZhcmlhYmxlRGVmaW5pdGlvbnNcIikpXSksbixcIilcIl0pOlwiXCIsXCIgb24gXCIsZihcInR5cGVDb25kaXRpb25cIiksRShQLGYsVCksXCIgXCIsZihcInNlbGVjdGlvblNldFwiKV07Y2FzZVwiU2VsZWN0aW9uU2V0XCI6cmV0dXJuW1wie1wiLGkoW3MsdChzLF8oUCwkLGYsXCJzZWxlY3Rpb25zXCIpKV0pLHMsXCJ9XCJdO2Nhc2VcIkZpZWxkXCI6cmV0dXJuIHUoW1QuYWxpYXM/W2YoXCJhbGlhc1wiKSxcIjogXCJdOlwiXCIsZihcIm5hbWVcIiksVC5hcmd1bWVudHMubGVuZ3RoPjA/dShbXCIoXCIsaShbbix0KFtsKFwiXCIsXCIsIFwiKSxuXSxfKFAsJCxmLFwiYXJndW1lbnRzXCIpKV0pLG4sXCIpXCJdKTpcIlwiLEUoUCxmLFQpLFQuc2VsZWN0aW9uU2V0P1wiIFwiOlwiXCIsZihcInNlbGVjdGlvblNldFwiKV0pO2Nhc2VcIk5hbWVcIjpyZXR1cm4gVC52YWx1ZTtjYXNlXCJTdHJpbmdWYWx1ZVwiOntpZihULmJsb2NrKXtsZXQgbT1ULnZhbHVlLnJlcGxhY2UoL1wiXCJcIi9nLFwiXFxcXCQmXCIpLnNwbGl0KGBcbmApO3JldHVybiBtLmxlbmd0aD09PTEmJihtWzBdPW1bMF0udHJpbSgpKSxtLmV2ZXJ5KHY9PnY9PT1cIlwiKSYmKG0ubGVuZ3RoPTApLHQocyxbJ1wiXCJcIicsLi4ubSwnXCJcIlwiJ10pfXJldHVyblsnXCInLFQudmFsdWUucmVwbGFjZSgvW1wiXFxcXF0vZyxcIlxcXFwkJlwiKS5yZXBsYWNlKC9cXG4vZyxcIlxcXFxuXCIpLCdcIiddfWNhc2VcIkludFZhbHVlXCI6Y2FzZVwiRmxvYXRWYWx1ZVwiOmNhc2VcIkVudW1WYWx1ZVwiOnJldHVybiBULnZhbHVlO2Nhc2VcIkJvb2xlYW5WYWx1ZVwiOnJldHVybiBULnZhbHVlP1widHJ1ZVwiOlwiZmFsc2VcIjtjYXNlXCJOdWxsVmFsdWVcIjpyZXR1cm5cIm51bGxcIjtjYXNlXCJWYXJpYWJsZVwiOnJldHVybltcIiRcIixmKFwibmFtZVwiKV07Y2FzZVwiTGlzdFZhbHVlXCI6cmV0dXJuIHUoW1wiW1wiLGkoW24sdChbbChcIlwiLFwiLCBcIiksbl0sUC5tYXAoZixcInZhbHVlc1wiKSldKSxuLFwiXVwiXSk7Y2FzZVwiT2JqZWN0VmFsdWVcIjpyZXR1cm4gdShbXCJ7XCIsJC5icmFja2V0U3BhY2luZyYmVC5maWVsZHMubGVuZ3RoPjA/XCIgXCI6XCJcIixpKFtuLHQoW2woXCJcIixcIiwgXCIpLG5dLFAubWFwKGYsXCJmaWVsZHNcIikpXSksbixsKFwiXCIsJC5icmFja2V0U3BhY2luZyYmVC5maWVsZHMubGVuZ3RoPjA/XCIgXCI6XCJcIiksXCJ9XCJdKTtjYXNlXCJPYmplY3RGaWVsZFwiOmNhc2VcIkFyZ3VtZW50XCI6cmV0dXJuW2YoXCJuYW1lXCIpLFwiOiBcIixmKFwidmFsdWVcIildO2Nhc2VcIkRpcmVjdGl2ZVwiOnJldHVybltcIkBcIixmKFwibmFtZVwiKSxULmFyZ3VtZW50cy5sZW5ndGg+MD91KFtcIihcIixpKFtuLHQoW2woXCJcIixcIiwgXCIpLG5dLF8oUCwkLGYsXCJhcmd1bWVudHNcIikpXSksbixcIilcIl0pOlwiXCJdO2Nhc2VcIk5hbWVkVHlwZVwiOnJldHVybiBmKFwibmFtZVwiKTtjYXNlXCJWYXJpYWJsZURlZmluaXRpb25cIjpyZXR1cm5bZihcInZhcmlhYmxlXCIpLFwiOiBcIixmKFwidHlwZVwiKSxULmRlZmF1bHRWYWx1ZT9bXCIgPSBcIixmKFwiZGVmYXVsdFZhbHVlXCIpXTpcIlwiLEUoUCxmLFQpXTtjYXNlXCJPYmplY3RUeXBlRXh0ZW5zaW9uXCI6Y2FzZVwiT2JqZWN0VHlwZURlZmluaXRpb25cIjpyZXR1cm5bZihcImRlc2NyaXB0aW9uXCIpLFQuZGVzY3JpcHRpb24/czpcIlwiLFQua2luZD09PVwiT2JqZWN0VHlwZUV4dGVuc2lvblwiP1wiZXh0ZW5kIFwiOlwiXCIsXCJ0eXBlIFwiLGYoXCJuYW1lXCIpLFQuaW50ZXJmYWNlcy5sZW5ndGg+MD9bXCIgaW1wbGVtZW50cyBcIiwuLi5TKFAsJCxmKV06XCJcIixFKFAsZixUKSxULmZpZWxkcy5sZW5ndGg+MD9bXCIge1wiLGkoW3MsdChzLF8oUCwkLGYsXCJmaWVsZHNcIikpXSkscyxcIn1cIl06XCJcIl07Y2FzZVwiRmllbGREZWZpbml0aW9uXCI6cmV0dXJuW2YoXCJkZXNjcmlwdGlvblwiKSxULmRlc2NyaXB0aW9uP3M6XCJcIixmKFwibmFtZVwiKSxULmFyZ3VtZW50cy5sZW5ndGg+MD91KFtcIihcIixpKFtuLHQoW2woXCJcIixcIiwgXCIpLG5dLF8oUCwkLGYsXCJhcmd1bWVudHNcIikpXSksbixcIilcIl0pOlwiXCIsXCI6IFwiLGYoXCJ0eXBlXCIpLEUoUCxmLFQpXTtjYXNlXCJEaXJlY3RpdmVEZWZpbml0aW9uXCI6cmV0dXJuW2YoXCJkZXNjcmlwdGlvblwiKSxULmRlc2NyaXB0aW9uP3M6XCJcIixcImRpcmVjdGl2ZSBcIixcIkBcIixmKFwibmFtZVwiKSxULmFyZ3VtZW50cy5sZW5ndGg+MD91KFtcIihcIixpKFtuLHQoW2woXCJcIixcIiwgXCIpLG5dLF8oUCwkLGYsXCJhcmd1bWVudHNcIikpXSksbixcIilcIl0pOlwiXCIsVC5yZXBlYXRhYmxlP1wiIHJlcGVhdGFibGVcIjpcIlwiLFwiIG9uIFwiLHQoXCIgfCBcIixQLm1hcChmLFwibG9jYXRpb25zXCIpKV07Y2FzZVwiRW51bVR5cGVFeHRlbnNpb25cIjpjYXNlXCJFbnVtVHlwZURlZmluaXRpb25cIjpyZXR1cm5bZihcImRlc2NyaXB0aW9uXCIpLFQuZGVzY3JpcHRpb24/czpcIlwiLFQua2luZD09PVwiRW51bVR5cGVFeHRlbnNpb25cIj9cImV4dGVuZCBcIjpcIlwiLFwiZW51bSBcIixmKFwibmFtZVwiKSxFKFAsZixUKSxULnZhbHVlcy5sZW5ndGg+MD9bXCIge1wiLGkoW3MsdChzLF8oUCwkLGYsXCJ2YWx1ZXNcIikpXSkscyxcIn1cIl06XCJcIl07Y2FzZVwiRW51bVZhbHVlRGVmaW5pdGlvblwiOnJldHVybltmKFwiZGVzY3JpcHRpb25cIiksVC5kZXNjcmlwdGlvbj9zOlwiXCIsZihcIm5hbWVcIiksRShQLGYsVCldO2Nhc2VcIklucHV0VmFsdWVEZWZpbml0aW9uXCI6cmV0dXJuW2YoXCJkZXNjcmlwdGlvblwiKSxULmRlc2NyaXB0aW9uP1QuZGVzY3JpcHRpb24uYmxvY2s/czphOlwiXCIsZihcIm5hbWVcIiksXCI6IFwiLGYoXCJ0eXBlXCIpLFQuZGVmYXVsdFZhbHVlP1tcIiA9IFwiLGYoXCJkZWZhdWx0VmFsdWVcIildOlwiXCIsRShQLGYsVCldO2Nhc2VcIklucHV0T2JqZWN0VHlwZUV4dGVuc2lvblwiOmNhc2VcIklucHV0T2JqZWN0VHlwZURlZmluaXRpb25cIjpyZXR1cm5bZihcImRlc2NyaXB0aW9uXCIpLFQuZGVzY3JpcHRpb24/czpcIlwiLFQua2luZD09PVwiSW5wdXRPYmplY3RUeXBlRXh0ZW5zaW9uXCI/XCJleHRlbmQgXCI6XCJcIixcImlucHV0IFwiLGYoXCJuYW1lXCIpLEUoUCxmLFQpLFQuZmllbGRzLmxlbmd0aD4wP1tcIiB7XCIsaShbcyx0KHMsXyhQLCQsZixcImZpZWxkc1wiKSldKSxzLFwifVwiXTpcIlwiXTtjYXNlXCJTY2hlbWFFeHRlbnNpb25cIjpyZXR1cm5bXCJleHRlbmQgc2NoZW1hXCIsRShQLGYsVCksLi4uVC5vcGVyYXRpb25UeXBlcy5sZW5ndGg+MD9bXCIge1wiLGkoW3MsdChzLF8oUCwkLGYsXCJvcGVyYXRpb25UeXBlc1wiKSldKSxzLFwifVwiXTpbXV07Y2FzZVwiU2NoZW1hRGVmaW5pdGlvblwiOnJldHVybltmKFwiZGVzY3JpcHRpb25cIiksVC5kZXNjcmlwdGlvbj9zOlwiXCIsXCJzY2hlbWFcIixFKFAsZixUKSxcIiB7XCIsVC5vcGVyYXRpb25UeXBlcy5sZW5ndGg+MD9pKFtzLHQocyxfKFAsJCxmLFwib3BlcmF0aW9uVHlwZXNcIikpXSk6XCJcIixzLFwifVwiXTtjYXNlXCJPcGVyYXRpb25UeXBlRGVmaW5pdGlvblwiOnJldHVybltmKFwib3BlcmF0aW9uXCIpLFwiOiBcIixmKFwidHlwZVwiKV07Y2FzZVwiSW50ZXJmYWNlVHlwZUV4dGVuc2lvblwiOmNhc2VcIkludGVyZmFjZVR5cGVEZWZpbml0aW9uXCI6cmV0dXJuW2YoXCJkZXNjcmlwdGlvblwiKSxULmRlc2NyaXB0aW9uP3M6XCJcIixULmtpbmQ9PT1cIkludGVyZmFjZVR5cGVFeHRlbnNpb25cIj9cImV4dGVuZCBcIjpcIlwiLFwiaW50ZXJmYWNlIFwiLGYoXCJuYW1lXCIpLFQuaW50ZXJmYWNlcy5sZW5ndGg+MD9bXCIgaW1wbGVtZW50cyBcIiwuLi5TKFAsJCxmKV06XCJcIixFKFAsZixUKSxULmZpZWxkcy5sZW5ndGg+MD9bXCIge1wiLGkoW3MsdChzLF8oUCwkLGYsXCJmaWVsZHNcIikpXSkscyxcIn1cIl06XCJcIl07Y2FzZVwiRnJhZ21lbnRTcHJlYWRcIjpyZXR1cm5bXCIuLi5cIixmKFwibmFtZVwiKSxFKFAsZixUKV07Y2FzZVwiSW5saW5lRnJhZ21lbnRcIjpyZXR1cm5bXCIuLi5cIixULnR5cGVDb25kaXRpb24/W1wiIG9uIFwiLGYoXCJ0eXBlQ29uZGl0aW9uXCIpXTpcIlwiLEUoUCxmLFQpLFwiIFwiLGYoXCJzZWxlY3Rpb25TZXRcIildO2Nhc2VcIlVuaW9uVHlwZUV4dGVuc2lvblwiOmNhc2VcIlVuaW9uVHlwZURlZmluaXRpb25cIjpyZXR1cm4gdShbZihcImRlc2NyaXB0aW9uXCIpLFQuZGVzY3JpcHRpb24/czpcIlwiLHUoW1Qua2luZD09PVwiVW5pb25UeXBlRXh0ZW5zaW9uXCI/XCJleHRlbmQgXCI6XCJcIixcInVuaW9uIFwiLGYoXCJuYW1lXCIpLEUoUCxmLFQpLFQudHlwZXMubGVuZ3RoPjA/W1wiID1cIixsKFwiXCIsXCIgXCIpLGkoW2woW2EsXCIgIFwiXSksdChbYSxcInwgXCJdLFAubWFwKGYsXCJ0eXBlc1wiKSldKV06XCJcIl0pXSk7Y2FzZVwiU2NhbGFyVHlwZUV4dGVuc2lvblwiOmNhc2VcIlNjYWxhclR5cGVEZWZpbml0aW9uXCI6cmV0dXJuW2YoXCJkZXNjcmlwdGlvblwiKSxULmRlc2NyaXB0aW9uP3M6XCJcIixULmtpbmQ9PT1cIlNjYWxhclR5cGVFeHRlbnNpb25cIj9cImV4dGVuZCBcIjpcIlwiLFwic2NhbGFyIFwiLGYoXCJuYW1lXCIpLEUoUCxmLFQpXTtjYXNlXCJOb25OdWxsVHlwZVwiOnJldHVybltmKFwidHlwZVwiKSxcIiFcIl07Y2FzZVwiTGlzdFR5cGVcIjpyZXR1cm5bXCJbXCIsZihcInR5cGVcIiksXCJdXCJdO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKFwidW5rbm93biBncmFwaHFsIHR5cGU6IFwiK0pTT04uc3RyaW5naWZ5KFQua2luZCkpfX1mdW5jdGlvbiBFKFAsJCxmKXtpZihmLmRpcmVjdGl2ZXMubGVuZ3RoPT09MClyZXR1cm5cIlwiO2xldCBUPXQoYSxQLm1hcCgkLFwiZGlyZWN0aXZlc1wiKSk7cmV0dXJuIGYua2luZD09PVwiRnJhZ21lbnREZWZpbml0aW9uXCJ8fGYua2luZD09PVwiT3BlcmF0aW9uRGVmaW5pdGlvblwiP3UoW2EsVF0pOltcIiBcIix1KGkoW24sVF0pKV19ZnVuY3Rpb24gXyhQLCQsZixUKXtyZXR1cm4gUC5tYXAoKG0sdixvKT0+e2xldCBoPWYoKTtyZXR1cm4gdjxvLmxlbmd0aC0xJiZwKCQub3JpZ2luYWxUZXh0LG0uZ2V0VmFsdWUoKSxjKT9baCxzXTpofSxUKX1mdW5jdGlvbiB3KFApe3JldHVybiBQLmtpbmQmJlAua2luZCE9PVwiQ29tbWVudFwifWZ1bmN0aW9uIEYoUCl7bGV0ICQ9UC5nZXRWYWx1ZSgpO2lmKCQua2luZD09PVwiQ29tbWVudFwiKXJldHVyblwiI1wiKyQudmFsdWUudHJpbUVuZCgpO3Rocm93IG5ldyBFcnJvcihcIk5vdCBhIGNvbW1lbnQ6IFwiK0pTT04uc3RyaW5naWZ5KCQpKX1mdW5jdGlvbiBTKFAsJCxmKXtsZXQgVD1QLmdldE5vZGUoKSxtPVtdLHtpbnRlcmZhY2VzOnZ9PVQsbz1QLm1hcChoPT5mKGgpLFwiaW50ZXJmYWNlc1wiKTtmb3IobGV0IGg9MDtoPHYubGVuZ3RoO2grKyl7bGV0IEM9dltoXTttLnB1c2gob1toXSk7bGV0IHg9dltoKzFdO2lmKHgpe2xldCBiPSQub3JpZ2luYWxUZXh0LnNsaWNlKEMubG9jLmVuZCx4LmxvYy5zdGFydCksQj1iLmluY2x1ZGVzKFwiI1wiKSxrPWIucmVwbGFjZSgvIy4qL2csXCJcIikudHJpbSgpO20ucHVzaChrPT09XCIsXCI/XCIsXCI6XCIgJlwiLEI/YTpcIiBcIil9fXJldHVybiBtfWZ1bmN0aW9uIE4oUCwkKXtQLmtpbmQ9PT1cIlN0cmluZ1ZhbHVlXCImJlAuYmxvY2smJiFQLnZhbHVlLmluY2x1ZGVzKGBcbmApJiYoJC52YWx1ZT0kLnZhbHVlLnRyaW0oKSl9Ti5pZ25vcmVkUHJvcGVydGllcz1uZXcgU2V0KFtcImxvY1wiLFwiY29tbWVudHNcIl0pO2Z1bmN0aW9uIEkoUCl7dmFyICQ7bGV0IGY9UC5nZXRWYWx1ZSgpO3JldHVybiBmPT1udWxsfHwoJD1mLmNvbW1lbnRzKT09PW51bGx8fCQ9PT12b2lkIDA/dm9pZCAwOiQuc29tZShUPT5ULnZhbHVlLnRyaW0oKT09PVwicHJldHRpZXItaWdub3JlXCIpfXIuZXhwb3J0cz17cHJpbnQ6RCxtYXNzYWdlQXN0Tm9kZTpOLGhhc1ByZXR0aWVySWdub3JlOkksaW5zZXJ0UHJhZ21hOnkscHJpbnRDb21tZW50OkYsY2FuQXR0YWNoQ29tbWVudDp3fX19KSxuZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtZ3JhcGhxbC9vcHRpb25zLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PU10KCk7ci5leHBvcnRzPXticmFja2V0U3BhY2luZzp0LmJyYWNrZXRTcGFjaW5nfX19KSx1Zz10ZSh7XCJzcmMvbGFuZ3VhZ2UtZ3JhcGhxbC9wYXJzZXJzLmpzXCIoKXtuZSgpfX0pLHNnPXRlKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9HcmFwaFFMLmpzb25cIihlLHIpe3IuZXhwb3J0cz17bmFtZTpcIkdyYXBoUUxcIix0eXBlOlwiZGF0YVwiLGNvbG9yOlwiI2UxMDA5OFwiLGV4dGVuc2lvbnM6W1wiLmdyYXBocWxcIixcIi5ncWxcIixcIi5ncmFwaHFsc1wiXSx0bVNjb3BlOlwic291cmNlLmdyYXBocWxcIixhY2VNb2RlOlwidGV4dFwiLGxhbmd1YWdlSWQ6MTM5fX19KSxpZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtZ3JhcGhxbC9pbmRleC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1fdCgpLHM9cmcoKSxhPW5nKCksbj11ZygpLHU9W3Qoc2coKSwoKT0+KHtzaW5jZTpcIjEuNS4wXCIscGFyc2VyczpbXCJncmFwaHFsXCJdLHZzY29kZUxhbmd1YWdlSWRzOltcImdyYXBocWxcIl19KSldLGk9e2dyYXBocWw6c307ci5leHBvcnRzPXtsYW5ndWFnZXM6dSxvcHRpb25zOmEscHJpbnRlcnM6aSxwYXJzZXJzOm59fX0pLFBvPXRlKHtcIm5vZGVfbW9kdWxlcy9jb2xsYXBzZS13aGl0ZS1zcGFjZS9pbmRleC5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxyLmV4cG9ydHM9dDtmdW5jdGlvbiB0KHMpe3JldHVybiBTdHJpbmcocykucmVwbGFjZSgvXFxzKy9nLFwiIFwiKX19fSksSW89dGUoe1wic3JjL2xhbmd1YWdlLW1hcmtkb3duL2xvYy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KGEpe3JldHVybiBhLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldH1mdW5jdGlvbiBzKGEpe3JldHVybiBhLnBvc2l0aW9uLmVuZC5vZmZzZXR9ci5leHBvcnRzPXtsb2NTdGFydDp0LGxvY0VuZDpzfX19KSxhZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vY29uc3RhbnRzLmV2YWx1YXRlLmpzXCIoZSxyKXtyLmV4cG9ydHM9e2Nqa1BhdHRlcm46XCIoPzpbXFxcXHUwMmVhLVxcXFx1MDJlYlxcXFx1MTEwMC1cXFxcdTExZmZcXFxcdTJlODAtXFxcXHUyZTk5XFxcXHUyZTliLVxcXFx1MmVmM1xcXFx1MmYwMC1cXFxcdTJmZDVcXFxcdTJmZjAtXFxcXHUzMDNmXFxcXHUzMDQxLVxcXFx1MzA5NlxcXFx1MzA5OS1cXFxcdTMwOWZcXFxcdTMwYTEtXFxcXHUzMGZhXFxcXHUzMGZjLVxcXFx1MzBmZlxcXFx1MzEwNS1cXFxcdTMxMmZcXFxcdTMxMzEtXFxcXHUzMThlXFxcXHUzMTkwLVxcXFx1MzE5MVxcXFx1MzE5Ni1cXFxcdTMxYmFcXFxcdTMxYzAtXFxcXHUzMWUzXFxcXHUzMWYwLVxcXFx1MzIxZVxcXFx1MzIyYS1cXFxcdTMyNDdcXFxcdTMyNjAtXFxcXHUzMjdlXFxcXHUzMjhhLVxcXFx1MzJiMFxcXFx1MzJjMC1cXFxcdTMyY2JcXFxcdTMyZDAtXFxcXHUzMzcwXFxcXHUzMzdiLVxcXFx1MzM3ZlxcXFx1MzNlMC1cXFxcdTMzZmVcXFxcdTM0MDAtXFxcXHU0ZGI1XFxcXHU0ZTAwLVxcXFx1OWZlZlxcXFx1YTk2MC1cXFxcdWE5N2NcXFxcdWFjMDAtXFxcXHVkN2EzXFxcXHVkN2IwLVxcXFx1ZDdjNlxcXFx1ZDdjYi1cXFxcdWQ3ZmJcXFxcdWY5MDAtXFxcXHVmYTZkXFxcXHVmYTcwLVxcXFx1ZmFkOVxcXFx1ZmUxMC1cXFxcdWZlMWZcXFxcdWZlMzAtXFxcXHVmZTZmXFxcXHVmZjAwLVxcXFx1ZmZlZl18W1xcXFx1ZDg0MC1cXFxcdWQ4NjhcXFxcdWQ4NmEtXFxcXHVkODZjXFxcXHVkODZmLVxcXFx1ZDg3MlxcXFx1ZDg3NC1cXFxcdWQ4NzldW1xcXFx1ZGMwMC1cXFxcdWRmZmZdfFxcXFx1ZDgyY1tcXFxcdWRjMDAtXFxcXHVkZDFlXFxcXHVkZDUwLVxcXFx1ZGQ1MlxcXFx1ZGQ2NC1cXFxcdWRkNjddfFxcXFx1ZDgzY1tcXFxcdWRlMDBcXFxcdWRlNTAtXFxcXHVkZTUxXXxcXFxcdWQ4NjlbXFxcXHVkYzAwLVxcXFx1ZGVkNlxcXFx1ZGYwMC1cXFxcdWRmZmZdfFxcXFx1ZDg2ZFtcXFxcdWRjMDAtXFxcXHVkZjM0XFxcXHVkZjQwLVxcXFx1ZGZmZl18XFxcXHVkODZlW1xcXFx1ZGMwMC1cXFxcdWRjMWRcXFxcdWRjMjAtXFxcXHVkZmZmXXxcXFxcdWQ4NzNbXFxcXHVkYzAwLVxcXFx1ZGVhMVxcXFx1ZGViMC1cXFxcdWRmZmZdfFxcXFx1ZDg3YVtcXFxcdWRjMDAtXFxcXHVkZmUwXXxcXFxcdWQ4N2VbXFxcXHVkYzAwLVxcXFx1ZGUxZF0pKD86W1xcXFx1ZmUwMC1cXFxcdWZlMGZdfFxcXFx1ZGI0MFtcXFxcdWRkMDAtXFxcXHVkZGVmXSk/XCIsa1BhdHRlcm46XCJbXFxcXHUxMTAwLVxcXFx1MTFmZlxcXFx1MzAwMS1cXFxcdTMwMDNcXFxcdTMwMDgtXFxcXHUzMDExXFxcXHUzMDEzLVxcXFx1MzAxZlxcXFx1MzAyZS1cXFxcdTMwMzBcXFxcdTMwMzdcXFxcdTMwZmJcXFxcdTMxMzEtXFxcXHUzMThlXFxcXHUzMjAwLVxcXFx1MzIxZVxcXFx1MzI2MC1cXFxcdTMyN2VcXFxcdWE5NjAtXFxcXHVhOTdjXFxcXHVhYzAwLVxcXFx1ZDdhM1xcXFx1ZDdiMC1cXFxcdWQ3YzZcXFxcdWQ3Y2ItXFxcXHVkN2ZiXFxcXHVmZTQ1LVxcXFx1ZmU0NlxcXFx1ZmY2MS1cXFxcdWZmNjVcXFxcdWZmYTAtXFxcXHVmZmJlXFxcXHVmZmMyLVxcXFx1ZmZjN1xcXFx1ZmZjYS1cXFxcdWZmY2ZcXFxcdWZmZDItXFxcXHVmZmQ3XFxcXHVmZmRhLVxcXFx1ZmZkY11cIixwdW5jdHVhdGlvblBhdHRlcm46XCJbXFxcXHUwMDIxLVxcXFx1MDAyZlxcXFx1MDAzYS1cXFxcdTAwNDBcXFxcdTAwNWItXFxcXHUwMDYwXFxcXHUwMDdiLVxcXFx1MDA3ZVxcXFx1MDBhMVxcXFx1MDBhN1xcXFx1MDBhYlxcXFx1MDBiNi1cXFxcdTAwYjdcXFxcdTAwYmJcXFxcdTAwYmZcXFxcdTAzN2VcXFxcdTAzODdcXFxcdTA1NWEtXFxcXHUwNTVmXFxcXHUwNTg5LVxcXFx1MDU4YVxcXFx1MDViZVxcXFx1MDVjMFxcXFx1MDVjM1xcXFx1MDVjNlxcXFx1MDVmMy1cXFxcdTA1ZjRcXFxcdTA2MDktXFxcXHUwNjBhXFxcXHUwNjBjLVxcXFx1MDYwZFxcXFx1MDYxYlxcXFx1MDYxZS1cXFxcdTA2MWZcXFxcdTA2NmEtXFxcXHUwNjZkXFxcXHUwNmQ0XFxcXHUwNzAwLVxcXFx1MDcwZFxcXFx1MDdmNy1cXFxcdTA3ZjlcXFxcdTA4MzAtXFxcXHUwODNlXFxcXHUwODVlXFxcXHUwOTY0LVxcXFx1MDk2NVxcXFx1MDk3MFxcXFx1MDlmZFxcXFx1MGE3NlxcXFx1MGFmMFxcXFx1MGM3N1xcXFx1MGM4NFxcXFx1MGRmNFxcXFx1MGU0ZlxcXFx1MGU1YS1cXFxcdTBlNWJcXFxcdTBmMDQtXFxcXHUwZjEyXFxcXHUwZjE0XFxcXHUwZjNhLVxcXFx1MGYzZFxcXFx1MGY4NVxcXFx1MGZkMC1cXFxcdTBmZDRcXFxcdTBmZDktXFxcXHUwZmRhXFxcXHUxMDRhLVxcXFx1MTA0ZlxcXFx1MTBmYlxcXFx1MTM2MC1cXFxcdTEzNjhcXFxcdTE0MDBcXFxcdTE2NmVcXFxcdTE2OWItXFxcXHUxNjljXFxcXHUxNmViLVxcXFx1MTZlZFxcXFx1MTczNS1cXFxcdTE3MzZcXFxcdTE3ZDQtXFxcXHUxN2Q2XFxcXHUxN2Q4LVxcXFx1MTdkYVxcXFx1MTgwMC1cXFxcdTE4MGFcXFxcdTE5NDQtXFxcXHUxOTQ1XFxcXHUxYTFlLVxcXFx1MWExZlxcXFx1MWFhMC1cXFxcdTFhYTZcXFxcdTFhYTgtXFxcXHUxYWFkXFxcXHUxYjVhLVxcXFx1MWI2MFxcXFx1MWJmYy1cXFxcdTFiZmZcXFxcdTFjM2ItXFxcXHUxYzNmXFxcXHUxYzdlLVxcXFx1MWM3ZlxcXFx1MWNjMC1cXFxcdTFjYzdcXFxcdTFjZDNcXFxcdTIwMTAtXFxcXHUyMDI3XFxcXHUyMDMwLVxcXFx1MjA0M1xcXFx1MjA0NS1cXFxcdTIwNTFcXFxcdTIwNTMtXFxcXHUyMDVlXFxcXHUyMDdkLVxcXFx1MjA3ZVxcXFx1MjA4ZC1cXFxcdTIwOGVcXFxcdTIzMDgtXFxcXHUyMzBiXFxcXHUyMzI5LVxcXFx1MjMyYVxcXFx1Mjc2OC1cXFxcdTI3NzVcXFxcdTI3YzUtXFxcXHUyN2M2XFxcXHUyN2U2LVxcXFx1MjdlZlxcXFx1Mjk4My1cXFxcdTI5OThcXFxcdTI5ZDgtXFxcXHUyOWRiXFxcXHUyOWZjLVxcXFx1MjlmZFxcXFx1MmNmOS1cXFxcdTJjZmNcXFxcdTJjZmUtXFxcXHUyY2ZmXFxcXHUyZDcwXFxcXHUyZTAwLVxcXFx1MmUyZVxcXFx1MmUzMC1cXFxcdTJlNGZcXFxcdTMwMDEtXFxcXHUzMDAzXFxcXHUzMDA4LVxcXFx1MzAxMVxcXFx1MzAxNC1cXFxcdTMwMWZcXFxcdTMwMzBcXFxcdTMwM2RcXFxcdTMwYTBcXFxcdTMwZmJcXFxcdWE0ZmUtXFxcXHVhNGZmXFxcXHVhNjBkLVxcXFx1YTYwZlxcXFx1YTY3M1xcXFx1YTY3ZVxcXFx1YTZmMi1cXFxcdWE2ZjdcXFxcdWE4NzQtXFxcXHVhODc3XFxcXHVhOGNlLVxcXFx1YThjZlxcXFx1YThmOC1cXFxcdWE4ZmFcXFxcdWE4ZmNcXFxcdWE5MmUtXFxcXHVhOTJmXFxcXHVhOTVmXFxcXHVhOWMxLVxcXFx1YTljZFxcXFx1YTlkZS1cXFxcdWE5ZGZcXFxcdWFhNWMtXFxcXHVhYTVmXFxcXHVhYWRlLVxcXFx1YWFkZlxcXFx1YWFmMC1cXFxcdWFhZjFcXFxcdWFiZWJcXFxcdWZkM2UtXFxcXHVmZDNmXFxcXHVmZTEwLVxcXFx1ZmUxOVxcXFx1ZmUzMC1cXFxcdWZlNTJcXFxcdWZlNTQtXFxcXHVmZTYxXFxcXHVmZTYzXFxcXHVmZTY4XFxcXHVmZTZhLVxcXFx1ZmU2YlxcXFx1ZmYwMS1cXFxcdWZmMDNcXFxcdWZmMDUtXFxcXHVmZjBhXFxcXHVmZjBjLVxcXFx1ZmYwZlxcXFx1ZmYxYS1cXFxcdWZmMWJcXFxcdWZmMWYtXFxcXHVmZjIwXFxcXHVmZjNiLVxcXFx1ZmYzZFxcXFx1ZmYzZlxcXFx1ZmY1YlxcXFx1ZmY1ZFxcXFx1ZmY1Zi1cXFxcdWZmNjVdfFxcXFx1ZDgwMFtcXFxcdWRkMDAtXFxcXHVkZDAyXFxcXHVkZjlmXFxcXHVkZmQwXXxcXFxcdWQ4MDFbXFxcXHVkZDZmXXxcXFxcdWQ4MDJbXFxcXHVkYzU3XFxcXHVkZDFmXFxcXHVkZDNmXFxcXHVkZTUwLVxcXFx1ZGU1OFxcXFx1ZGU3ZlxcXFx1ZGVmMC1cXFxcdWRlZjZcXFxcdWRmMzktXFxcXHVkZjNmXFxcXHVkZjk5LVxcXFx1ZGY5Y118XFxcXHVkODAzW1xcXFx1ZGY1NS1cXFxcdWRmNTldfFxcXFx1ZDgwNFtcXFxcdWRjNDctXFxcXHVkYzRkXFxcXHVkY2JiLVxcXFx1ZGNiY1xcXFx1ZGNiZS1cXFxcdWRjYzFcXFxcdWRkNDAtXFxcXHVkZDQzXFxcXHVkZDc0LVxcXFx1ZGQ3NVxcXFx1ZGRjNS1cXFxcdWRkYzhcXFxcdWRkY2RcXFxcdWRkZGJcXFxcdWRkZGQtXFxcXHVkZGRmXFxcXHVkZTM4LVxcXFx1ZGUzZFxcXFx1ZGVhOV18XFxcXHVkODA1W1xcXFx1ZGM0Yi1cXFxcdWRjNGZcXFxcdWRjNWJcXFxcdWRjNWRcXFxcdWRjYzZcXFxcdWRkYzEtXFxcXHVkZGQ3XFxcXHVkZTQxLVxcXFx1ZGU0M1xcXFx1ZGU2MC1cXFxcdWRlNmNcXFxcdWRmM2MtXFxcXHVkZjNlXXxcXFxcdWQ4MDZbXFxcXHVkYzNiXFxcXHVkZGUyXFxcXHVkZTNmLVxcXFx1ZGU0NlxcXFx1ZGU5YS1cXFxcdWRlOWNcXFxcdWRlOWUtXFxcXHVkZWEyXXxcXFxcdWQ4MDdbXFxcXHVkYzQxLVxcXFx1ZGM0NVxcXFx1ZGM3MC1cXFxcdWRjNzFcXFxcdWRlZjctXFxcXHVkZWY4XFxcXHVkZmZmXXxcXFxcdWQ4MDlbXFxcXHVkYzcwLVxcXFx1ZGM3NF18XFxcXHVkODFhW1xcXFx1ZGU2ZS1cXFxcdWRlNmZcXFxcdWRlZjVcXFxcdWRmMzctXFxcXHVkZjNiXFxcXHVkZjQ0XXxcXFxcdWQ4MWJbXFxcXHVkZTk3LVxcXFx1ZGU5YVxcXFx1ZGZlMl18XFxcXHVkODJmW1xcXFx1ZGM5Zl18XFxcXHVkODM2W1xcXFx1ZGU4Ny1cXFxcdWRlOGJdfFxcXFx1ZDgzYVtcXFxcdWRkNWUtXFxcXHVkZDVmXVwifX19KSxpdT10ZSh7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vdXRpbHMuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2dldExhc3Q6dH09VWUoKSx7bG9jU3RhcnQ6cyxsb2NFbmQ6YX09SW8oKSx7Y2prUGF0dGVybjpuLGtQYXR0ZXJuOnUscHVuY3R1YXRpb25QYXR0ZXJuOml9PWFnKCksbD1bXCJsaXF1aWROb2RlXCIsXCJpbmxpbmVDb2RlXCIsXCJlbXBoYXNpc1wiLFwiZXNDb21tZW50XCIsXCJzdHJvbmdcIixcImRlbGV0ZVwiLFwid2lraUxpbmtcIixcImxpbmtcIixcImxpbmtSZWZlcmVuY2VcIixcImltYWdlXCIsXCJpbWFnZVJlZmVyZW5jZVwiLFwiZm9vdG5vdGVcIixcImZvb3Rub3RlUmVmZXJlbmNlXCIsXCJzZW50ZW5jZVwiLFwid2hpdGVzcGFjZVwiLFwid29yZFwiLFwiYnJlYWtcIixcImlubGluZU1hdGhcIl0scD1bLi4ubCxcInRhYmxlQ2VsbFwiLFwicGFyYWdyYXBoXCIsXCJoZWFkaW5nXCJdLGQ9bmV3IFJlZ0V4cCh1KSx5PW5ldyBSZWdFeHAoaSk7ZnVuY3Rpb24gZyhGLFMpe2xldCBOPVwibm9uLWNqa1wiLEk9XCJjai1sZXR0ZXJcIixQPVwiay1sZXR0ZXJcIiwkPVwiY2prLXB1bmN0dWF0aW9uXCIsZj1bXSxUPShTLnByb3NlV3JhcD09PVwicHJlc2VydmVcIj9GOkYucmVwbGFjZShuZXcgUmVnRXhwKGAoJHtufSlcbigke259KWAsXCJnXCIpLFwiJDEkMlwiKSkuc3BsaXQoLyhbXFx0XFxuIF0rKS8pO2ZvcihsZXRbdixvXW9mIFQuZW50cmllcygpKXtpZih2JTI9PT0xKXtmLnB1c2goe3R5cGU6XCJ3aGl0ZXNwYWNlXCIsdmFsdWU6L1xcbi8udGVzdChvKT9gXG5gOlwiIFwifSk7Y29udGludWV9aWYoKHY9PT0wfHx2PT09VC5sZW5ndGgtMSkmJm89PT1cIlwiKWNvbnRpbnVlO2xldCBoPW8uc3BsaXQobmV3IFJlZ0V4cChgKCR7bn0pYCkpO2ZvcihsZXRbQyx4XW9mIGguZW50cmllcygpKWlmKCEoKEM9PT0wfHxDPT09aC5sZW5ndGgtMSkmJng9PT1cIlwiKSl7aWYoQyUyPT09MCl7eCE9PVwiXCImJm0oe3R5cGU6XCJ3b3JkXCIsdmFsdWU6eCxraW5kOk4saGFzTGVhZGluZ1B1bmN0dWF0aW9uOnkudGVzdCh4WzBdKSxoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOnkudGVzdCh0KHgpKX0pO2NvbnRpbnVlfW0oeS50ZXN0KHgpP3t0eXBlOlwid29yZFwiLHZhbHVlOngsa2luZDokLGhhc0xlYWRpbmdQdW5jdHVhdGlvbjohMCxoYXNUcmFpbGluZ1B1bmN0dWF0aW9uOiEwfTp7dHlwZTpcIndvcmRcIix2YWx1ZTp4LGtpbmQ6ZC50ZXN0KHgpP1A6SSxoYXNMZWFkaW5nUHVuY3R1YXRpb246ITEsaGFzVHJhaWxpbmdQdW5jdHVhdGlvbjohMX0pfX1yZXR1cm4gZjtmdW5jdGlvbiBtKHYpe2xldCBvPXQoZik7byYmby50eXBlPT09XCJ3b3JkXCImJihvLmtpbmQ9PT1OJiZ2LmtpbmQ9PT1JJiYhby5oYXNUcmFpbGluZ1B1bmN0dWF0aW9ufHxvLmtpbmQ9PT1JJiZ2LmtpbmQ9PT1OJiYhdi5oYXNMZWFkaW5nUHVuY3R1YXRpb24/Zi5wdXNoKHt0eXBlOlwid2hpdGVzcGFjZVwiLHZhbHVlOlwiIFwifSk6IWgoTiwkKSYmIVtvLnZhbHVlLHYudmFsdWVdLnNvbWUoQz0+L1xcdTMwMDAvLnRlc3QoQykpJiZmLnB1c2goe3R5cGU6XCJ3aGl0ZXNwYWNlXCIsdmFsdWU6XCJcIn0pKSxmLnB1c2godik7ZnVuY3Rpb24gaChDLHgpe3JldHVybiBvLmtpbmQ9PT1DJiZ2LmtpbmQ9PT14fHxvLmtpbmQ9PT14JiZ2LmtpbmQ9PT1DfX19ZnVuY3Rpb24gYyhGLFMpe2xldFssTixJLFBdPVMuc2xpY2UoRi5wb3NpdGlvbi5zdGFydC5vZmZzZXQsRi5wb3NpdGlvbi5lbmQub2Zmc2V0KS5tYXRjaCgvXlxccyooXFxkKykoXFwufFxcKSkoXFxzKikvKTtyZXR1cm57bnVtYmVyVGV4dDpOLG1hcmtlcjpJLGxlYWRpbmdTcGFjZXM6UH19ZnVuY3Rpb24gRChGLFMpe2lmKCFGLm9yZGVyZWR8fEYuY2hpbGRyZW4ubGVuZ3RoPDIpcmV0dXJuITE7bGV0IE49TnVtYmVyKGMoRi5jaGlsZHJlblswXSxTLm9yaWdpbmFsVGV4dCkubnVtYmVyVGV4dCksST1OdW1iZXIoYyhGLmNoaWxkcmVuWzFdLFMub3JpZ2luYWxUZXh0KS5udW1iZXJUZXh0KTtpZihOPT09MCYmRi5jaGlsZHJlbi5sZW5ndGg+Mil7bGV0IFA9TnVtYmVyKGMoRi5jaGlsZHJlblsyXSxTLm9yaWdpbmFsVGV4dCkubnVtYmVyVGV4dCk7cmV0dXJuIEk9PT0xJiZQPT09MX1yZXR1cm4gST09PTF9ZnVuY3Rpb24gRShGLFMpe2xldHt2YWx1ZTpOfT1GO3JldHVybiBGLnBvc2l0aW9uLmVuZC5vZmZzZXQ9PT1TLmxlbmd0aCYmTi5lbmRzV2l0aChgXG5gKSYmUy5lbmRzV2l0aChgXG5gKT9OLnNsaWNlKDAsLTEpOk59ZnVuY3Rpb24gXyhGLFMpe3JldHVybiBmdW5jdGlvbiBOKEksUCwkKXtsZXQgZj1PYmplY3QuYXNzaWduKHt9LFMoSSxQLCQpKTtyZXR1cm4gZi5jaGlsZHJlbiYmKGYuY2hpbGRyZW49Zi5jaGlsZHJlbi5tYXAoKFQsbSk9Pk4oVCxtLFtmLC4uLiRdKSkpLGZ9KEYsbnVsbCxbXSl9ZnVuY3Rpb24gdyhGKXtpZigoRj09bnVsbD92b2lkIDA6Ri50eXBlKSE9PVwibGlua1wifHxGLmNoaWxkcmVuLmxlbmd0aCE9PTEpcmV0dXJuITE7bGV0W1NdPUYuY2hpbGRyZW47cmV0dXJuIHMoRik9PT1zKFMpJiZhKEYpPT09YShTKX1yLmV4cG9ydHM9e21hcEFzdDpfLHNwbGl0VGV4dDpnLHB1bmN0dWF0aW9uUGF0dGVybjppLGdldEZlbmNlZENvZGVCbG9ja1ZhbHVlOkUsZ2V0T3JkZXJlZExpc3RJdGVtSW5mbzpjLGhhc0dpdERpZmZGcmllbmRseU9yZGVyZWRMaXN0OkQsSU5MSU5FX05PREVfVFlQRVM6bCxJTkxJTkVfTk9ERV9XUkFQUEVSX1RZUEVTOnAsaXNBdXRvbGluazp3fX19KSxvZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vZW1iZWQuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2luZmVyUGFyc2VyQnlMYW5ndWFnZTp0LGdldE1heENvbnRpbnVvdXNDb3VudDpzfT1VZSgpLHtidWlsZGVyczp7aGFyZGxpbmU6YSxtYXJrQXNSb290Om59LHV0aWxzOntyZXBsYWNlRW5kT2ZMaW5lOnV9fT1xZSgpLGk9c3UoKSx7Z2V0RmVuY2VkQ29kZUJsb2NrVmFsdWU6bH09aXUoKTtmdW5jdGlvbiBwKGQseSxnLGMpe2xldCBEPWQuZ2V0VmFsdWUoKTtpZihELnR5cGU9PT1cImNvZGVcIiYmRC5sYW5nIT09bnVsbCl7bGV0IEU9dChELmxhbmcsYyk7aWYoRSl7bGV0IF89Yy5fX2luSnNUZW1wbGF0ZT9cIn5cIjpcImBcIix3PV8ucmVwZWF0KE1hdGgubWF4KDMscyhELnZhbHVlLF8pKzEpKSxGPXtwYXJzZXI6RX07RC5sYW5nPT09XCJ0c3hcIiYmKEYuZmlsZXBhdGg9XCJkdW1teS50c3hcIik7bGV0IFM9ZyhsKEQsYy5vcmlnaW5hbFRleHQpLEYse3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pO3JldHVybiBuKFt3LEQubGFuZyxELm1ldGE/XCIgXCIrRC5tZXRhOlwiXCIsYSx1KFMpLGEsd10pfX1zd2l0Y2goRC50eXBlKXtjYXNlXCJmcm9udC1tYXR0ZXJcIjpyZXR1cm4gaShELGcpO2Nhc2VcImltcG9ydEV4cG9ydFwiOnJldHVybltnKEQudmFsdWUse3BhcnNlcjpcImJhYmVsXCJ9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KSxhXTtjYXNlXCJqc3hcIjpyZXR1cm4gZyhgPCQ+JHtELnZhbHVlfTwvJD5gLHtwYXJzZXI6XCJfX2pzX2V4cHJlc3Npb25cIixyb290TWFya2VyOlwibWR4XCJ9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KX1yZXR1cm4gbnVsbH1yLmV4cG9ydHM9cH19KSxrbz10ZSh7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vcHJhZ21hLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PV9vKCkscz1bXCJmb3JtYXRcIixcInByZXR0aWVyXCJdO2Z1bmN0aW9uIGEobil7bGV0IHU9YEAoJHtzLmpvaW4oXCJ8XCIpfSlgLGk9bmV3IFJlZ0V4cChbYDwhLS1cXFxccyoke3V9XFxcXHMqLS0+YCxge1xcXFxzKlxcXFwvXFxcXCpcXFxccyoke3V9XFxcXHMqXFxcXCpcXFxcL1xcXFxzKn1gLGA8IS0tLipcXHI/XG5bXFxcXHNcXFxcU10qKF58XG4pW15cXFxcU1xuXSoke3V9W15cXFxcU1xuXSooJHxcbilbXFxcXHNcXFxcU10qXG4uKi0tPmBdLmpvaW4oXCJ8XCIpLFwibVwiKSxsPW4ubWF0Y2goaSk7cmV0dXJuKGw9PW51bGw/dm9pZCAwOmwuaW5kZXgpPT09MH1yLmV4cG9ydHM9e3N0YXJ0V2l0aFByYWdtYTphLGhhc1ByYWdtYTpuPT5hKHQobikuY29udGVudC50cmltU3RhcnQoKSksaW5zZXJ0UHJhZ21hOm49PntsZXQgdT10KG4pLGk9YDwhLS0gQCR7c1swXX0gLS0+YDtyZXR1cm4gdS5mcm9udE1hdHRlcj9gJHt1LmZyb250TWF0dGVyLnJhd31cblxuJHtpfVxuXG4ke3UuY29udGVudH1gOmAke2l9XG5cbiR7dS5jb250ZW50fWB9fX19KSxsZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vcHJpbnQtcHJlcHJvY2Vzcy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1sdCgpLHtnZXRPcmRlcmVkTGlzdEl0ZW1JbmZvOnMsbWFwQXN0OmEsc3BsaXRUZXh0Om59PWl1KCksdT0vXi4kL3N1O2Z1bmN0aW9uIGkodyxGKXtyZXR1cm4gdz1kKHcsRiksdz1jKHcpLHc9cCh3LEYpLHc9RSh3LEYpLHc9Xyh3LEYpLHc9RCh3LEYpLHc9bCh3KSx3PXkodyksd31mdW5jdGlvbiBsKHcpe3JldHVybiBhKHcsRj0+Ri50eXBlIT09XCJpbXBvcnRcIiYmRi50eXBlIT09XCJleHBvcnRcIj9GOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxGKSx7fSx7dHlwZTpcImltcG9ydEV4cG9ydFwifSkpfWZ1bmN0aW9uIHAodyxGKXtyZXR1cm4gYSh3LFM9PlMudHlwZSE9PVwiaW5saW5lQ29kZVwifHxGLnByb3NlV3JhcD09PVwicHJlc2VydmVcIj9TOk9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxTKSx7fSx7dmFsdWU6Uy52YWx1ZS5yZXBsYWNlKC9cXHMrL2csXCIgXCIpfSkpfWZ1bmN0aW9uIGQodyxGKXtyZXR1cm4gYSh3LFM9PlMudHlwZSE9PVwidGV4dFwifHxTLnZhbHVlPT09XCIqXCJ8fFMudmFsdWU9PT1cIl9cInx8IXUudGVzdChTLnZhbHVlKXx8Uy5wb3NpdGlvbi5lbmQub2Zmc2V0LVMucG9zaXRpb24uc3RhcnQub2Zmc2V0PT09Uy52YWx1ZS5sZW5ndGg/UzpPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sUykse30se3ZhbHVlOkYub3JpZ2luYWxUZXh0LnNsaWNlKFMucG9zaXRpb24uc3RhcnQub2Zmc2V0LFMucG9zaXRpb24uZW5kLm9mZnNldCl9KSl9ZnVuY3Rpb24geSh3KXtyZXR1cm4gZyh3LChGLFMpPT5GLnR5cGU9PT1cImltcG9ydEV4cG9ydFwiJiZTLnR5cGU9PT1cImltcG9ydEV4cG9ydFwiLChGLFMpPT4oe3R5cGU6XCJpbXBvcnRFeHBvcnRcIix2YWx1ZTpGLnZhbHVlK2BcblxuYCtTLnZhbHVlLHBvc2l0aW9uOntzdGFydDpGLnBvc2l0aW9uLnN0YXJ0LGVuZDpTLnBvc2l0aW9uLmVuZH19KSl9ZnVuY3Rpb24gZyh3LEYsUyl7cmV0dXJuIGEodyxOPT57aWYoIU4uY2hpbGRyZW4pcmV0dXJuIE47bGV0IEk9Ti5jaGlsZHJlbi5yZWR1Y2UoKFAsJCk9PntsZXQgZj10KFApO3JldHVybiBmJiZGKGYsJCk/UC5zcGxpY2UoLTEsMSxTKGYsJCkpOlAucHVzaCgkKSxQfSxbXSk7cmV0dXJuIE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxOKSx7fSx7Y2hpbGRyZW46SX0pfSl9ZnVuY3Rpb24gYyh3KXtyZXR1cm4gZyh3LChGLFMpPT5GLnR5cGU9PT1cInRleHRcIiYmUy50eXBlPT09XCJ0ZXh0XCIsKEYsUyk9Pih7dHlwZTpcInRleHRcIix2YWx1ZTpGLnZhbHVlK1MudmFsdWUscG9zaXRpb246e3N0YXJ0OkYucG9zaXRpb24uc3RhcnQsZW5kOlMucG9zaXRpb24uZW5kfX0pKX1mdW5jdGlvbiBEKHcsRil7cmV0dXJuIGEodywoUyxOLEkpPT57bGV0W1BdPUk7aWYoUy50eXBlIT09XCJ0ZXh0XCIpcmV0dXJuIFM7bGV0e3ZhbHVlOiR9PVM7cmV0dXJuIFAudHlwZT09PVwicGFyYWdyYXBoXCImJihOPT09MCYmKCQ9JC50cmltU3RhcnQoKSksTj09PVAuY2hpbGRyZW4ubGVuZ3RoLTEmJigkPSQudHJpbUVuZCgpKSkse3R5cGU6XCJzZW50ZW5jZVwiLHBvc2l0aW9uOlMucG9zaXRpb24sY2hpbGRyZW46bigkLEYpfX0pfWZ1bmN0aW9uIEUodyxGKXtyZXR1cm4gYSh3LChTLE4sSSk9PntpZihTLnR5cGU9PT1cImNvZGVcIil7bGV0IFA9L15cXG4/KD86IHs0LH18XFx0KS8udGVzdChGLm9yaWdpbmFsVGV4dC5zbGljZShTLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxTLnBvc2l0aW9uLmVuZC5vZmZzZXQpKTtpZihTLmlzSW5kZW50ZWQ9UCxQKWZvcihsZXQgJD0wOyQ8SS5sZW5ndGg7JCsrKXtsZXQgZj1JWyRdO2lmKGYuaGFzSW5kZW50ZWRDb2RlYmxvY2spYnJlYWs7Zi50eXBlPT09XCJsaXN0XCImJihmLmhhc0luZGVudGVkQ29kZWJsb2NrPSEwKX19cmV0dXJuIFN9KX1mdW5jdGlvbiBfKHcsRil7cmV0dXJuIGEodywoSSxQLCQpPT57aWYoSS50eXBlPT09XCJsaXN0XCImJkkuY2hpbGRyZW4ubGVuZ3RoPjApe2ZvcihsZXQgZj0wO2Y8JC5sZW5ndGg7ZisrKXtsZXQgVD0kW2ZdO2lmKFQudHlwZT09PVwibGlzdFwiJiYhVC5pc0FsaWduZWQpcmV0dXJuIEkuaXNBbGlnbmVkPSExLEl9SS5pc0FsaWduZWQ9TihJKX1yZXR1cm4gSX0pO2Z1bmN0aW9uIFMoSSl7cmV0dXJuIEkuY2hpbGRyZW4ubGVuZ3RoPT09MD8tMTpJLmNoaWxkcmVuWzBdLnBvc2l0aW9uLnN0YXJ0LmNvbHVtbi0xfWZ1bmN0aW9uIE4oSSl7aWYoIUkub3JkZXJlZClyZXR1cm4hMDtsZXRbUCwkXT1JLmNoaWxkcmVuO2lmKHMoUCxGLm9yaWdpbmFsVGV4dCkubGVhZGluZ1NwYWNlcy5sZW5ndGg+MSlyZXR1cm4hMDtsZXQgVD1TKFApO2lmKFQ9PT0tMSlyZXR1cm4hMTtpZihJLmNoaWxkcmVuLmxlbmd0aD09PTEpcmV0dXJuIFQlRi50YWJXaWR0aD09PTA7bGV0IG09UygkKTtyZXR1cm4gVCE9PW0/ITE6VCVGLnRhYldpZHRoPT09MD8hMDpzKCQsRi5vcmlnaW5hbFRleHQpLmxlYWRpbmdTcGFjZXMubGVuZ3RoPjF9fXIuZXhwb3J0cz1pfX0pLGNnPXRlKHtcInNyYy9sYW5ndWFnZS1tYXJrZG93bi9jbGVhbi5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1QbygpLHtpc0Zyb250TWF0dGVyTm9kZTpzfT1VZSgpLHtzdGFydFdpdGhQcmFnbWE6YX09a28oKSxuPW5ldyBTZXQoW1wicG9zaXRpb25cIixcInJhd1wiXSk7ZnVuY3Rpb24gdShpLGwscCl7aWYoKGkudHlwZT09PVwiZnJvbnQtbWF0dGVyXCJ8fGkudHlwZT09PVwiY29kZVwifHxpLnR5cGU9PT1cInlhbWxcInx8aS50eXBlPT09XCJpbXBvcnRcInx8aS50eXBlPT09XCJleHBvcnRcInx8aS50eXBlPT09XCJqc3hcIikmJmRlbGV0ZSBsLnZhbHVlLGkudHlwZT09PVwibGlzdFwiJiZkZWxldGUgbC5pc0FsaWduZWQsKGkudHlwZT09PVwibGlzdFwifHxpLnR5cGU9PT1cImxpc3RJdGVtXCIpJiYoZGVsZXRlIGwuc3ByZWFkLGRlbGV0ZSBsLmxvb3NlKSxpLnR5cGU9PT1cInRleHRcInx8KGkudHlwZT09PVwiaW5saW5lQ29kZVwiJiYobC52YWx1ZT1pLnZhbHVlLnJlcGxhY2UoL1tcXHRcXG4gXSsvZyxcIiBcIikpLGkudHlwZT09PVwid2lraUxpbmtcIiYmKGwudmFsdWU9aS52YWx1ZS50cmltKCkucmVwbGFjZSgvW1xcdFxcbl0rL2csXCIgXCIpKSwoaS50eXBlPT09XCJkZWZpbml0aW9uXCJ8fGkudHlwZT09PVwibGlua1JlZmVyZW5jZVwifHxpLnR5cGU9PT1cImltYWdlUmVmZXJlbmNlXCIpJiYobC5sYWJlbD10KGkubGFiZWwpKSwoaS50eXBlPT09XCJkZWZpbml0aW9uXCJ8fGkudHlwZT09PVwibGlua1wifHxpLnR5cGU9PT1cImltYWdlXCIpJiZpLnRpdGxlJiYobC50aXRsZT1pLnRpdGxlLnJlcGxhY2UoL1xcXFwoW1wiJyldKS9nLFwiJDFcIikpLHAmJnAudHlwZT09PVwicm9vdFwiJiZwLmNoaWxkcmVuLmxlbmd0aD4wJiYocC5jaGlsZHJlblswXT09PWl8fHMocC5jaGlsZHJlblswXSkmJnAuY2hpbGRyZW5bMV09PT1pKSYmaS50eXBlPT09XCJodG1sXCImJmEoaS52YWx1ZSkpKXJldHVybiBudWxsfXUuaWdub3JlZFByb3BlcnRpZXM9bixyLmV4cG9ydHM9dX19KSxwZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtbWFya2Rvd24vcHJpbnRlci1tYXJrZG93bi5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD1QbygpLHtnZXRMYXN0OnMsZ2V0TWluTm90UHJlc2VudENvbnRpbnVvdXNDb3VudDphLGdldE1heENvbnRpbnVvdXNDb3VudDpuLGdldFN0cmluZ1dpZHRoOnUsaXNOb25FbXB0eUFycmF5Oml9PVVlKCkse2J1aWxkZXJzOnticmVha1BhcmVudDpsLGpvaW46cCxsaW5lOmQsbGl0ZXJhbGxpbmU6eSxtYXJrQXNSb290OmcsaGFyZGxpbmU6Yyxzb2Z0bGluZTpELGlmQnJlYWs6RSxmaWxsOl8sYWxpZ246dyxpbmRlbnQ6Rixncm91cDpTLGhhcmRsaW5lV2l0aG91dEJyZWFrUGFyZW50Ok59LHV0aWxzOntub3JtYWxpemVEb2M6SSxyZXBsYWNlVGV4dEVuZE9mTGluZTpQfSxwcmludGVyOntwcmludERvY1RvU3RyaW5nOiR9fT1xZSgpLGY9b2coKSx7aW5zZXJ0UHJhZ21hOlR9PWtvKCkse2xvY1N0YXJ0Om0sbG9jRW5kOnZ9PUlvKCksbz1sZygpLGg9Y2coKSx7Z2V0RmVuY2VkQ29kZUJsb2NrVmFsdWU6QyxoYXNHaXREaWZmRnJpZW5kbHlPcmRlcmVkTGlzdDp4LHNwbGl0VGV4dDpiLHB1bmN0dWF0aW9uUGF0dGVybjpCLElOTElORV9OT0RFX1RZUEVTOmssSU5MSU5FX05PREVfV1JBUFBFUl9UWVBFUzpNLGlzQXV0b2xpbms6Un09aXUoKSxxPW5ldyBTZXQoW1wiaW1wb3J0RXhwb3J0XCJdKSxKPVtcImhlYWRpbmdcIixcInRhYmxlQ2VsbFwiLFwibGlua1wiLFwid2lraUxpbmtcIl0sTD1uZXcgU2V0KFtcImxpc3RJdGVtXCIsXCJkZWZpbml0aW9uXCIsXCJmb290bm90ZURlZmluaXRpb25cIl0pO2Z1bmN0aW9uIFEob2UsSCxjZSl7bGV0IFg9b2UuZ2V0VmFsdWUoKTtpZihnZShvZSkpcmV0dXJuIGIoSC5vcmlnaW5hbFRleHQuc2xpY2UoWC5wb3NpdGlvbi5zdGFydC5vZmZzZXQsWC5wb3NpdGlvbi5lbmQub2Zmc2V0KSxIKS5tYXAocGU9PnBlLnR5cGU9PT1cIndvcmRcIj9wZS52YWx1ZTpwZS52YWx1ZT09PVwiXCI/XCJcIjpXKG9lLHBlLnZhbHVlLEgpKTtzd2l0Y2goWC50eXBlKXtjYXNlXCJmcm9udC1tYXR0ZXJcIjpyZXR1cm4gSC5vcmlnaW5hbFRleHQuc2xpY2UoWC5wb3NpdGlvbi5zdGFydC5vZmZzZXQsWC5wb3NpdGlvbi5lbmQub2Zmc2V0KTtjYXNlXCJyb290XCI6cmV0dXJuIFguY2hpbGRyZW4ubGVuZ3RoPT09MD9cIlwiOltJKGRlKG9lLEgsY2UpKSxxLmhhcyh6KFgpLnR5cGUpP1wiXCI6Y107Y2FzZVwicGFyYWdyYXBoXCI6cmV0dXJuIHVlKG9lLEgsY2Use3Bvc3Rwcm9jZXNzb3I6X30pO2Nhc2VcInNlbnRlbmNlXCI6cmV0dXJuIHVlKG9lLEgsY2UpO2Nhc2VcIndvcmRcIjp7bGV0IHBlPVgudmFsdWUucmVwbGFjZSgvXFwqL2csXCJcXFxcJCZcIikucmVwbGFjZShuZXcgUmVnRXhwKFtgKF58JHtCfSkoXyspYCxgKF8rKSgke0J9fCQpYF0uam9pbihcInxcIiksXCJnXCIpLChmZSxBLEcscmUseWUpPT4oRz9gJHtBfSR7R31gOmAke3JlfSR7eWV9YCkucmVwbGFjZSgvXy9nLFwiXFxcXF9cIikpLEFlPShmZSxBLEcpPT5mZS50eXBlPT09XCJzZW50ZW5jZVwiJiZHPT09MCxDZT0oZmUsQSxHKT0+UihmZS5jaGlsZHJlbltHLTFdKTtyZXR1cm4gcGUhPT1YLnZhbHVlJiYob2UubWF0Y2godm9pZCAwLEFlLENlKXx8b2UubWF0Y2godm9pZCAwLEFlLChmZSxBLEcpPT5mZS50eXBlPT09XCJlbXBoYXNpc1wiJiZHPT09MCxDZSkpJiYocGU9cGUucmVwbGFjZSgvXihcXFxcP1sqX10pKy8sZmU9PmZlLnJlcGxhY2UoL1xcXFwvZyxcIlwiKSkpLHBlfWNhc2VcIndoaXRlc3BhY2VcIjp7bGV0IHBlPW9lLmdldFBhcmVudE5vZGUoKSxBZT1wZS5jaGlsZHJlbi5pbmRleE9mKFgpLENlPXBlLmNoaWxkcmVuW0FlKzFdLGZlPUNlJiYvXj58Xig/OlsqKy1dfCN7MSw2fXxcXGQrWykuXSkkLy50ZXN0KENlLnZhbHVlKT9cIm5ldmVyXCI6SC5wcm9zZVdyYXA7cmV0dXJuIFcob2UsWC52YWx1ZSx7cHJvc2VXcmFwOmZlfSl9Y2FzZVwiZW1waGFzaXNcIjp7bGV0IHBlO2lmKFIoWC5jaGlsZHJlblswXSkpcGU9SC5vcmlnaW5hbFRleHRbWC5wb3NpdGlvbi5zdGFydC5vZmZzZXRdO2Vsc2V7bGV0IEFlPW9lLmdldFBhcmVudE5vZGUoKSxDZT1BZS5jaGlsZHJlbi5pbmRleE9mKFgpLGZlPUFlLmNoaWxkcmVuW0NlLTFdLEE9QWUuY2hpbGRyZW5bQ2UrMV07cGU9ZmUmJmZlLnR5cGU9PT1cInNlbnRlbmNlXCImJmZlLmNoaWxkcmVuLmxlbmd0aD4wJiZzKGZlLmNoaWxkcmVuKS50eXBlPT09XCJ3b3JkXCImJiFzKGZlLmNoaWxkcmVuKS5oYXNUcmFpbGluZ1B1bmN0dWF0aW9ufHxBJiZBLnR5cGU9PT1cInNlbnRlbmNlXCImJkEuY2hpbGRyZW4ubGVuZ3RoPjAmJkEuY2hpbGRyZW5bMF0udHlwZT09PVwid29yZFwiJiYhQS5jaGlsZHJlblswXS5oYXNMZWFkaW5nUHVuY3R1YXRpb258fGxlKG9lLFwiZW1waGFzaXNcIik/XCIqXCI6XCJfXCJ9cmV0dXJuW3BlLHVlKG9lLEgsY2UpLHBlXX1jYXNlXCJzdHJvbmdcIjpyZXR1cm5bXCIqKlwiLHVlKG9lLEgsY2UpLFwiKipcIl07Y2FzZVwiZGVsZXRlXCI6cmV0dXJuW1wifn5cIix1ZShvZSxILGNlKSxcIn5+XCJdO2Nhc2VcImlubGluZUNvZGVcIjp7bGV0IHBlPWEoWC52YWx1ZSxcImBcIiksQWU9XCJgXCIucmVwZWF0KHBlfHwxKSxDZT1wZSYmIS9eXFxzLy50ZXN0KFgudmFsdWUpP1wiIFwiOlwiXCI7cmV0dXJuW0FlLENlLFgudmFsdWUsQ2UsQWVdfWNhc2VcIndpa2lMaW5rXCI6e2xldCBwZT1cIlwiO3JldHVybiBILnByb3NlV3JhcD09PVwicHJlc2VydmVcIj9wZT1YLnZhbHVlOnBlPVgudmFsdWUucmVwbGFjZSgvW1xcdFxcbl0rL2csXCIgXCIpLFtcIltbXCIscGUsXCJdXVwiXX1jYXNlXCJsaW5rXCI6c3dpdGNoKEgub3JpZ2luYWxUZXh0W1gucG9zaXRpb24uc3RhcnQub2Zmc2V0XSl7Y2FzZVwiPFwiOntsZXQgcGU9XCJtYWlsdG86XCI7cmV0dXJuW1wiPFwiLFgudXJsLnN0YXJ0c1dpdGgocGUpJiZILm9yaWdpbmFsVGV4dC5zbGljZShYLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCsxLFgucG9zaXRpb24uc3RhcnQub2Zmc2V0KzErcGUubGVuZ3RoKSE9PXBlP1gudXJsLnNsaWNlKHBlLmxlbmd0aCk6WC51cmwsXCI+XCJdfWNhc2VcIltcIjpyZXR1cm5bXCJbXCIsdWUob2UsSCxjZSksXCJdKFwiLGhlKFgudXJsLFwiKVwiKSx3ZShYLnRpdGxlLEgpLFwiKVwiXTtkZWZhdWx0OnJldHVybiBILm9yaWdpbmFsVGV4dC5zbGljZShYLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxYLnBvc2l0aW9uLmVuZC5vZmZzZXQpfWNhc2VcImltYWdlXCI6cmV0dXJuW1wiIVtcIixYLmFsdHx8XCJcIixcIl0oXCIsaGUoWC51cmwsXCIpXCIpLHdlKFgudGl0bGUsSCksXCIpXCJdO2Nhc2VcImJsb2NrcXVvdGVcIjpyZXR1cm5bXCI+IFwiLHcoXCI+IFwiLHVlKG9lLEgsY2UpKV07Y2FzZVwiaGVhZGluZ1wiOnJldHVybltcIiNcIi5yZXBlYXQoWC5kZXB0aCkrXCIgXCIsdWUob2UsSCxjZSldO2Nhc2VcImNvZGVcIjp7aWYoWC5pc0luZGVudGVkKXtsZXQgQ2U9XCIgXCIucmVwZWF0KDQpO3JldHVybiB3KENlLFtDZSwuLi5QKFgudmFsdWUsYyldKX1sZXQgcGU9SC5fX2luSnNUZW1wbGF0ZT9cIn5cIjpcImBcIixBZT1wZS5yZXBlYXQoTWF0aC5tYXgoMyxuKFgudmFsdWUscGUpKzEpKTtyZXR1cm5bQWUsWC5sYW5nfHxcIlwiLFgubWV0YT9cIiBcIitYLm1ldGE6XCJcIixjLC4uLlAoQyhYLEgub3JpZ2luYWxUZXh0KSxjKSxjLEFlXX1jYXNlXCJodG1sXCI6e2xldCBwZT1vZS5nZXRQYXJlbnROb2RlKCksQWU9cGUudHlwZT09PVwicm9vdFwiJiZzKHBlLmNoaWxkcmVuKT09PVg/WC52YWx1ZS50cmltRW5kKCk6WC52YWx1ZSxDZT0vXjwhLS0uKi0tPiQvcy50ZXN0KEFlKTtyZXR1cm4gUChBZSxDZT9jOmcoeSkpfWNhc2VcImxpc3RcIjp7bGV0IHBlPVkoWCxvZS5nZXRQYXJlbnROb2RlKCkpLEFlPXgoWCxIKTtyZXR1cm4gdWUob2UsSCxjZSx7cHJvY2Vzc29yOihDZSxmZSk9PntsZXQgQT1yZSgpLEc9Q2UuZ2V0VmFsdWUoKTtpZihHLmNoaWxkcmVuLmxlbmd0aD09PTImJkcuY2hpbGRyZW5bMV0udHlwZT09PVwiaHRtbFwiJiZHLmNoaWxkcmVuWzBdLnBvc2l0aW9uLnN0YXJ0LmNvbHVtbiE9PUcuY2hpbGRyZW5bMV0ucG9zaXRpb24uc3RhcnQuY29sdW1uKXJldHVybltBLFYoQ2UsSCxjZSxBKV07cmV0dXJuW0EsdyhcIiBcIi5yZXBlYXQoQS5sZW5ndGgpLFYoQ2UsSCxjZSxBKSldO2Z1bmN0aW9uIHJlKCl7bGV0IHllPVgub3JkZXJlZD8oZmU9PT0wP1guc3RhcnQ6QWU/MTpYLnN0YXJ0K2ZlKSsocGUlMj09PTA/XCIuIFwiOlwiKSBcIik6cGUlMj09PTA/XCItIFwiOlwiKiBcIjtyZXR1cm4gWC5pc0FsaWduZWR8fFguaGFzSW5kZW50ZWRDb2RlYmxvY2s/aih5ZSxIKTp5ZX19fSl9Y2FzZVwidGhlbWF0aWNCcmVha1wiOntsZXQgcGU9ZWUob2UsXCJsaXN0XCIpO3JldHVybiBwZT09PS0xP1wiLS0tXCI6WShvZS5nZXRQYXJlbnROb2RlKHBlKSxvZS5nZXRQYXJlbnROb2RlKHBlKzEpKSUyPT09MD9cIioqKlwiOlwiLS0tXCJ9Y2FzZVwibGlua1JlZmVyZW5jZVwiOnJldHVybltcIltcIix1ZShvZSxILGNlKSxcIl1cIixYLnJlZmVyZW5jZVR5cGU9PT1cImZ1bGxcIj9OZShYKTpYLnJlZmVyZW5jZVR5cGU9PT1cImNvbGxhcHNlZFwiP1wiW11cIjpcIlwiXTtjYXNlXCJpbWFnZVJlZmVyZW5jZVwiOnN3aXRjaChYLnJlZmVyZW5jZVR5cGUpe2Nhc2VcImZ1bGxcIjpyZXR1cm5bXCIhW1wiLFguYWx0fHxcIlwiLFwiXVwiLE5lKFgpXTtkZWZhdWx0OnJldHVybltcIiFbXCIsWC5hbHQsXCJdXCIsWC5yZWZlcmVuY2VUeXBlPT09XCJjb2xsYXBzZWRcIj9cIltdXCI6XCJcIl19Y2FzZVwiZGVmaW5pdGlvblwiOntsZXQgcGU9SC5wcm9zZVdyYXA9PT1cImFsd2F5c1wiP2Q6XCIgXCI7cmV0dXJuIFMoW05lKFgpLFwiOlwiLEYoW3BlLGhlKFgudXJsKSxYLnRpdGxlPT09bnVsbD9cIlwiOltwZSx3ZShYLnRpdGxlLEgsITEpXV0pXSl9Y2FzZVwiZm9vdG5vdGVcIjpyZXR1cm5bXCJbXlwiLHVlKG9lLEgsY2UpLFwiXVwiXTtjYXNlXCJmb290bm90ZVJlZmVyZW5jZVwiOnJldHVybiBQZShYKTtjYXNlXCJmb290bm90ZURlZmluaXRpb25cIjp7bGV0IHBlPW9lLmdldFBhcmVudE5vZGUoKS5jaGlsZHJlbltvZS5nZXROYW1lKCkrMV0sQWU9WC5jaGlsZHJlbi5sZW5ndGg9PT0xJiZYLmNoaWxkcmVuWzBdLnR5cGU9PT1cInBhcmFncmFwaFwiJiYoSC5wcm9zZVdyYXA9PT1cIm5ldmVyXCJ8fEgucHJvc2VXcmFwPT09XCJwcmVzZXJ2ZVwiJiZYLmNoaWxkcmVuWzBdLnBvc2l0aW9uLnN0YXJ0LmxpbmU9PT1YLmNoaWxkcmVuWzBdLnBvc2l0aW9uLmVuZC5saW5lKTtyZXR1cm5bUGUoWCksXCI6IFwiLEFlP3VlKG9lLEgsY2UpOlMoW3coXCIgXCIucmVwZWF0KDQpLHVlKG9lLEgsY2Use3Byb2Nlc3NvcjooQ2UsZmUpPT5mZT09PTA/UyhbRCxjZSgpXSk6Y2UoKX0pKSxwZSYmcGUudHlwZT09PVwiZm9vdG5vdGVEZWZpbml0aW9uXCI/RDpcIlwiXSldfWNhc2VcInRhYmxlXCI6cmV0dXJuIEsob2UsSCxjZSk7Y2FzZVwidGFibGVDZWxsXCI6cmV0dXJuIHVlKG9lLEgsY2UpO2Nhc2VcImJyZWFrXCI6cmV0dXJuL1xccy8udGVzdChILm9yaWdpbmFsVGV4dFtYLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldF0pP1tcIiAgXCIsZyh5KV06W1wiXFxcXFwiLGNdO2Nhc2VcImxpcXVpZE5vZGVcIjpyZXR1cm4gUChYLnZhbHVlLGMpO2Nhc2VcImltcG9ydEV4cG9ydFwiOnJldHVybltYLnZhbHVlLGNdO2Nhc2VcImVzQ29tbWVudFwiOnJldHVybltcInsvKiBcIixYLnZhbHVlLFwiICovfVwiXTtjYXNlXCJqc3hcIjpyZXR1cm4gWC52YWx1ZTtjYXNlXCJtYXRoXCI6cmV0dXJuW1wiJCRcIixjLFgudmFsdWU/Wy4uLlAoWC52YWx1ZSxjKSxjXTpcIlwiLFwiJCRcIl07Y2FzZVwiaW5saW5lTWF0aFwiOnJldHVybiBILm9yaWdpbmFsVGV4dC5zbGljZShtKFgpLHYoWCkpO2Nhc2VcInRhYmxlUm93XCI6Y2FzZVwibGlzdEl0ZW1cIjpkZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5rbm93biBtYXJrZG93biB0eXBlICR7SlNPTi5zdHJpbmdpZnkoWC50eXBlKX1gKX19ZnVuY3Rpb24gVihvZSxILGNlLFgpe2xldCBwZT1vZS5nZXRWYWx1ZSgpLEFlPXBlLmNoZWNrZWQ9PT1udWxsP1wiXCI6cGUuY2hlY2tlZD9cIlt4XSBcIjpcIlsgXSBcIjtyZXR1cm5bQWUsdWUob2UsSCxjZSx7cHJvY2Vzc29yOihDZSxmZSk9PntpZihmZT09PTAmJkNlLmdldFZhbHVlKCkudHlwZSE9PVwibGlzdFwiKXJldHVybiB3KFwiIFwiLnJlcGVhdChBZS5sZW5ndGgpLGNlKCkpO2xldCBBPVwiIFwiLnJlcGVhdChrZShILnRhYldpZHRoLVgubGVuZ3RoLDAsMykpO3JldHVybltBLHcoQSxjZSgpKV19fSldfWZ1bmN0aW9uIGoob2UsSCl7bGV0IGNlPVgoKTtyZXR1cm4gb2UrXCIgXCIucmVwZWF0KGNlPj00PzA6Y2UpO2Z1bmN0aW9uIFgoKXtsZXQgcGU9b2UubGVuZ3RoJUgudGFiV2lkdGg7cmV0dXJuIHBlPT09MD8wOkgudGFiV2lkdGgtcGV9fWZ1bmN0aW9uIFkob2UsSCl7cmV0dXJuIGllKG9lLEgsY2U9PmNlLm9yZGVyZWQ9PT1vZS5vcmRlcmVkKX1mdW5jdGlvbiBpZShvZSxILGNlKXtsZXQgWD0tMTtmb3IobGV0IHBlIG9mIEguY2hpbGRyZW4paWYocGUudHlwZT09PW9lLnR5cGUmJmNlKHBlKT9YKys6WD0tMSxwZT09PW9lKXJldHVybiBYfWZ1bmN0aW9uIGVlKG9lLEgpe2xldCBjZT1BcnJheS5pc0FycmF5KEgpP0g6W0hdLFg9LTEscGU7Zm9yKDtwZT1vZS5nZXRQYXJlbnROb2RlKCsrWCk7KWlmKGNlLmluY2x1ZGVzKHBlLnR5cGUpKXJldHVybiBYO3JldHVybi0xfWZ1bmN0aW9uIGxlKG9lLEgpe2xldCBjZT1lZShvZSxIKTtyZXR1cm4gY2U9PT0tMT9udWxsOm9lLmdldFBhcmVudE5vZGUoY2UpfWZ1bmN0aW9uIFcob2UsSCxjZSl7aWYoY2UucHJvc2VXcmFwPT09XCJwcmVzZXJ2ZVwiJiZIPT09YFxuYClyZXR1cm4gYztsZXQgWD1jZS5wcm9zZVdyYXA9PT1cImFsd2F5c1wiJiYhbGUob2UsSik7cmV0dXJuIEghPT1cIlwiP1g/ZDpcIiBcIjpYP0Q6XCJcIn1mdW5jdGlvbiBLKG9lLEgsY2Upe2xldCBYPW9lLmdldFZhbHVlKCkscGU9W10sQWU9b2UubWFwKHllPT55ZS5tYXAoKEVlLEJlKT0+e2xldCB2ZT0kKGNlKCksSCkuZm9ybWF0dGVkLHplPXUodmUpO3JldHVybiBwZVtCZV09TWF0aC5tYXgocGVbQmVdfHwzLHplKSx7dGV4dDp2ZSx3aWR0aDp6ZX19LFwiY2hpbGRyZW5cIiksXCJjaGlsZHJlblwiKSxDZT1BKCExKTtpZihILnByb3NlV3JhcCE9PVwibmV2ZXJcIilyZXR1cm5bbCxDZV07bGV0IGZlPUEoITApO3JldHVybltsLFMoRShmZSxDZSkpXTtmdW5jdGlvbiBBKHllKXtsZXQgRWU9W3JlKEFlWzBdLHllKSxHKHllKV07cmV0dXJuIEFlLmxlbmd0aD4xJiZFZS5wdXNoKHAoTixBZS5zbGljZSgxKS5tYXAoQmU9PnJlKEJlLHllKSkpKSxwKE4sRWUpfWZ1bmN0aW9uIEcoeWUpe3JldHVybmB8ICR7cGUubWFwKChCZSx2ZSk9PntsZXQgemU9WC5hbGlnblt2ZV0sYmU9emU9PT1cImNlbnRlclwifHx6ZT09PVwibGVmdFwiP1wiOlwiOlwiLVwiLFllPXplPT09XCJjZW50ZXJcInx8emU9PT1cInJpZ2h0XCI/XCI6XCI6XCItXCIsU2U9eWU/XCItXCI6XCItXCIucmVwZWF0KEJlLTIpO3JldHVybmAke2JlfSR7U2V9JHtZZX1gfSkuam9pbihcIiB8IFwiKX0gfGB9ZnVuY3Rpb24gcmUoeWUsRWUpe3JldHVybmB8ICR7eWUubWFwKCh2ZSx6ZSk9PntsZXR7dGV4dDpiZSx3aWR0aDpZZX09dmU7aWYoRWUpcmV0dXJuIGJlO2xldCBTZT1wZVt6ZV0tWWUsSWU9WC5hbGlnblt6ZV0sT2U9MDtJZT09PVwicmlnaHRcIj9PZT1TZTpJZT09PVwiY2VudGVyXCImJihPZT1NYXRoLmZsb29yKFNlLzIpKTtsZXQgSmU9U2UtT2U7cmV0dXJuYCR7XCIgXCIucmVwZWF0KE9lKX0ke2JlfSR7XCIgXCIucmVwZWF0KEplKX1gfSkuam9pbihcIiB8IFwiKX0gfGB9fWZ1bmN0aW9uIGRlKG9lLEgsY2Upe2xldCBYPVtdLHBlPW51bGwse2NoaWxkcmVuOkFlfT1vZS5nZXRWYWx1ZSgpO2ZvcihsZXRbQ2UsZmVdb2YgQWUuZW50cmllcygpKXN3aXRjaChVKGZlKSl7Y2FzZVwic3RhcnRcIjpwZT09PW51bGwmJihwZT17aW5kZXg6Q2Usb2Zmc2V0OmZlLnBvc2l0aW9uLmVuZC5vZmZzZXR9KTticmVhaztjYXNlXCJlbmRcIjpwZSE9PW51bGwmJihYLnB1c2goe3N0YXJ0OnBlLGVuZDp7aW5kZXg6Q2Usb2Zmc2V0OmZlLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldH19KSxwZT1udWxsKTticmVhaztkZWZhdWx0OmJyZWFrfXJldHVybiB1ZShvZSxILGNlLHtwcm9jZXNzb3I6KENlLGZlKT0+e2lmKFgubGVuZ3RoPjApe2xldCBBPVhbMF07aWYoZmU9PT1BLnN0YXJ0LmluZGV4KXJldHVybltGZShBZVtBLnN0YXJ0LmluZGV4XSksSC5vcmlnaW5hbFRleHQuc2xpY2UoQS5zdGFydC5vZmZzZXQsQS5lbmQub2Zmc2V0KSxGZShBZVtBLmVuZC5pbmRleF0pXTtpZihBLnN0YXJ0LmluZGV4PGZlJiZmZTxBLmVuZC5pbmRleClyZXR1cm4hMTtpZihmZT09PUEuZW5kLmluZGV4KXJldHVybiBYLnNoaWZ0KCksITF9cmV0dXJuIGNlKCl9fSl9ZnVuY3Rpb24gdWUob2UsSCxjZSl7bGV0IFg9YXJndW1lbnRzLmxlbmd0aD4zJiZhcmd1bWVudHNbM10hPT12b2lkIDA/YXJndW1lbnRzWzNdOnt9LHtwb3N0cHJvY2Vzc29yOnBlfT1YLEFlPVgucHJvY2Vzc29yfHwoKCk9PmNlKCkpLENlPW9lLmdldFZhbHVlKCksZmU9W10sQTtyZXR1cm4gb2UuZWFjaCgoRyxyZSk9PntsZXQgeWU9Ry5nZXRWYWx1ZSgpLEVlPUFlKEcscmUpO2lmKEVlIT09ITEpe2xldCBCZT17cGFydHM6ZmUscHJldk5vZGU6QSxwYXJlbnROb2RlOkNlLG9wdGlvbnM6SH07Wih5ZSxCZSkmJihmZS5wdXNoKGMpLEEmJnEuaGFzKEEudHlwZSl8fChzZSh5ZSxCZSl8fERlKHllLEJlKSkmJmZlLnB1c2goYyksRGUoeWUsQmUpJiZmZS5wdXNoKGMpKSxmZS5wdXNoKEVlKSxBPXllfX0sXCJjaGlsZHJlblwiKSxwZT9wZShmZSk6ZmV9ZnVuY3Rpb24gRmUob2Upe2lmKG9lLnR5cGU9PT1cImh0bWxcIilyZXR1cm4gb2UudmFsdWU7aWYob2UudHlwZT09PVwicGFyYWdyYXBoXCImJkFycmF5LmlzQXJyYXkob2UuY2hpbGRyZW4pJiZvZS5jaGlsZHJlbi5sZW5ndGg9PT0xJiZvZS5jaGlsZHJlblswXS50eXBlPT09XCJlc0NvbW1lbnRcIilyZXR1cm5bXCJ7LyogXCIsb2UuY2hpbGRyZW5bMF0udmFsdWUsXCIgKi99XCJdfWZ1bmN0aW9uIHoob2Upe2xldCBIPW9lO2Zvcig7aShILmNoaWxkcmVuKTspSD1zKEguY2hpbGRyZW4pO3JldHVybiBIfWZ1bmN0aW9uIFUob2Upe2xldCBIO2lmKG9lLnR5cGU9PT1cImh0bWxcIilIPW9lLnZhbHVlLm1hdGNoKC9ePCEtLVxccypwcmV0dGllci1pZ25vcmUoPzotKHN0YXJ0fGVuZCkpP1xccyotLT4kLyk7ZWxzZXtsZXQgY2U7b2UudHlwZT09PVwiZXNDb21tZW50XCI/Y2U9b2U6b2UudHlwZT09PVwicGFyYWdyYXBoXCImJm9lLmNoaWxkcmVuLmxlbmd0aD09PTEmJm9lLmNoaWxkcmVuWzBdLnR5cGU9PT1cImVzQ29tbWVudFwiJiYoY2U9b2UuY2hpbGRyZW5bMF0pLGNlJiYoSD1jZS52YWx1ZS5tYXRjaCgvXnByZXR0aWVyLWlnbm9yZSg/Oi0oc3RhcnR8ZW5kKSk/JC8pKX1yZXR1cm4gSD9IWzFdfHxcIm5leHRcIjohMX1mdW5jdGlvbiBaKG9lLEgpe2xldCBjZT1ILnBhcnRzLmxlbmd0aD09PTAsWD1rLmluY2x1ZGVzKG9lLnR5cGUpLHBlPW9lLnR5cGU9PT1cImh0bWxcIiYmTS5pbmNsdWRlcyhILnBhcmVudE5vZGUudHlwZSk7cmV0dXJuIWNlJiYhWCYmIXBlfWZ1bmN0aW9uIHNlKG9lLEgpe3ZhciBjZSxYLHBlO2xldCBDZT0oSC5wcmV2Tm9kZSYmSC5wcmV2Tm9kZS50eXBlKT09PW9lLnR5cGUmJkwuaGFzKG9lLnR5cGUpLGZlPUgucGFyZW50Tm9kZS50eXBlPT09XCJsaXN0SXRlbVwiJiYhSC5wYXJlbnROb2RlLmxvb3NlLEE9KChjZT1ILnByZXZOb2RlKT09PW51bGx8fGNlPT09dm9pZCAwP3ZvaWQgMDpjZS50eXBlKT09PVwibGlzdEl0ZW1cIiYmSC5wcmV2Tm9kZS5sb29zZSxHPVUoSC5wcmV2Tm9kZSk9PT1cIm5leHRcIixyZT1vZS50eXBlPT09XCJodG1sXCImJigoWD1ILnByZXZOb2RlKT09PW51bGx8fFg9PT12b2lkIDA/dm9pZCAwOlgudHlwZSk9PT1cImh0bWxcIiYmSC5wcmV2Tm9kZS5wb3NpdGlvbi5lbmQubGluZSsxPT09b2UucG9zaXRpb24uc3RhcnQubGluZSx5ZT1vZS50eXBlPT09XCJodG1sXCImJkgucGFyZW50Tm9kZS50eXBlPT09XCJsaXN0SXRlbVwiJiYoKHBlPUgucHJldk5vZGUpPT09bnVsbHx8cGU9PT12b2lkIDA/dm9pZCAwOnBlLnR5cGUpPT09XCJwYXJhZ3JhcGhcIiYmSC5wcmV2Tm9kZS5wb3NpdGlvbi5lbmQubGluZSsxPT09b2UucG9zaXRpb24uc3RhcnQubGluZTtyZXR1cm4gQXx8IShDZXx8ZmV8fEd8fHJlfHx5ZSl9ZnVuY3Rpb24gRGUob2UsSCl7bGV0IGNlPUgucHJldk5vZGUmJkgucHJldk5vZGUudHlwZT09PVwibGlzdFwiLFg9b2UudHlwZT09PVwiY29kZVwiJiZvZS5pc0luZGVudGVkO3JldHVybiBjZSYmWH1mdW5jdGlvbiBnZShvZSl7bGV0IEg9bGUob2UsW1wibGlua1JlZmVyZW5jZVwiLFwiaW1hZ2VSZWZlcmVuY2VcIl0pO3JldHVybiBIJiYoSC50eXBlIT09XCJsaW5rUmVmZXJlbmNlXCJ8fEgucmVmZXJlbmNlVHlwZSE9PVwiZnVsbFwiKX1mdW5jdGlvbiBoZShvZSl7bGV0IEg9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOltdLGNlPVtcIiBcIiwuLi5BcnJheS5pc0FycmF5KEgpP0g6W0hdXTtyZXR1cm4gbmV3IFJlZ0V4cChjZS5tYXAoWD0+YFxcXFwke1h9YCkuam9pbihcInxcIikpLnRlc3Qob2UpP2A8JHtvZX0+YDpvZX1mdW5jdGlvbiB3ZShvZSxIKXtsZXQgY2U9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOiEwO2lmKCFvZSlyZXR1cm5cIlwiO2lmKGNlKXJldHVyblwiIFwiK3dlKG9lLEgsITEpO2lmKG9lPW9lLnJlcGxhY2UoL1xcXFwoW1wiJyldKS9nLFwiJDFcIiksb2UuaW5jbHVkZXMoJ1wiJykmJm9lLmluY2x1ZGVzKFwiJ1wiKSYmIW9lLmluY2x1ZGVzKFwiKVwiKSlyZXR1cm5gKCR7b2V9KWA7bGV0IFg9b2Uuc3BsaXQoXCInXCIpLmxlbmd0aC0xLHBlPW9lLnNwbGl0KCdcIicpLmxlbmd0aC0xLEFlPVg+cGU/J1wiJzpwZT5YfHxILnNpbmdsZVF1b3RlP1wiJ1wiOidcIic7cmV0dXJuIG9lPW9lLnJlcGxhY2UoL1xcXFwvLFwiXFxcXFxcXFxcIiksb2U9b2UucmVwbGFjZShuZXcgUmVnRXhwKGAoJHtBZX0pYCxcImdcIiksXCJcXFxcJDFcIiksYCR7QWV9JHtvZX0ke0FlfWB9ZnVuY3Rpb24ga2Uob2UsSCxjZSl7cmV0dXJuIG9lPEg/SDpvZT5jZT9jZTpvZX1mdW5jdGlvbiBSZShvZSl7bGV0IEg9TnVtYmVyKG9lLmdldE5hbWUoKSk7aWYoSD09PTApcmV0dXJuITE7bGV0IGNlPW9lLmdldFBhcmVudE5vZGUoKS5jaGlsZHJlbltILTFdO3JldHVybiBVKGNlKT09PVwibmV4dFwifWZ1bmN0aW9uIE5lKG9lKXtyZXR1cm5gWyR7dChvZS5sYWJlbCl9XWB9ZnVuY3Rpb24gUGUob2Upe3JldHVybmBbXiR7b2UubGFiZWx9XWB9ci5leHBvcnRzPXtwcmVwcm9jZXNzOm8scHJpbnQ6USxlbWJlZDpmLG1hc3NhZ2VBc3ROb2RlOmgsaGFzUHJldHRpZXJJZ25vcmU6UmUsaW5zZXJ0UHJhZ21hOlR9fX0pLGZnPXRlKHtcInNyYy9sYW5ndWFnZS1tYXJrZG93bi9vcHRpb25zLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PU10KCk7ci5leHBvcnRzPXtwcm9zZVdyYXA6dC5wcm9zZVdyYXAsc2luZ2xlUXVvdGU6dC5zaW5nbGVRdW90ZX19fSksRGc9dGUoe1wic3JjL2xhbmd1YWdlLW1hcmtkb3duL3BhcnNlcnMuanNcIigpe25lKCl9fSksX2E9dGUoe1wibm9kZV9tb2R1bGVzL2xpbmd1aXN0LWxhbmd1YWdlcy9kYXRhL01hcmtkb3duLmpzb25cIihlLHIpe3IuZXhwb3J0cz17bmFtZTpcIk1hcmtkb3duXCIsdHlwZTpcInByb3NlXCIsY29sb3I6XCIjMDgzZmExXCIsYWxpYXNlczpbXCJwYW5kb2NcIl0sYWNlTW9kZTpcIm1hcmtkb3duXCIsY29kZW1pcnJvck1vZGU6XCJnZm1cIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L3gtZ2ZtXCIsd3JhcDohMCxleHRlbnNpb25zOltcIi5tZFwiLFwiLmxpdmVtZFwiLFwiLm1hcmtkb3duXCIsXCIubWRvd25cIixcIi5tZHduXCIsXCIubWR4XCIsXCIubWtkXCIsXCIubWtkblwiLFwiLm1rZG93blwiLFwiLnJvbm5cIixcIi5zY2RcIixcIi53b3JrYm9va1wiXSxmaWxlbmFtZXM6W1wiY29udGVudHMubHJcIl0sdG1TY29wZTpcInNvdXJjZS5nZm1cIixsYW5ndWFnZUlkOjIyMn19fSksbWc9dGUoe1wic3JjL2xhbmd1YWdlLW1hcmtkb3duL2luZGV4LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PV90KCkscz1wZygpLGE9ZmcoKSxuPURnKCksdT1bdChfYSgpLGw9Pih7c2luY2U6XCIxLjguMFwiLHBhcnNlcnM6W1wibWFya2Rvd25cIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wibWFya2Rvd25cIl0sZmlsZW5hbWVzOlsuLi5sLmZpbGVuYW1lcyxcIlJFQURNRVwiXSxleHRlbnNpb25zOmwuZXh0ZW5zaW9ucy5maWx0ZXIocD0+cCE9PVwiLm1keFwiKX0pKSx0KF9hKCksKCk9Pih7bmFtZTpcIk1EWFwiLHNpbmNlOlwiMS4xNS4wXCIscGFyc2VyczpbXCJtZHhcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wibWR4XCJdLGZpbGVuYW1lczpbXSxleHRlbnNpb25zOltcIi5tZHhcIl19KSldLGk9e21kYXN0OnN9O3IuZXhwb3J0cz17bGFuZ3VhZ2VzOnUsb3B0aW9uczphLHByaW50ZXJzOmkscGFyc2VyczpufX19KSxkZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9jbGVhbi5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7aXNGcm9udE1hdHRlck5vZGU6dH09VWUoKSxzPW5ldyBTZXQoW1wic291cmNlU3BhblwiLFwic3RhcnRTb3VyY2VTcGFuXCIsXCJlbmRTb3VyY2VTcGFuXCIsXCJuYW1lU3BhblwiLFwidmFsdWVTcGFuXCJdKTtmdW5jdGlvbiBhKG4sdSl7aWYobi50eXBlPT09XCJ0ZXh0XCJ8fG4udHlwZT09PVwiY29tbWVudFwifHx0KG4pfHxuLnR5cGU9PT1cInlhbWxcInx8bi50eXBlPT09XCJ0b21sXCIpcmV0dXJuIG51bGw7bi50eXBlPT09XCJhdHRyaWJ1dGVcIiYmZGVsZXRlIHUudmFsdWUsbi50eXBlPT09XCJkb2NUeXBlXCImJmRlbGV0ZSB1LnZhbHVlfWEuaWdub3JlZFByb3BlcnRpZXM9cyxyLmV4cG9ydHM9YX19KSxnZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9jb25zdGFudHMuZXZhbHVhdGUuanNcIihlLHIpe3IuZXhwb3J0cz17Q1NTX0RJU1BMQVlfVEFHUzp7YXJlYTpcIm5vbmVcIixiYXNlOlwibm9uZVwiLGJhc2Vmb250Olwibm9uZVwiLGRhdGFsaXN0Olwibm9uZVwiLGhlYWQ6XCJub25lXCIsbGluazpcIm5vbmVcIixtZXRhOlwibm9uZVwiLG5vZW1iZWQ6XCJub25lXCIsbm9mcmFtZXM6XCJub25lXCIscGFyYW06XCJibG9ja1wiLHJwOlwibm9uZVwiLHNjcmlwdDpcImJsb2NrXCIsc291cmNlOlwiYmxvY2tcIixzdHlsZTpcIm5vbmVcIix0ZW1wbGF0ZTpcImlubGluZVwiLHRyYWNrOlwiYmxvY2tcIix0aXRsZTpcIm5vbmVcIixodG1sOlwiYmxvY2tcIixib2R5OlwiYmxvY2tcIixhZGRyZXNzOlwiYmxvY2tcIixibG9ja3F1b3RlOlwiYmxvY2tcIixjZW50ZXI6XCJibG9ja1wiLGRpdjpcImJsb2NrXCIsZmlndXJlOlwiYmxvY2tcIixmaWdjYXB0aW9uOlwiYmxvY2tcIixmb290ZXI6XCJibG9ja1wiLGZvcm06XCJibG9ja1wiLGhlYWRlcjpcImJsb2NrXCIsaHI6XCJibG9ja1wiLGxlZ2VuZDpcImJsb2NrXCIsbGlzdGluZzpcImJsb2NrXCIsbWFpbjpcImJsb2NrXCIscDpcImJsb2NrXCIscGxhaW50ZXh0OlwiYmxvY2tcIixwcmU6XCJibG9ja1wiLHhtcDpcImJsb2NrXCIsc2xvdDpcImNvbnRlbnRzXCIscnVieTpcInJ1YnlcIixydDpcInJ1YnktdGV4dFwiLGFydGljbGU6XCJibG9ja1wiLGFzaWRlOlwiYmxvY2tcIixoMTpcImJsb2NrXCIsaDI6XCJibG9ja1wiLGgzOlwiYmxvY2tcIixoNDpcImJsb2NrXCIsaDU6XCJibG9ja1wiLGg2OlwiYmxvY2tcIixoZ3JvdXA6XCJibG9ja1wiLG5hdjpcImJsb2NrXCIsc2VjdGlvbjpcImJsb2NrXCIsZGlyOlwiYmxvY2tcIixkZDpcImJsb2NrXCIsZGw6XCJibG9ja1wiLGR0OlwiYmxvY2tcIixvbDpcImJsb2NrXCIsdWw6XCJibG9ja1wiLGxpOlwibGlzdC1pdGVtXCIsdGFibGU6XCJ0YWJsZVwiLGNhcHRpb246XCJ0YWJsZS1jYXB0aW9uXCIsY29sZ3JvdXA6XCJ0YWJsZS1jb2x1bW4tZ3JvdXBcIixjb2w6XCJ0YWJsZS1jb2x1bW5cIix0aGVhZDpcInRhYmxlLWhlYWRlci1ncm91cFwiLHRib2R5OlwidGFibGUtcm93LWdyb3VwXCIsdGZvb3Q6XCJ0YWJsZS1mb290ZXItZ3JvdXBcIix0cjpcInRhYmxlLXJvd1wiLHRkOlwidGFibGUtY2VsbFwiLHRoOlwidGFibGUtY2VsbFwiLGZpZWxkc2V0OlwiYmxvY2tcIixidXR0b246XCJpbmxpbmUtYmxvY2tcIixkZXRhaWxzOlwiYmxvY2tcIixzdW1tYXJ5OlwiYmxvY2tcIixkaWFsb2c6XCJibG9ja1wiLG1ldGVyOlwiaW5saW5lLWJsb2NrXCIscHJvZ3Jlc3M6XCJpbmxpbmUtYmxvY2tcIixvYmplY3Q6XCJpbmxpbmUtYmxvY2tcIix2aWRlbzpcImlubGluZS1ibG9ja1wiLGF1ZGlvOlwiaW5saW5lLWJsb2NrXCIsc2VsZWN0OlwiaW5saW5lLWJsb2NrXCIsb3B0aW9uOlwiYmxvY2tcIixvcHRncm91cDpcImJsb2NrXCJ9LENTU19ESVNQTEFZX0RFRkFVTFQ6XCJpbmxpbmVcIixDU1NfV0hJVEVfU1BBQ0VfVEFHUzp7bGlzdGluZzpcInByZVwiLHBsYWludGV4dDpcInByZVwiLHByZTpcInByZVwiLHhtcDpcInByZVwiLG5vYnI6XCJub3dyYXBcIix0YWJsZTpcImluaXRpYWxcIix0ZXh0YXJlYTpcInByZS13cmFwXCJ9LENTU19XSElURV9TUEFDRV9ERUZBVUxUOlwibm9ybWFsXCJ9fX0pLHlnPXRlKHtcInNyYy9sYW5ndWFnZS1odG1sL3V0aWxzL2lzLXVua25vd24tbmFtZXNwYWNlLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO2Z1bmN0aW9uIHQocyl7cmV0dXJuIHMudHlwZT09PVwiZWxlbWVudFwiJiYhcy5oYXNFeHBsaWNpdE5hbWVzcGFjZSYmIVtcImh0bWxcIixcInN2Z1wiXS5pbmNsdWRlcyhzLm5hbWVzcGFjZSl9ci5leHBvcnRzPXR9fSksUnQ9dGUoe1wic3JjL2xhbmd1YWdlLWh0bWwvdXRpbHMvaW5kZXguanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2luZmVyUGFyc2VyQnlMYW5ndWFnZTp0LGlzRnJvbnRNYXR0ZXJOb2RlOnN9PVVlKCkse2J1aWxkZXJzOntsaW5lOmEsaGFyZGxpbmU6bixqb2luOnV9LHV0aWxzOntnZXREb2NQYXJ0czppLHJlcGxhY2VUZXh0RW5kT2ZMaW5lOmx9fT1xZSgpLHtDU1NfRElTUExBWV9UQUdTOnAsQ1NTX0RJU1BMQVlfREVGQVVMVDpkLENTU19XSElURV9TUEFDRV9UQUdTOnksQ1NTX1dISVRFX1NQQUNFX0RFRkFVTFQ6Z309Z2coKSxjPXlnKCksRD1uZXcgU2V0KFtcIlx0XCIsYFxuYCxcIlxcZlwiLFwiXFxyXCIsXCIgXCJdKSxFPUE9PkEucmVwbGFjZSgvXltcXHRcXG5cXGZcXHIgXSsvLFwiXCIpLF89QT0+QS5yZXBsYWNlKC9bXFx0XFxuXFxmXFxyIF0rJC8sXCJcIiksdz1BPT5FKF8oQSkpLEY9QT0+QS5yZXBsYWNlKC9eW1xcdFxcZlxcciBdKlxcbi9nLFwiXCIpLFM9QT0+RihfKEEpKSxOPUE9PkEuc3BsaXQoL1tcXHRcXG5cXGZcXHIgXSsvKSxJPUE9PkEubWF0Y2goL15bXFx0XFxuXFxmXFxyIF0qLylbMF0sUD1BPT57bGV0WyxHLHJlLHllXT1BLm1hdGNoKC9eKFtcXHRcXG5cXGZcXHIgXSopKC4qPykoW1xcdFxcblxcZlxcciBdKikkL3MpO3JldHVybntsZWFkaW5nV2hpdGVzcGFjZTpHLHRyYWlsaW5nV2hpdGVzcGFjZTp5ZSx0ZXh0OnJlfX0sJD1BPT4vW1xcdFxcblxcZlxcciBdLy50ZXN0KEEpO2Z1bmN0aW9uIGYoQSxHKXtyZXR1cm4hIShBLnR5cGU9PT1cImllQ29uZGl0aW9uYWxDb21tZW50XCImJkEubGFzdENoaWxkJiYhQS5sYXN0Q2hpbGQuaXNTZWxmQ2xvc2luZyYmIUEubGFzdENoaWxkLmVuZFNvdXJjZVNwYW58fEEudHlwZT09PVwiaWVDb25kaXRpb25hbENvbW1lbnRcIiYmIUEuY29tcGxldGV8fHNlKEEpJiZBLmNoaWxkcmVuLnNvbWUocmU9PnJlLnR5cGUhPT1cInRleHRcIiYmcmUudHlwZSE9PVwiaW50ZXJwb2xhdGlvblwiKXx8WChBLEcpJiYhbyhBKSYmQS50eXBlIT09XCJpbnRlcnBvbGF0aW9uXCIpfWZ1bmN0aW9uIFQoQSl7cmV0dXJuIEEudHlwZT09PVwiYXR0cmlidXRlXCJ8fCFBLnBhcmVudHx8IUEucHJldj8hMTptKEEucHJldil9ZnVuY3Rpb24gbShBKXtyZXR1cm4gQS50eXBlPT09XCJjb21tZW50XCImJkEudmFsdWUudHJpbSgpPT09XCJwcmV0dGllci1pZ25vcmVcIn1mdW5jdGlvbiB2KEEpe3JldHVybiBBLnR5cGU9PT1cInRleHRcInx8QS50eXBlPT09XCJjb21tZW50XCJ9ZnVuY3Rpb24gbyhBKXtyZXR1cm4gQS50eXBlPT09XCJlbGVtZW50XCImJihBLmZ1bGxOYW1lPT09XCJzY3JpcHRcInx8QS5mdWxsTmFtZT09PVwic3R5bGVcInx8QS5mdWxsTmFtZT09PVwic3ZnOnN0eWxlXCJ8fGMoQSkmJihBLm5hbWU9PT1cInNjcmlwdFwifHxBLm5hbWU9PT1cInN0eWxlXCIpKX1mdW5jdGlvbiBoKEEpe3JldHVybiBBLmNoaWxkcmVuJiYhbyhBKX1mdW5jdGlvbiBDKEEpe3JldHVybiBvKEEpfHxBLnR5cGU9PT1cImludGVycG9sYXRpb25cInx8eChBKX1mdW5jdGlvbiB4KEEpe3JldHVybiB3ZShBKS5zdGFydHNXaXRoKFwicHJlXCIpfWZ1bmN0aW9uIGIoQSxHKXtsZXQgcmU9eWUoKTtpZihyZSYmIUEucHJldiYmQS5wYXJlbnQmJkEucGFyZW50LnRhZ0RlZmluaXRpb24mJkEucGFyZW50LnRhZ0RlZmluaXRpb24uaWdub3JlRmlyc3RMZilyZXR1cm4gQS50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCI7cmV0dXJuIHJlO2Z1bmN0aW9uIHllKCl7cmV0dXJuIHMoQSk/ITE6KEEudHlwZT09PVwidGV4dFwifHxBLnR5cGU9PT1cImludGVycG9sYXRpb25cIikmJkEucHJldiYmKEEucHJldi50eXBlPT09XCJ0ZXh0XCJ8fEEucHJldi50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCIpPyEwOiFBLnBhcmVudHx8QS5wYXJlbnQuY3NzRGlzcGxheT09PVwibm9uZVwiPyExOnNlKEEucGFyZW50KT8hMDohKCFBLnByZXYmJihBLnBhcmVudC50eXBlPT09XCJyb290XCJ8fHNlKEEpJiZBLnBhcmVudHx8byhBLnBhcmVudCl8fEgoQS5wYXJlbnQsRyl8fCF1ZShBLnBhcmVudC5jc3NEaXNwbGF5KSl8fEEucHJldiYmIVUoQS5wcmV2LmNzc0Rpc3BsYXkpKX19ZnVuY3Rpb24gQihBLEcpe3JldHVybiBzKEEpPyExOihBLnR5cGU9PT1cInRleHRcInx8QS50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCIpJiZBLm5leHQmJihBLm5leHQudHlwZT09PVwidGV4dFwifHxBLm5leHQudHlwZT09PVwiaW50ZXJwb2xhdGlvblwiKT8hMDohQS5wYXJlbnR8fEEucGFyZW50LmNzc0Rpc3BsYXk9PT1cIm5vbmVcIj8hMTpzZShBLnBhcmVudCk/ITA6ISghQS5uZXh0JiYoQS5wYXJlbnQudHlwZT09PVwicm9vdFwifHxzZShBKSYmQS5wYXJlbnR8fG8oQS5wYXJlbnQpfHxIKEEucGFyZW50LEcpfHwhRmUoQS5wYXJlbnQuY3NzRGlzcGxheSkpfHxBLm5leHQmJiF6KEEubmV4dC5jc3NEaXNwbGF5KSl9ZnVuY3Rpb24gayhBKXtyZXR1cm4gWihBLmNzc0Rpc3BsYXkpJiYhbyhBKX1mdW5jdGlvbiBNKEEpe3JldHVybiBzKEEpfHxBLm5leHQmJkEuc291cmNlU3Bhbi5lbmQmJkEuc291cmNlU3Bhbi5lbmQubGluZSsxPEEubmV4dC5zb3VyY2VTcGFuLnN0YXJ0LmxpbmV9ZnVuY3Rpb24gUihBKXtyZXR1cm4gcShBKXx8QS50eXBlPT09XCJlbGVtZW50XCImJkEuY2hpbGRyZW4ubGVuZ3RoPjAmJihbXCJib2R5XCIsXCJzY3JpcHRcIixcInN0eWxlXCJdLmluY2x1ZGVzKEEubmFtZSl8fEEuY2hpbGRyZW4uc29tZShHPT5lZShHKSkpfHxBLmZpcnN0Q2hpbGQmJkEuZmlyc3RDaGlsZD09PUEubGFzdENoaWxkJiZBLmZpcnN0Q2hpbGQudHlwZSE9PVwidGV4dFwiJiZWKEEuZmlyc3RDaGlsZCkmJighQS5sYXN0Q2hpbGQuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlfHxqKEEubGFzdENoaWxkKSl9ZnVuY3Rpb24gcShBKXtyZXR1cm4gQS50eXBlPT09XCJlbGVtZW50XCImJkEuY2hpbGRyZW4ubGVuZ3RoPjAmJihbXCJodG1sXCIsXCJoZWFkXCIsXCJ1bFwiLFwib2xcIixcInNlbGVjdFwiXS5pbmNsdWRlcyhBLm5hbWUpfHxBLmNzc0Rpc3BsYXkuc3RhcnRzV2l0aChcInRhYmxlXCIpJiZBLmNzc0Rpc3BsYXkhPT1cInRhYmxlLWNlbGxcIil9ZnVuY3Rpb24gSihBKXtyZXR1cm4gWShBKXx8QS5wcmV2JiZMKEEucHJldil8fFEoQSl9ZnVuY3Rpb24gTChBKXtyZXR1cm4gWShBKXx8QS50eXBlPT09XCJlbGVtZW50XCImJkEuZnVsbE5hbWU9PT1cImJyXCJ8fFEoQSl9ZnVuY3Rpb24gUShBKXtyZXR1cm4gVihBKSYmaihBKX1mdW5jdGlvbiBWKEEpe3JldHVybiBBLmhhc0xlYWRpbmdTcGFjZXMmJihBLnByZXY/QS5wcmV2LnNvdXJjZVNwYW4uZW5kLmxpbmU8QS5zb3VyY2VTcGFuLnN0YXJ0LmxpbmU6QS5wYXJlbnQudHlwZT09PVwicm9vdFwifHxBLnBhcmVudC5zdGFydFNvdXJjZVNwYW4uZW5kLmxpbmU8QS5zb3VyY2VTcGFuLnN0YXJ0LmxpbmUpfWZ1bmN0aW9uIGooQSl7cmV0dXJuIEEuaGFzVHJhaWxpbmdTcGFjZXMmJihBLm5leHQ/QS5uZXh0LnNvdXJjZVNwYW4uc3RhcnQubGluZT5BLnNvdXJjZVNwYW4uZW5kLmxpbmU6QS5wYXJlbnQudHlwZT09PVwicm9vdFwifHxBLnBhcmVudC5lbmRTb3VyY2VTcGFuJiZBLnBhcmVudC5lbmRTb3VyY2VTcGFuLnN0YXJ0LmxpbmU+QS5zb3VyY2VTcGFuLmVuZC5saW5lKX1mdW5jdGlvbiBZKEEpe3N3aXRjaChBLnR5cGUpe2Nhc2VcImllQ29uZGl0aW9uYWxDb21tZW50XCI6Y2FzZVwiY29tbWVudFwiOmNhc2VcImRpcmVjdGl2ZVwiOnJldHVybiEwO2Nhc2VcImVsZW1lbnRcIjpyZXR1cm5bXCJzY3JpcHRcIixcInNlbGVjdFwiXS5pbmNsdWRlcyhBLm5hbWUpfXJldHVybiExfWZ1bmN0aW9uIGllKEEpe3JldHVybiBBLmxhc3RDaGlsZD9pZShBLmxhc3RDaGlsZCk6QX1mdW5jdGlvbiBlZShBKXtyZXR1cm4gQS5jaGlsZHJlbiYmQS5jaGlsZHJlbi5zb21lKEc9PkcudHlwZSE9PVwidGV4dFwiKX1mdW5jdGlvbiBsZShBKXtsZXR7dHlwZTpHLGxhbmc6cmV9PUEuYXR0ck1hcDtpZihHPT09XCJtb2R1bGVcInx8Rz09PVwidGV4dC9qYXZhc2NyaXB0XCJ8fEc9PT1cInRleHQvYmFiZWxcInx8Rz09PVwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwifHxyZT09PVwianN4XCIpcmV0dXJuXCJiYWJlbFwiO2lmKEc9PT1cImFwcGxpY2F0aW9uL3gtdHlwZXNjcmlwdFwifHxyZT09PVwidHNcInx8cmU9PT1cInRzeFwiKXJldHVyblwidHlwZXNjcmlwdFwiO2lmKEc9PT1cInRleHQvbWFya2Rvd25cIilyZXR1cm5cIm1hcmtkb3duXCI7aWYoRz09PVwidGV4dC9odG1sXCIpcmV0dXJuXCJodG1sXCI7aWYoRyYmKEcuZW5kc1dpdGgoXCJqc29uXCIpfHxHLmVuZHNXaXRoKFwiaW1wb3J0bWFwXCIpKXx8Rz09PVwic3BlY3VsYXRpb25ydWxlc1wiKXJldHVyblwianNvblwiO2lmKEc9PT1cInRleHQveC1oYW5kbGViYXJzLXRlbXBsYXRlXCIpcmV0dXJuXCJnbGltbWVyXCJ9ZnVuY3Rpb24gVyhBLEcpe2xldHtsYW5nOnJlfT1BLmF0dHJNYXA7aWYoIXJlfHxyZT09PVwicG9zdGNzc1wifHxyZT09PVwiY3NzXCIpcmV0dXJuXCJjc3NcIjtpZihyZT09PVwic2Nzc1wiKXJldHVyblwic2Nzc1wiO2lmKHJlPT09XCJsZXNzXCIpcmV0dXJuXCJsZXNzXCI7aWYocmU9PT1cInN0eWx1c1wiKXJldHVybiB0KFwic3R5bHVzXCIsRyl9ZnVuY3Rpb24gSyhBLEcpe2lmKEEubmFtZT09PVwic2NyaXB0XCImJiFBLmF0dHJNYXAuc3JjKXJldHVybiFBLmF0dHJNYXAubGFuZyYmIUEuYXR0ck1hcC50eXBlP1wiYmFiZWxcIjpsZShBKTtpZihBLm5hbWU9PT1cInN0eWxlXCIpcmV0dXJuIFcoQSxHKTtpZihHJiZYKEEsRykpcmV0dXJuIGxlKEEpfHwhKFwic3JjXCJpbiBBLmF0dHJNYXApJiZ0KEEuYXR0ck1hcC5sYW5nLEcpfWZ1bmN0aW9uIGRlKEEpe3JldHVybiBBPT09XCJibG9ja1wifHxBPT09XCJsaXN0LWl0ZW1cInx8QS5zdGFydHNXaXRoKFwidGFibGVcIil9ZnVuY3Rpb24gdWUoQSl7cmV0dXJuIWRlKEEpJiZBIT09XCJpbmxpbmUtYmxvY2tcIn1mdW5jdGlvbiBGZShBKXtyZXR1cm4hZGUoQSkmJkEhPT1cImlubGluZS1ibG9ja1wifWZ1bmN0aW9uIHooQSl7cmV0dXJuIWRlKEEpfWZ1bmN0aW9uIFUoQSl7cmV0dXJuIWRlKEEpfWZ1bmN0aW9uIFooQSl7cmV0dXJuIWRlKEEpJiZBIT09XCJpbmxpbmUtYmxvY2tcIn1mdW5jdGlvbiBzZShBKXtyZXR1cm4gd2UoQSkuc3RhcnRzV2l0aChcInByZVwiKX1mdW5jdGlvbiBEZShBLEcpe2xldCByZT0wO2ZvcihsZXQgeWU9QS5zdGFjay5sZW5ndGgtMTt5ZT49MDt5ZS0tKXtsZXQgRWU9QS5zdGFja1t5ZV07RWUmJnR5cGVvZiBFZT09XCJvYmplY3RcIiYmIUFycmF5LmlzQXJyYXkoRWUpJiZHKEVlKSYmcmUrK31yZXR1cm4gcmV9ZnVuY3Rpb24gZ2UoQSxHKXtsZXQgcmU9QTtmb3IoO3JlOyl7aWYoRyhyZSkpcmV0dXJuITA7cmU9cmUucGFyZW50fXJldHVybiExfWZ1bmN0aW9uIGhlKEEsRyl7aWYoQS5wcmV2JiZBLnByZXYudHlwZT09PVwiY29tbWVudFwiKXtsZXQgeWU9QS5wcmV2LnZhbHVlLm1hdGNoKC9eXFxzKmRpc3BsYXk6XFxzKihbYS16XSspXFxzKiQvKTtpZih5ZSlyZXR1cm4geWVbMV19bGV0IHJlPSExO2lmKEEudHlwZT09PVwiZWxlbWVudFwiJiZBLm5hbWVzcGFjZT09PVwic3ZnXCIpaWYoZ2UoQSx5ZT0+eWUuZnVsbE5hbWU9PT1cInN2Zzpmb3JlaWduT2JqZWN0XCIpKXJlPSEwO2Vsc2UgcmV0dXJuIEEubmFtZT09PVwic3ZnXCI/XCJpbmxpbmUtYmxvY2tcIjpcImJsb2NrXCI7c3dpdGNoKEcuaHRtbFdoaXRlc3BhY2VTZW5zaXRpdml0eSl7Y2FzZVwic3RyaWN0XCI6cmV0dXJuXCJpbmxpbmVcIjtjYXNlXCJpZ25vcmVcIjpyZXR1cm5cImJsb2NrXCI7ZGVmYXVsdDpyZXR1cm4gRy5wYXJzZXI9PT1cInZ1ZVwiJiZBLnBhcmVudCYmQS5wYXJlbnQudHlwZT09PVwicm9vdFwiP1wiYmxvY2tcIjpBLnR5cGU9PT1cImVsZW1lbnRcIiYmKCFBLm5hbWVzcGFjZXx8cmV8fGMoQSkpJiZwW0EubmFtZV18fGR9fWZ1bmN0aW9uIHdlKEEpe3JldHVybiBBLnR5cGU9PT1cImVsZW1lbnRcIiYmKCFBLm5hbWVzcGFjZXx8YyhBKSkmJnlbQS5uYW1lXXx8Z31mdW5jdGlvbiBrZShBKXtsZXQgRz1OdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7Zm9yKGxldCByZSBvZiBBLnNwbGl0KGBcbmApKXtpZihyZS5sZW5ndGg9PT0wKWNvbnRpbnVlO2lmKCFELmhhcyhyZVswXSkpcmV0dXJuIDA7bGV0IHllPUkocmUpLmxlbmd0aDtyZS5sZW5ndGghPT15ZSYmeWU8RyYmKEc9eWUpfXJldHVybiBHPT09TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZPzA6R31mdW5jdGlvbiBSZShBKXtsZXQgRz1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06a2UoQSk7cmV0dXJuIEc9PT0wP0E6QS5zcGxpdChgXG5gKS5tYXAocmU9PnJlLnNsaWNlKEcpKS5qb2luKGBcbmApfWZ1bmN0aW9uIE5lKEEsRyl7bGV0IHJlPTA7Zm9yKGxldCB5ZT0wO3llPEEubGVuZ3RoO3llKyspQVt5ZV09PT1HJiZyZSsrO3JldHVybiByZX1mdW5jdGlvbiBQZShBKXtyZXR1cm4gQS5yZXBsYWNlKC8mYXBvczsvZyxcIidcIikucmVwbGFjZSgvJnF1b3Q7L2csJ1wiJyl9dmFyIG9lPW5ldyBTZXQoW1widGVtcGxhdGVcIixcInN0eWxlXCIsXCJzY3JpcHRcIl0pO2Z1bmN0aW9uIEgoQSxHKXtyZXR1cm4gY2UoQSxHKSYmIW9lLmhhcyhBLmZ1bGxOYW1lKX1mdW5jdGlvbiBjZShBLEcpe3JldHVybiBHLnBhcnNlcj09PVwidnVlXCImJkEudHlwZT09PVwiZWxlbWVudFwiJiZBLnBhcmVudC50eXBlPT09XCJyb290XCImJkEuZnVsbE5hbWUudG9Mb3dlckNhc2UoKSE9PVwiaHRtbFwifWZ1bmN0aW9uIFgoQSxHKXtyZXR1cm4gY2UoQSxHKSYmKEgoQSxHKXx8QS5hdHRyTWFwLmxhbmcmJkEuYXR0ck1hcC5sYW5nIT09XCJodG1sXCIpfWZ1bmN0aW9uIHBlKEEpe2xldCBHPUEuZnVsbE5hbWU7cmV0dXJuIEcuY2hhckF0KDApPT09XCIjXCJ8fEc9PT1cInNsb3Qtc2NvcGVcInx8Rz09PVwidi1zbG90XCJ8fEcuc3RhcnRzV2l0aChcInYtc2xvdDpcIil9ZnVuY3Rpb24gQWUoQSxHKXtsZXQgcmU9QS5wYXJlbnQ7aWYoIWNlKHJlLEcpKXJldHVybiExO2xldCB5ZT1yZS5mdWxsTmFtZSxFZT1BLmZ1bGxOYW1lO3JldHVybiB5ZT09PVwic2NyaXB0XCImJkVlPT09XCJzZXR1cFwifHx5ZT09PVwic3R5bGVcIiYmRWU9PT1cInZhcnNcIn1mdW5jdGlvbiBDZShBKXtsZXQgRz1hcmd1bWVudHMubGVuZ3RoPjEmJmFyZ3VtZW50c1sxXSE9PXZvaWQgMD9hcmd1bWVudHNbMV06QS52YWx1ZTtyZXR1cm4gQS5wYXJlbnQuaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlP0EucGFyZW50LmlzSW5kZW50YXRpb25TZW5zaXRpdmU/bChHKTpsKFJlKFMoRykpLG4pOmkodShhLE4oRykpKX1mdW5jdGlvbiBmZShBLEcpe3JldHVybiBjZShBLEcpJiZBLm5hbWU9PT1cInNjcmlwdFwifXIuZXhwb3J0cz17aHRtbFRyaW06dyxodG1sVHJpbVByZXNlcnZlSW5kZW50YXRpb246UyxoYXNIdG1sV2hpdGVzcGFjZTokLGdldExlYWRpbmdBbmRUcmFpbGluZ0h0bWxXaGl0ZXNwYWNlOlAsY2FuSGF2ZUludGVycG9sYXRpb246aCxjb3VudENoYXJzOk5lLGNvdW50UGFyZW50czpEZSxkZWRlbnRTdHJpbmc6UmUsZm9yY2VCcmVha0NoaWxkcmVuOnEsZm9yY2VCcmVha0NvbnRlbnQ6Uixmb3JjZU5leHRFbXB0eUxpbmU6TSxnZXRMYXN0RGVzY2VuZGFudDppZSxnZXROb2RlQ3NzU3R5bGVEaXNwbGF5OmhlLGdldE5vZGVDc3NTdHlsZVdoaXRlU3BhY2U6d2UsaGFzUHJldHRpZXJJZ25vcmU6VCxpbmZlclNjcmlwdFBhcnNlcjpLLGlzVnVlQ3VzdG9tQmxvY2s6SCxpc1Z1ZU5vbkh0bWxCbG9jazpYLGlzVnVlU2NyaXB0VGFnOmZlLGlzVnVlU2xvdEF0dHJpYnV0ZTpwZSxpc1Z1ZVNmY0JpbmRpbmdzQXR0cmlidXRlOkFlLGlzVnVlU2ZjQmxvY2s6Y2UsaXNEYW5nbGluZ1NwYWNlU2Vuc2l0aXZlTm9kZTprLGlzSW5kZW50YXRpb25TZW5zaXRpdmVOb2RlOngsaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmVOb2RlOmIsaXNQcmVMaWtlTm9kZTpzZSxpc1NjcmlwdExpa2VUYWc6byxpc1RleHRMaWtlTm9kZTp2LGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6Qixpc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlOkMsaXNVbmtub3duTmFtZXNwYWNlOmMscHJlZmVySGFyZGxpbmVBc0xlYWRpbmdTcGFjZXM6SixwcmVmZXJIYXJkbGluZUFzVHJhaWxpbmdTcGFjZXM6TCxzaG91bGRQcmVzZXJ2ZUNvbnRlbnQ6Zix1bmVzY2FwZVF1b3RlRW50aXRpZXM6UGUsZ2V0VGV4dFZhbHVlUGFydHM6Q2V9fX0pLGhnPXRlKHtcIm5vZGVfbW9kdWxlcy9hbmd1bGFyLWh0bWwtcGFyc2VyL2xpYi9jb21waWxlci9zcmMvY2hhcnMuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pLGUuJEVPRj0wLGUuJEJTUEFDRT04LGUuJFRBQj05LGUuJExGPTEwLGUuJFZUQUI9MTEsZS4kRkY9MTIsZS4kQ1I9MTMsZS4kU1BBQ0U9MzIsZS4kQkFORz0zMyxlLiREUT0zNCxlLiRIQVNIPTM1LGUuJCQ9MzYsZS4kUEVSQ0VOVD0zNyxlLiRBTVBFUlNBTkQ9MzgsZS4kU1E9MzksZS4kTFBBUkVOPTQwLGUuJFJQQVJFTj00MSxlLiRTVEFSPTQyLGUuJFBMVVM9NDMsZS4kQ09NTUE9NDQsZS4kTUlOVVM9NDUsZS4kUEVSSU9EPTQ2LGUuJFNMQVNIPTQ3LGUuJENPTE9OPTU4LGUuJFNFTUlDT0xPTj01OSxlLiRMVD02MCxlLiRFUT02MSxlLiRHVD02MixlLiRRVUVTVElPTj02MyxlLiQwPTQ4LGUuJDc9NTUsZS4kOT01NyxlLiRBPTY1LGUuJEU9NjksZS4kRj03MCxlLiRYPTg4LGUuJFo9OTAsZS4kTEJSQUNLRVQ9OTEsZS4kQkFDS1NMQVNIPTkyLGUuJFJCUkFDS0VUPTkzLGUuJENBUkVUPTk0LGUuJF89OTUsZS4kYT05NyxlLiRiPTk4LGUuJGU9MTAxLGUuJGY9MTAyLGUuJG49MTEwLGUuJHI9MTE0LGUuJHQ9MTE2LGUuJHU9MTE3LGUuJHY9MTE4LGUuJHg9MTIwLGUuJHo9MTIyLGUuJExCUkFDRT0xMjMsZS4kQkFSPTEyNCxlLiRSQlJBQ0U9MTI1LGUuJE5CU1A9MTYwLGUuJFBJUEU9MTI0LGUuJFRJTERBPTEyNixlLiRBVD02NCxlLiRCVD05NjtmdW5jdGlvbiByKGkpe3JldHVybiBpPj1lLiRUQUImJmk8PWUuJFNQQUNFfHxpPT1lLiROQlNQfWUuaXNXaGl0ZXNwYWNlPXI7ZnVuY3Rpb24gdChpKXtyZXR1cm4gZS4kMDw9aSYmaTw9ZS4kOX1lLmlzRGlnaXQ9dDtmdW5jdGlvbiBzKGkpe3JldHVybiBpPj1lLiRhJiZpPD1lLiR6fHxpPj1lLiRBJiZpPD1lLiRafWUuaXNBc2NpaUxldHRlcj1zO2Z1bmN0aW9uIGEoaSl7cmV0dXJuIGk+PWUuJGEmJmk8PWUuJGZ8fGk+PWUuJEEmJmk8PWUuJEZ8fHQoaSl9ZS5pc0FzY2lpSGV4RGlnaXQ9YTtmdW5jdGlvbiBuKGkpe3JldHVybiBpPT09ZS4kTEZ8fGk9PT1lLiRDUn1lLmlzTmV3TGluZT1uO2Z1bmN0aW9uIHUoaSl7cmV0dXJuIGUuJDA8PWkmJmk8PWUuJDd9ZS5pc09jdGFsRGlnaXQ9dX19KSx2Zz10ZSh7XCJub2RlX21vZHVsZXMvYW5ndWxhci1odG1sLXBhcnNlci9saWIvY29tcGlsZXIvc3JjL2FvdC9zdGF0aWNfc3ltYm9sLmpzXCIoZSl7XCJ1c2Ugc3RyaWN0XCI7bmUoKSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KTt2YXIgcj1jbGFzc3tjb25zdHJ1Y3RvcihzLGEsbil7dGhpcy5maWxlUGF0aD1zLHRoaXMubmFtZT1hLHRoaXMubWVtYmVycz1ufWFzc2VydE5vTWVtYmVycygpe2lmKHRoaXMubWVtYmVycy5sZW5ndGgpdGhyb3cgbmV3IEVycm9yKGBJbGxlZ2FsIHN0YXRlOiBzeW1ib2wgd2l0aG91dCBtZW1iZXJzIGV4cGVjdGVkLCBidXQgZ290ICR7SlNPTi5zdHJpbmdpZnkodGhpcyl9LmApfX07ZS5TdGF0aWNTeW1ib2w9cjt2YXIgdD1jbGFzc3tjb25zdHJ1Y3Rvcigpe3RoaXMuY2FjaGU9bmV3IE1hcH1nZXQocyxhLG4pe249bnx8W107bGV0IHU9bi5sZW5ndGg/YC4ke24uam9pbihcIi5cIil9YDpcIlwiLGk9YFwiJHtzfVwiLiR7YX0ke3V9YCxsPXRoaXMuY2FjaGUuZ2V0KGkpO3JldHVybiBsfHwobD1uZXcgcihzLGEsbiksdGhpcy5jYWNoZS5zZXQoaSxsKSksbH19O2UuU3RhdGljU3ltYm9sQ2FjaGU9dH19KSxDZz10ZSh7XCJub2RlX21vZHVsZXMvYW5ndWxhci1odG1sLXBhcnNlci9saWIvY29tcGlsZXIvc3JjL3V0aWwuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPS8tKyhbYS16MC05XSkvZztmdW5jdGlvbiB0KG8pe3JldHVybiBvLnJlcGxhY2UocixmdW5jdGlvbigpe2Zvcih2YXIgaD1hcmd1bWVudHMubGVuZ3RoLEM9bmV3IEFycmF5KGgpLHg9MDt4PGg7eCsrKUNbeF09YXJndW1lbnRzW3hdO3JldHVybiBDWzFdLnRvVXBwZXJDYXNlKCl9KX1lLmRhc2hDYXNlVG9DYW1lbENhc2U9dDtmdW5jdGlvbiBzKG8saCl7cmV0dXJuIG4obyxcIjpcIixoKX1lLnNwbGl0QXRDb2xvbj1zO2Z1bmN0aW9uIGEobyxoKXtyZXR1cm4gbihvLFwiLlwiLGgpfWUuc3BsaXRBdFBlcmlvZD1hO2Z1bmN0aW9uIG4obyxoLEMpe2xldCB4PW8uaW5kZXhPZihoKTtyZXR1cm4geD09LTE/Qzpbby5zbGljZSgwLHgpLnRyaW0oKSxvLnNsaWNlKHgrMSkudHJpbSgpXX1mdW5jdGlvbiB1KG8saCxDKXtyZXR1cm4gQXJyYXkuaXNBcnJheShvKT9oLnZpc2l0QXJyYXkobyxDKTpGKG8pP2gudmlzaXRTdHJpbmdNYXAobyxDKTpvPT1udWxsfHx0eXBlb2Ygbz09XCJzdHJpbmdcInx8dHlwZW9mIG89PVwibnVtYmVyXCJ8fHR5cGVvZiBvPT1cImJvb2xlYW5cIj9oLnZpc2l0UHJpbWl0aXZlKG8sQyk6aC52aXNpdE90aGVyKG8sQyl9ZS52aXNpdFZhbHVlPXU7ZnVuY3Rpb24gaShvKXtyZXR1cm4gbyE9bnVsbH1lLmlzRGVmaW5lZD1pO2Z1bmN0aW9uIGwobyl7cmV0dXJuIG89PT12b2lkIDA/bnVsbDpvfWUubm9VbmRlZmluZWQ9bDt2YXIgcD1jbGFzc3t2aXNpdEFycmF5KG8saCl7cmV0dXJuIG8ubWFwKEM9PnUoQyx0aGlzLGgpKX12aXNpdFN0cmluZ01hcChvLGgpe2xldCBDPXt9O3JldHVybiBPYmplY3Qua2V5cyhvKS5mb3JFYWNoKHg9PntDW3hdPXUob1t4XSx0aGlzLGgpfSksQ312aXNpdFByaW1pdGl2ZShvLGgpe3JldHVybiBvfXZpc2l0T3RoZXIobyxoKXtyZXR1cm4gb319O2UuVmFsdWVUcmFuc2Zvcm1lcj1wLGUuU3luY0FzeW5jPXthc3NlcnRTeW5jOm89PntpZihQKG8pKXRocm93IG5ldyBFcnJvcihcIklsbGVnYWwgc3RhdGU6IHZhbHVlIGNhbm5vdCBiZSBhIHByb21pc2VcIik7cmV0dXJuIG99LHRoZW46KG8saCk9PlAobyk/by50aGVuKGgpOmgobyksYWxsOm89Pm8uc29tZShQKT9Qcm9taXNlLmFsbChvKTpvfTtmdW5jdGlvbiBkKG8pe3Rocm93IG5ldyBFcnJvcihgSW50ZXJuYWwgRXJyb3I6ICR7b31gKX1lLmVycm9yPWQ7ZnVuY3Rpb24geShvLGgpe2xldCBDPUVycm9yKG8pO3JldHVybiBDW2ddPSEwLGgmJihDW2NdPWgpLEN9ZS5zeW50YXhFcnJvcj15O3ZhciBnPVwibmdTeW50YXhFcnJvclwiLGM9XCJuZ1BhcnNlRXJyb3JzXCI7ZnVuY3Rpb24gRChvKXtyZXR1cm4gb1tnXX1lLmlzU3ludGF4RXJyb3I9RDtmdW5jdGlvbiBFKG8pe3JldHVybiBvW2NdfHxbXX1lLmdldFBhcnNlRXJyb3JzPUU7ZnVuY3Rpb24gXyhvKXtyZXR1cm4gby5yZXBsYWNlKC8oWy4qKz9ePSE6JHt9KCl8W1xcXVxcL1xcXFxdKS9nLFwiXFxcXCQxXCIpfWUuZXNjYXBlUmVnRXhwPV87dmFyIHc9T2JqZWN0LmdldFByb3RvdHlwZU9mKHt9KTtmdW5jdGlvbiBGKG8pe3JldHVybiB0eXBlb2Ygbz09XCJvYmplY3RcIiYmbyE9PW51bGwmJk9iamVjdC5nZXRQcm90b3R5cGVPZihvKT09PXd9ZnVuY3Rpb24gUyhvKXtsZXQgaD1cIlwiO2ZvcihsZXQgQz0wO0M8by5sZW5ndGg7QysrKXtsZXQgeD1vLmNoYXJDb2RlQXQoQyk7aWYoeD49NTUyOTYmJng8PTU2MzE5JiZvLmxlbmd0aD5DKzEpe2xldCBiPW8uY2hhckNvZGVBdChDKzEpO2I+PTU2MzIwJiZiPD01NzM0MyYmKEMrKyx4PSh4LTU1Mjk2PDwxMCkrYi01NjMyMCs2NTUzNil9eDw9MTI3P2grPVN0cmluZy5mcm9tQ2hhckNvZGUoeCk6eDw9MjA0Nz9oKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHg+PjYmMzF8MTkyLHgmNjN8MTI4KTp4PD02NTUzNT9oKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHg+PjEyfDIyNCx4Pj42JjYzfDEyOCx4JjYzfDEyOCk6eDw9MjA5NzE1MSYmKGgrPVN0cmluZy5mcm9tQ2hhckNvZGUoeD4+MTgmN3wyNDAseD4+MTImNjN8MTI4LHg+PjYmNjN8MTI4LHgmNjN8MTI4KSl9cmV0dXJuIGh9ZS51dGY4RW5jb2RlPVM7ZnVuY3Rpb24gTihvKXtpZih0eXBlb2Ygbz09XCJzdHJpbmdcIilyZXR1cm4gbztpZihvIGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuXCJbXCIrby5tYXAoTikuam9pbihcIiwgXCIpK1wiXVwiO2lmKG89PW51bGwpcmV0dXJuXCJcIitvO2lmKG8ub3ZlcnJpZGRlbk5hbWUpcmV0dXJuYCR7by5vdmVycmlkZGVuTmFtZX1gO2lmKG8ubmFtZSlyZXR1cm5gJHtvLm5hbWV9YDtpZighby50b1N0cmluZylyZXR1cm5cIm9iamVjdFwiO2xldCBoPW8udG9TdHJpbmcoKTtpZihoPT1udWxsKXJldHVyblwiXCIraDtsZXQgQz1oLmluZGV4T2YoYFxuYCk7cmV0dXJuIEM9PT0tMT9oOmguc3Vic3RyaW5nKDAsQyl9ZS5zdHJpbmdpZnk9TjtmdW5jdGlvbiBJKG8pe3JldHVybiB0eXBlb2Ygbz09XCJmdW5jdGlvblwiJiZvLmhhc093blByb3BlcnR5KFwiX19mb3J3YXJkX3JlZl9fXCIpP28oKTpvfWUucmVzb2x2ZUZvcndhcmRSZWY9STtmdW5jdGlvbiBQKG8pe3JldHVybiEhbyYmdHlwZW9mIG8udGhlbj09XCJmdW5jdGlvblwifWUuaXNQcm9taXNlPVA7dmFyICQ9Y2xhc3N7Y29uc3RydWN0b3Iobyl7dGhpcy5mdWxsPW87bGV0IGg9by5zcGxpdChcIi5cIik7dGhpcy5tYWpvcj1oWzBdLHRoaXMubWlub3I9aFsxXSx0aGlzLnBhdGNoPWguc2xpY2UoMikuam9pbihcIi5cIil9fTtlLlZlcnNpb249JDt2YXIgZj10eXBlb2Ygd2luZG93PFwidVwiJiZ3aW5kb3csVD10eXBlb2Ygc2VsZjxcInVcIiYmdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlPFwidVwiJiZzZWxmIGluc3RhbmNlb2YgV29ya2VyR2xvYmFsU2NvcGUmJnNlbGYsbT10eXBlb2YgZ2xvYmFsVGhpczxcInVcIiYmZ2xvYmFsVGhpcyx2PW18fGZ8fFQ7ZS5nbG9iYWw9dn19KSxFZz10ZSh7XCJub2RlX21vZHVsZXMvYW5ndWxhci1odG1sLXBhcnNlci9saWIvY29tcGlsZXIvc3JjL2NvbXBpbGVfbWV0YWRhdGEuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPXZnKCksdD1DZygpLHM9L14oPzooPzpcXFsoW15cXF1dKylcXF0pfCg/OlxcKChbXlxcKV0rKVxcKSkpfChcXEBbLVxcd10rKSQvO2Z1bmN0aW9uIGEoQyl7cmV0dXJuIEMucmVwbGFjZSgvXFxXL2csXCJfXCIpfWUuc2FuaXRpemVJZGVudGlmaWVyPWE7dmFyIG49MDtmdW5jdGlvbiB1KEMpe2lmKCFDfHwhQy5yZWZlcmVuY2UpcmV0dXJuIG51bGw7bGV0IHg9Qy5yZWZlcmVuY2U7aWYoeCBpbnN0YW5jZW9mIHIuU3RhdGljU3ltYm9sKXJldHVybiB4Lm5hbWU7aWYoeC5fX2Fub255bW91c1R5cGUpcmV0dXJuIHguX19hbm9ueW1vdXNUeXBlO2xldCBiPXQuc3RyaW5naWZ5KHgpO3JldHVybiBiLmluZGV4T2YoXCIoXCIpPj0wPyhiPWBhbm9ueW1vdXNfJHtuKyt9YCx4Ll9fYW5vbnltb3VzVHlwZT1iKTpiPWEoYiksYn1lLmlkZW50aWZpZXJOYW1lPXU7ZnVuY3Rpb24gaShDKXtsZXQgeD1DLnJlZmVyZW5jZTtyZXR1cm4geCBpbnN0YW5jZW9mIHIuU3RhdGljU3ltYm9sP3guZmlsZVBhdGg6YC4vJHt0LnN0cmluZ2lmeSh4KX1gfWUuaWRlbnRpZmllck1vZHVsZVVybD1pO2Z1bmN0aW9uIGwoQyx4KXtyZXR1cm5gVmlld18ke3Uoe3JlZmVyZW5jZTpDfSl9XyR7eH1gfWUudmlld0NsYXNzTmFtZT1sO2Z1bmN0aW9uIHAoQyl7cmV0dXJuYFJlbmRlclR5cGVfJHt1KHtyZWZlcmVuY2U6Q30pfWB9ZS5yZW5kZXJlclR5cGVOYW1lPXA7ZnVuY3Rpb24gZChDKXtyZXR1cm5gSG9zdFZpZXdfJHt1KHtyZWZlcmVuY2U6Q30pfWB9ZS5ob3N0Vmlld0NsYXNzTmFtZT1kO2Z1bmN0aW9uIHkoQyl7cmV0dXJuYCR7dSh7cmVmZXJlbmNlOkN9KX1OZ0ZhY3RvcnlgfWUuY29tcG9uZW50RmFjdG9yeU5hbWU9eTt2YXIgZzsoZnVuY3Rpb24oQyl7Q1tDLlBpcGU9MF09XCJQaXBlXCIsQ1tDLkRpcmVjdGl2ZT0xXT1cIkRpcmVjdGl2ZVwiLENbQy5OZ01vZHVsZT0yXT1cIk5nTW9kdWxlXCIsQ1tDLkluamVjdGFibGU9M109XCJJbmplY3RhYmxlXCJ9KShnPWUuQ29tcGlsZVN1bW1hcnlLaW5kfHwoZS5Db21waWxlU3VtbWFyeUtpbmQ9e30pKTtmdW5jdGlvbiBjKEMpe3JldHVybiBDLnZhbHVlIT1udWxsP2EoQy52YWx1ZSk6dShDLmlkZW50aWZpZXIpfWUudG9rZW5OYW1lPWM7ZnVuY3Rpb24gRChDKXtyZXR1cm4gQy5pZGVudGlmaWVyIT1udWxsP0MuaWRlbnRpZmllci5yZWZlcmVuY2U6Qy52YWx1ZX1lLnRva2VuUmVmZXJlbmNlPUQ7dmFyIEU9Y2xhc3N7Y29uc3RydWN0b3IoKXtsZXR7bW9kdWxlVXJsOkMsc3R5bGVzOngsc3R5bGVVcmxzOmJ9PWFyZ3VtZW50cy5sZW5ndGg+MCYmYXJndW1lbnRzWzBdIT09dm9pZCAwP2FyZ3VtZW50c1swXTp7fTt0aGlzLm1vZHVsZVVybD1DfHxudWxsLHRoaXMuc3R5bGVzPVAoeCksdGhpcy5zdHlsZVVybHM9UChiKX19O2UuQ29tcGlsZVN0eWxlc2hlZXRNZXRhZGF0YT1FO3ZhciBfPWNsYXNze2NvbnN0cnVjdG9yKEMpe2xldHtlbmNhcHN1bGF0aW9uOngsdGVtcGxhdGU6Yix0ZW1wbGF0ZVVybDpCLGh0bWxBc3Q6ayxzdHlsZXM6TSxzdHlsZVVybHM6UixleHRlcm5hbFN0eWxlc2hlZXRzOnEsYW5pbWF0aW9uczpKLG5nQ29udGVudFNlbGVjdG9yczpMLGludGVycG9sYXRpb246USxpc0lubGluZTpWLHByZXNlcnZlV2hpdGVzcGFjZXM6an09QztpZih0aGlzLmVuY2Fwc3VsYXRpb249eCx0aGlzLnRlbXBsYXRlPWIsdGhpcy50ZW1wbGF0ZVVybD1CLHRoaXMuaHRtbEFzdD1rLHRoaXMuc3R5bGVzPVAoTSksdGhpcy5zdHlsZVVybHM9UChSKSx0aGlzLmV4dGVybmFsU3R5bGVzaGVldHM9UChxKSx0aGlzLmFuaW1hdGlvbnM9Sj9mKEopOltdLHRoaXMubmdDb250ZW50U2VsZWN0b3JzPUx8fFtdLFEmJlEubGVuZ3RoIT0yKXRocm93IG5ldyBFcnJvcihcIidpbnRlcnBvbGF0aW9uJyBzaG91bGQgaGF2ZSBhIHN0YXJ0IGFuZCBhbiBlbmQgc3ltYm9sLlwiKTt0aGlzLmludGVycG9sYXRpb249USx0aGlzLmlzSW5saW5lPVYsdGhpcy5wcmVzZXJ2ZVdoaXRlc3BhY2VzPWp9dG9TdW1tYXJ5KCl7cmV0dXJue25nQ29udGVudFNlbGVjdG9yczp0aGlzLm5nQ29udGVudFNlbGVjdG9ycyxlbmNhcHN1bGF0aW9uOnRoaXMuZW5jYXBzdWxhdGlvbixzdHlsZXM6dGhpcy5zdHlsZXMsYW5pbWF0aW9uczp0aGlzLmFuaW1hdGlvbnN9fX07ZS5Db21waWxlVGVtcGxhdGVNZXRhZGF0YT1fO3ZhciB3PWNsYXNze3N0YXRpYyBjcmVhdGUoQyl7bGV0e2lzSG9zdDp4LHR5cGU6Yixpc0NvbXBvbmVudDpCLHNlbGVjdG9yOmssZXhwb3J0QXM6TSxjaGFuZ2VEZXRlY3Rpb246UixpbnB1dHM6cSxvdXRwdXRzOkosaG9zdDpMLHByb3ZpZGVyczpRLHZpZXdQcm92aWRlcnM6VixxdWVyaWVzOmosZ3VhcmRzOlksdmlld1F1ZXJpZXM6aWUsZW50cnlDb21wb25lbnRzOmVlLHRlbXBsYXRlOmxlLGNvbXBvbmVudFZpZXdUeXBlOlcscmVuZGVyZXJUeXBlOkssY29tcG9uZW50RmFjdG9yeTpkZX09Qyx1ZT17fSxGZT17fSx6PXt9O0whPW51bGwmJk9iamVjdC5rZXlzKEwpLmZvckVhY2goc2U9PntsZXQgRGU9TFtzZV0sZ2U9c2UubWF0Y2gocyk7Z2U9PT1udWxsP3pbc2VdPURlOmdlWzFdIT1udWxsP0ZlW2dlWzFdXT1EZTpnZVsyXSE9bnVsbCYmKHVlW2dlWzJdXT1EZSl9KTtsZXQgVT17fTtxIT1udWxsJiZxLmZvckVhY2goc2U9PntsZXQgRGU9dC5zcGxpdEF0Q29sb24oc2UsW3NlLHNlXSk7VVtEZVswXV09RGVbMV19KTtsZXQgWj17fTtyZXR1cm4gSiE9bnVsbCYmSi5mb3JFYWNoKHNlPT57bGV0IERlPXQuc3BsaXRBdENvbG9uKHNlLFtzZSxzZV0pO1pbRGVbMF1dPURlWzFdfSksbmV3IHcoe2lzSG9zdDp4LHR5cGU6Yixpc0NvbXBvbmVudDohIUIsc2VsZWN0b3I6ayxleHBvcnRBczpNLGNoYW5nZURldGVjdGlvbjpSLGlucHV0czpVLG91dHB1dHM6Wixob3N0TGlzdGVuZXJzOnVlLGhvc3RQcm9wZXJ0aWVzOkZlLGhvc3RBdHRyaWJ1dGVzOnoscHJvdmlkZXJzOlEsdmlld1Byb3ZpZGVyczpWLHF1ZXJpZXM6aixndWFyZHM6WSx2aWV3UXVlcmllczppZSxlbnRyeUNvbXBvbmVudHM6ZWUsdGVtcGxhdGU6bGUsY29tcG9uZW50Vmlld1R5cGU6VyxyZW5kZXJlclR5cGU6Syxjb21wb25lbnRGYWN0b3J5OmRlfSl9Y29uc3RydWN0b3IoQyl7bGV0e2lzSG9zdDp4LHR5cGU6Yixpc0NvbXBvbmVudDpCLHNlbGVjdG9yOmssZXhwb3J0QXM6TSxjaGFuZ2VEZXRlY3Rpb246UixpbnB1dHM6cSxvdXRwdXRzOkosaG9zdExpc3RlbmVyczpMLGhvc3RQcm9wZXJ0aWVzOlEsaG9zdEF0dHJpYnV0ZXM6Vixwcm92aWRlcnM6aix2aWV3UHJvdmlkZXJzOlkscXVlcmllczppZSxndWFyZHM6ZWUsdmlld1F1ZXJpZXM6bGUsZW50cnlDb21wb25lbnRzOlcsdGVtcGxhdGU6Syxjb21wb25lbnRWaWV3VHlwZTpkZSxyZW5kZXJlclR5cGU6dWUsY29tcG9uZW50RmFjdG9yeTpGZX09Qzt0aGlzLmlzSG9zdD0hIXgsdGhpcy50eXBlPWIsdGhpcy5pc0NvbXBvbmVudD1CLHRoaXMuc2VsZWN0b3I9ayx0aGlzLmV4cG9ydEFzPU0sdGhpcy5jaGFuZ2VEZXRlY3Rpb249Uix0aGlzLmlucHV0cz1xLHRoaXMub3V0cHV0cz1KLHRoaXMuaG9zdExpc3RlbmVycz1MLHRoaXMuaG9zdFByb3BlcnRpZXM9USx0aGlzLmhvc3RBdHRyaWJ1dGVzPVYsdGhpcy5wcm92aWRlcnM9UChqKSx0aGlzLnZpZXdQcm92aWRlcnM9UChZKSx0aGlzLnF1ZXJpZXM9UChpZSksdGhpcy5ndWFyZHM9ZWUsdGhpcy52aWV3UXVlcmllcz1QKGxlKSx0aGlzLmVudHJ5Q29tcG9uZW50cz1QKFcpLHRoaXMudGVtcGxhdGU9Syx0aGlzLmNvbXBvbmVudFZpZXdUeXBlPWRlLHRoaXMucmVuZGVyZXJUeXBlPXVlLHRoaXMuY29tcG9uZW50RmFjdG9yeT1GZX10b1N1bW1hcnkoKXtyZXR1cm57c3VtbWFyeUtpbmQ6Zy5EaXJlY3RpdmUsdHlwZTp0aGlzLnR5cGUsaXNDb21wb25lbnQ6dGhpcy5pc0NvbXBvbmVudCxzZWxlY3Rvcjp0aGlzLnNlbGVjdG9yLGV4cG9ydEFzOnRoaXMuZXhwb3J0QXMsaW5wdXRzOnRoaXMuaW5wdXRzLG91dHB1dHM6dGhpcy5vdXRwdXRzLGhvc3RMaXN0ZW5lcnM6dGhpcy5ob3N0TGlzdGVuZXJzLGhvc3RQcm9wZXJ0aWVzOnRoaXMuaG9zdFByb3BlcnRpZXMsaG9zdEF0dHJpYnV0ZXM6dGhpcy5ob3N0QXR0cmlidXRlcyxwcm92aWRlcnM6dGhpcy5wcm92aWRlcnMsdmlld1Byb3ZpZGVyczp0aGlzLnZpZXdQcm92aWRlcnMscXVlcmllczp0aGlzLnF1ZXJpZXMsZ3VhcmRzOnRoaXMuZ3VhcmRzLHZpZXdRdWVyaWVzOnRoaXMudmlld1F1ZXJpZXMsZW50cnlDb21wb25lbnRzOnRoaXMuZW50cnlDb21wb25lbnRzLGNoYW5nZURldGVjdGlvbjp0aGlzLmNoYW5nZURldGVjdGlvbix0ZW1wbGF0ZTp0aGlzLnRlbXBsYXRlJiZ0aGlzLnRlbXBsYXRlLnRvU3VtbWFyeSgpLGNvbXBvbmVudFZpZXdUeXBlOnRoaXMuY29tcG9uZW50Vmlld1R5cGUscmVuZGVyZXJUeXBlOnRoaXMucmVuZGVyZXJUeXBlLGNvbXBvbmVudEZhY3Rvcnk6dGhpcy5jb21wb25lbnRGYWN0b3J5fX19O2UuQ29tcGlsZURpcmVjdGl2ZU1ldGFkYXRhPXc7dmFyIEY9Y2xhc3N7Y29uc3RydWN0b3IoQyl7bGV0e3R5cGU6eCxuYW1lOmIscHVyZTpCfT1DO3RoaXMudHlwZT14LHRoaXMubmFtZT1iLHRoaXMucHVyZT0hIUJ9dG9TdW1tYXJ5KCl7cmV0dXJue3N1bW1hcnlLaW5kOmcuUGlwZSx0eXBlOnRoaXMudHlwZSxuYW1lOnRoaXMubmFtZSxwdXJlOnRoaXMucHVyZX19fTtlLkNvbXBpbGVQaXBlTWV0YWRhdGE9Rjt2YXIgUz1jbGFzc3t9O2UuQ29tcGlsZVNoYWxsb3dNb2R1bGVNZXRhZGF0YT1TO3ZhciBOPWNsYXNze2NvbnN0cnVjdG9yKEMpe2xldHt0eXBlOngscHJvdmlkZXJzOmIsZGVjbGFyZWREaXJlY3RpdmVzOkIsZXhwb3J0ZWREaXJlY3RpdmVzOmssZGVjbGFyZWRQaXBlczpNLGV4cG9ydGVkUGlwZXM6UixlbnRyeUNvbXBvbmVudHM6cSxib290c3RyYXBDb21wb25lbnRzOkosaW1wb3J0ZWRNb2R1bGVzOkwsZXhwb3J0ZWRNb2R1bGVzOlEsc2NoZW1hczpWLHRyYW5zaXRpdmVNb2R1bGU6aixpZDpZfT1DO3RoaXMudHlwZT14fHxudWxsLHRoaXMuZGVjbGFyZWREaXJlY3RpdmVzPVAoQiksdGhpcy5leHBvcnRlZERpcmVjdGl2ZXM9UChrKSx0aGlzLmRlY2xhcmVkUGlwZXM9UChNKSx0aGlzLmV4cG9ydGVkUGlwZXM9UChSKSx0aGlzLnByb3ZpZGVycz1QKGIpLHRoaXMuZW50cnlDb21wb25lbnRzPVAocSksdGhpcy5ib290c3RyYXBDb21wb25lbnRzPVAoSiksdGhpcy5pbXBvcnRlZE1vZHVsZXM9UChMKSx0aGlzLmV4cG9ydGVkTW9kdWxlcz1QKFEpLHRoaXMuc2NoZW1hcz1QKFYpLHRoaXMuaWQ9WXx8bnVsbCx0aGlzLnRyYW5zaXRpdmVNb2R1bGU9anx8bnVsbH10b1N1bW1hcnkoKXtsZXQgQz10aGlzLnRyYW5zaXRpdmVNb2R1bGU7cmV0dXJue3N1bW1hcnlLaW5kOmcuTmdNb2R1bGUsdHlwZTp0aGlzLnR5cGUsZW50cnlDb21wb25lbnRzOkMuZW50cnlDb21wb25lbnRzLHByb3ZpZGVyczpDLnByb3ZpZGVycyxtb2R1bGVzOkMubW9kdWxlcyxleHBvcnRlZERpcmVjdGl2ZXM6Qy5leHBvcnRlZERpcmVjdGl2ZXMsZXhwb3J0ZWRQaXBlczpDLmV4cG9ydGVkUGlwZXN9fX07ZS5Db21waWxlTmdNb2R1bGVNZXRhZGF0YT1OO3ZhciBJPWNsYXNze2NvbnN0cnVjdG9yKCl7dGhpcy5kaXJlY3RpdmVzU2V0PW5ldyBTZXQsdGhpcy5kaXJlY3RpdmVzPVtdLHRoaXMuZXhwb3J0ZWREaXJlY3RpdmVzU2V0PW5ldyBTZXQsdGhpcy5leHBvcnRlZERpcmVjdGl2ZXM9W10sdGhpcy5waXBlc1NldD1uZXcgU2V0LHRoaXMucGlwZXM9W10sdGhpcy5leHBvcnRlZFBpcGVzU2V0PW5ldyBTZXQsdGhpcy5leHBvcnRlZFBpcGVzPVtdLHRoaXMubW9kdWxlc1NldD1uZXcgU2V0LHRoaXMubW9kdWxlcz1bXSx0aGlzLmVudHJ5Q29tcG9uZW50c1NldD1uZXcgU2V0LHRoaXMuZW50cnlDb21wb25lbnRzPVtdLHRoaXMucHJvdmlkZXJzPVtdfWFkZFByb3ZpZGVyKEMseCl7dGhpcy5wcm92aWRlcnMucHVzaCh7cHJvdmlkZXI6Qyxtb2R1bGU6eH0pfWFkZERpcmVjdGl2ZShDKXt0aGlzLmRpcmVjdGl2ZXNTZXQuaGFzKEMucmVmZXJlbmNlKXx8KHRoaXMuZGlyZWN0aXZlc1NldC5hZGQoQy5yZWZlcmVuY2UpLHRoaXMuZGlyZWN0aXZlcy5wdXNoKEMpKX1hZGRFeHBvcnRlZERpcmVjdGl2ZShDKXt0aGlzLmV4cG9ydGVkRGlyZWN0aXZlc1NldC5oYXMoQy5yZWZlcmVuY2UpfHwodGhpcy5leHBvcnRlZERpcmVjdGl2ZXNTZXQuYWRkKEMucmVmZXJlbmNlKSx0aGlzLmV4cG9ydGVkRGlyZWN0aXZlcy5wdXNoKEMpKX1hZGRQaXBlKEMpe3RoaXMucGlwZXNTZXQuaGFzKEMucmVmZXJlbmNlKXx8KHRoaXMucGlwZXNTZXQuYWRkKEMucmVmZXJlbmNlKSx0aGlzLnBpcGVzLnB1c2goQykpfWFkZEV4cG9ydGVkUGlwZShDKXt0aGlzLmV4cG9ydGVkUGlwZXNTZXQuaGFzKEMucmVmZXJlbmNlKXx8KHRoaXMuZXhwb3J0ZWRQaXBlc1NldC5hZGQoQy5yZWZlcmVuY2UpLHRoaXMuZXhwb3J0ZWRQaXBlcy5wdXNoKEMpKX1hZGRNb2R1bGUoQyl7dGhpcy5tb2R1bGVzU2V0LmhhcyhDLnJlZmVyZW5jZSl8fCh0aGlzLm1vZHVsZXNTZXQuYWRkKEMucmVmZXJlbmNlKSx0aGlzLm1vZHVsZXMucHVzaChDKSl9YWRkRW50cnlDb21wb25lbnQoQyl7dGhpcy5lbnRyeUNvbXBvbmVudHNTZXQuaGFzKEMuY29tcG9uZW50VHlwZSl8fCh0aGlzLmVudHJ5Q29tcG9uZW50c1NldC5hZGQoQy5jb21wb25lbnRUeXBlKSx0aGlzLmVudHJ5Q29tcG9uZW50cy5wdXNoKEMpKX19O2UuVHJhbnNpdGl2ZUNvbXBpbGVOZ01vZHVsZU1ldGFkYXRhPUk7ZnVuY3Rpb24gUChDKXtyZXR1cm4gQ3x8W119dmFyICQ9Y2xhc3N7Y29uc3RydWN0b3IoQyx4KXtsZXR7dXNlQ2xhc3M6Yix1c2VWYWx1ZTpCLHVzZUV4aXN0aW5nOmssdXNlRmFjdG9yeTpNLGRlcHM6UixtdWx0aTpxfT14O3RoaXMudG9rZW49Qyx0aGlzLnVzZUNsYXNzPWJ8fG51bGwsdGhpcy51c2VWYWx1ZT1CLHRoaXMudXNlRXhpc3Rpbmc9ayx0aGlzLnVzZUZhY3Rvcnk9TXx8bnVsbCx0aGlzLmRlcGVuZGVuY2llcz1SfHxudWxsLHRoaXMubXVsdGk9ISFxfX07ZS5Qcm92aWRlck1ldGE9JDtmdW5jdGlvbiBmKEMpe3JldHVybiBDLnJlZHVjZSgoeCxiKT0+e2xldCBCPUFycmF5LmlzQXJyYXkoYik/ZihiKTpiO3JldHVybiB4LmNvbmNhdChCKX0sW10pfWUuZmxhdHRlbj1mO2Z1bmN0aW9uIFQoQyl7cmV0dXJuIEMucmVwbGFjZSgvKFxcdys6XFwvXFwvW1xcdzotXSspPyhcXC8rKT8vLFwibmc6Ly8vXCIpfWZ1bmN0aW9uIG0oQyx4LGIpe2xldCBCO3JldHVybiBiLmlzSW5saW5lP3gudHlwZS5yZWZlcmVuY2UgaW5zdGFuY2VvZiByLlN0YXRpY1N5bWJvbD9CPWAke3gudHlwZS5yZWZlcmVuY2UuZmlsZVBhdGh9LiR7eC50eXBlLnJlZmVyZW5jZS5uYW1lfS5odG1sYDpCPWAke3UoQyl9LyR7dSh4LnR5cGUpfS5odG1sYDpCPWIudGVtcGxhdGVVcmwseC50eXBlLnJlZmVyZW5jZSBpbnN0YW5jZW9mIHIuU3RhdGljU3ltYm9sP0I6VChCKX1lLnRlbXBsYXRlU291cmNlVXJsPW07ZnVuY3Rpb24gdihDLHgpe2xldCBiPUMubW9kdWxlVXJsLnNwbGl0KC9cXC9cXFxcL2cpLEI9YltiLmxlbmd0aC0xXTtyZXR1cm4gVChgY3NzLyR7eH0ke0J9Lm5nc3R5bGUuanNgKX1lLnNoYXJlZFN0eWxlc2hlZXRKaXRVcmw9djtmdW5jdGlvbiBvKEMpe3JldHVybiBUKGAke3UoQy50eXBlKX0vbW9kdWxlLm5nZmFjdG9yeS5qc2ApfWUubmdNb2R1bGVKaXRVcmw9bztmdW5jdGlvbiBoKEMseCl7cmV0dXJuIFQoYCR7dShDKX0vJHt1KHgudHlwZSl9Lm5nZmFjdG9yeS5qc2ApfWUudGVtcGxhdGVKaXRVcmw9aH19KSxGZz10ZSh7XCJub2RlX21vZHVsZXMvYW5ndWxhci1odG1sLXBhcnNlci9saWIvY29tcGlsZXIvc3JjL3BhcnNlX3V0aWwuanNcIihlKXtcInVzZSBzdHJpY3RcIjtuZSgpLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLFwiX19lc01vZHVsZVwiLHt2YWx1ZTohMH0pO3ZhciByPWhnKCksdD1FZygpLHM9Y2xhc3N7Y29uc3RydWN0b3IoZCx5LGcsYyl7dGhpcy5maWxlPWQsdGhpcy5vZmZzZXQ9eSx0aGlzLmxpbmU9Zyx0aGlzLmNvbD1jfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMub2Zmc2V0IT1udWxsP2Ake3RoaXMuZmlsZS51cmx9QCR7dGhpcy5saW5lfToke3RoaXMuY29sfWA6dGhpcy5maWxlLnVybH1tb3ZlQnkoZCl7bGV0IHk9dGhpcy5maWxlLmNvbnRlbnQsZz15Lmxlbmd0aCxjPXRoaXMub2Zmc2V0LEQ9dGhpcy5saW5lLEU9dGhpcy5jb2w7Zm9yKDtjPjAmJmQ8MDspaWYoYy0tLGQrKyx5LmNoYXJDb2RlQXQoYyk9PXIuJExGKXtELS07bGV0IHc9eS5zdWJzdHIoMCxjLTEpLmxhc3RJbmRleE9mKFN0cmluZy5mcm9tQ2hhckNvZGUoci4kTEYpKTtFPXc+MD9jLXc6Y31lbHNlIEUtLTtmb3IoO2M8ZyYmZD4wOyl7bGV0IF89eS5jaGFyQ29kZUF0KGMpO2MrKyxkLS0sXz09ci4kTEY/KEQrKyxFPTApOkUrK31yZXR1cm4gbmV3IHModGhpcy5maWxlLGMsRCxFKX1nZXRDb250ZXh0KGQseSl7bGV0IGc9dGhpcy5maWxlLmNvbnRlbnQsYz10aGlzLm9mZnNldDtpZihjIT1udWxsKXtjPmcubGVuZ3RoLTEmJihjPWcubGVuZ3RoLTEpO2xldCBEPWMsRT0wLF89MDtmb3IoO0U8ZCYmYz4wJiYoYy0tLEUrKywhKGdbY109PWBcbmAmJisrXz09eSkpOyk7Zm9yKEU9MCxfPTA7RTxkJiZEPGcubGVuZ3RoLTEmJihEKyssRSsrLCEoZ1tEXT09YFxuYCYmKytfPT15KSk7KTtyZXR1cm57YmVmb3JlOmcuc3Vic3RyaW5nKGMsdGhpcy5vZmZzZXQpLGFmdGVyOmcuc3Vic3RyaW5nKHRoaXMub2Zmc2V0LEQrMSl9fXJldHVybiBudWxsfX07ZS5QYXJzZUxvY2F0aW9uPXM7dmFyIGE9Y2xhc3N7Y29uc3RydWN0b3IoZCx5KXt0aGlzLmNvbnRlbnQ9ZCx0aGlzLnVybD15fX07ZS5QYXJzZVNvdXJjZUZpbGU9YTt2YXIgbj1jbGFzc3tjb25zdHJ1Y3RvcihkLHkpe2xldCBnPWFyZ3VtZW50cy5sZW5ndGg+MiYmYXJndW1lbnRzWzJdIT09dm9pZCAwP2FyZ3VtZW50c1syXTpudWxsO3RoaXMuc3RhcnQ9ZCx0aGlzLmVuZD15LHRoaXMuZGV0YWlscz1nfXRvU3RyaW5nKCl7cmV0dXJuIHRoaXMuc3RhcnQuZmlsZS5jb250ZW50LnN1YnN0cmluZyh0aGlzLnN0YXJ0Lm9mZnNldCx0aGlzLmVuZC5vZmZzZXQpfX07ZS5QYXJzZVNvdXJjZVNwYW49bixlLkVNUFRZX1BBUlNFX0xPQ0FUSU9OPW5ldyBzKG5ldyBhKFwiXCIsXCJcIiksMCwwLDApLGUuRU1QVFlfU09VUkNFX1NQQU49bmV3IG4oZS5FTVBUWV9QQVJTRV9MT0NBVElPTixlLkVNUFRZX1BBUlNFX0xPQ0FUSU9OKTt2YXIgdTsoZnVuY3Rpb24oZCl7ZFtkLldBUk5JTkc9MF09XCJXQVJOSU5HXCIsZFtkLkVSUk9SPTFdPVwiRVJST1JcIn0pKHU9ZS5QYXJzZUVycm9yTGV2ZWx8fChlLlBhcnNlRXJyb3JMZXZlbD17fSkpO3ZhciBpPWNsYXNze2NvbnN0cnVjdG9yKGQseSl7bGV0IGc9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl0hPT12b2lkIDA/YXJndW1lbnRzWzJdOnUuRVJST1I7dGhpcy5zcGFuPWQsdGhpcy5tc2c9eSx0aGlzLmxldmVsPWd9Y29udGV4dHVhbE1lc3NhZ2UoKXtsZXQgZD10aGlzLnNwYW4uc3RhcnQuZ2V0Q29udGV4dCgxMDAsMyk7cmV0dXJuIGQ/YCR7dGhpcy5tc2d9IChcIiR7ZC5iZWZvcmV9WyR7dVt0aGlzLmxldmVsXX0gLT5dJHtkLmFmdGVyfVwiKWA6dGhpcy5tc2d9dG9TdHJpbmcoKXtsZXQgZD10aGlzLnNwYW4uZGV0YWlscz9gLCAke3RoaXMuc3Bhbi5kZXRhaWxzfWA6XCJcIjtyZXR1cm5gJHt0aGlzLmNvbnRleHR1YWxNZXNzYWdlKCl9OiAke3RoaXMuc3Bhbi5zdGFydH0ke2R9YH19O2UuUGFyc2VFcnJvcj1pO2Z1bmN0aW9uIGwoZCx5KXtsZXQgZz10LmlkZW50aWZpZXJNb2R1bGVVcmwoeSksYz1nIT1udWxsP2BpbiAke2R9ICR7dC5pZGVudGlmaWVyTmFtZSh5KX0gaW4gJHtnfWA6YGluICR7ZH0gJHt0LmlkZW50aWZpZXJOYW1lKHkpfWAsRD1uZXcgYShcIlwiLGMpO3JldHVybiBuZXcgbihuZXcgcyhELC0xLC0xLC0xKSxuZXcgcyhELC0xLC0xLC0xKSl9ZS50eXBlU291cmNlU3Bhbj1sO2Z1bmN0aW9uIHAoZCx5LGcpe2xldCBjPWBpbiAke2R9ICR7eX0gaW4gJHtnfWAsRD1uZXcgYShcIlwiLGMpO3JldHVybiBuZXcgbihuZXcgcyhELC0xLC0xLC0xKSxuZXcgcyhELC0xLC0xLC0xKSl9ZS5yM0ppdFR5cGVTb3VyY2VTcGFuPXB9fSksQWc9dGUoe1wic3JjL2xhbmd1YWdlLWh0bWwvcHJpbnQtcHJlcHJvY2Vzcy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7UGFyc2VTb3VyY2VTcGFuOnR9PUZnKCkse2h0bWxUcmltOnMsZ2V0TGVhZGluZ0FuZFRyYWlsaW5nSHRtbFdoaXRlc3BhY2U6YSxoYXNIdG1sV2hpdGVzcGFjZTpuLGNhbkhhdmVJbnRlcnBvbGF0aW9uOnUsZ2V0Tm9kZUNzc1N0eWxlRGlzcGxheTppLGlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6bCxpc0luZGVudGF0aW9uU2Vuc2l0aXZlTm9kZTpwLGlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlTm9kZTpkLGlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZU5vZGU6eSxpc1doaXRlc3BhY2VTZW5zaXRpdmVOb2RlOmcsaXNWdWVTY3JpcHRUYWc6Y309UnQoKSxEPVtfLHcsUyxJLFAsVCwkLGYsbSxOLHZdO2Z1bmN0aW9uIEUobyxoKXtmb3IobGV0IEMgb2YgRClDKG8saCk7cmV0dXJuIG99ZnVuY3Rpb24gXyhvKXtvLndhbGsoaD0+e2lmKGgudHlwZT09PVwiZWxlbWVudFwiJiZoLnRhZ0RlZmluaXRpb24uaWdub3JlRmlyc3RMZiYmaC5jaGlsZHJlbi5sZW5ndGg+MCYmaC5jaGlsZHJlblswXS50eXBlPT09XCJ0ZXh0XCImJmguY2hpbGRyZW5bMF0udmFsdWVbMF09PT1gXG5gKXtsZXQgQz1oLmNoaWxkcmVuWzBdO0MudmFsdWUubGVuZ3RoPT09MT9oLnJlbW92ZUNoaWxkKEMpOkMudmFsdWU9Qy52YWx1ZS5zbGljZSgxKX19KX1mdW5jdGlvbiB3KG8pe2xldCBoPUM9PkMudHlwZT09PVwiZWxlbWVudFwiJiZDLnByZXYmJkMucHJldi50eXBlPT09XCJpZUNvbmRpdGlvbmFsU3RhcnRDb21tZW50XCImJkMucHJldi5zb3VyY2VTcGFuLmVuZC5vZmZzZXQ9PT1DLnN0YXJ0U291cmNlU3Bhbi5zdGFydC5vZmZzZXQmJkMuZmlyc3RDaGlsZCYmQy5maXJzdENoaWxkLnR5cGU9PT1cImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCImJkMuZmlyc3RDaGlsZC5zb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldD09PUMuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7by53YWxrKEM9PntpZihDLmNoaWxkcmVuKWZvcihsZXQgeD0wO3g8Qy5jaGlsZHJlbi5sZW5ndGg7eCsrKXtsZXQgYj1DLmNoaWxkcmVuW3hdO2lmKCFoKGIpKWNvbnRpbnVlO2xldCBCPWIucHJldixrPWIuZmlyc3RDaGlsZDtDLnJlbW92ZUNoaWxkKEIpLHgtLTtsZXQgTT1uZXcgdChCLnNvdXJjZVNwYW4uc3RhcnQsay5zb3VyY2VTcGFuLmVuZCksUj1uZXcgdChNLnN0YXJ0LGIuc291cmNlU3Bhbi5lbmQpO2IuY29uZGl0aW9uPUIuY29uZGl0aW9uLGIuc291cmNlU3Bhbj1SLGIuc3RhcnRTb3VyY2VTcGFuPU0sYi5yZW1vdmVDaGlsZChrKX19KX1mdW5jdGlvbiBGKG8saCxDKXtvLndhbGsoeD0+e2lmKHguY2hpbGRyZW4pZm9yKGxldCBiPTA7Yjx4LmNoaWxkcmVuLmxlbmd0aDtiKyspe2xldCBCPXguY2hpbGRyZW5bYl07aWYoQi50eXBlIT09XCJ0ZXh0XCImJiFoKEIpKWNvbnRpbnVlO0IudHlwZSE9PVwidGV4dFwiJiYoQi50eXBlPVwidGV4dFwiLEIudmFsdWU9QyhCKSk7bGV0IGs9Qi5wcmV2OyFrfHxrLnR5cGUhPT1cInRleHRcInx8KGsudmFsdWUrPUIudmFsdWUsay5zb3VyY2VTcGFuPW5ldyB0KGsuc291cmNlU3Bhbi5zdGFydCxCLnNvdXJjZVNwYW4uZW5kKSx4LnJlbW92ZUNoaWxkKEIpLGItLSl9fSl9ZnVuY3Rpb24gUyhvKXtyZXR1cm4gRihvLGg9PmgudHlwZT09PVwiY2RhdGFcIixoPT5gPCFbQ0RBVEFbJHtoLnZhbHVlfV1dPmApfWZ1bmN0aW9uIE4obyl7bGV0IGg9Qz0+Qy50eXBlPT09XCJlbGVtZW50XCImJkMuYXR0cnMubGVuZ3RoPT09MCYmQy5jaGlsZHJlbi5sZW5ndGg9PT0xJiZDLmZpcnN0Q2hpbGQudHlwZT09PVwidGV4dFwiJiYhbihDLmNoaWxkcmVuWzBdLnZhbHVlKSYmIUMuZmlyc3RDaGlsZC5oYXNMZWFkaW5nU3BhY2VzJiYhQy5maXJzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzJiZDLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlJiYhQy5oYXNMZWFkaW5nU3BhY2VzJiZDLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSYmIUMuaGFzVHJhaWxpbmdTcGFjZXMmJkMucHJldiYmQy5wcmV2LnR5cGU9PT1cInRleHRcIiYmQy5uZXh0JiZDLm5leHQudHlwZT09PVwidGV4dFwiO28ud2FsayhDPT57aWYoQy5jaGlsZHJlbilmb3IobGV0IHg9MDt4PEMuY2hpbGRyZW4ubGVuZ3RoO3grKyl7bGV0IGI9Qy5jaGlsZHJlblt4XTtpZighaChiKSljb250aW51ZTtsZXQgQj1iLnByZXYsaz1iLm5leHQ7Qi52YWx1ZSs9YDwke2IucmF3TmFtZX0+YCtiLmZpcnN0Q2hpbGQudmFsdWUrYDwvJHtiLnJhd05hbWV9PmAray52YWx1ZSxCLnNvdXJjZVNwYW49bmV3IHQoQi5zb3VyY2VTcGFuLnN0YXJ0LGsuc291cmNlU3Bhbi5lbmQpLEIuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlPWsuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlLEIuaGFzVHJhaWxpbmdTcGFjZXM9ay5oYXNUcmFpbGluZ1NwYWNlcyxDLnJlbW92ZUNoaWxkKGIpLHgtLSxDLnJlbW92ZUNoaWxkKGspfX0pfWZ1bmN0aW9uIEkobyxoKXtpZihoLnBhcnNlcj09PVwiaHRtbFwiKXJldHVybjtsZXQgQz0ve3soLis/KX19L3M7by53YWxrKHg9PntpZih1KHgpKWZvcihsZXQgYiBvZiB4LmNoaWxkcmVuKXtpZihiLnR5cGUhPT1cInRleHRcIiljb250aW51ZTtsZXQgQj1iLnNvdXJjZVNwYW4uc3RhcnQsaz1udWxsLE09Yi52YWx1ZS5zcGxpdChDKTtmb3IobGV0IFI9MDtSPE0ubGVuZ3RoO1IrKyxCPWspe2xldCBxPU1bUl07aWYoUiUyPT09MCl7az1CLm1vdmVCeShxLmxlbmd0aCkscS5sZW5ndGg+MCYmeC5pbnNlcnRDaGlsZEJlZm9yZShiLHt0eXBlOlwidGV4dFwiLHZhbHVlOnEsc291cmNlU3BhbjpuZXcgdChCLGspfSk7Y29udGludWV9az1CLm1vdmVCeShxLmxlbmd0aCs0KSx4Lmluc2VydENoaWxkQmVmb3JlKGIse3R5cGU6XCJpbnRlcnBvbGF0aW9uXCIsc291cmNlU3BhbjpuZXcgdChCLGspLGNoaWxkcmVuOnEubGVuZ3RoPT09MD9bXTpbe3R5cGU6XCJ0ZXh0XCIsdmFsdWU6cSxzb3VyY2VTcGFuOm5ldyB0KEIubW92ZUJ5KDIpLGsubW92ZUJ5KC0yKSl9XX0pfXgucmVtb3ZlQ2hpbGQoYil9fSl9ZnVuY3Rpb24gUChvKXtvLndhbGsoaD0+e2lmKCFoLmNoaWxkcmVuKXJldHVybjtpZihoLmNoaWxkcmVuLmxlbmd0aD09PTB8fGguY2hpbGRyZW4ubGVuZ3RoPT09MSYmaC5jaGlsZHJlblswXS50eXBlPT09XCJ0ZXh0XCImJnMoaC5jaGlsZHJlblswXS52YWx1ZSkubGVuZ3RoPT09MCl7aC5oYXNEYW5nbGluZ1NwYWNlcz1oLmNoaWxkcmVuLmxlbmd0aD4wLGguY2hpbGRyZW49W107cmV0dXJufWxldCBDPWcoaCkseD1wKGgpO2lmKCFDKWZvcihsZXQgYj0wO2I8aC5jaGlsZHJlbi5sZW5ndGg7YisrKXtsZXQgQj1oLmNoaWxkcmVuW2JdO2lmKEIudHlwZSE9PVwidGV4dFwiKWNvbnRpbnVlO2xldHtsZWFkaW5nV2hpdGVzcGFjZTprLHRleHQ6TSx0cmFpbGluZ1doaXRlc3BhY2U6Un09YShCLnZhbHVlKSxxPUIucHJldixKPUIubmV4dDtNPyhCLnZhbHVlPU0sQi5zb3VyY2VTcGFuPW5ldyB0KEIuc291cmNlU3Bhbi5zdGFydC5tb3ZlQnkoay5sZW5ndGgpLEIuc291cmNlU3Bhbi5lbmQubW92ZUJ5KC1SLmxlbmd0aCkpLGsmJihxJiYocS5oYXNUcmFpbGluZ1NwYWNlcz0hMCksQi5oYXNMZWFkaW5nU3BhY2VzPSEwKSxSJiYoQi5oYXNUcmFpbGluZ1NwYWNlcz0hMCxKJiYoSi5oYXNMZWFkaW5nU3BhY2VzPSEwKSkpOihoLnJlbW92ZUNoaWxkKEIpLGItLSwoa3x8UikmJihxJiYocS5oYXNUcmFpbGluZ1NwYWNlcz0hMCksSiYmKEouaGFzTGVhZGluZ1NwYWNlcz0hMCkpKX1oLmlzV2hpdGVzcGFjZVNlbnNpdGl2ZT1DLGguaXNJbmRlbnRhdGlvblNlbnNpdGl2ZT14fSl9ZnVuY3Rpb24gJChvKXtvLndhbGsoaD0+e2guaXNTZWxmQ2xvc2luZz0haC5jaGlsZHJlbnx8aC50eXBlPT09XCJlbGVtZW50XCImJihoLnRhZ0RlZmluaXRpb24uaXNWb2lkfHxoLnN0YXJ0U291cmNlU3Bhbj09PWguZW5kU291cmNlU3Bhbil9KX1mdW5jdGlvbiBmKG8saCl7by53YWxrKEM9PntDLnR5cGU9PT1cImVsZW1lbnRcIiYmKEMuaGFzSHRtQ29tcG9uZW50Q2xvc2luZ1RhZz1DLmVuZFNvdXJjZVNwYW4mJi9ePFxccypcXC9cXHMqXFwvXFxzKj4kLy50ZXN0KGgub3JpZ2luYWxUZXh0LnNsaWNlKEMuZW5kU291cmNlU3Bhbi5zdGFydC5vZmZzZXQsQy5lbmRTb3VyY2VTcGFuLmVuZC5vZmZzZXQpKSl9KX1mdW5jdGlvbiBUKG8saCl7by53YWxrKEM9PntDLmNzc0Rpc3BsYXk9aShDLGgpfSl9ZnVuY3Rpb24gbShvLGgpe28ud2FsayhDPT57bGV0e2NoaWxkcmVuOnh9PUM7aWYoeCl7aWYoeC5sZW5ndGg9PT0wKXtDLmlzRGFuZ2xpbmdTcGFjZVNlbnNpdGl2ZT1sKEMpO3JldHVybn1mb3IobGV0IGIgb2YgeCliLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlPWQoYixoKSxiLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZT15KGIsaCk7Zm9yKGxldCBiPTA7Yjx4Lmxlbmd0aDtiKyspe2xldCBCPXhbYl07Qi5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZT0oYj09PTB8fEIucHJldi5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUpJiZCLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlLEIuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlPShiPT09eC5sZW5ndGgtMXx8Qi5uZXh0LmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlKSYmQi5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmV9fX0pfWZ1bmN0aW9uIHYobyxoKXtpZihoLnBhcnNlcj09PVwidnVlXCIpe2xldCBDPW8uY2hpbGRyZW4uZmluZChiPT5jKGIsaCkpO2lmKCFDKXJldHVybjtsZXR7bGFuZzp4fT1DLmF0dHJNYXA7KHg9PT1cInRzXCJ8fHg9PT1cInR5cGVzY3JpcHRcIikmJihoLl9fc2hvdWxkX3BhcnNlX3Z1ZV90ZW1wbGF0ZV93aXRoX3RzPSEwKX19ci5leHBvcnRzPUV9fSksU2c9dGUoe1wic3JjL2xhbmd1YWdlLWh0bWwvcHJhZ21hLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO2Z1bmN0aW9uIHQoYSl7cmV0dXJuL15cXHMqPCEtLVxccypAKD86Zm9ybWF0fHByZXR0aWVyKVxccyotLT4vLnRlc3QoYSl9ZnVuY3Rpb24gcyhhKXtyZXR1cm5gPCEtLSBAZm9ybWF0IC0tPlxuXG5gK2EucmVwbGFjZSgvXlxccypcXG4vLFwiXCIpfXIuZXhwb3J0cz17aGFzUHJhZ21hOnQsaW5zZXJ0UHJhZ21hOnN9fX0pLGF1PXRlKHtcInNyYy9sYW5ndWFnZS1odG1sL2xvYy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KGEpe3JldHVybiBhLnNvdXJjZVNwYW4uc3RhcnQub2Zmc2V0fWZ1bmN0aW9uIHMoYSl7cmV0dXJuIGEuc291cmNlU3Bhbi5lbmQub2Zmc2V0fXIuZXhwb3J0cz17bG9jU3RhcnQ6dCxsb2NFbmQ6c319fSksdXI9dGUoe1wic3JjL2xhbmd1YWdlLWh0bWwvcHJpbnQvdGFnLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PVp0KCkse2lzTm9uRW1wdHlBcnJheTpzfT1VZSgpLHtidWlsZGVyczp7aW5kZW50OmEsam9pbjpuLGxpbmU6dSxzb2Z0bGluZTppLGhhcmRsaW5lOmx9LHV0aWxzOntyZXBsYWNlVGV4dEVuZE9mTGluZTpwfX09cWUoKSx7bG9jU3RhcnQ6ZCxsb2NFbmQ6eX09YXUoKSx7aXNUZXh0TGlrZU5vZGU6ZyxnZXRMYXN0RGVzY2VuZGFudDpjLGlzUHJlTGlrZU5vZGU6RCxoYXNQcmV0dGllcklnbm9yZTpFLHNob3VsZFByZXNlcnZlQ29udGVudDpfLGlzVnVlU2ZjQmxvY2s6d309UnQoKTtmdW5jdGlvbiBGKEwsUSl7cmV0dXJuW0wuaXNTZWxmQ2xvc2luZz9cIlwiOlMoTCxRKSxOKEwsUSldfWZ1bmN0aW9uIFMoTCxRKXtyZXR1cm4gTC5sYXN0Q2hpbGQmJm8oTC5sYXN0Q2hpbGQpP1wiXCI6W0koTCxRKSwkKEwsUSldfWZ1bmN0aW9uIE4oTCxRKXtyZXR1cm4oTC5uZXh0P20oTC5uZXh0KTp2KEwucGFyZW50KSk/XCJcIjpbZihMLFEpLFAoTCxRKV19ZnVuY3Rpb24gSShMLFEpe3JldHVybiB2KEwpP2YoTC5sYXN0Q2hpbGQsUSk6XCJcIn1mdW5jdGlvbiBQKEwsUSl7cmV0dXJuIG8oTCk/JChMLnBhcmVudCxRKTpoKEwpP3EoTC5uZXh0KTpcIlwifWZ1bmN0aW9uICQoTCxRKXtpZih0KCFMLmlzU2VsZkNsb3NpbmcpLFQoTCxRKSlyZXR1cm5cIlwiO3N3aXRjaChMLnR5cGUpe2Nhc2VcImllQ29uZGl0aW9uYWxDb21tZW50XCI6cmV0dXJuXCI8IVwiO2Nhc2VcImVsZW1lbnRcIjppZihMLmhhc0h0bUNvbXBvbmVudENsb3NpbmdUYWcpcmV0dXJuXCI8Ly9cIjtkZWZhdWx0OnJldHVybmA8LyR7TC5yYXdOYW1lfWB9fWZ1bmN0aW9uIGYoTCxRKXtpZihUKEwsUSkpcmV0dXJuXCJcIjtzd2l0Y2goTC50eXBlKXtjYXNlXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOmNhc2VcImllQ29uZGl0aW9uYWxFbmRDb21tZW50XCI6cmV0dXJuXCJbZW5kaWZdLS0+XCI7Y2FzZVwiaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudFwiOnJldHVyblwiXT48IS0tPlwiO2Nhc2VcImludGVycG9sYXRpb25cIjpyZXR1cm5cIn19XCI7Y2FzZVwiZWxlbWVudFwiOmlmKEwuaXNTZWxmQ2xvc2luZylyZXR1cm5cIi8+XCI7ZGVmYXVsdDpyZXR1cm5cIj5cIn19ZnVuY3Rpb24gVChMLFEpe3JldHVybiFMLmlzU2VsZkNsb3NpbmcmJiFMLmVuZFNvdXJjZVNwYW4mJihFKEwpfHxfKEwucGFyZW50LFEpKX1mdW5jdGlvbiBtKEwpe3JldHVybiBMLnByZXYmJkwucHJldi50eXBlIT09XCJkb2NUeXBlXCImJiFnKEwucHJldikmJkwuaXNMZWFkaW5nU3BhY2VTZW5zaXRpdmUmJiFMLmhhc0xlYWRpbmdTcGFjZXN9ZnVuY3Rpb24gdihMKXtyZXR1cm4gTC5sYXN0Q2hpbGQmJkwubGFzdENoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSYmIUwubGFzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzJiYhZyhjKEwubGFzdENoaWxkKSkmJiFEKEwpfWZ1bmN0aW9uIG8oTCl7cmV0dXJuIUwubmV4dCYmIUwuaGFzVHJhaWxpbmdTcGFjZXMmJkwuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlJiZnKGMoTCkpfWZ1bmN0aW9uIGgoTCl7cmV0dXJuIEwubmV4dCYmIWcoTC5uZXh0KSYmZyhMKSYmTC5pc1RyYWlsaW5nU3BhY2VTZW5zaXRpdmUmJiFMLmhhc1RyYWlsaW5nU3BhY2VzfWZ1bmN0aW9uIEMoTCl7bGV0IFE9TC50cmltKCkubWF0Y2goL15wcmV0dGllci1pZ25vcmUtYXR0cmlidXRlKD86XFxzKyguKykpPyQvcyk7cmV0dXJuIFE/UVsxXT9RWzFdLnNwbGl0KC9cXHMrLyk6ITA6ITF9ZnVuY3Rpb24geChMKXtyZXR1cm4hTC5wcmV2JiZMLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlJiYhTC5oYXNMZWFkaW5nU3BhY2VzfWZ1bmN0aW9uIGIoTCxRLFYpe2xldCBqPUwuZ2V0VmFsdWUoKTtpZighcyhqLmF0dHJzKSlyZXR1cm4gai5pc1NlbGZDbG9zaW5nP1wiIFwiOlwiXCI7bGV0IFk9ai5wcmV2JiZqLnByZXYudHlwZT09PVwiY29tbWVudFwiJiZDKGoucHJldi52YWx1ZSksaWU9dHlwZW9mIFk9PVwiYm9vbGVhblwiPygpPT5ZOkFycmF5LmlzQXJyYXkoWSk/dWU9PlkuaW5jbHVkZXModWUucmF3TmFtZSk6KCk9PiExLGVlPUwubWFwKHVlPT57bGV0IEZlPXVlLmdldFZhbHVlKCk7cmV0dXJuIGllKEZlKT9wKFEub3JpZ2luYWxUZXh0LnNsaWNlKGQoRmUpLHkoRmUpKSk6VigpfSxcImF0dHJzXCIpLGxlPWoudHlwZT09PVwiZWxlbWVudFwiJiZqLmZ1bGxOYW1lPT09XCJzY3JpcHRcIiYmai5hdHRycy5sZW5ndGg9PT0xJiZqLmF0dHJzWzBdLmZ1bGxOYW1lPT09XCJzcmNcIiYmai5jaGlsZHJlbi5sZW5ndGg9PT0wLEs9US5zaW5nbGVBdHRyaWJ1dGVQZXJMaW5lJiZqLmF0dHJzLmxlbmd0aD4xJiYhdyhqLFEpP2w6dSxkZT1bYShbbGU/XCIgXCI6dSxuKEssZWUpXSldO3JldHVybiBqLmZpcnN0Q2hpbGQmJngoai5maXJzdENoaWxkKXx8ai5pc1NlbGZDbG9zaW5nJiZ2KGoucGFyZW50KXx8bGU/ZGUucHVzaChqLmlzU2VsZkNsb3Npbmc/XCIgXCI6XCJcIik6ZGUucHVzaChRLmJyYWNrZXRTYW1lTGluZT9qLmlzU2VsZkNsb3Npbmc/XCIgXCI6XCJcIjpqLmlzU2VsZkNsb3Npbmc/dTppKSxkZX1mdW5jdGlvbiBCKEwpe3JldHVybiBMLmZpcnN0Q2hpbGQmJngoTC5maXJzdENoaWxkKT9cIlwiOkooTCl9ZnVuY3Rpb24gayhMLFEsVil7bGV0IGo9TC5nZXRWYWx1ZSgpO3JldHVybltNKGosUSksYihMLFEsViksai5pc1NlbGZDbG9zaW5nP1wiXCI6QihqKV19ZnVuY3Rpb24gTShMLFEpe3JldHVybiBMLnByZXYmJmgoTC5wcmV2KT9cIlwiOltSKEwsUSkscShMKV19ZnVuY3Rpb24gUihMLFEpe3JldHVybiB4KEwpP0ooTC5wYXJlbnQpOm0oTCk/ZihMLnByZXYsUSk6XCJcIn1mdW5jdGlvbiBxKEwpe3N3aXRjaChMLnR5cGUpe2Nhc2VcImllQ29uZGl0aW9uYWxDb21tZW50XCI6Y2FzZVwiaWVDb25kaXRpb25hbFN0YXJ0Q29tbWVudFwiOnJldHVybmA8IS0tW2lmICR7TC5jb25kaXRpb259YDtjYXNlXCJpZUNvbmRpdGlvbmFsRW5kQ29tbWVudFwiOnJldHVyblwiPCEtLTwhXCI7Y2FzZVwiaW50ZXJwb2xhdGlvblwiOnJldHVyblwie3tcIjtjYXNlXCJkb2NUeXBlXCI6cmV0dXJuXCI8IURPQ1RZUEVcIjtjYXNlXCJlbGVtZW50XCI6aWYoTC5jb25kaXRpb24pcmV0dXJuYDwhLS1baWYgJHtMLmNvbmRpdGlvbn1dPjwhLS0+PCR7TC5yYXdOYW1lfWA7ZGVmYXVsdDpyZXR1cm5gPCR7TC5yYXdOYW1lfWB9fWZ1bmN0aW9uIEooTCl7c3dpdGNoKHQoIUwuaXNTZWxmQ2xvc2luZyksTC50eXBlKXtjYXNlXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOnJldHVyblwiXT5cIjtjYXNlXCJlbGVtZW50XCI6aWYoTC5jb25kaXRpb24pcmV0dXJuXCI+PCEtLTwhW2VuZGlmXS0tPlwiO2RlZmF1bHQ6cmV0dXJuXCI+XCJ9fXIuZXhwb3J0cz17cHJpbnRDbG9zaW5nVGFnOkYscHJpbnRDbG9zaW5nVGFnU3RhcnQ6UyxwcmludENsb3NpbmdUYWdTdGFydE1hcmtlcjokLHByaW50Q2xvc2luZ1RhZ0VuZE1hcmtlcjpmLHByaW50Q2xvc2luZ1RhZ1N1ZmZpeDpQLHByaW50Q2xvc2luZ1RhZ0VuZDpOLG5lZWRzVG9Cb3Jyb3dMYXN0Q2hpbGRDbG9zaW5nVGFnRW5kTWFya2VyOnYsbmVlZHNUb0JvcnJvd1BhcmVudENsb3NpbmdUYWdTdGFydE1hcmtlcjpvLG5lZWRzVG9Cb3Jyb3dQcmV2Q2xvc2luZ1RhZ0VuZE1hcmtlcjptLHByaW50T3BlbmluZ1RhZzprLHByaW50T3BlbmluZ1RhZ1N0YXJ0Ok0scHJpbnRPcGVuaW5nVGFnUHJlZml4OlIscHJpbnRPcGVuaW5nVGFnU3RhcnRNYXJrZXI6cSxwcmludE9wZW5pbmdUYWdFbmRNYXJrZXI6SixuZWVkc1RvQm9ycm93TmV4dE9wZW5pbmdUYWdTdGFydE1hcmtlcjpoLG5lZWRzVG9Cb3Jyb3dQYXJlbnRPcGVuaW5nVGFnRW5kTWFya2VyOnh9fX0pLHhnPXRlKHtcIm5vZGVfbW9kdWxlcy9wYXJzZS1zcmNzZXQvc3JjL3BhcnNlLXNyY3NldC5qc1wiKGUscil7bmUoKSxmdW5jdGlvbih0LHMpe3R5cGVvZiBkZWZpbmU9PVwiZnVuY3Rpb25cIiYmZGVmaW5lLmFtZD9kZWZpbmUoW10scyk6dHlwZW9mIHI9PVwib2JqZWN0XCImJnIuZXhwb3J0cz9yLmV4cG9ydHM9cygpOnQucGFyc2VTcmNzZXQ9cygpfShlLGZ1bmN0aW9uKCl7cmV0dXJuIGZ1bmN0aW9uKHQscyl7dmFyIGE9cyYmcy5sb2dnZXJ8fGNvbnNvbGU7ZnVuY3Rpb24gbigkKXtyZXR1cm4gJD09PVwiIFwifHwkPT09XCJcdFwifHwkPT09YFxuYHx8JD09PVwiXFxmXCJ8fCQ9PT1cIlxcclwifWZ1bmN0aW9uIHUoJCl7dmFyIGYsVD0kLmV4ZWModC5zdWJzdHJpbmcoUykpO2lmKFQpcmV0dXJuIGY9VFswXSxTKz1mLmxlbmd0aCxmfWZvcih2YXIgaT10Lmxlbmd0aCxsPS9eWyBcXHRcXG5cXHJcXHUwMDBjXSsvLHA9L15bLCBcXHRcXG5cXHJcXHUwMDBjXSsvLGQ9L15bXiBcXHRcXG5cXHJcXHUwMDBjXSsvLHk9L1ssXSskLyxnPS9eXFxkKyQvLGM9L14tPyg/OlswLTldK3xbMC05XSpcXC5bMC05XSspKD86W2VFXVsrLV0/WzAtOV0rKT8kLyxELEUsXyx3LEYsUz0wLE49W107Oyl7aWYodShwKSxTPj1pKXJldHVybiBOO0Q9dShkKSxFPVtdLEQuc2xpY2UoLTEpPT09XCIsXCI/KEQ9RC5yZXBsYWNlKHksXCJcIiksUCgpKTpJKCl9ZnVuY3Rpb24gSSgpe2Zvcih1KGwpLF89XCJcIix3PVwiaW4gZGVzY3JpcHRvclwiOzspe2lmKEY9dC5jaGFyQXQoUyksdz09PVwiaW4gZGVzY3JpcHRvclwiKWlmKG4oRikpXyYmKEUucHVzaChfKSxfPVwiXCIsdz1cImFmdGVyIGRlc2NyaXB0b3JcIik7ZWxzZSBpZihGPT09XCIsXCIpe1MrPTEsXyYmRS5wdXNoKF8pLFAoKTtyZXR1cm59ZWxzZSBpZihGPT09XCIoXCIpXz1fK0Ysdz1cImluIHBhcmVuc1wiO2Vsc2UgaWYoRj09PVwiXCIpe18mJkUucHVzaChfKSxQKCk7cmV0dXJufWVsc2UgXz1fK0Y7ZWxzZSBpZih3PT09XCJpbiBwYXJlbnNcIilpZihGPT09XCIpXCIpXz1fK0Ysdz1cImluIGRlc2NyaXB0b3JcIjtlbHNlIGlmKEY9PT1cIlwiKXtFLnB1c2goXyksUCgpO3JldHVybn1lbHNlIF89XytGO2Vsc2UgaWYodz09PVwiYWZ0ZXIgZGVzY3JpcHRvclwiJiYhbihGKSlpZihGPT09XCJcIil7UCgpO3JldHVybn1lbHNlIHc9XCJpbiBkZXNjcmlwdG9yXCIsUy09MTtTKz0xfX1mdW5jdGlvbiBQKCl7dmFyICQ9ITEsZixULG0sdixvPXt9LGgsQyx4LGIsQjtmb3Iodj0wO3Y8RS5sZW5ndGg7disrKWg9RVt2XSxDPWhbaC5sZW5ndGgtMV0seD1oLnN1YnN0cmluZygwLGgubGVuZ3RoLTEpLGI9cGFyc2VJbnQoeCwxMCksQj1wYXJzZUZsb2F0KHgpLGcudGVzdCh4KSYmQz09PVwid1wiPygoZnx8VCkmJigkPSEwKSxiPT09MD8kPSEwOmY9Yik6Yy50ZXN0KHgpJiZDPT09XCJ4XCI/KChmfHxUfHxtKSYmKCQ9ITApLEI8MD8kPSEwOlQ9Qik6Zy50ZXN0KHgpJiZDPT09XCJoXCI/KChtfHxUKSYmKCQ9ITApLGI9PT0wPyQ9ITA6bT1iKTokPSEwOyQ/YSYmYS5lcnJvciYmYS5lcnJvcihcIkludmFsaWQgc3Jjc2V0IGRlc2NyaXB0b3IgZm91bmQgaW4gJ1wiK3QrXCInIGF0ICdcIitoK1wiJy5cIik6KG8udXJsPUQsZiYmKG8udz1mKSxUJiYoby5kPVQpLG0mJihvLmg9bSksTi5wdXNoKG8pKX19fSl9fSksYmc9dGUoe1wic3JjL2xhbmd1YWdlLWh0bWwvc3ludGF4LWF0dHJpYnV0ZS5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXIgdD14ZygpLHtidWlsZGVyczp7aWZCcmVhazpzLGpvaW46YSxsaW5lOm59fT1xZSgpO2Z1bmN0aW9uIHUobCl7bGV0IHA9dChsLHtsb2dnZXI6e2Vycm9yKEkpe3Rocm93IG5ldyBFcnJvcihJKX19fSksZD1wLnNvbWUoST0+e2xldHt3OlB9PUk7cmV0dXJuIFB9KSx5PXAuc29tZShJPT57bGV0e2g6UH09STtyZXR1cm4gUH0pLGc9cC5zb21lKEk9PntsZXR7ZDpQfT1JO3JldHVybiBQfSk7aWYoZCt5K2c+MSl0aHJvdyBuZXcgRXJyb3IoXCJNaXhlZCBkZXNjcmlwdG9yIGluIHNyY3NldCBpcyBub3Qgc3VwcG9ydGVkXCIpO2xldCBjPWQ/XCJ3XCI6eT9cImhcIjpcImRcIixEPWQ/XCJ3XCI6eT9cImhcIjpcInhcIixFPUk9Pk1hdGgubWF4KC4uLkkpLF89cC5tYXAoST0+SS51cmwpLHc9RShfLm1hcChJPT5JLmxlbmd0aCkpLEY9cC5tYXAoST0+SVtjXSkubWFwKEk9Pkk/SS50b1N0cmluZygpOlwiXCIpLFM9Ri5tYXAoST0+e2xldCBQPUkuaW5kZXhPZihcIi5cIik7cmV0dXJuIFA9PT0tMT9JLmxlbmd0aDpQfSksTj1FKFMpO3JldHVybiBhKFtcIixcIixuXSxfLm1hcCgoSSxQKT0+e2xldCAkPVtJXSxmPUZbUF07aWYoZil7bGV0IFQ9dy1JLmxlbmd0aCsxLG09Ti1TW1BdLHY9XCIgXCIucmVwZWF0KFQrbSk7JC5wdXNoKHModixcIiBcIiksZitEKX1yZXR1cm4gJH0pKX1mdW5jdGlvbiBpKGwpe3JldHVybiBsLnRyaW0oKS5zcGxpdCgvXFxzKy8pLmpvaW4oXCIgXCIpfXIuZXhwb3J0cz17cHJpbnRJbWdTcmNzZXQ6dSxwcmludENsYXNzTmFtZXM6aX19fSksVGc9dGUoe1wic3JjL2xhbmd1YWdlLWh0bWwvc3ludGF4LXZ1ZS5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7YnVpbGRlcnM6e2dyb3VwOnR9fT1xZSgpO2Z1bmN0aW9uIHMoaSxsKXtsZXR7bGVmdDpwLG9wZXJhdG9yOmQscmlnaHQ6eX09YShpKTtyZXR1cm5bdChsKGBmdW5jdGlvbiBfKCR7cH0pIHt9YCx7cGFyc2VyOlwiYmFiZWxcIixfX2lzVnVlRm9yQmluZGluZ0xlZnQ6ITB9KSksXCIgXCIsZCxcIiBcIixsKHkse3BhcnNlcjpcIl9fanNfZXhwcmVzc2lvblwifSx7c3RyaXBUcmFpbGluZ0hhcmRsaW5lOiEwfSldfWZ1bmN0aW9uIGEoaSl7bGV0IGw9LyguKj8pXFxzKyhpbnxvZilcXHMrKC4qKS9zLHA9LywoW14sXFxdfV0qKSg/OiwoW14sXFxdfV0qKSk/JC8sZD0vXlxcKHxcXCkkL2cseT1pLm1hdGNoKGwpO2lmKCF5KXJldHVybjtsZXQgZz17fTtpZihnLmZvcj15WzNdLnRyaW0oKSwhZy5mb3IpcmV0dXJuO2xldCBjPXlbMV0udHJpbSgpLnJlcGxhY2UoZCxcIlwiKSxEPWMubWF0Y2gocCk7RD8oZy5hbGlhcz1jLnJlcGxhY2UocCxcIlwiKSxnLml0ZXJhdG9yMT1EWzFdLnRyaW0oKSxEWzJdJiYoZy5pdGVyYXRvcjI9RFsyXS50cmltKCkpKTpnLmFsaWFzPWM7bGV0IEU9W2cuYWxpYXMsZy5pdGVyYXRvcjEsZy5pdGVyYXRvcjJdO2lmKCFFLnNvbWUoKF8sdyk9PiFfJiYodz09PTB8fEUuc2xpY2UodysxKS5zb21lKEJvb2xlYW4pKSkpcmV0dXJue2xlZnQ6RS5maWx0ZXIoQm9vbGVhbikuam9pbihcIixcIiksb3BlcmF0b3I6eVsyXSxyaWdodDpnLmZvcn19ZnVuY3Rpb24gbihpLGwpe3JldHVybiBsKGBmdW5jdGlvbiBfKCR7aX0pIHt9YCx7cGFyc2VyOlwiYmFiZWxcIixfX2lzVnVlQmluZGluZ3M6ITB9KX1mdW5jdGlvbiB1KGkpe2xldCBsPS9eKD86W1xcdyRdK3xcXChbXildKlxcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC8scD0vXlskQS1aX2Etel1bXFx3JF0qKD86XFwuWyRBLVpfYS16XVtcXHckXSp8XFxbJ1teJ10qJ118XFxbXCJbXlwiXSpcIl18XFxbXFxkK118XFxbWyRBLVpfYS16XVtcXHckXSpdKSokLyxkPWkudHJpbSgpO3JldHVybiBsLnRlc3QoZCl8fHAudGVzdChkKX1yLmV4cG9ydHM9e2lzVnVlRXZlbnRCaW5kaW5nRXhwcmVzc2lvbjp1LHByaW50VnVlRm9yOnMscHJpbnRWdWVCaW5kaW5nczpufX19KSxMbz10ZSh7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9nZXQtbm9kZS1jb250ZW50LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntuZWVkc1RvQm9ycm93UGFyZW50Q2xvc2luZ1RhZ1N0YXJ0TWFya2VyOnQscHJpbnRDbG9zaW5nVGFnU3RhcnRNYXJrZXI6cyxuZWVkc1RvQm9ycm93TGFzdENoaWxkQ2xvc2luZ1RhZ0VuZE1hcmtlcjphLHByaW50Q2xvc2luZ1RhZ0VuZE1hcmtlcjpuLG5lZWRzVG9Cb3Jyb3dQYXJlbnRPcGVuaW5nVGFnRW5kTWFya2VyOnUscHJpbnRPcGVuaW5nVGFnRW5kTWFya2VyOml9PXVyKCk7ZnVuY3Rpb24gbChwLGQpe2xldCB5PXAuc3RhcnRTb3VyY2VTcGFuLmVuZC5vZmZzZXQ7cC5maXJzdENoaWxkJiZ1KHAuZmlyc3RDaGlsZCkmJih5LT1pKHApLmxlbmd0aCk7bGV0IGc9cC5lbmRTb3VyY2VTcGFuLnN0YXJ0Lm9mZnNldDtyZXR1cm4gcC5sYXN0Q2hpbGQmJnQocC5sYXN0Q2hpbGQpP2crPXMocCxkKS5sZW5ndGg6YShwKSYmKGctPW4ocC5sYXN0Q2hpbGQsZCkubGVuZ3RoKSxkLm9yaWdpbmFsVGV4dC5zbGljZSh5LGcpfXIuZXhwb3J0cz1sfX0pLEJnPXRlKHtcInNyYy9sYW5ndWFnZS1odG1sL2VtYmVkLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7YnJlYWtQYXJlbnQ6dCxncm91cDpzLGhhcmRsaW5lOmEsaW5kZW50Om4sbGluZTp1LGZpbGw6aSxzb2Z0bGluZTpsfSx1dGlsczp7bWFwRG9jOnAscmVwbGFjZVRleHRFbmRPZkxpbmU6ZH19PXFlKCkseT1zdSgpLHtwcmludENsb3NpbmdUYWc6ZyxwcmludENsb3NpbmdUYWdTdWZmaXg6YyxuZWVkc1RvQm9ycm93UHJldkNsb3NpbmdUYWdFbmRNYXJrZXI6RCxwcmludE9wZW5pbmdUYWdQcmVmaXg6RSxwcmludE9wZW5pbmdUYWc6X309dXIoKSx7cHJpbnRJbWdTcmNzZXQ6dyxwcmludENsYXNzTmFtZXM6Rn09YmcoKSx7cHJpbnRWdWVGb3I6UyxwcmludFZ1ZUJpbmRpbmdzOk4saXNWdWVFdmVudEJpbmRpbmdFeHByZXNzaW9uOkl9PVRnKCkse2lzU2NyaXB0TGlrZVRhZzpQLGlzVnVlTm9uSHRtbEJsb2NrOiQsaW5mZXJTY3JpcHRQYXJzZXI6ZixodG1sVHJpbVByZXNlcnZlSW5kZW50YXRpb246VCxkZWRlbnRTdHJpbmc6bSx1bmVzY2FwZVF1b3RlRW50aXRpZXM6dixpc1Z1ZVNsb3RBdHRyaWJ1dGU6byxpc1Z1ZVNmY0JpbmRpbmdzQXR0cmlidXRlOmgsZ2V0VGV4dFZhbHVlUGFydHM6Q309UnQoKSx4PUxvKCk7ZnVuY3Rpb24gYihrLE0sUil7bGV0IHE9ZWU9Pm5ldyBSZWdFeHAoZWUuam9pbihcInxcIikpLnRlc3Qoay5mdWxsTmFtZSksSj0oKT0+dihrLnZhbHVlKSxMPSExLFE9KGVlLGxlKT0+e2xldCBXPWVlLnR5cGU9PT1cIk5HUm9vdFwiP2VlLm5vZGUudHlwZT09PVwiTkdNaWNyb3N5bnRheFwiJiZlZS5ub2RlLmJvZHkubGVuZ3RoPT09MSYmZWUubm9kZS5ib2R5WzBdLnR5cGU9PT1cIk5HTWljcm9zeW50YXhFeHByZXNzaW9uXCI/ZWUubm9kZS5ib2R5WzBdLmV4cHJlc3Npb246ZWUubm9kZTplZS50eXBlPT09XCJKc0V4cHJlc3Npb25Sb290XCI/ZWUubm9kZTplZTtXJiYoVy50eXBlPT09XCJPYmplY3RFeHByZXNzaW9uXCJ8fFcudHlwZT09PVwiQXJyYXlFeHByZXNzaW9uXCJ8fGxlLnBhcnNlcj09PVwiX192dWVfZXhwcmVzc2lvblwiJiYoVy50eXBlPT09XCJUZW1wbGF0ZUxpdGVyYWxcInx8Vy50eXBlPT09XCJTdHJpbmdMaXRlcmFsXCIpKSYmKEw9ITApfSxWPWVlPT5zKGVlKSxqPWZ1bmN0aW9uKGVlKXtsZXQgbGU9YXJndW1lbnRzLmxlbmd0aD4xJiZhcmd1bWVudHNbMV0hPT12b2lkIDA/YXJndW1lbnRzWzFdOiEwO3JldHVybiBzKFtuKFtsLGVlXSksbGU/bDpcIlwiXSl9LFk9ZWU9Pkw/VihlZSk6aihlZSksaWU9KGVlLGxlKT0+TShlZSxPYmplY3QuYXNzaWduKHtfX29uSHRtbEJpbmRpbmdSb290OlEsX19lbWJlZGRlZEluSHRtbDohMH0sbGUpKTtpZihrLmZ1bGxOYW1lPT09XCJzcmNzZXRcIiYmKGsucGFyZW50LmZ1bGxOYW1lPT09XCJpbWdcInx8ay5wYXJlbnQuZnVsbE5hbWU9PT1cInNvdXJjZVwiKSlyZXR1cm4gaih3KEooKSkpO2lmKGsuZnVsbE5hbWU9PT1cImNsYXNzXCImJiFSLnBhcmVudFBhcnNlcil7bGV0IGVlPUooKTtpZighZWUuaW5jbHVkZXMoXCJ7e1wiKSlyZXR1cm4gRihlZSl9aWYoay5mdWxsTmFtZT09PVwic3R5bGVcIiYmIVIucGFyZW50UGFyc2VyKXtsZXQgZWU9SigpO2lmKCFlZS5pbmNsdWRlcyhcInt7XCIpKXJldHVybiBqKGllKGVlLHtwYXJzZXI6XCJjc3NcIixfX2lzSFRNTFN0eWxlQXR0cmlidXRlOiEwfSkpfWlmKFIucGFyc2VyPT09XCJ2dWVcIil7aWYoay5mdWxsTmFtZT09PVwidi1mb3JcIilyZXR1cm4gUyhKKCksaWUpO2lmKG8oayl8fGgoayxSKSlyZXR1cm4gTihKKCksaWUpO2xldCBlZT1bXCJeQFwiLFwiXnYtb246XCJdLGxlPVtcIl46XCIsXCJedi1iaW5kOlwiXSxXPVtcIl52LVwiXTtpZihxKGVlKSl7bGV0IEs9SigpLGRlPUkoSyk/XCJfX2pzX2V4cHJlc3Npb25cIjpSLl9fc2hvdWxkX3BhcnNlX3Z1ZV90ZW1wbGF0ZV93aXRoX3RzP1wiX192dWVfdHNfZXZlbnRfYmluZGluZ1wiOlwiX192dWVfZXZlbnRfYmluZGluZ1wiO3JldHVybiBZKGllKEsse3BhcnNlcjpkZX0pKX1pZihxKGxlKSlyZXR1cm4gWShpZShKKCkse3BhcnNlcjpcIl9fdnVlX2V4cHJlc3Npb25cIn0pKTtpZihxKFcpKXJldHVybiBZKGllKEooKSx7cGFyc2VyOlwiX19qc19leHByZXNzaW9uXCJ9KSl9aWYoUi5wYXJzZXI9PT1cImFuZ3VsYXJcIil7bGV0IGVlPSh6LFUpPT5pZSh6LE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSxVKSx7fSx7dHJhaWxpbmdDb21tYTpcIm5vbmVcIn0pKSxsZT1bXCJeXFxcXCpcIl0sVz1bXCJeXFxcXCguK1xcXFwpJFwiLFwiXm9uLVwiXSxLPVtcIl5cXFxcWy4rXFxcXF0kXCIsXCJeYmluZChvbik/LVwiLFwiXm5nLShpZnxzaG93fGhpZGV8Y2xhc3N8c3R5bGUpJFwiXSxkZT1bXCJeaTE4bigtLispPyRcIl07aWYocShXKSlyZXR1cm4gWShlZShKKCkse3BhcnNlcjpcIl9fbmdfYWN0aW9uXCJ9KSk7aWYocShLKSlyZXR1cm4gWShlZShKKCkse3BhcnNlcjpcIl9fbmdfYmluZGluZ1wifSkpO2lmKHEoZGUpKXtsZXQgej1KKCkudHJpbSgpO3JldHVybiBqKGkoQyhrLHopKSwhei5pbmNsdWRlcyhcIkBAXCIpKX1pZihxKGxlKSlyZXR1cm4gWShlZShKKCkse3BhcnNlcjpcIl9fbmdfZGlyZWN0aXZlXCJ9KSk7bGV0IHVlPS97eyguKz8pfX0vcyxGZT1KKCk7aWYodWUudGVzdChGZSkpe2xldCB6PVtdO2ZvcihsZXRbVSxaXW9mIEZlLnNwbGl0KHVlKS5lbnRyaWVzKCkpaWYoVSUyPT09MCl6LnB1c2goZChaKSk7ZWxzZSB0cnl7ei5wdXNoKHMoW1wie3tcIixuKFt1LGVlKFose3BhcnNlcjpcIl9fbmdfaW50ZXJwb2xhdGlvblwiLF9faXNJbkh0bWxJbnRlcnBvbGF0aW9uOiEwfSldKSx1LFwifX1cIl0pKX1jYXRjaHt6LnB1c2goXCJ7e1wiLGQoWiksXCJ9fVwiKX1yZXR1cm4gcyh6KX19cmV0dXJuIG51bGx9ZnVuY3Rpb24gQihrLE0sUixxKXtsZXQgSj1rLmdldFZhbHVlKCk7c3dpdGNoKEoudHlwZSl7Y2FzZVwiZWxlbWVudFwiOntpZihQKEopfHxKLnR5cGU9PT1cImludGVycG9sYXRpb25cIilyZXR1cm47aWYoIUouaXNTZWxmQ2xvc2luZyYmJChKLHEpKXtsZXQgTD1mKEoscSk7aWYoIUwpcmV0dXJuO2xldCBRPXgoSixxKSxWPS9eXFxzKiQvLnRlc3QoUSksaj1cIlwiO3JldHVybiBWfHwoaj1SKFQoUSkse3BhcnNlcjpMLF9fZW1iZWRkZWRJbkh0bWw6ITB9LHtzdHJpcFRyYWlsaW5nSGFyZGxpbmU6ITB9KSxWPWo9PT1cIlwiKSxbRShKLHEpLHMoXyhrLHEsTSkpLFY/XCJcIjphLGosVj9cIlwiOmEsZyhKLHEpLGMoSixxKV19YnJlYWt9Y2FzZVwidGV4dFwiOntpZihQKEoucGFyZW50KSl7bGV0IEw9ZihKLnBhcmVudCxxKTtpZihMKXtsZXQgUT1MPT09XCJtYXJrZG93blwiP20oSi52YWx1ZS5yZXBsYWNlKC9eW15cXFNcXG5dKlxcbi8sXCJcIikpOkoudmFsdWUsVj17cGFyc2VyOkwsX19lbWJlZGRlZEluSHRtbDohMH07aWYocS5wYXJzZXI9PT1cImh0bWxcIiYmTD09PVwiYmFiZWxcIil7bGV0IGo9XCJzY3JpcHRcIix7YXR0ck1hcDpZfT1KLnBhcmVudDtZJiYoWS50eXBlPT09XCJtb2R1bGVcInx8WS50eXBlPT09XCJ0ZXh0L2JhYmVsXCImJllbXCJkYXRhLXR5cGVcIl09PT1cIm1vZHVsZVwiKSYmKGo9XCJtb2R1bGVcIiksVi5fX2JhYmVsU291cmNlVHlwZT1qfXJldHVyblt0LEUoSixxKSxSKFEsVix7c3RyaXBUcmFpbGluZ0hhcmRsaW5lOiEwfSksYyhKLHEpXX19ZWxzZSBpZihKLnBhcmVudC50eXBlPT09XCJpbnRlcnBvbGF0aW9uXCIpe2xldCBMPXtfX2lzSW5IdG1sSW50ZXJwb2xhdGlvbjohMCxfX2VtYmVkZGVkSW5IdG1sOiEwfTtyZXR1cm4gcS5wYXJzZXI9PT1cImFuZ3VsYXJcIj8oTC5wYXJzZXI9XCJfX25nX2ludGVycG9sYXRpb25cIixMLnRyYWlsaW5nQ29tbWE9XCJub25lXCIpOnEucGFyc2VyPT09XCJ2dWVcIj9MLnBhcnNlcj1xLl9fc2hvdWxkX3BhcnNlX3Z1ZV90ZW1wbGF0ZV93aXRoX3RzP1wiX192dWVfdHNfZXhwcmVzc2lvblwiOlwiX192dWVfZXhwcmVzc2lvblwiOkwucGFyc2VyPVwiX19qc19leHByZXNzaW9uXCIsW24oW3UsUihKLnZhbHVlLEwse3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pXSksSi5wYXJlbnQubmV4dCYmRChKLnBhcmVudC5uZXh0KT9cIiBcIjp1XX1icmVha31jYXNlXCJhdHRyaWJ1dGVcIjp7aWYoIUoudmFsdWUpYnJlYWs7aWYoL15QUkVUVElFUl9IVE1MX1BMQUNFSE9MREVSX1xcZCtfXFxkK19JTl9KUyQvLnRlc3QocS5vcmlnaW5hbFRleHQuc2xpY2UoSi52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0LEoudmFsdWVTcGFuLmVuZC5vZmZzZXQpKSlyZXR1cm5bSi5yYXdOYW1lLFwiPVwiLEoudmFsdWVdO2lmKHEucGFyc2VyPT09XCJsd2NcIiYmL157Lip9JC9zLnRlc3QocS5vcmlnaW5hbFRleHQuc2xpY2UoSi52YWx1ZVNwYW4uc3RhcnQub2Zmc2V0LEoudmFsdWVTcGFuLmVuZC5vZmZzZXQpKSlyZXR1cm5bSi5yYXdOYW1lLFwiPVwiLEoudmFsdWVdO2xldCBMPWIoSiwoUSxWKT0+UihRLE9iamVjdC5hc3NpZ24oe19faXNJbkh0bWxBdHRyaWJ1dGU6ITAsX19lbWJlZGRlZEluSHRtbDohMH0sVikse3N0cmlwVHJhaWxpbmdIYXJkbGluZTohMH0pLHEpO2lmKEwpcmV0dXJuW0oucmF3TmFtZSwnPVwiJyxzKHAoTCxRPT50eXBlb2YgUT09XCJzdHJpbmdcIj9RLnJlcGxhY2UoL1wiL2csXCImcXVvdDtcIik6USkpLCdcIiddO2JyZWFrfWNhc2VcImZyb250LW1hdHRlclwiOnJldHVybiB5KEosUil9fXIuZXhwb3J0cz1CfX0pLE9vPXRlKHtcInNyYy9sYW5ndWFnZS1odG1sL3ByaW50L2NoaWxkcmVuLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7YnJlYWtQYXJlbnQ6dCxncm91cDpzLGlmQnJlYWs6YSxsaW5lOm4sc29mdGxpbmU6dSxoYXJkbGluZTppfSx1dGlsczp7cmVwbGFjZVRleHRFbmRPZkxpbmU6bH19PXFlKCkse2xvY1N0YXJ0OnAsbG9jRW5kOmR9PWF1KCkse2ZvcmNlQnJlYWtDaGlsZHJlbjp5LGZvcmNlTmV4dEVtcHR5TGluZTpnLGlzVGV4dExpa2VOb2RlOmMsaGFzUHJldHRpZXJJZ25vcmU6RCxwcmVmZXJIYXJkbGluZUFzTGVhZGluZ1NwYWNlczpFfT1SdCgpLHtwcmludE9wZW5pbmdUYWdQcmVmaXg6XyxuZWVkc1RvQm9ycm93TmV4dE9wZW5pbmdUYWdTdGFydE1hcmtlcjp3LHByaW50T3BlbmluZ1RhZ1N0YXJ0TWFya2VyOkYsbmVlZHNUb0JvcnJvd1ByZXZDbG9zaW5nVGFnRW5kTWFya2VyOlMscHJpbnRDbG9zaW5nVGFnRW5kTWFya2VyOk4scHJpbnRDbG9zaW5nVGFnU3VmZml4OkksbmVlZHNUb0JvcnJvd1BhcmVudENsb3NpbmdUYWdTdGFydE1hcmtlcjpQfT11cigpO2Z1bmN0aW9uICQobSx2LG8pe2xldCBoPW0uZ2V0VmFsdWUoKTtyZXR1cm4gRChoKT9bXyhoLHYpLC4uLmwodi5vcmlnaW5hbFRleHQuc2xpY2UocChoKSsoaC5wcmV2JiZ3KGgucHJldik/RihoKS5sZW5ndGg6MCksZChoKS0oaC5uZXh0JiZTKGgubmV4dCk/TihoLHYpLmxlbmd0aDowKSkpLEkoaCx2KV06bygpfWZ1bmN0aW9uIGYobSx2KXtyZXR1cm4gYyhtKSYmYyh2KT9tLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZT9tLmhhc1RyYWlsaW5nU3BhY2VzP0Uodik/aTpuOlwiXCI6RSh2KT9pOnU6dyhtKSYmKEQodil8fHYuZmlyc3RDaGlsZHx8di5pc1NlbGZDbG9zaW5nfHx2LnR5cGU9PT1cImVsZW1lbnRcIiYmdi5hdHRycy5sZW5ndGg+MCl8fG0udHlwZT09PVwiZWxlbWVudFwiJiZtLmlzU2VsZkNsb3NpbmcmJlModik/XCJcIjohdi5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZXx8RSh2KXx8Uyh2KSYmbS5sYXN0Q2hpbGQmJlAobS5sYXN0Q2hpbGQpJiZtLmxhc3RDaGlsZC5sYXN0Q2hpbGQmJlAobS5sYXN0Q2hpbGQubGFzdENoaWxkKT9pOnYuaGFzTGVhZGluZ1NwYWNlcz9uOnV9ZnVuY3Rpb24gVChtLHYsbyl7bGV0IGg9bS5nZXRWYWx1ZSgpO2lmKHkoaCkpcmV0dXJuW3QsLi4ubS5tYXAoeD0+e2xldCBiPXguZ2V0VmFsdWUoKSxCPWIucHJldj9mKGIucHJldixiKTpcIlwiO3JldHVybltCP1tCLGcoYi5wcmV2KT9pOlwiXCJdOlwiXCIsJCh4LHYsbyldfSxcImNoaWxkcmVuXCIpXTtsZXQgQz1oLmNoaWxkcmVuLm1hcCgoKT0+U3ltYm9sKFwiXCIpKTtyZXR1cm4gbS5tYXAoKHgsYik9PntsZXQgQj14LmdldFZhbHVlKCk7aWYoYyhCKSl7aWYoQi5wcmV2JiZjKEIucHJldikpe2xldCBRPWYoQi5wcmV2LEIpO2lmKFEpcmV0dXJuIGcoQi5wcmV2KT9baSxpLCQoeCx2LG8pXTpbUSwkKHgsdixvKV19cmV0dXJuICQoeCx2LG8pfWxldCBrPVtdLE09W10sUj1bXSxxPVtdLEo9Qi5wcmV2P2YoQi5wcmV2LEIpOlwiXCIsTD1CLm5leHQ/ZihCLEIubmV4dCk6XCJcIjtyZXR1cm4gSiYmKGcoQi5wcmV2KT9rLnB1c2goaSxpKTpKPT09aT9rLnB1c2goaSk6YyhCLnByZXYpP00ucHVzaChKKTpNLnB1c2goYShcIlwiLHUse2dyb3VwSWQ6Q1tiLTFdfSkpKSxMJiYoZyhCKT9jKEIubmV4dCkmJnEucHVzaChpLGkpOkw9PT1pP2MoQi5uZXh0KSYmcS5wdXNoKGkpOlIucHVzaChMKSksWy4uLmsscyhbLi4uTSxzKFskKHgsdixvKSwuLi5SXSx7aWQ6Q1tiXX0pXSksLi4ucV19LFwiY2hpbGRyZW5cIil9ci5leHBvcnRzPXtwcmludENoaWxkcmVuOlR9fX0pLE5nPXRlKHtcInNyYy9sYW5ndWFnZS1odG1sL3ByaW50L2VsZW1lbnQuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOnticmVha1BhcmVudDp0LGRlZGVudFRvUm9vdDpzLGdyb3VwOmEsaWZCcmVhazpuLGluZGVudElmQnJlYWs6dSxpbmRlbnQ6aSxsaW5lOmwsc29mdGxpbmU6cH0sdXRpbHM6e3JlcGxhY2VUZXh0RW5kT2ZMaW5lOmR9fT1xZSgpLHk9TG8oKSx7c2hvdWxkUHJlc2VydmVDb250ZW50OmcsaXNTY3JpcHRMaWtlVGFnOmMsaXNWdWVDdXN0b21CbG9jazpELGNvdW50UGFyZW50czpFLGZvcmNlQnJlYWtDb250ZW50Ol99PVJ0KCkse3ByaW50T3BlbmluZ1RhZ1ByZWZpeDp3LHByaW50T3BlbmluZ1RhZzpGLHByaW50Q2xvc2luZ1RhZ1N1ZmZpeDpTLHByaW50Q2xvc2luZ1RhZzpOLG5lZWRzVG9Cb3Jyb3dQcmV2Q2xvc2luZ1RhZ0VuZE1hcmtlcjpJLG5lZWRzVG9Cb3Jyb3dMYXN0Q2hpbGRDbG9zaW5nVGFnRW5kTWFya2VyOlB9PXVyKCkse3ByaW50Q2hpbGRyZW46JH09T28oKTtmdW5jdGlvbiBmKFQsbSx2KXtsZXQgbz1ULmdldFZhbHVlKCk7aWYoZyhvLG0pKXJldHVyblt3KG8sbSksYShGKFQsbSx2KSksLi4uZCh5KG8sbSkpLC4uLk4obyxtKSxTKG8sbSldO2xldCBoPW8uY2hpbGRyZW4ubGVuZ3RoPT09MSYmby5maXJzdENoaWxkLnR5cGU9PT1cImludGVycG9sYXRpb25cIiYmby5maXJzdENoaWxkLmlzTGVhZGluZ1NwYWNlU2Vuc2l0aXZlJiYhby5maXJzdENoaWxkLmhhc0xlYWRpbmdTcGFjZXMmJm8ubGFzdENoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZSYmIW8ubGFzdENoaWxkLmhhc1RyYWlsaW5nU3BhY2VzLEM9U3ltYm9sKFwiZWxlbWVudC1hdHRyLWdyb3VwLWlkXCIpLHg9TT0+YShbYShGKFQsbSx2KSx7aWQ6Q30pLE0sTihvLG0pXSksYj1NPT5oP3UoTSx7Z3JvdXBJZDpDfSk6KGMobyl8fEQobyxtKSkmJm8ucGFyZW50LnR5cGU9PT1cInJvb3RcIiYmbS5wYXJzZXI9PT1cInZ1ZVwiJiYhbS52dWVJbmRlbnRTY3JpcHRBbmRTdHlsZT9NOmkoTSksQj0oKT0+aD9uKHAsXCJcIix7Z3JvdXBJZDpDfSk6by5maXJzdENoaWxkLmhhc0xlYWRpbmdTcGFjZXMmJm8uZmlyc3RDaGlsZC5pc0xlYWRpbmdTcGFjZVNlbnNpdGl2ZT9sOm8uZmlyc3RDaGlsZC50eXBlPT09XCJ0ZXh0XCImJm8uaXNXaGl0ZXNwYWNlU2Vuc2l0aXZlJiZvLmlzSW5kZW50YXRpb25TZW5zaXRpdmU/cyhwKTpwLGs9KCk9PihvLm5leHQ/SShvLm5leHQpOlAoby5wYXJlbnQpKT9vLmxhc3RDaGlsZC5oYXNUcmFpbGluZ1NwYWNlcyYmby5sYXN0Q2hpbGQuaXNUcmFpbGluZ1NwYWNlU2Vuc2l0aXZlP1wiIFwiOlwiXCI6aD9uKHAsXCJcIix7Z3JvdXBJZDpDfSk6by5sYXN0Q2hpbGQuaGFzVHJhaWxpbmdTcGFjZXMmJm8ubGFzdENoaWxkLmlzVHJhaWxpbmdTcGFjZVNlbnNpdGl2ZT9sOihvLmxhc3RDaGlsZC50eXBlPT09XCJjb21tZW50XCJ8fG8ubGFzdENoaWxkLnR5cGU9PT1cInRleHRcIiYmby5pc1doaXRlc3BhY2VTZW5zaXRpdmUmJm8uaXNJbmRlbnRhdGlvblNlbnNpdGl2ZSkmJm5ldyBSZWdFeHAoYFxcXFxuW1xcXFx0IF17JHttLnRhYldpZHRoKkUoVCxSPT5SLnBhcmVudCYmUi5wYXJlbnQudHlwZSE9PVwicm9vdFwiKX19JGApLnRlc3Qoby5sYXN0Q2hpbGQudmFsdWUpP1wiXCI6cDtyZXR1cm4gby5jaGlsZHJlbi5sZW5ndGg9PT0wP3goby5oYXNEYW5nbGluZ1NwYWNlcyYmby5pc0RhbmdsaW5nU3BhY2VTZW5zaXRpdmU/bDpcIlwiKTp4KFtfKG8pP3Q6XCJcIixiKFtCKCksJChULG0sdildKSxrKCldKX1yLmV4cG9ydHM9e3ByaW50RWxlbWVudDpmfX19KSx3Zz10ZSh7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9wcmludGVyLWh0bWwuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOntmaWxsOnQsZ3JvdXA6cyxoYXJkbGluZTphLGxpdGVyYWxsaW5lOm59LHV0aWxzOntjbGVhbkRvYzp1LGdldERvY1BhcnRzOmksaXNDb25jYXQ6bCxyZXBsYWNlVGV4dEVuZE9mTGluZTpwfX09cWUoKSxkPWRnKCkse2NvdW50Q2hhcnM6eSx1bmVzY2FwZVF1b3RlRW50aXRpZXM6ZyxnZXRUZXh0VmFsdWVQYXJ0czpjfT1SdCgpLEQ9QWcoKSx7aW5zZXJ0UHJhZ21hOkV9PVNnKCkse2xvY1N0YXJ0Ol8sbG9jRW5kOnd9PWF1KCksRj1CZygpLHtwcmludENsb3NpbmdUYWdTdWZmaXg6UyxwcmludENsb3NpbmdUYWdFbmQ6TixwcmludE9wZW5pbmdUYWdQcmVmaXg6SSxwcmludE9wZW5pbmdUYWdTdGFydDpQfT11cigpLHtwcmludEVsZW1lbnQ6JH09TmcoKSx7cHJpbnRDaGlsZHJlbjpmfT1PbygpO2Z1bmN0aW9uIFQobSx2LG8pe2xldCBoPW0uZ2V0VmFsdWUoKTtzd2l0Y2goaC50eXBlKXtjYXNlXCJmcm9udC1tYXR0ZXJcIjpyZXR1cm4gcChoLnJhdyk7Y2FzZVwicm9vdFwiOnJldHVybiB2Ll9fb25IdG1sUm9vdCYmdi5fX29uSHRtbFJvb3QoaCksW3MoZihtLHYsbykpLGFdO2Nhc2VcImVsZW1lbnRcIjpjYXNlXCJpZUNvbmRpdGlvbmFsQ29tbWVudFwiOnJldHVybiAkKG0sdixvKTtjYXNlXCJpZUNvbmRpdGlvbmFsU3RhcnRDb21tZW50XCI6Y2FzZVwiaWVDb25kaXRpb25hbEVuZENvbW1lbnRcIjpyZXR1cm5bUChoKSxOKGgpXTtjYXNlXCJpbnRlcnBvbGF0aW9uXCI6cmV0dXJuW1AoaCx2KSwuLi5tLm1hcChvLFwiY2hpbGRyZW5cIiksTihoLHYpXTtjYXNlXCJ0ZXh0XCI6e2lmKGgucGFyZW50LnR5cGU9PT1cImludGVycG9sYXRpb25cIil7bGV0IHg9L1xcblteXFxTXFxuXSokLyxiPXgudGVzdChoLnZhbHVlKSxCPWI/aC52YWx1ZS5yZXBsYWNlKHgsXCJcIik6aC52YWx1ZTtyZXR1cm5bLi4ucChCKSxiP2E6XCJcIl19bGV0IEM9dShbSShoLHYpLC4uLmMoaCksUyhoLHYpXSk7cmV0dXJuIGwoQyl8fEMudHlwZT09PVwiZmlsbFwiP3QoaShDKSk6Q31jYXNlXCJkb2NUeXBlXCI6cmV0dXJuW3MoW1AoaCx2KSxcIiBcIixoLnZhbHVlLnJlcGxhY2UoL15odG1sXFxiL2ksXCJodG1sXCIpLnJlcGxhY2UoL1xccysvZyxcIiBcIildKSxOKGgsdildO2Nhc2VcImNvbW1lbnRcIjpyZXR1cm5bSShoLHYpLC4uLnAodi5vcmlnaW5hbFRleHQuc2xpY2UoXyhoKSx3KGgpKSxuKSxTKGgsdildO2Nhc2VcImF0dHJpYnV0ZVwiOntpZihoLnZhbHVlPT09bnVsbClyZXR1cm4gaC5yYXdOYW1lO2xldCBDPWcoaC52YWx1ZSkseD15KEMsXCInXCIpLGI9eShDLCdcIicpLEI9eDxiP1wiJ1wiOidcIic7cmV0dXJuW2gucmF3TmFtZSxcIj1cIixCLC4uLnAoQj09PSdcIic/Qy5yZXBsYWNlKC9cIi9nLFwiJnF1b3Q7XCIpOkMucmVwbGFjZSgvJy9nLFwiJmFwb3M7XCIpKSxCXX1kZWZhdWx0OnRocm93IG5ldyBFcnJvcihgVW5leHBlY3RlZCBub2RlIHR5cGUgJHtoLnR5cGV9YCl9fXIuZXhwb3J0cz17cHJlcHJvY2VzczpELHByaW50OlQsaW5zZXJ0UHJhZ21hOkUsbWFzc2FnZUFzdE5vZGU6ZCxlbWJlZDpGfX19KSxfZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9vcHRpb25zLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PU10KCkscz1cIkhUTUxcIjtyLmV4cG9ydHM9e2JyYWNrZXRTYW1lTGluZTp0LmJyYWNrZXRTYW1lTGluZSxodG1sV2hpdGVzcGFjZVNlbnNpdGl2aXR5OntzaW5jZTpcIjEuMTUuMFwiLGNhdGVnb3J5OnMsdHlwZTpcImNob2ljZVwiLGRlZmF1bHQ6XCJjc3NcIixkZXNjcmlwdGlvbjpcIkhvdyB0byBoYW5kbGUgd2hpdGVzcGFjZXMgaW4gSFRNTC5cIixjaG9pY2VzOlt7dmFsdWU6XCJjc3NcIixkZXNjcmlwdGlvbjpcIlJlc3BlY3QgdGhlIGRlZmF1bHQgdmFsdWUgb2YgQ1NTIGRpc3BsYXkgcHJvcGVydHkuXCJ9LHt2YWx1ZTpcInN0cmljdFwiLGRlc2NyaXB0aW9uOlwiV2hpdGVzcGFjZXMgYXJlIGNvbnNpZGVyZWQgc2Vuc2l0aXZlLlwifSx7dmFsdWU6XCJpZ25vcmVcIixkZXNjcmlwdGlvbjpcIldoaXRlc3BhY2VzIGFyZSBjb25zaWRlcmVkIGluc2Vuc2l0aXZlLlwifV19LHNpbmdsZUF0dHJpYnV0ZVBlckxpbmU6dC5zaW5nbGVBdHRyaWJ1dGVQZXJMaW5lLHZ1ZUluZGVudFNjcmlwdEFuZFN0eWxlOntzaW5jZTpcIjEuMTkuMFwiLGNhdGVnb3J5OnMsdHlwZTpcImJvb2xlYW5cIixkZWZhdWx0OiExLGRlc2NyaXB0aW9uOlwiSW5kZW50IHNjcmlwdCBhbmQgc3R5bGUgdGFncyBpbiBWdWUgZmlsZXMuXCJ9fX19KSxQZz10ZSh7XCJzcmMvbGFuZ3VhZ2UtaHRtbC9wYXJzZXJzLmpzXCIoKXtuZSgpfX0pLE9uPXRlKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9IVE1MLmpzb25cIihlLHIpe3IuZXhwb3J0cz17bmFtZTpcIkhUTUxcIix0eXBlOlwibWFya3VwXCIsdG1TY29wZTpcInRleHQuaHRtbC5iYXNpY1wiLGFjZU1vZGU6XCJodG1sXCIsY29kZW1pcnJvck1vZGU6XCJodG1sbWl4ZWRcIixjb2RlbWlycm9yTWltZVR5cGU6XCJ0ZXh0L2h0bWxcIixjb2xvcjpcIiNlMzRjMjZcIixhbGlhc2VzOltcInhodG1sXCJdLGV4dGVuc2lvbnM6W1wiLmh0bWxcIixcIi5odGFcIixcIi5odG1cIixcIi5odG1sLmhsXCIsXCIuaW5jXCIsXCIueGh0XCIsXCIueGh0bWxcIl0sbGFuZ3VhZ2VJZDoxNDZ9fX0pLElnPXRlKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9WdWUuanNvblwiKGUscil7ci5leHBvcnRzPXtuYW1lOlwiVnVlXCIsdHlwZTpcIm1hcmt1cFwiLGNvbG9yOlwiIzQxYjg4M1wiLGV4dGVuc2lvbnM6W1wiLnZ1ZVwiXSx0bVNjb3BlOlwidGV4dC5odG1sLnZ1ZVwiLGFjZU1vZGU6XCJodG1sXCIsbGFuZ3VhZ2VJZDozOTF9fX0pLGtnPXRlKHtcInNyYy9sYW5ndWFnZS1odG1sL2luZGV4LmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PV90KCkscz13ZygpLGE9X2coKSxuPVBnKCksdT1bdChPbigpLCgpPT4oe25hbWU6XCJBbmd1bGFyXCIsc2luY2U6XCIxLjE1LjBcIixwYXJzZXJzOltcImFuZ3VsYXJcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wiaHRtbFwiXSxleHRlbnNpb25zOltcIi5jb21wb25lbnQuaHRtbFwiXSxmaWxlbmFtZXM6W119KSksdChPbigpLGw9Pih7c2luY2U6XCIxLjE1LjBcIixwYXJzZXJzOltcImh0bWxcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wiaHRtbFwiXSxleHRlbnNpb25zOlsuLi5sLmV4dGVuc2lvbnMsXCIubWptbFwiXX0pKSx0KE9uKCksKCk9Pih7bmFtZTpcIkxpZ2h0bmluZyBXZWIgQ29tcG9uZW50c1wiLHNpbmNlOlwiMS4xNy4wXCIscGFyc2VyczpbXCJsd2NcIl0sdnNjb2RlTGFuZ3VhZ2VJZHM6W1wiaHRtbFwiXSxleHRlbnNpb25zOltdLGZpbGVuYW1lczpbXX0pKSx0KElnKCksKCk9Pih7c2luY2U6XCIxLjEwLjBcIixwYXJzZXJzOltcInZ1ZVwiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJ2dWVcIl19KSldLGk9e2h0bWw6c307ci5leHBvcnRzPXtsYW5ndWFnZXM6dSxwcmludGVyczppLG9wdGlvbnM6YSxwYXJzZXJzOm59fX0pLExnPXRlKHtcInNyYy9sYW5ndWFnZS15YW1sL3ByYWdtYS5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTtmdW5jdGlvbiB0KG4pe3JldHVybi9eXFxzKkAoPzpwcmV0dGllcnxmb3JtYXQpXFxzKiQvLnRlc3Qobil9ZnVuY3Rpb24gcyhuKXtyZXR1cm4vXlxccyojW15cXFNcXG5dKkAoPzpwcmV0dGllcnxmb3JtYXQpXFxzKj8oPzpcXG58JCkvLnRlc3Qobil9ZnVuY3Rpb24gYShuKXtyZXR1cm5gIyBAZm9ybWF0XG5cbiR7bn1gfXIuZXhwb3J0cz17aXNQcmFnbWE6dCxoYXNQcmFnbWE6cyxpbnNlcnRQcmFnbWE6YX19fSksT2c9dGUoe1wic3JjL2xhbmd1YWdlLXlhbWwvbG9jLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO2Z1bmN0aW9uIHQoYSl7cmV0dXJuIGEucG9zaXRpb24uc3RhcnQub2Zmc2V0fWZ1bmN0aW9uIHMoYSl7cmV0dXJuIGEucG9zaXRpb24uZW5kLm9mZnNldH1yLmV4cG9ydHM9e2xvY1N0YXJ0OnQsbG9jRW5kOnN9fX0pLGpnPXRlKHtcInNyYy9sYW5ndWFnZS15YW1sL2VtYmVkLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO2Z1bmN0aW9uIHQocyxhLG4sdSl7aWYocy5nZXRWYWx1ZSgpLnR5cGU9PT1cInJvb3RcIiYmdS5maWxlcGF0aCYmLyg/OlsvXFxcXF18XilcXC4oPzpwcmV0dGllcnxzdHlsZWxpbnR8bGludHN0YWdlZClyYyQvLnRlc3QodS5maWxlcGF0aCkpcmV0dXJuIG4odS5vcmlnaW5hbFRleHQsT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LHUpLHt9LHtwYXJzZXI6XCJqc29uXCJ9KSl9ci5leHBvcnRzPXR9fSksJHQ9dGUoe1wic3JjL2xhbmd1YWdlLXlhbWwvdXRpbHMuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2dldExhc3Q6dCxpc05vbkVtcHR5QXJyYXk6c309VWUoKTtmdW5jdGlvbiBhKGYsVCl7bGV0IG09MCx2PWYuc3RhY2subGVuZ3RoLTE7Zm9yKGxldCBvPTA7bzx2O28rKyl7bGV0IGg9Zi5zdGFja1tvXTtuKGgpJiZUKGgpJiZtKyt9cmV0dXJuIG19ZnVuY3Rpb24gbihmLFQpe3JldHVybiBmJiZ0eXBlb2YgZi50eXBlPT1cInN0cmluZ1wiJiYoIVR8fFQuaW5jbHVkZXMoZi50eXBlKSl9ZnVuY3Rpb24gdShmLFQsbSl7cmV0dXJuIFQoXCJjaGlsZHJlblwiaW4gZj9PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sZikse30se2NoaWxkcmVuOmYuY2hpbGRyZW4ubWFwKHY9PnUodixULGYpKX0pOmYsbSl9ZnVuY3Rpb24gaShmLFQsbSl7T2JqZWN0LmRlZmluZVByb3BlcnR5KGYsVCx7Z2V0Om0sZW51bWVyYWJsZTohMX0pfWZ1bmN0aW9uIGwoZixUKXtsZXQgbT0wLHY9VC5sZW5ndGg7Zm9yKGxldCBvPWYucG9zaXRpb24uZW5kLm9mZnNldC0xO288djtvKyspe2xldCBoPVRbb107aWYoaD09PWBcbmAmJm0rKyxtPT09MSYmL1xcUy8udGVzdChoKSlyZXR1cm4hMTtpZihtPT09MilyZXR1cm4hMH1yZXR1cm4hMX1mdW5jdGlvbiBwKGYpe3N3aXRjaChmLmdldFZhbHVlKCkudHlwZSl7Y2FzZVwidGFnXCI6Y2FzZVwiYW5jaG9yXCI6Y2FzZVwiY29tbWVudFwiOnJldHVybiExfWxldCBtPWYuc3RhY2subGVuZ3RoO2ZvcihsZXQgdj0xO3Y8bTt2Kyspe2xldCBvPWYuc3RhY2tbdl0saD1mLnN0YWNrW3YtMV07aWYoQXJyYXkuaXNBcnJheShoKSYmdHlwZW9mIG89PVwibnVtYmVyXCImJm8hPT1oLmxlbmd0aC0xKXJldHVybiExfXJldHVybiEwfWZ1bmN0aW9uIGQoZil7cmV0dXJuIHMoZi5jaGlsZHJlbik/ZCh0KGYuY2hpbGRyZW4pKTpmfWZ1bmN0aW9uIHkoZil7cmV0dXJuIGYudmFsdWUudHJpbSgpPT09XCJwcmV0dGllci1pZ25vcmVcIn1mdW5jdGlvbiBnKGYpe2xldCBUPWYuZ2V0VmFsdWUoKTtpZihULnR5cGU9PT1cImRvY3VtZW50Qm9keVwiKXtsZXQgbT1mLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gUyhtLmhlYWQpJiZ5KHQobS5oZWFkLmVuZENvbW1lbnRzKSl9cmV0dXJuIEUoVCkmJnkodChULmxlYWRpbmdDb21tZW50cykpfWZ1bmN0aW9uIGMoZil7cmV0dXJuIXMoZi5jaGlsZHJlbikmJiFEKGYpfWZ1bmN0aW9uIEQoZil7cmV0dXJuIEUoZil8fF8oZil8fHcoZil8fEYoZil8fFMoZil9ZnVuY3Rpb24gRShmKXtyZXR1cm4gcyhmPT1udWxsP3ZvaWQgMDpmLmxlYWRpbmdDb21tZW50cyl9ZnVuY3Rpb24gXyhmKXtyZXR1cm4gcyhmPT1udWxsP3ZvaWQgMDpmLm1pZGRsZUNvbW1lbnRzKX1mdW5jdGlvbiB3KGYpe3JldHVybiBmPT1udWxsP3ZvaWQgMDpmLmluZGljYXRvckNvbW1lbnR9ZnVuY3Rpb24gRihmKXtyZXR1cm4gZj09bnVsbD92b2lkIDA6Zi50cmFpbGluZ0NvbW1lbnR9ZnVuY3Rpb24gUyhmKXtyZXR1cm4gcyhmPT1udWxsP3ZvaWQgMDpmLmVuZENvbW1lbnRzKX1mdW5jdGlvbiBOKGYpe2xldCBUPVtdLG07Zm9yKGxldCB2IG9mIGYuc3BsaXQoLyggKykvKSl2IT09XCIgXCI/bT09PVwiIFwiP1QucHVzaCh2KTpULnB1c2goKFQucG9wKCl8fFwiXCIpK3YpOm09PT12b2lkIDAmJlQudW5zaGlmdChcIlwiKSxtPXY7cmV0dXJuIG09PT1cIiBcIiYmVC5wdXNoKChULnBvcCgpfHxcIlwiKStcIiBcIiksVFswXT09PVwiXCImJihULnNoaWZ0KCksVC51bnNoaWZ0KFwiIFwiKyhULnNoaWZ0KCl8fFwiXCIpKSksVH1mdW5jdGlvbiBJKGYsVCxtKXtsZXQgdj1ULnNwbGl0KGBcbmApLm1hcCgobyxoLEMpPT5oPT09MCYmaD09PUMubGVuZ3RoLTE/bzpoIT09MCYmaCE9PUMubGVuZ3RoLTE/by50cmltKCk6aD09PTA/by50cmltRW5kKCk6by50cmltU3RhcnQoKSk7cmV0dXJuIG0ucHJvc2VXcmFwPT09XCJwcmVzZXJ2ZVwiP3YubWFwKG89Pm8ubGVuZ3RoPT09MD9bXTpbb10pOnYubWFwKG89Pm8ubGVuZ3RoPT09MD9bXTpOKG8pKS5yZWR1Y2UoKG8saCxDKT0+QyE9PTAmJnZbQy0xXS5sZW5ndGg+MCYmaC5sZW5ndGg+MCYmIShmPT09XCJxdW90ZURvdWJsZVwiJiZ0KHQobykpLmVuZHNXaXRoKFwiXFxcXFwiKSk/Wy4uLm8uc2xpY2UoMCwtMSksWy4uLnQobyksLi4uaF1dOlsuLi5vLGhdLFtdKS5tYXAobz0+bS5wcm9zZVdyYXA9PT1cIm5ldmVyXCI/W28uam9pbihcIiBcIildOm8pfWZ1bmN0aW9uIFAoZixUKXtsZXR7cGFyZW50SW5kZW50Om0saXNMYXN0RGVzY2VuZGFudDp2LG9wdGlvbnM6b309VCxoPWYucG9zaXRpb24uc3RhcnQubGluZT09PWYucG9zaXRpb24uZW5kLmxpbmU/XCJcIjpvLm9yaWdpbmFsVGV4dC5zbGljZShmLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxmLnBvc2l0aW9uLmVuZC5vZmZzZXQpLm1hdGNoKC9eW15cXG5dKlxcbiguKikkL3MpWzFdLEM7aWYoZi5pbmRlbnQ9PT1udWxsKXtsZXQgQj1oLm1hdGNoKC9eKD88bGVhZGluZ1NwYWNlPiAqKVteXFxuXFxyIF0vbSk7Qz1CP0IuZ3JvdXBzLmxlYWRpbmdTcGFjZS5sZW5ndGg6TnVtYmVyLlBPU0lUSVZFX0lORklOSVRZfWVsc2UgQz1mLmluZGVudC0xK207bGV0IHg9aC5zcGxpdChgXG5gKS5tYXAoQj0+Qi5zbGljZShDKSk7aWYoby5wcm9zZVdyYXA9PT1cInByZXNlcnZlXCJ8fGYudHlwZT09PVwiYmxvY2tMaXRlcmFsXCIpcmV0dXJuIGIoeC5tYXAoQj0+Qi5sZW5ndGg9PT0wP1tdOltCXSkpO3JldHVybiBiKHgubWFwKEI9PkIubGVuZ3RoPT09MD9bXTpOKEIpKS5yZWR1Y2UoKEIsayxNKT0+TSE9PTAmJnhbTS0xXS5sZW5ndGg+MCYmay5sZW5ndGg+MCYmIS9eXFxzLy50ZXN0KGtbMF0pJiYhL15cXHN8XFxzJC8udGVzdCh0KEIpKT9bLi4uQi5zbGljZSgwLC0xKSxbLi4udChCKSwuLi5rXV06Wy4uLkIsa10sW10pLm1hcChCPT5CLnJlZHVjZSgoayxNKT0+ay5sZW5ndGg+MCYmL1xccyQvLnRlc3QodChrKSk/Wy4uLmsuc2xpY2UoMCwtMSksdChrKStcIiBcIitNXTpbLi4uayxNXSxbXSkpLm1hcChCPT5vLnByb3NlV3JhcD09PVwibmV2ZXJcIj9bQi5qb2luKFwiIFwiKV06QikpO2Z1bmN0aW9uIGIoQil7aWYoZi5jaG9tcGluZz09PVwia2VlcFwiKXJldHVybiB0KEIpLmxlbmd0aD09PTA/Qi5zbGljZSgwLC0xKTpCO2xldCBrPTA7Zm9yKGxldCBNPUIubGVuZ3RoLTE7TT49MCYmQltNXS5sZW5ndGg9PT0wO00tLSlrKys7cmV0dXJuIGs9PT0wP0I6az49MiYmIXY/Qi5zbGljZSgwLC0oay0xKSk6Qi5zbGljZSgwLC1rKX19ZnVuY3Rpb24gJChmKXtpZighZilyZXR1cm4hMDtzd2l0Y2goZi50eXBlKXtjYXNlXCJwbGFpblwiOmNhc2VcInF1b3RlRG91YmxlXCI6Y2FzZVwicXVvdGVTaW5nbGVcIjpjYXNlXCJhbGlhc1wiOmNhc2VcImZsb3dNYXBwaW5nXCI6Y2FzZVwiZmxvd1NlcXVlbmNlXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX19ci5leHBvcnRzPXtnZXRMYXN0OnQsZ2V0QW5jZXN0b3JDb3VudDphLGlzTm9kZTpuLGlzRW1wdHlOb2RlOmMsaXNJbmxpbmVOb2RlOiQsbWFwTm9kZTp1LGRlZmluZVNob3J0Y3V0OmksaXNOZXh0TGluZUVtcHR5OmwsaXNMYXN0RGVzY2VuZGFudE5vZGU6cCxnZXRCbG9ja1ZhbHVlTGluZUNvbnRlbnRzOlAsZ2V0Rmxvd1NjYWxhckxpbmVDb250ZW50czpJLGdldExhc3REZXNjZW5kYW50Tm9kZTpkLGhhc1ByZXR0aWVySWdub3JlOmcsaGFzTGVhZGluZ0NvbW1lbnRzOkUsaGFzTWlkZGxlQ29tbWVudHM6XyxoYXNJbmRpY2F0b3JDb21tZW50OncsaGFzVHJhaWxpbmdDb21tZW50OkYsaGFzRW5kQ29tbWVudHM6U319fSkscWc9dGUoe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnQtcHJlcHJvY2Vzcy5qc1wiKGUscil7XCJ1c2Ugc3RyaWN0XCI7bmUoKTt2YXJ7ZGVmaW5lU2hvcnRjdXQ6dCxtYXBOb2RlOnN9PSR0KCk7ZnVuY3Rpb24gYSh1KXtyZXR1cm4gcyh1LG4pfWZ1bmN0aW9uIG4odSl7c3dpdGNoKHUudHlwZSl7Y2FzZVwiZG9jdW1lbnRcIjp0KHUsXCJoZWFkXCIsKCk9PnUuY2hpbGRyZW5bMF0pLHQodSxcImJvZHlcIiwoKT0+dS5jaGlsZHJlblsxXSk7YnJlYWs7Y2FzZVwiZG9jdW1lbnRCb2R5XCI6Y2FzZVwic2VxdWVuY2VJdGVtXCI6Y2FzZVwiZmxvd1NlcXVlbmNlSXRlbVwiOmNhc2VcIm1hcHBpbmdLZXlcIjpjYXNlXCJtYXBwaW5nVmFsdWVcIjp0KHUsXCJjb250ZW50XCIsKCk9PnUuY2hpbGRyZW5bMF0pO2JyZWFrO2Nhc2VcIm1hcHBpbmdJdGVtXCI6Y2FzZVwiZmxvd01hcHBpbmdJdGVtXCI6dCh1LFwia2V5XCIsKCk9PnUuY2hpbGRyZW5bMF0pLHQodSxcInZhbHVlXCIsKCk9PnUuY2hpbGRyZW5bMV0pO2JyZWFrfXJldHVybiB1fXIuZXhwb3J0cz1hfX0pLE1yPXRlKHtcInNyYy9sYW5ndWFnZS15YW1sL3ByaW50L21pc2MuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFye2J1aWxkZXJzOntzb2Z0bGluZTp0LGFsaWduOnN9fT1xZSgpLHtoYXNFbmRDb21tZW50czphLGlzTmV4dExpbmVFbXB0eTpuLGlzTm9kZTp1fT0kdCgpLGk9bmV3IFdlYWtNYXA7ZnVuY3Rpb24gbCh5LGcpe2xldCBjPXkuZ2V0VmFsdWUoKSxEPXkuc3RhY2tbMF0sRTtyZXR1cm4gaS5oYXMoRCk/RT1pLmdldChEKTooRT1uZXcgU2V0LGkuc2V0KEQsRSkpLCFFLmhhcyhjLnBvc2l0aW9uLmVuZC5saW5lKSYmKEUuYWRkKGMucG9zaXRpb24uZW5kLmxpbmUpLG4oYyxnKSYmIXAoeS5nZXRQYXJlbnROb2RlKCkpKT90OlwiXCJ9ZnVuY3Rpb24gcCh5KXtyZXR1cm4gYSh5KSYmIXUoeSxbXCJkb2N1bWVudEhlYWRcIixcImRvY3VtZW50Qm9keVwiLFwiZmxvd01hcHBpbmdcIixcImZsb3dTZXF1ZW5jZVwiXSl9ZnVuY3Rpb24gZCh5LGcpe3JldHVybiBzKFwiIFwiLnJlcGVhdCh5KSxnKX1yLmV4cG9ydHM9e2FsaWduV2l0aFNwYWNlczpkLHNob3VsZFByaW50RW5kQ29tbWVudHM6cCxwcmludE5leHRFbXB0eUxpbmU6bH19fSksTWc9dGUoe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnQvZmxvdy1tYXBwaW5nLXNlcXVlbmNlLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7aWZCcmVhazp0LGxpbmU6cyxzb2Z0bGluZTphLGhhcmRsaW5lOm4sam9pbjp1fX09cWUoKSx7aXNFbXB0eU5vZGU6aSxnZXRMYXN0OmwsaGFzRW5kQ29tbWVudHM6cH09JHQoKSx7cHJpbnROZXh0RW1wdHlMaW5lOmQsYWxpZ25XaXRoU3BhY2VzOnl9PU1yKCk7ZnVuY3Rpb24gZyhELEUsXyl7bGV0IHc9RC5nZXRWYWx1ZSgpLEY9dy50eXBlPT09XCJmbG93TWFwcGluZ1wiLFM9Rj9cIntcIjpcIltcIixOPUY/XCJ9XCI6XCJdXCIsST1hO0YmJncuY2hpbGRyZW4ubGVuZ3RoPjAmJl8uYnJhY2tldFNwYWNpbmcmJihJPXMpO2xldCBQPWwody5jaGlsZHJlbiksJD1QJiZQLnR5cGU9PT1cImZsb3dNYXBwaW5nSXRlbVwiJiZpKFAua2V5KSYmaShQLnZhbHVlKTtyZXR1cm5bUyx5KF8udGFiV2lkdGgsW0ksYyhELEUsXyksXy50cmFpbGluZ0NvbW1hPT09XCJub25lXCI/XCJcIjp0KFwiLFwiKSxwKHcpP1tuLHUobixELm1hcChFLFwiZW5kQ29tbWVudHNcIikpXTpcIlwiXSksJD9cIlwiOkksTl19ZnVuY3Rpb24gYyhELEUsXyl7bGV0IHc9RC5nZXRWYWx1ZSgpO3JldHVybiBELm1hcCgoUyxOKT0+W0UoKSxOPT09dy5jaGlsZHJlbi5sZW5ndGgtMT9cIlwiOltcIixcIixzLHcuY2hpbGRyZW5bTl0ucG9zaXRpb24uc3RhcnQubGluZSE9PXcuY2hpbGRyZW5bTisxXS5wb3NpdGlvbi5zdGFydC5saW5lP2QoUyxfLm9yaWdpbmFsVGV4dCk6XCJcIl1dLFwiY2hpbGRyZW5cIil9ci5leHBvcnRzPXtwcmludEZsb3dNYXBwaW5nOmcscHJpbnRGbG93U2VxdWVuY2U6Z319fSksUmc9dGUoe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnQvbWFwcGluZy1pdGVtLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7Y29uZGl0aW9uYWxHcm91cDp0LGdyb3VwOnMsaGFyZGxpbmU6YSxpZkJyZWFrOm4sam9pbjp1LGxpbmU6aX19PXFlKCkse2hhc0xlYWRpbmdDb21tZW50czpsLGhhc01pZGRsZUNvbW1lbnRzOnAsaGFzVHJhaWxpbmdDb21tZW50OmQsaGFzRW5kQ29tbWVudHM6eSxpc05vZGU6Zyxpc0VtcHR5Tm9kZTpjLGlzSW5saW5lTm9kZTpEfT0kdCgpLHthbGlnbldpdGhTcGFjZXM6RX09TXIoKTtmdW5jdGlvbiBfKE4sSSxQLCQsZil7bGV0e2tleTpULHZhbHVlOm19PU4sdj1jKFQpLG89YyhtKTtpZih2JiZvKXJldHVyblwiOiBcIjtsZXQgaD0kKFwia2V5XCIpLEM9RihOKT9cIiBcIjpcIlwiO2lmKG8pcmV0dXJuIE4udHlwZT09PVwiZmxvd01hcHBpbmdJdGVtXCImJkkudHlwZT09PVwiZmxvd01hcHBpbmdcIj9oOk4udHlwZT09PVwibWFwcGluZ0l0ZW1cIiYmdyhULmNvbnRlbnQsZikmJiFkKFQuY29udGVudCkmJighSS50YWd8fEkudGFnLnZhbHVlIT09XCJ0YWc6eWFtbC5vcmcsMjAwMjpzZXRcIik/W2gsQyxcIjpcIl06W1wiPyBcIixFKDIsaCldO2xldCB4PSQoXCJ2YWx1ZVwiKTtpZih2KXJldHVybltcIjogXCIsRSgyLHgpXTtpZihsKG0pfHwhRChULmNvbnRlbnQpKXJldHVybltcIj8gXCIsRSgyLGgpLGEsdShcIlwiLFAubWFwKCQsXCJ2YWx1ZVwiLFwibGVhZGluZ0NvbW1lbnRzXCIpLm1hcChxPT5bcSxhXSkpLFwiOiBcIixFKDIseCldO2lmKFMoVC5jb250ZW50KSYmIWwoVC5jb250ZW50KSYmIXAoVC5jb250ZW50KSYmIWQoVC5jb250ZW50KSYmIXkoVCkmJiFsKG0uY29udGVudCkmJiFwKG0uY29udGVudCkmJiF5KG0pJiZ3KG0uY29udGVudCxmKSlyZXR1cm5baCxDLFwiOiBcIix4XTtsZXQgYj1TeW1ib2woXCJtYXBwaW5nS2V5XCIpLEI9cyhbbihcIj8gXCIpLHMoRSgyLGgpLHtpZDpifSldKSxrPVthLFwiOiBcIixFKDIseCldLE09W0MsXCI6XCJdO2wobS5jb250ZW50KXx8eShtKSYmbS5jb250ZW50JiYhZyhtLmNvbnRlbnQsW1wibWFwcGluZ1wiLFwic2VxdWVuY2VcIl0pfHxJLnR5cGU9PT1cIm1hcHBpbmdcIiYmZChULmNvbnRlbnQpJiZEKG0uY29udGVudCl8fGcobS5jb250ZW50LFtcIm1hcHBpbmdcIixcInNlcXVlbmNlXCJdKSYmbS5jb250ZW50LnRhZz09PW51bGwmJm0uY29udGVudC5hbmNob3I9PT1udWxsP00ucHVzaChhKTptLmNvbnRlbnQmJk0ucHVzaChpKSxNLnB1c2goeCk7bGV0IFI9RShmLnRhYldpZHRoLE0pO3JldHVybiB3KFQuY29udGVudCxmKSYmIWwoVC5jb250ZW50KSYmIXAoVC5jb250ZW50KSYmIXkoVCk/dChbW2gsUl1dKTp0KFtbQixuKGssUix7Z3JvdXBJZDpifSldXSl9ZnVuY3Rpb24gdyhOLEkpe2lmKCFOKXJldHVybiEwO3N3aXRjaChOLnR5cGUpe2Nhc2VcInBsYWluXCI6Y2FzZVwicXVvdGVTaW5nbGVcIjpjYXNlXCJxdW90ZURvdWJsZVwiOmJyZWFrO2Nhc2VcImFsaWFzXCI6cmV0dXJuITA7ZGVmYXVsdDpyZXR1cm4hMX1pZihJLnByb3NlV3JhcD09PVwicHJlc2VydmVcIilyZXR1cm4gTi5wb3NpdGlvbi5zdGFydC5saW5lPT09Ti5wb3NpdGlvbi5lbmQubGluZTtpZigvXFxcXCQvbS50ZXN0KEkub3JpZ2luYWxUZXh0LnNsaWNlKE4ucG9zaXRpb24uc3RhcnQub2Zmc2V0LE4ucG9zaXRpb24uZW5kLm9mZnNldCkpKXJldHVybiExO3N3aXRjaChJLnByb3NlV3JhcCl7Y2FzZVwibmV2ZXJcIjpyZXR1cm4hTi52YWx1ZS5pbmNsdWRlcyhgXG5gKTtjYXNlXCJhbHdheXNcIjpyZXR1cm4hL1tcXG4gXS8udGVzdChOLnZhbHVlKTtkZWZhdWx0OnJldHVybiExfX1mdW5jdGlvbiBGKE4pe3JldHVybiBOLmtleS5jb250ZW50JiZOLmtleS5jb250ZW50LnR5cGU9PT1cImFsaWFzXCJ9ZnVuY3Rpb24gUyhOKXtpZighTilyZXR1cm4hMDtzd2l0Y2goTi50eXBlKXtjYXNlXCJwbGFpblwiOmNhc2VcInF1b3RlRG91YmxlXCI6Y2FzZVwicXVvdGVTaW5nbGVcIjpyZXR1cm4gTi5wb3NpdGlvbi5zdGFydC5saW5lPT09Ti5wb3NpdGlvbi5lbmQubGluZTtjYXNlXCJhbGlhc1wiOnJldHVybiEwO2RlZmF1bHQ6cmV0dXJuITF9fXIuZXhwb3J0cz1ffX0pLCRnPXRlKHtcInNyYy9sYW5ndWFnZS15YW1sL3ByaW50L2Jsb2NrLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7ZGVkZW50OnQsZGVkZW50VG9Sb290OnMsZmlsbDphLGhhcmRsaW5lOm4sam9pbjp1LGxpbmU6aSxsaXRlcmFsbGluZTpsLG1hcmtBc1Jvb3Q6cH0sdXRpbHM6e2dldERvY1BhcnRzOmR9fT1xZSgpLHtnZXRBbmNlc3RvckNvdW50OnksZ2V0QmxvY2tWYWx1ZUxpbmVDb250ZW50czpnLGhhc0luZGljYXRvckNvbW1lbnQ6Yyxpc0xhc3REZXNjZW5kYW50Tm9kZTpELGlzTm9kZTpFfT0kdCgpLHthbGlnbldpdGhTcGFjZXM6X309TXIoKTtmdW5jdGlvbiB3KEYsUyxOKXtsZXQgST1GLmdldFZhbHVlKCksUD15KEYsdj0+RSh2LFtcInNlcXVlbmNlXCIsXCJtYXBwaW5nXCJdKSksJD1EKEYpLGY9W0kudHlwZT09PVwiYmxvY2tGb2xkZWRcIj9cIj5cIjpcInxcIl07SS5pbmRlbnQhPT1udWxsJiZmLnB1c2goSS5pbmRlbnQudG9TdHJpbmcoKSksSS5jaG9tcGluZyE9PVwiY2xpcFwiJiZmLnB1c2goSS5jaG9tcGluZz09PVwia2VlcFwiP1wiK1wiOlwiLVwiKSxjKEkpJiZmLnB1c2goXCIgXCIsUyhcImluZGljYXRvckNvbW1lbnRcIikpO2xldCBUPWcoSSx7cGFyZW50SW5kZW50OlAsaXNMYXN0RGVzY2VuZGFudDokLG9wdGlvbnM6Tn0pLG09W107Zm9yKGxldFt2LG9db2YgVC5lbnRyaWVzKCkpdj09PTAmJm0ucHVzaChuKSxtLnB1c2goYShkKHUoaSxvKSkpKSx2IT09VC5sZW5ndGgtMT9tLnB1c2goby5sZW5ndGg9PT0wP246cChsKSk6SS5jaG9tcGluZz09PVwia2VlcFwiJiYkJiZtLnB1c2gocyhvLmxlbmd0aD09PTA/bjpsKSk7cmV0dXJuIEkuaW5kZW50PT09bnVsbD9mLnB1c2godChfKE4udGFiV2lkdGgsbSkpKTpmLnB1c2gocyhfKEkuaW5kZW50LTErUCxtKSkpLGZ9ci5leHBvcnRzPXd9fSksVmc9dGUoe1wic3JjL2xhbmd1YWdlLXlhbWwvcHJpbnRlci15YW1sLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhcntidWlsZGVyczp7YnJlYWtQYXJlbnQ6dCxmaWxsOnMsZ3JvdXA6YSxoYXJkbGluZTpuLGpvaW46dSxsaW5lOmksbGluZVN1ZmZpeDpsLGxpdGVyYWxsaW5lOnB9LHV0aWxzOntnZXREb2NQYXJ0czpkLHJlcGxhY2VUZXh0RW5kT2ZMaW5lOnl9fT1xZSgpLHtpc1ByZXZpb3VzTGluZUVtcHR5Omd9PVVlKCkse2luc2VydFByYWdtYTpjLGlzUHJhZ21hOkR9PUxnKCkse2xvY1N0YXJ0OkV9PU9nKCksXz1qZygpLHtnZXRGbG93U2NhbGFyTGluZUNvbnRlbnRzOncsZ2V0TGFzdERlc2NlbmRhbnROb2RlOkYsaGFzTGVhZGluZ0NvbW1lbnRzOlMsaGFzTWlkZGxlQ29tbWVudHM6TixoYXNUcmFpbGluZ0NvbW1lbnQ6SSxoYXNFbmRDb21tZW50czpQLGhhc1ByZXR0aWVySWdub3JlOiQsaXNMYXN0RGVzY2VuZGFudE5vZGU6Zixpc05vZGU6VCxpc0lubGluZU5vZGU6bX09JHQoKSx2PXFnKCkse2FsaWduV2l0aFNwYWNlczpvLHByaW50TmV4dEVtcHR5TGluZTpoLHNob3VsZFByaW50RW5kQ29tbWVudHM6Q309TXIoKSx7cHJpbnRGbG93TWFwcGluZzp4LHByaW50Rmxvd1NlcXVlbmNlOmJ9PU1nKCksQj1SZygpLGs9JGcoKTtmdW5jdGlvbiBNKGosWSxpZSl7bGV0IGVlPWouZ2V0VmFsdWUoKSxsZT1bXTtlZS50eXBlIT09XCJtYXBwaW5nVmFsdWVcIiYmUyhlZSkmJmxlLnB1c2goW3UobixqLm1hcChpZSxcImxlYWRpbmdDb21tZW50c1wiKSksbl0pO2xldHt0YWc6VyxhbmNob3I6S309ZWU7VyYmbGUucHVzaChpZShcInRhZ1wiKSksVyYmSyYmbGUucHVzaChcIiBcIiksSyYmbGUucHVzaChpZShcImFuY2hvclwiKSk7bGV0IGRlPVwiXCI7VChlZSxbXCJtYXBwaW5nXCIsXCJzZXF1ZW5jZVwiLFwiY29tbWVudFwiLFwiZGlyZWN0aXZlXCIsXCJtYXBwaW5nSXRlbVwiLFwic2VxdWVuY2VJdGVtXCJdKSYmIWYoaikmJihkZT1oKGosWS5vcmlnaW5hbFRleHQpKSwoV3x8SykmJihUKGVlLFtcInNlcXVlbmNlXCIsXCJtYXBwaW5nXCJdKSYmIU4oZWUpP2xlLnB1c2gobik6bGUucHVzaChcIiBcIikpLE4oZWUpJiZsZS5wdXNoKFtlZS5taWRkbGVDb21tZW50cy5sZW5ndGg9PT0xP1wiXCI6bix1KG4sai5tYXAoaWUsXCJtaWRkbGVDb21tZW50c1wiKSksbl0pO2xldCB1ZT1qLmdldFBhcmVudE5vZGUoKTtyZXR1cm4gJChqKT9sZS5wdXNoKHkoWS5vcmlnaW5hbFRleHQuc2xpY2UoZWUucG9zaXRpb24uc3RhcnQub2Zmc2V0LGVlLnBvc2l0aW9uLmVuZC5vZmZzZXQpLnRyaW1FbmQoKSxwKSk6bGUucHVzaChhKFIoZWUsdWUsaixZLGllKSkpLEkoZWUpJiYhVChlZSxbXCJkb2N1bWVudFwiLFwiZG9jdW1lbnRIZWFkXCJdKSYmbGUucHVzaChsKFtlZS50eXBlPT09XCJtYXBwaW5nVmFsdWVcIiYmIWVlLmNvbnRlbnQ/XCJcIjpcIiBcIix1ZS50eXBlPT09XCJtYXBwaW5nS2V5XCImJmouZ2V0UGFyZW50Tm9kZSgyKS50eXBlPT09XCJtYXBwaW5nXCImJm0oZWUpP1wiXCI6dCxpZShcInRyYWlsaW5nQ29tbWVudFwiKV0pKSxDKGVlKSYmbGUucHVzaChvKGVlLnR5cGU9PT1cInNlcXVlbmNlSXRlbVwiPzI6MCxbbix1KG4sai5tYXAoRmU9PltnKFkub3JpZ2luYWxUZXh0LEZlLmdldFZhbHVlKCksRSk/bjpcIlwiLGllKCldLFwiZW5kQ29tbWVudHNcIikpXSkpLGxlLnB1c2goZGUpLGxlfWZ1bmN0aW9uIFIoaixZLGllLGVlLGxlKXtzd2l0Y2goai50eXBlKXtjYXNlXCJyb290XCI6e2xldHtjaGlsZHJlbjpXfT1qLEs9W107aWUuZWFjaCgodWUsRmUpPT57bGV0IHo9V1tGZV0sVT1XW0ZlKzFdO0ZlIT09MCYmSy5wdXNoKG4pLEsucHVzaChsZSgpKSxKKHosVSk/KEsucHVzaChuLFwiLi4uXCIpLEkoeikmJksucHVzaChcIiBcIixsZShcInRyYWlsaW5nQ29tbWVudFwiKSkpOlUmJiFJKFUuaGVhZCkmJksucHVzaChuLFwiLS0tXCIpfSxcImNoaWxkcmVuXCIpO2xldCBkZT1GKGopO3JldHVybighVChkZSxbXCJibG9ja0xpdGVyYWxcIixcImJsb2NrRm9sZGVkXCJdKXx8ZGUuY2hvbXBpbmchPT1cImtlZXBcIikmJksucHVzaChuKSxLfWNhc2VcImRvY3VtZW50XCI6e2xldCBXPVkuY2hpbGRyZW5baWUuZ2V0TmFtZSgpKzFdLEs9W107cmV0dXJuIEwoaixXLFksZWUpPT09XCJoZWFkXCImJigoai5oZWFkLmNoaWxkcmVuLmxlbmd0aD4wfHxqLmhlYWQuZW5kQ29tbWVudHMubGVuZ3RoPjApJiZLLnB1c2gobGUoXCJoZWFkXCIpKSxJKGouaGVhZCk/Sy5wdXNoKFtcIi0tLVwiLFwiIFwiLGxlKFtcImhlYWRcIixcInRyYWlsaW5nQ29tbWVudFwiXSldKTpLLnB1c2goXCItLS1cIikpLHEoaikmJksucHVzaChsZShcImJvZHlcIikpLHUobixLKX1jYXNlXCJkb2N1bWVudEhlYWRcIjpyZXR1cm4gdShuLFsuLi5pZS5tYXAobGUsXCJjaGlsZHJlblwiKSwuLi5pZS5tYXAobGUsXCJlbmRDb21tZW50c1wiKV0pO2Nhc2VcImRvY3VtZW50Qm9keVwiOntsZXR7Y2hpbGRyZW46VyxlbmRDb21tZW50czpLfT1qLGRlPVwiXCI7aWYoVy5sZW5ndGg+MCYmSy5sZW5ndGg+MCl7bGV0IHVlPUYoaik7VCh1ZSxbXCJibG9ja0ZvbGRlZFwiLFwiYmxvY2tMaXRlcmFsXCJdKT91ZS5jaG9tcGluZyE9PVwia2VlcFwiJiYoZGU9W24sbl0pOmRlPW59cmV0dXJuW3UobixpZS5tYXAobGUsXCJjaGlsZHJlblwiKSksZGUsdShuLGllLm1hcChsZSxcImVuZENvbW1lbnRzXCIpKV19Y2FzZVwiZGlyZWN0aXZlXCI6cmV0dXJuW1wiJVwiLHUoXCIgXCIsW2oubmFtZSwuLi5qLnBhcmFtZXRlcnNdKV07Y2FzZVwiY29tbWVudFwiOnJldHVybltcIiNcIixqLnZhbHVlXTtjYXNlXCJhbGlhc1wiOnJldHVybltcIipcIixqLnZhbHVlXTtjYXNlXCJ0YWdcIjpyZXR1cm4gZWUub3JpZ2luYWxUZXh0LnNsaWNlKGoucG9zaXRpb24uc3RhcnQub2Zmc2V0LGoucG9zaXRpb24uZW5kLm9mZnNldCk7Y2FzZVwiYW5jaG9yXCI6cmV0dXJuW1wiJlwiLGoudmFsdWVdO2Nhc2VcInBsYWluXCI6cmV0dXJuIFEoai50eXBlLGVlLm9yaWdpbmFsVGV4dC5zbGljZShqLnBvc2l0aW9uLnN0YXJ0Lm9mZnNldCxqLnBvc2l0aW9uLmVuZC5vZmZzZXQpLGVlKTtjYXNlXCJxdW90ZURvdWJsZVwiOmNhc2VcInF1b3RlU2luZ2xlXCI6e2xldCBXPVwiJ1wiLEs9J1wiJyxkZT1lZS5vcmlnaW5hbFRleHQuc2xpY2Uoai5wb3NpdGlvbi5zdGFydC5vZmZzZXQrMSxqLnBvc2l0aW9uLmVuZC5vZmZzZXQtMSk7aWYoai50eXBlPT09XCJxdW90ZVNpbmdsZVwiJiZkZS5pbmNsdWRlcyhcIlxcXFxcIil8fGoudHlwZT09PVwicXVvdGVEb3VibGVcIiYmL1xcXFxbXlwiXS8udGVzdChkZSkpe2xldCBGZT1qLnR5cGU9PT1cInF1b3RlRG91YmxlXCI/SzpXO3JldHVybltGZSxRKGoudHlwZSxkZSxlZSksRmVdfWlmKGRlLmluY2x1ZGVzKEspKXJldHVybltXLFEoai50eXBlLGoudHlwZT09PVwicXVvdGVEb3VibGVcIj9kZS5yZXBsYWNlKC9cXFxcXCIvZyxLKS5yZXBsYWNlKC8nL2csVy5yZXBlYXQoMikpOmRlLGVlKSxXXTtpZihkZS5pbmNsdWRlcyhXKSlyZXR1cm5bSyxRKGoudHlwZSxqLnR5cGU9PT1cInF1b3RlU2luZ2xlXCI/ZGUucmVwbGFjZSgvJycvZyxXKTpkZSxlZSksS107bGV0IHVlPWVlLnNpbmdsZVF1b3RlP1c6SztyZXR1cm5bdWUsUShqLnR5cGUsZGUsZWUpLHVlXX1jYXNlXCJibG9ja0ZvbGRlZFwiOmNhc2VcImJsb2NrTGl0ZXJhbFwiOnJldHVybiBrKGllLGxlLGVlKTtjYXNlXCJtYXBwaW5nXCI6Y2FzZVwic2VxdWVuY2VcIjpyZXR1cm4gdShuLGllLm1hcChsZSxcImNoaWxkcmVuXCIpKTtjYXNlXCJzZXF1ZW5jZUl0ZW1cIjpyZXR1cm5bXCItIFwiLG8oMixqLmNvbnRlbnQ/bGUoXCJjb250ZW50XCIpOlwiXCIpXTtjYXNlXCJtYXBwaW5nS2V5XCI6Y2FzZVwibWFwcGluZ1ZhbHVlXCI6cmV0dXJuIGouY29udGVudD9sZShcImNvbnRlbnRcIik6XCJcIjtjYXNlXCJtYXBwaW5nSXRlbVwiOmNhc2VcImZsb3dNYXBwaW5nSXRlbVwiOnJldHVybiBCKGosWSxpZSxsZSxlZSk7Y2FzZVwiZmxvd01hcHBpbmdcIjpyZXR1cm4geChpZSxsZSxlZSk7Y2FzZVwiZmxvd1NlcXVlbmNlXCI6cmV0dXJuIGIoaWUsbGUsZWUpO2Nhc2VcImZsb3dTZXF1ZW5jZUl0ZW1cIjpyZXR1cm4gbGUoXCJjb250ZW50XCIpO2RlZmF1bHQ6dGhyb3cgbmV3IEVycm9yKGBVbmV4cGVjdGVkIG5vZGUgdHlwZSAke2oudHlwZX1gKX19ZnVuY3Rpb24gcShqKXtyZXR1cm4gai5ib2R5LmNoaWxkcmVuLmxlbmd0aD4wfHxQKGouYm9keSl9ZnVuY3Rpb24gSihqLFkpe3JldHVybiBJKGopfHxZJiYoWS5oZWFkLmNoaWxkcmVuLmxlbmd0aD4wfHxQKFkuaGVhZCkpfWZ1bmN0aW9uIEwoaixZLGllLGVlKXtyZXR1cm4gaWUuY2hpbGRyZW5bMF09PT1qJiYvLS0tKD86XFxzfCQpLy50ZXN0KGVlLm9yaWdpbmFsVGV4dC5zbGljZShFKGopLEUoaikrNCkpfHxqLmhlYWQuY2hpbGRyZW4ubGVuZ3RoPjB8fFAoai5oZWFkKXx8SShqLmhlYWQpP1wiaGVhZFwiOkooaixZKT8hMTpZP1wicm9vdFwiOiExfWZ1bmN0aW9uIFEoaixZLGllKXtsZXQgZWU9dyhqLFksaWUpO3JldHVybiB1KG4sZWUubWFwKGxlPT5zKGQodShpLGxlKSkpKSl9ZnVuY3Rpb24gVihqLFkpe2lmKFQoWSkpc3dpdGNoKGRlbGV0ZSBZLnBvc2l0aW9uLFkudHlwZSl7Y2FzZVwiY29tbWVudFwiOmlmKEQoWS52YWx1ZSkpcmV0dXJuIG51bGw7YnJlYWs7Y2FzZVwicXVvdGVEb3VibGVcIjpjYXNlXCJxdW90ZVNpbmdsZVwiOlkudHlwZT1cInF1b3RlXCI7YnJlYWt9fXIuZXhwb3J0cz17cHJlcHJvY2Vzczp2LGVtYmVkOl8scHJpbnQ6TSxtYXNzYWdlQXN0Tm9kZTpWLGluc2VydFByYWdtYTpjfX19KSxXZz10ZSh7XCJzcmMvbGFuZ3VhZ2UteWFtbC9vcHRpb25zLmpzXCIoZSxyKXtcInVzZSBzdHJpY3RcIjtuZSgpO3ZhciB0PU10KCk7ci5leHBvcnRzPXticmFja2V0U3BhY2luZzp0LmJyYWNrZXRTcGFjaW5nLHNpbmdsZVF1b3RlOnQuc2luZ2xlUXVvdGUscHJvc2VXcmFwOnQucHJvc2VXcmFwfX19KSxIZz10ZSh7XCJzcmMvbGFuZ3VhZ2UteWFtbC9wYXJzZXJzLmpzXCIoKXtuZSgpfX0pLEdnPXRlKHtcIm5vZGVfbW9kdWxlcy9saW5ndWlzdC1sYW5ndWFnZXMvZGF0YS9ZQU1MLmpzb25cIihlLHIpe3IuZXhwb3J0cz17bmFtZTpcIllBTUxcIix0eXBlOlwiZGF0YVwiLGNvbG9yOlwiI2NiMTcxZVwiLHRtU2NvcGU6XCJzb3VyY2UueWFtbFwiLGFsaWFzZXM6W1wieW1sXCJdLGV4dGVuc2lvbnM6W1wiLnltbFwiLFwiLm1pclwiLFwiLnJlZWtcIixcIi5ydml6XCIsXCIuc3VibGltZS1zeW50YXhcIixcIi5zeW50YXhcIixcIi55YW1sXCIsXCIueWFtbC10bWxhbmd1YWdlXCIsXCIueWFtbC5zZWRcIixcIi55bWwubXlzcWxcIl0sZmlsZW5hbWVzOltcIi5jbGFuZy1mb3JtYXRcIixcIi5jbGFuZy10aWR5XCIsXCIuZ2VtcmNcIixcIkNJVEFUSU9OLmNmZlwiLFwiZ2xpZGUubG9ja1wiLFwieWFybi5sb2NrXCJdLGFjZU1vZGU6XCJ5YW1sXCIsY29kZW1pcnJvck1vZGU6XCJ5YW1sXCIsY29kZW1pcnJvck1pbWVUeXBlOlwidGV4dC94LXlhbWxcIixsYW5ndWFnZUlkOjQwN319fSksVWc9dGUoe1wic3JjL2xhbmd1YWdlLXlhbWwvaW5kZXguanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCk7dmFyIHQ9X3QoKSxzPVZnKCksYT1XZygpLG49SGcoKSx1PVt0KEdnKCksaT0+KHtzaW5jZTpcIjEuMTQuMFwiLHBhcnNlcnM6W1wieWFtbFwiXSx2c2NvZGVMYW5ndWFnZUlkczpbXCJ5YW1sXCIsXCJhbnNpYmxlXCIsXCJob21lLWFzc2lzdGFudFwiXSxmaWxlbmFtZXM6Wy4uLmkuZmlsZW5hbWVzLmZpbHRlcihsPT5sIT09XCJ5YXJuLmxvY2tcIiksXCIucHJldHRpZXJyY1wiLFwiLnN0eWxlbGludHJjXCIsXCIubGludHN0YWdlZHJjXCJdfSkpXTtyLmV4cG9ydHM9e2xhbmd1YWdlczp1LHByaW50ZXJzOnt5YW1sOnN9LG9wdGlvbnM6YSxwYXJzZXJzOm59fX0pLEpnPXRlKHtcInNyYy9sYW5ndWFnZXMuanNcIihlLHIpe1widXNlIHN0cmljdFwiO25lKCksci5leHBvcnRzPVtUZCgpLEdkKCksWmQoKSxpZygpLG1nKCksa2coKSxVZygpXX19KTtuZSgpO3Zhcnt2ZXJzaW9uOnpnfT1JYSgpLEx0PUdtKCkse2dldFN1cHBvcnRJbmZvOlhnfT1YbigpLEtnPVVtKCksWWc9SmcoKSxRZz1xZSgpO2Z1bmN0aW9uIE50KGUpe2xldCByPWFyZ3VtZW50cy5sZW5ndGg+MSYmYXJndW1lbnRzWzFdIT09dm9pZCAwP2FyZ3VtZW50c1sxXToxO3JldHVybiBmdW5jdGlvbigpe2Zvcih2YXIgdD1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KHQpLGE9MDthPHQ7YSsrKXNbYV09YXJndW1lbnRzW2FdO2xldCBuPXNbcl18fHt9LHU9bi5wbHVnaW5zfHxbXTtyZXR1cm4gc1tyXT1PYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sbikse30se3BsdWdpbnM6Wy4uLllnLC4uLkFycmF5LmlzQXJyYXkodSk/dTpPYmplY3QudmFsdWVzKHUpXX0pLGUoLi4ucyl9fXZhciBqbj1OdChMdC5mb3JtYXRXaXRoQ3Vyc29yKTtqby5leHBvcnRzPXtmb3JtYXRXaXRoQ3Vyc29yOmpuLGZvcm1hdChlLHIpe3JldHVybiBqbihlLHIpLmZvcm1hdHRlZH0sY2hlY2soZSxyKXtsZXR7Zm9ybWF0dGVkOnR9PWpuKGUscik7cmV0dXJuIHQ9PT1lfSxkb2M6UWcsZ2V0U3VwcG9ydEluZm86TnQoWGcsMCksdmVyc2lvbjp6Zyx1dGlsOktnLF9fZGVidWc6e3BhcnNlOk50KEx0LnBhcnNlKSxmb3JtYXRBU1Q6TnQoTHQuZm9ybWF0QVNUKSxmb3JtYXREb2M6TnQoTHQuZm9ybWF0RG9jKSxwcmludFRvRG9jOk50KEx0LnByaW50VG9Eb2MpLHByaW50RG9jVG9TdHJpbmc6TnQoTHQucHJpbnREb2NUb1N0cmluZyl9fX0pO3JldHVybiBaZygpO30pOyIsIlxuICAgICAgaW1wb3J0IEFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiO1xuICAgICAgaW1wb3J0IGRvbUFQSSBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3N0eWxlRG9tQVBJLmpzXCI7XG4gICAgICBpbXBvcnQgaW5zZXJ0Rm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9pbnNlcnRCeVNlbGVjdG9yLmpzXCI7XG4gICAgICBpbXBvcnQgc2V0QXR0cmlidXRlcyBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL3NldEF0dHJpYnV0ZXNXaXRob3V0QXR0cmlidXRlcy5qc1wiO1xuICAgICAgaW1wb3J0IGluc2VydFN0eWxlRWxlbWVudCBmcm9tIFwiIS4uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvZGlzdC9ydW50aW1lL2luc2VydFN0eWxlRWxlbWVudC5qc1wiO1xuICAgICAgaW1wb3J0IHN0eWxlVGFnVHJhbnNmb3JtRm4gZnJvbSBcIiEuLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2Rpc3QvcnVudGltZS9zdHlsZVRhZ1RyYW5zZm9ybS5qc1wiO1xuICAgICAgaW1wb3J0IGNvbnRlbnQsICogYXMgbmFtZWRFeHBvcnQgZnJvbSBcIiEhLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvZGlzdC9janMuanMhLi9zdHlsZS5jc3NcIjtcbiAgICAgIFxuICAgICAgXG5cbnZhciBvcHRpb25zID0ge307XG5cbm9wdGlvbnMuc3R5bGVUYWdUcmFuc2Zvcm0gPSBzdHlsZVRhZ1RyYW5zZm9ybUZuO1xub3B0aW9ucy5zZXRBdHRyaWJ1dGVzID0gc2V0QXR0cmlidXRlcztcblxuICAgICAgb3B0aW9ucy5pbnNlcnQgPSBpbnNlcnRGbi5iaW5kKG51bGwsIFwiaGVhZFwiKTtcbiAgICBcbm9wdGlvbnMuZG9tQVBJID0gZG9tQVBJO1xub3B0aW9ucy5pbnNlcnRTdHlsZUVsZW1lbnQgPSBpbnNlcnRTdHlsZUVsZW1lbnQ7XG5cbnZhciB1cGRhdGUgPSBBUEkoY29udGVudCwgb3B0aW9ucyk7XG5cblxuXG5leHBvcnQgKiBmcm9tIFwiISEuLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9kaXN0L2Nqcy5qcyEuL3N0eWxlLmNzc1wiO1xuICAgICAgIGV4cG9ydCBkZWZhdWx0IGNvbnRlbnQgJiYgY29udGVudC5sb2NhbHMgPyBjb250ZW50LmxvY2FscyA6IHVuZGVmaW5lZDtcbiIsIlwidXNlIHN0cmljdFwiO1xuXG52YXIgc3R5bGVzSW5ET00gPSBbXTtcblxuZnVuY3Rpb24gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcikge1xuICB2YXIgcmVzdWx0ID0gLTE7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXNJbkRPTS5sZW5ndGg7IGkrKykge1xuICAgIGlmIChzdHlsZXNJbkRPTVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICByZXN1bHQgPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuZnVuY3Rpb24gbW9kdWxlc1RvRG9tKGxpc3QsIG9wdGlvbnMpIHtcbiAgdmFyIGlkQ291bnRNYXAgPSB7fTtcbiAgdmFyIGlkZW50aWZpZXJzID0gW107XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGl0ZW0gPSBsaXN0W2ldO1xuICAgIHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuICAgIHZhciBjb3VudCA9IGlkQ291bnRNYXBbaWRdIHx8IDA7XG4gICAgdmFyIGlkZW50aWZpZXIgPSBcIlwiLmNvbmNhdChpZCwgXCIgXCIpLmNvbmNhdChjb3VudCk7XG4gICAgaWRDb3VudE1hcFtpZF0gPSBjb3VudCArIDE7XG4gICAgdmFyIGluZGV4QnlJZGVudGlmaWVyID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgdmFyIG9iaiA9IHtcbiAgICAgIGNzczogaXRlbVsxXSxcbiAgICAgIG1lZGlhOiBpdGVtWzJdLFxuICAgICAgc291cmNlTWFwOiBpdGVtWzNdLFxuICAgICAgc3VwcG9ydHM6IGl0ZW1bNF0sXG4gICAgICBsYXllcjogaXRlbVs1XVxuICAgIH07XG5cbiAgICBpZiAoaW5kZXhCeUlkZW50aWZpZXIgIT09IC0xKSB7XG4gICAgICBzdHlsZXNJbkRPTVtpbmRleEJ5SWRlbnRpZmllcl0ucmVmZXJlbmNlcysrO1xuICAgICAgc3R5bGVzSW5ET01baW5kZXhCeUlkZW50aWZpZXJdLnVwZGF0ZXIob2JqKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIHVwZGF0ZXIgPSBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKTtcbiAgICAgIG9wdGlvbnMuYnlJbmRleCA9IGk7XG4gICAgICBzdHlsZXNJbkRPTS5zcGxpY2UoaSwgMCwge1xuICAgICAgICBpZGVudGlmaWVyOiBpZGVudGlmaWVyLFxuICAgICAgICB1cGRhdGVyOiB1cGRhdGVyLFxuICAgICAgICByZWZlcmVuY2VzOiAxXG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZGVudGlmaWVycy5wdXNoKGlkZW50aWZpZXIpO1xuICB9XG5cbiAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuXG5mdW5jdGlvbiBhZGRFbGVtZW50U3R5bGUob2JqLCBvcHRpb25zKSB7XG4gIHZhciBhcGkgPSBvcHRpb25zLmRvbUFQSShvcHRpb25zKTtcbiAgYXBpLnVwZGF0ZShvYmopO1xuXG4gIHZhciB1cGRhdGVyID0gZnVuY3Rpb24gdXBkYXRlcihuZXdPYmopIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJiBuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJiBuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwICYmIG5ld09iai5zdXBwb3J0cyA9PT0gb2JqLnN1cHBvcnRzICYmIG5ld09iai5sYXllciA9PT0gb2JqLmxheWVyKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgYXBpLnVwZGF0ZShvYmogPSBuZXdPYmopO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcGkucmVtb3ZlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiB1cGRhdGVyO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChsaXN0LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICBsaXN0ID0gbGlzdCB8fCBbXTtcbiAgdmFyIGxhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgbmV3TGlzdCA9IG5ld0xpc3QgfHwgW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhc3RJZGVudGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICB2YXIgaW5kZXggPSBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKTtcbiAgICAgIHN0eWxlc0luRE9NW2luZGV4XS5yZWZlcmVuY2VzLS07XG4gICAgfVxuXG4gICAgdmFyIG5ld0xhc3RJZGVudGlmaWVycyA9IG1vZHVsZXNUb0RvbShuZXdMaXN0LCBvcHRpb25zKTtcblxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICB2YXIgX2lkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbX2ldO1xuXG4gICAgICB2YXIgX2luZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoX2lkZW50aWZpZXIpO1xuXG4gICAgICBpZiAoc3R5bGVzSW5ET01bX2luZGV4XS5yZWZlcmVuY2VzID09PSAwKSB7XG4gICAgICAgIHN0eWxlc0luRE9NW19pbmRleF0udXBkYXRlcigpO1xuXG4gICAgICAgIHN0eWxlc0luRE9NLnNwbGljZShfaW5kZXgsIDEpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGxhc3RJZGVudGlmaWVycyA9IG5ld0xhc3RJZGVudGlmaWVycztcbiAgfTtcbn07IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBtZW1vID0ge307XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuZnVuY3Rpb24gZ2V0VGFyZ2V0KHRhcmdldCkge1xuICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgIHZhciBzdHlsZVRhcmdldCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IodGFyZ2V0KTsgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcblxuICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgd2lsbCB0aHJvdyBhbiBleGNlcHRpb24gaWYgYWNjZXNzIHRvIGlmcmFtZSBpcyBibG9ja2VkXG4gICAgICAgIC8vIGR1ZSB0byBjcm9zcy1vcmlnaW4gcmVzdHJpY3Rpb25zXG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gc3R5bGVUYXJnZXQuY29udGVudERvY3VtZW50LmhlYWQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIGlzdGFuYnVsIGlnbm9yZSBuZXh0XG4gICAgICAgIHN0eWxlVGFyZ2V0ID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBtZW1vW3RhcmdldF0gPSBzdHlsZVRhcmdldDtcbiAgfVxuXG4gIHJldHVybiBtZW1vW3RhcmdldF07XG59XG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cblxuXG5mdW5jdGlvbiBpbnNlcnRCeVNlbGVjdG9yKGluc2VydCwgc3R5bGUpIHtcbiAgdmFyIHRhcmdldCA9IGdldFRhcmdldChpbnNlcnQpO1xuXG4gIGlmICghdGFyZ2V0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiQ291bGRuJ3QgZmluZCBhIHN0eWxlIHRhcmdldC4gVGhpcyBwcm9iYWJseSBtZWFucyB0aGF0IHRoZSB2YWx1ZSBmb3IgdGhlICdpbnNlcnQnIHBhcmFtZXRlciBpcyBpbnZhbGlkLlwiKTtcbiAgfVxuXG4gIHRhcmdldC5hcHBlbmRDaGlsZChzdHlsZSk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW5zZXJ0QnlTZWxlY3RvcjsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykge1xuICB2YXIgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgb3B0aW9ucy5zZXRBdHRyaWJ1dGVzKGVsZW1lbnQsIG9wdGlvbnMuYXR0cmlidXRlcyk7XG4gIG9wdGlvbnMuaW5zZXJ0KGVsZW1lbnQsIG9wdGlvbnMub3B0aW9ucyk7XG4gIHJldHVybiBlbGVtZW50O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGluc2VydFN0eWxlRWxlbWVudDsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzZXRBdHRyaWJ1dGVzV2l0aG91dEF0dHJpYnV0ZXMoc3R5bGVFbGVtZW50KSB7XG4gIHZhciBub25jZSA9IHR5cGVvZiBfX3dlYnBhY2tfbm9uY2VfXyAhPT0gXCJ1bmRlZmluZWRcIiA/IF9fd2VicGFja19ub25jZV9fIDogbnVsbDtcblxuICBpZiAobm9uY2UpIHtcbiAgICBzdHlsZUVsZW1lbnQuc2V0QXR0cmlidXRlKFwibm9uY2VcIiwgbm9uY2UpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0QXR0cmlidXRlc1dpdGhvdXRBdHRyaWJ1dGVzOyIsIlwidXNlIHN0cmljdFwiO1xuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAgKi9cbmZ1bmN0aW9uIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKSB7XG4gIHZhciBjc3MgPSBcIlwiO1xuXG4gIGlmIChvYmouc3VwcG9ydHMpIHtcbiAgICBjc3MgKz0gXCJAc3VwcG9ydHMgKFwiLmNvbmNhdChvYmouc3VwcG9ydHMsIFwiKSB7XCIpO1xuICB9XG5cbiAgaWYgKG9iai5tZWRpYSkge1xuICAgIGNzcyArPSBcIkBtZWRpYSBcIi5jb25jYXQob2JqLm1lZGlhLCBcIiB7XCIpO1xuICB9XG5cbiAgdmFyIG5lZWRMYXllciA9IHR5cGVvZiBvYmoubGF5ZXIgIT09IFwidW5kZWZpbmVkXCI7XG5cbiAgaWYgKG5lZWRMYXllcikge1xuICAgIGNzcyArPSBcIkBsYXllclwiLmNvbmNhdChvYmoubGF5ZXIubGVuZ3RoID4gMCA/IFwiIFwiLmNvbmNhdChvYmoubGF5ZXIpIDogXCJcIiwgXCIge1wiKTtcbiAgfVxuXG4gIGNzcyArPSBvYmouY3NzO1xuXG4gIGlmIChuZWVkTGF5ZXIpIHtcbiAgICBjc3MgKz0gXCJ9XCI7XG4gIH1cblxuICBpZiAob2JqLm1lZGlhKSB7XG4gICAgY3NzICs9IFwifVwiO1xuICB9XG5cbiAgaWYgKG9iai5zdXBwb3J0cykge1xuICAgIGNzcyArPSBcIn1cIjtcbiAgfVxuXG4gIHZhciBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuXG4gIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICBjc3MgKz0gXCJcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiLmNvbmNhdChidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpLCBcIiAqL1wiKTtcbiAgfSAvLyBGb3Igb2xkIElFXG5cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqL1xuXG5cbiAgb3B0aW9ucy5zdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCwgb3B0aW9ucy5vcHRpb25zKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCkge1xuICAvLyBpc3RhbmJ1bCBpZ25vcmUgaWZcbiAgaWYgKHN0eWxlRWxlbWVudC5wYXJlbnROb2RlID09PSBudWxsKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgc3R5bGVFbGVtZW50LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc3R5bGVFbGVtZW50KTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqL1xuXG5cbmZ1bmN0aW9uIGRvbUFQSShvcHRpb25zKSB7XG4gIHZhciBzdHlsZUVsZW1lbnQgPSBvcHRpb25zLmluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZShvYmopIHtcbiAgICAgIGFwcGx5KHN0eWxlRWxlbWVudCwgb3B0aW9ucywgb2JqKTtcbiAgICB9LFxuICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuICAgICAgcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlRWxlbWVudCk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGRvbUFQSTsiLCJcInVzZSBzdHJpY3RcIjtcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgICovXG5mdW5jdGlvbiBzdHlsZVRhZ1RyYW5zZm9ybShjc3MsIHN0eWxlRWxlbWVudCkge1xuICBpZiAoc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQpIHtcbiAgICBzdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuICB9IGVsc2Uge1xuICAgIHdoaWxlIChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZCkge1xuICAgICAgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudC5maXJzdENoaWxkKTtcbiAgICB9XG5cbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY3NzKSk7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBzdHlsZVRhZ1RyYW5zZm9ybTsiLCJpbXBvcnQgeyB0b2RvRm9ybUdlbmVyYXRvciwgdG9kb0l0ZW0sIGl0ZW1Db21wb25lbnRHZW5lcmF0b3IsIGRldGFpbHNGb3JtR2VuZXJhdG9yIH0gZnJvbSBcIi4vaXRlbXNcIjtcbmltcG9ydCB7IHRvZG9zIH0gZnJvbSBcIi4vbmF2XCI7XG5pbXBvcnQgeyByZW1vdmUgfSBmcm9tIFwibG9kYXNoXCI7XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRUb2RvQnRuRXZlbnRMaXN0ZW5lcigpIHtcbiAgICBjb25zdCBhZGRUb2RvID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5hZGQtdGFza1wiKTtcblxuICAgIGFkZFRvZG8uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgb3ZlcmxheVRvZ2dsZS5lbmFibGUoKTtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZCh0b2RvRm9ybUdlbmVyYXRvcigpKTtcbiAgICB9KVxuXG4gICAgLy8gRm9yIHRvZG8gYnV0dG9uIGluIHRoZSBtYWluIHNjcmVlbiwgbm90IHRoZSBmb3JtXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBlZGl0QnRuRXZlbnRMaXN0ZW5lcigpIHtcbiAgICBjb25zdCBwYXJlbnRGb3JtID0gdGhpcy5jbG9zZXN0KFwiW2RhdGEtaW5mb11cIik7XG4gICAgY29uc3QgZGF0YUluZm9WYWx1ZSA9IHBhcmVudEZvcm0uZ2V0QXR0cmlidXRlKFwiZGF0YS1pbmZvXCIpO1xuICAgIGNvbnN0IHRhcmdldEl0ZW1Db21wb25lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKGAubWFpbi1jb250ZW50IFtkYXRhLWluZm89JyR7ZGF0YUluZm9WYWx1ZX0nXWApO1xuXG4gICAgY29uc3QgYm9keURpdiA9IHRoaXMuY2xvc2VzdChcIi5mb3JtLWJvZHlcIik7XG4gICAgY29uc3QgY2xvc2VCdG4gPSBib2R5RGl2LnBhcmVudE5vZGUucXVlcnlTZWxlY3RvcihcIi5mb3JtLWNsb3NlXCIpO1xuICAgIGNvbnN0IG5ld1RpdGxlID0gYm9keURpdi5xdWVyeVNlbGVjdG9yKFwiLmZvcm0tdGl0bGVcIik7XG4gICAgY29uc3QgbmV3RGVzY3JpcHRpb24gPSBib2R5RGl2LnF1ZXJ5U2VsZWN0b3IoXCIuZm9ybS1kZXRhaWxzXCIpO1xuICAgIGNvbnN0IG5ld0RhdGUgPSBib2R5RGl2LnF1ZXJ5U2VsZWN0b3IoXCIuZGF0ZS1pbnB1dFwiKTtcbiAgICBjb25zdCBuZXdQcmlvcml0eSA9IGJvZHlEaXYucXVlcnlTZWxlY3RvcihcImJ1dHRvbi5hY3RpdmVcIik7XG4gICAgY29uc3QgbmV3T2JqZWN0ID0gdG9kb0l0ZW0obmV3VGl0bGUudmFsdWUsIG5ld0Rlc2NyaXB0aW9uLnZhbHVlLCBuZXdEYXRlLnZhbHVlLCBuZXdQcmlvcml0eS50ZXh0Q29udGVudCk7XG4gICAgXG5cbiAgICB1cGRhdGVJdGVtQ29tcG9uZW50KHRhcmdldEl0ZW1Db21wb25lbnQsIG5ld09iamVjdCk7XG4gICAgY2xvc2VCdG4uY2xpY2soKTtcbiAgICBvdmVybGF5VG9nZ2xlLmRpc2FibGUoKTtcblxufVxuXG5mdW5jdGlvbiB1cGRhdGVJdGVtQ29tcG9uZW50KHRhcmdldEl0ZW1Db21wb25lbnQsdG9kb0l0ZW0pIHtcbiAgICBjb25zdCBwcmlvcml0eVN0cmlwID0gdGFyZ2V0SXRlbUNvbXBvbmVudC5xdWVyeVNlbGVjdG9yKFwiLnByaW9yaXR5LXN0cmlwXCIpO1xuICAgIGNvbnN0IHRpdGxlID0gdGFyZ2V0SXRlbUNvbXBvbmVudC5xdWVyeVNlbGVjdG9yKFwiLnRvZG8tdGl0bGVcIik7XG4gICAgY29uc3QgZGF0ZSA9IHRhcmdldEl0ZW1Db21wb25lbnQucXVlcnlTZWxlY3RvcihcIi50b2RvLWRhdGVcIik7XG5cbiAgICBwcmlvcml0eVN0cmlwLmNsYXNzTGlzdC5yZW1vdmUocHJpb3JpdHlTdHJpcC5jbGFzc0xpc3RbMV0pO1xuICAgIHByaW9yaXR5U3RyaXAuY2xhc3NMaXN0LmFkZChgcHJpb3JpdHktJHt0b2RvSXRlbS5wcmlvcml0eX1gKTtcblxuICAgIHRpdGxlLnRleHRDb250ZW50ID0gdG9kb0l0ZW0udGl0bGU7XG4gICAgZGF0ZS50ZXh0Q29udGVudCA9IHRvZG9JdGVtLmRhdGU7XG5cblxuICAgIHRhcmdldEl0ZW1Db21wb25lbnQuc2V0QXR0cmlidXRlKFwiZGF0YS1pbmZvXCIsIEpTT04uc3RyaW5naWZ5KHRvZG9JdGVtKSk7XG4gICAgXG59XG5cblxuY29uc3Qgb3ZlcmxheVRvZ2dsZSA9IChmdW5jdGlvbigpIHtcbiAgICBjb25zdCBvdmVybGF5ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5vdmVybGF5XCIpO1xuXG4gICAgY29uc3QgZW5hYmxlID0gKCkgPT4ge1xuICAgICAgICBvdmVybGF5LmNsYXNzTGlzdC5hZGQoXCJlbmFibGVkXCIpO1xuICAgICAgICBtYWtlQmFja2dyb3VuZEl0ZW1zU3RhdGljKHRydWUpO1xuICAgIH07XG4gICAgY29uc3QgZGlzYWJsZSA9ICgpID0+IHtcbiAgICAgICAgb3ZlcmxheS5jbGFzc0xpc3QucmVtb3ZlKFwiZW5hYmxlZFwiKTtcbiAgICAgICAgbWFrZUJhY2tncm91bmRJdGVtc1N0YXRpYyhmYWxzZSk7XG4gICAgfTtcblxuICAgIHJldHVybiB7ZW5hYmxlLCBkaXNhYmxlfTtcbn0pKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZUJ0bkV2ZW50TGlzdGVuZXIoKSB7XG4gICAgY29uc3QgYm9keU5vZGUgPSBkb2N1bWVudC5ib2R5O1xuICAgIGNvbnN0IGZvcm1Ob2RlID0gdGhpcy5jbG9zZXN0KFwiYm9keT5kaXZcIik7XG5cbiAgICBib2R5Tm9kZS5yZW1vdmVDaGlsZChmb3JtTm9kZSk7XG4gICAgb3ZlcmxheVRvZ2dsZS5kaXNhYmxlKCk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBzdWJtaXRCdG5FdmVudExpc3RlbmVyKCkge1xuICAgIGNvbnN0IGJvZHlEaXYgPSB0aGlzLnBhcmVudE5vZGUucGFyZW50Tm9kZTtcbiAgICBjb25zdCBjbG9zZUJ0biA9IGJvZHlEaXYucGFyZW50Tm9kZS5xdWVyeVNlbGVjdG9yKFwiLmZvcm0tY2xvc2VcIik7XG4gICAgY29uc3QgdGl0bGUgPSBib2R5RGl2LnF1ZXJ5U2VsZWN0b3IoXCIuZm9ybS10aXRsZVwiKTtcbiAgICBjb25zdCBkZXNjcmlwdGlvbiA9IGJvZHlEaXYucXVlcnlTZWxlY3RvcihcIi5mb3JtLWRldGFpbHNcIik7XG4gICAgY29uc3QgZGF0ZSA9IGJvZHlEaXYucXVlcnlTZWxlY3RvcihcIi5kYXRlLWlucHV0XCIpO1xuICAgIGNvbnN0IHByaW9yaXR5ID0gYm9keURpdi5xdWVyeVNlbGVjdG9yKFwiYnV0dG9uLmFjdGl2ZVwiKS50ZXh0Q29udGVudDtcblxuXG5cbiAgICBjb25zdCBmaWVsZHMgPSBbXG4gICAgICAgIHtrZXk6IFwiVGl0bGVcIiwgZWxlbWVudDogdGl0bGV9LFxuICAgICAgICB7a2V5OlwiRGF0ZVwiLCBlbGVtZW50OiBkYXRlfVxuICAgIF07XG5cbiAgICBsZXQgZW1wdHlGaWVsZDtcblxuICAgIGZvciAobGV0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICBpZiAoZmllbGQuZWxlbWVudC52YWx1ZSA9PT0gXCJcIikge1xuICAgICAgICAgICAgZW1wdHlGaWVsZCA9IGZpZWxkLmtleTtcbiAgICAgICAgICAgIGVtcHR5RmllbGRBbGVydChlbXB0eUZpZWxkKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVtcHR5RmllbGQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb25zdCBuZXdJdGVtID0gdG9kb0l0ZW0odGl0bGUudmFsdWUsIGRlc2NyaXB0aW9uLnZhbHVlLCBkYXRlLnZhbHVlLCBwcmlvcml0eSk7XG4gICAgICAgIGNsb3NlQnRuLmNsaWNrKCk7XG4gICAgICAgIHRvZG9zLnB1c2gobmV3SXRlbSk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRvZG9zKTtcbiAgICAgICAgaW5zZXJ0VG9kb0l0ZW1Db21wb25lbnQobmV3SXRlbSk7XG4gICAgfVxufVxuXG5leHBvcnQgZnVuY3Rpb24gZGVsZXRlQnRuRXZlbnRMaXN0ZW5lcigpIHtcbiAgICBjb25zdCBtYWluQ29udGVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubWFpbi1jb250ZW50XCIpO1xuICAgIGNvbnN0IGNvbXBvbmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuICAgIG1haW5Db250ZW50LnJlbW92ZUNoaWxkKGNvbXBvbmVudCk7XG4gICAgXy5yZW1vdmUodG9kb3MsIG9iaiA9PiBKU09OLnN0cmluZ2lmeShvYmopID09PSBjb21wb25lbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbmZvXCIpKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGFpbHNCdG5FdmVudExpc3RlbmVyKCkge1xuICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICBjb25zdCBkZXRhaWxzUGFnZSA9IGRldGFpbHNGb3JtR2VuZXJhdG9yKEpTT04ucGFyc2UocGFyZW50LmdldEF0dHJpYnV0ZShcImRhdGEtaW5mb1wiKSkpO1xuICAgIG92ZXJsYXlUb2dnbGUuZW5hYmxlKCk7XG4gICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChkZXRhaWxzUGFnZSk7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBhZGRFZGl0QnRuRXZlbnRMaXN0ZW5lcihlZGl0QnV0dG9uKSB7XG4gICAgZWRpdEJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgZnVuY3Rpb24oKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcbiAgICAgICAgY29uc3QgZWRpdFBhZ2UgPSB0b2RvRm9ybUdlbmVyYXRvcihmYWxzZSwgSlNPTi5wYXJzZShwYXJlbnQuZ2V0QXR0cmlidXRlKFwiZGF0YS1pbmZvXCIpKSk7XG4gICAgICAgIG92ZXJsYXlUb2dnbGUuZW5hYmxlKCk7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoZWRpdFBhZ2UpO1xuICAgIH0pXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBob21lQnRuRXZlbnRMaXN0ZW5lcigpIHtcbiAgICBjb25zdCBpbmJveEJ0biA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIucGFnZS1pbmJveFwiKTtcbiAgICBpbmJveEJ0bi5jbGljaygpO1xuICB9XG5cblxuZXhwb3J0IGZ1bmN0aW9uIGluc2VydFRvZG9JdGVtQ29tcG9uZW50KHRvZG9JdGVtKSB7XG4gICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tYWluLWNvbnRlbnRcIikuYXBwZW5kQ2hpbGQoaXRlbUNvbXBvbmVudEdlbmVyYXRvcih0b2RvSXRlbSkpO1xufVxuXG5mdW5jdGlvbiBtYWtlQmFja2dyb3VuZEl0ZW1zU3RhdGljKG1ha2VTdGF0aWMpIHtcbiAgICBjb25zdCBlbGVtZW50cyA9IFsnLmhlYWRlcicsICcuY29udGVudCcsICcuYWRkLXRhc2snXTtcbiAgICBjb25zdCBwb2ludGVyRXZlbnRzID0gbWFrZVN0YXRpYyA/ICdub25lJyA6ICcnO1xuICBcbiAgICBlbGVtZW50cy5mb3JFYWNoKGVsZW1lbnQgPT4ge1xuICAgICAgICBjb25zdCBlbCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWxlbWVudCk7XG4gICAgICAgIGVsLnN0eWxlLnBvaW50ZXJFdmVudHMgPSBwb2ludGVyRXZlbnRzO1xuICAgIH0pO1xufVxuXG5mdW5jdGlvbiBlbXB0eUZpZWxkQWxlcnQoZmllbGROYW1lKSB7XG4gICAgd2luZG93LmFsZXJ0KGAke2ZpZWxkTmFtZX0gaXMgcmVxdWlyZWRgKTtcbn0iLCJpbXBvcnQgeyBwYXJzZUlTTywgZm9ybWF0LCBhZGQgfSBmcm9tIFwiZGF0ZS1mbnNcIjtcbmltcG9ydCB7IGRvYyB9IGZyb20gXCJwcmV0dGllclwiO1xuaW1wb3J0IHsgY2xvc2VCdG5FdmVudExpc3RlbmVyLCBzdWJtaXRCdG5FdmVudExpc3RlbmVyLCBkZWxldGVCdG5FdmVudExpc3RlbmVyLCBkZXRhaWxzQnRuRXZlbnRMaXN0ZW5lciwgYWRkRWRpdEJ0bkV2ZW50TGlzdGVuZXIsIGVkaXRCdG5FdmVudExpc3RlbmVyIH0gZnJvbSBcIi4vZXZlbnRzXCI7XG5cbi8qXG5Vc2UgYSBmYWN0b3J5IGZ1bmN0aW9uIHRvIHJldHVybiB0b2RvLWl0ZW1zXG5lYWNoIGl0ZW0gc2hvdWxkIGhhdmUgdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOlxuXG5TdHJpbmcgdGl0bGVcblN0cmluZyBkZXNjcmlwdGlvblxuRGF0ZSBkdWVEYXRlXG5TdHJpbmcgcHJpb3JpdHlcbiovXG5cbmV4cG9ydCBmdW5jdGlvbiB0b2RvSXRlbSh0aXRsZSwgZGVzY3JpcHRpb24sIGR1ZURhdGUsIHByaW9yaXR5U3RyaW5nLCBwcm9qZWN0TmFtZSAsIGRvbmU9ZmFsc2UpIHtcbiAgY29uc3QgUHJpb3JpdGllcyA9IE9iamVjdC5mcmVlemUoe1xuICAgIGxvdzogXCJsb3dcIixcbiAgICBtZWRpdW06IFwibWVkaXVtXCIsXG4gICAgaGlnaDogXCJoaWdoXCIsXG4gIH0pO1xuXG4gIGNvbnN0IHByaW9yaXR5ID0gUHJpb3JpdGllc1twcmlvcml0eVN0cmluZy50b0xvd2VyQ2FzZSgpXSB8fCBcImxvd1wiO1xuICBjb25zdCBwcm9qZWN0ID0gcHJvamVjdE5hbWUgfHwgXCJpbmJveFwiO1xuICAvLyBjb25zdCBkYXRlID0gZm9ybWF0KHBhcnNlSVNPKGR1ZURhdGUpLCBcIk1NL2RkL3l5eXlcIik7IC8vIHBhcnNlSVNPIHBhcnNlcyBkYXRlIHN0cmluZ3Mgd3JpdHRlbiBpbiBJU08gODYwMSBmb3JtYXRcbiAgY29uc3QgZGF0ZSA9IGR1ZURhdGU7XG4gIFxuICByZXR1cm4geyB0aXRsZSwgZGVzY3JpcHRpb24sIGRhdGUsIHByaW9yaXR5LCBwcm9qZWN0LCBkb25lIH07XG59XG5cbmV4cG9ydCBmdW5jdGlvbiBpdGVtQ29tcG9uZW50R2VuZXJhdG9yKHRvZG9JdGVtKSB7XG4gIGNvbnN0IGl0ZW1EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBwcmlvcml0eUNvbG9yID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3QgY2hlY2tCb3ggPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gIGNvbnN0IHRpdGxlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3QgZGV0YWlsc0J1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJidXR0b25cIik7XG4gIGNvbnN0IGRhdGVEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBlZGl0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgY29uc3QgZWRpdEltZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpXCIpO1xuICBjb25zdCBkZWxldGVCdXR0b24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICBjb25zdCBkZWxldGVJbWcgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaVwiKTtcbiAgY29uc3QgY2hlY2thYmxlU3ViQ29tcG9uZW50cyA9IFt0aXRsZURpdiwgZGV0YWlsc0J1dHRvbiwgZGF0ZURpdiwgZWRpdEJ1dHRvbiwgZGVsZXRlQnV0dG9uXTtcblxuICBpdGVtRGl2LmNsYXNzTGlzdC5hZGQoXCJ0b2RvXCIpO1xuICBpdGVtRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtaW5mb1wiLCBKU09OLnN0cmluZ2lmeSh0b2RvSXRlbSkpO1xuXG4gIHByaW9yaXR5Q29sb3IuY2xhc3NMaXN0LmFkZChcInByaW9yaXR5LXN0cmlwXCIsIGBwcmlvcml0eS0ke3RvZG9JdGVtLnByaW9yaXR5fWApO1xuICBpdGVtRGl2LmFwcGVuZENoaWxkKHByaW9yaXR5Q29sb3IpO1xuXG4gIGNoZWNrQm94LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gIGNoZWNrQm94LmNsYXNzTGlzdC5hZGQoXCJ0b2RvLWNoZWNrYm94XCIpO1xuXG4gIGlmICh0b2RvSXRlbS5kb25lID09PSBmYWxzZSkge1xuICAgIGNoZWNrQm94Q2hlY2tlcihmYWxzZSwgY2hlY2tCb3gsIC4uLmNoZWNrYWJsZVN1YkNvbXBvbmVudHMpO1xuICAgIHRvZG9JdGVtLmRvbmUgPSBmYWxzZTtcbiAgICBpdGVtRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtaW5mb1wiLCBKU09OLnN0cmluZ2lmeSh0b2RvSXRlbSkpO1xuICB9IGVsc2Uge1xuICAgICAgY2hlY2tCb3hDaGVja2VyKHRydWUsIGNoZWNrQm94LCAuLi5jaGVja2FibGVTdWJDb21wb25lbnRzKTtcbiAgICAgIHRvZG9JdGVtLmRvbmUgPSB0cnVlXG4gICAgICBpdGVtRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtaW5mb1wiLCBKU09OLnN0cmluZ2lmeSh0b2RvSXRlbSkpO1xuICB9O1xuXG5cbiAgY2hlY2tCb3guYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICBpZiAoY2hlY2tCb3guY2xhc3NMaXN0LmNvbnRhaW5zKFwiY2ItY2hlY2tlZFwiKSkge1xuICAgICAgICBjaGVja0JveENoZWNrZXIoZmFsc2UsIGNoZWNrQm94LCAuLi5jaGVja2FibGVTdWJDb21wb25lbnRzKTtcbiAgICAgICAgdG9kb0l0ZW0uZG9uZSA9IGZhbHNlO1xuICAgICAgICBpdGVtRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtaW5mb1wiLCBKU09OLnN0cmluZ2lmeSh0b2RvSXRlbSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNoZWNrQm94Q2hlY2tlcih0cnVlLCBjaGVja0JveCwgLi4uY2hlY2thYmxlU3ViQ29tcG9uZW50cyk7XG4gICAgICAgIHRvZG9JdGVtLmRvbmUgPSB0cnVlXG4gICAgICAgIGl0ZW1EaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1pbmZvXCIsIEpTT04uc3RyaW5naWZ5KHRvZG9JdGVtKSk7XG4gICAgfVxuICB9KVxuICBpdGVtRGl2LmFwcGVuZENoaWxkKGNoZWNrQm94KTtcblxuICB0aXRsZURpdi50ZXh0Q29udGVudCA9IHRvZG9JdGVtLnRpdGxlO1xuICB0aXRsZURpdi5jbGFzc0xpc3QuYWRkKFwidG9kby10aXRsZVwiKTtcbiAgaXRlbURpdi5hcHBlbmRDaGlsZCh0aXRsZURpdik7XG5cbiAgZGV0YWlsc0J1dHRvbi50ZXh0Q29udGVudCA9IFwiREVUQUlMU1wiO1xuICBkZXRhaWxzQnV0dG9uLmNsYXNzTGlzdC5hZGQoXCJ0b2RvLWRldGFpbHNcIik7XG4gIGRldGFpbHNCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGRldGFpbHNCdG5FdmVudExpc3RlbmVyKTtcbiAgaXRlbURpdi5hcHBlbmRDaGlsZChkZXRhaWxzQnV0dG9uKTtcblxuICBkYXRlRGl2LnRleHRDb250ZW50ID0gdG9kb0l0ZW0uZGF0ZTtcbiAgZGF0ZURpdi5jbGFzc0xpc3QuYWRkKFwidG9kby1kYXRlXCIpO1xuICBpdGVtRGl2LmFwcGVuZENoaWxkKGRhdGVEaXYpO1xuXG4gIGVkaXRCdXR0b24uY2xhc3NMaXN0LmFkZChcInRvZG8tZWRpdFwiKTtcbiAgZWRpdEltZy5jbGFzc0xpc3QuYWRkKFwiYmlcIiwgXCJiaS1wZW5jaWwtc3F1YXJlXCIpO1xuICBlZGl0QnV0dG9uLmFwcGVuZENoaWxkKGVkaXRJbWcpO1xuICBhZGRFZGl0QnRuRXZlbnRMaXN0ZW5lcihlZGl0QnV0dG9uKTtcbiAgaXRlbURpdi5hcHBlbmRDaGlsZChlZGl0QnV0dG9uKTtcblxuICBkZWxldGVCdXR0b24uY2xhc3NMaXN0LmFkZChcInRvZG8tZGVsZXRlXCIpO1xuICBkZWxldGVJbWcuY2xhc3NMaXN0LmFkZChcImJpXCIsIFwiYmktdHJhc2hcIik7XG4gIGRlbGV0ZUJ1dHRvbi5hcHBlbmRDaGlsZChkZWxldGVJbWcpO1xuICBkZWxldGVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGRlbGV0ZUJ0bkV2ZW50TGlzdGVuZXIpO1xuICBpdGVtRGl2LmFwcGVuZENoaWxkKGRlbGV0ZUJ1dHRvbik7XG5cbiAgcmV0dXJuIGl0ZW1EaXY7XG59XG5cbmV4cG9ydCBmdW5jdGlvbiB0b2RvRm9ybUdlbmVyYXRvcihuZXdGb3JtID0gdHJ1ZSwgdG9kb0l0ZW0gPSBudWxsKSB7XG4gIGNvbnN0IGZvcm1EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCBjbG9zZUJ1dHRvbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IGhlYWRlckRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IGJvZHlEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBjb25zdCB0aXRsZUFyZWEgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwidGV4dGFyZWFcIik7XG4gIGNvbnN0IGRldGFpbHNBcmVhID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICBjb25zdCBkYXRlRGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY29uc3QgZGF0ZUlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICBjb25zdCBwcmlvcml0eURpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gIGNvbnN0IGxvd1ByaW9yaXR5QnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgY29uc3QgbWVkaXVtUHJpb3JpdHlCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICBjb25zdCBoaWdoUHJpb3JpdHlCdG4gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnV0dG9uXCIpO1xuICBjb25zdCBhZGRUb2RvQnRuID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcblxuICBjbG9zZUJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZm9ybS1jbG9zZVwiKTtcbiAgY2xvc2VCdXR0b24udGV4dENvbnRlbnQgPSBcInhcIjtcbiAgY2xvc2VCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGNsb3NlQnRuRXZlbnRMaXN0ZW5lcik7XG5cbiAgaGVhZGVyRGl2LnRleHRDb250ZW50ID0gXCJDcmVhdGUgQSBOZXcgVG8gRG9cIjtcbiAgaGVhZGVyRGl2LmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbXBvbmVudFwiLCBcImZvcm0taGVhZGVyXCIpO1xuICBib2R5RGl2LmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbXBvbmVudFwiLCBcImZvcm0tYm9keVwiKTtcbiAgaGVhZGVyRGl2LmFwcGVuZENoaWxkKGNsb3NlQnV0dG9uKTtcbiAgZm9ybURpdi5hcHBlbmRDaGlsZChoZWFkZXJEaXYpO1xuXG4gIGZvcm1EaXYuY2xhc3NMaXN0LmFkZChcImZvcm0tY29tcG9uZW50XCIsIFwiZm9ybVwiKTtcbiAgZm9ybURpdi5hcHBlbmRDaGlsZChib2R5RGl2KTtcblxuICB0aXRsZUFyZWEucGxhY2Vob2xkZXIgPSBcIlRpdGxlOiBQYXkgYmlsbHNcIjtcbiAgdGl0bGVBcmVhLmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbXBvbmVudFwiLCBcImZvcm0tdGl0bGVcIik7XG4gIGJvZHlEaXYuYXBwZW5kQ2hpbGQodGl0bGVBcmVhKTtcblxuICBkZXRhaWxzQXJlYS5wbGFjZWhvbGRlciA9IFwiRGV0YWlsczogZS5nIGludGVybmV0LCBwaG9uZSwgcmVudC5cIjtcbiAgZGV0YWlsc0FyZWEuY2xhc3NMaXN0LmFkZChcImZvcm0tY29tcG9uZW50XCIsIFwiZm9ybS1kZXRhaWxzXCIpO1xuICBib2R5RGl2LmFwcGVuZENoaWxkKGRldGFpbHNBcmVhKTtcblxuICBkYXRlRGl2LnRleHRDb250ZW50ID0gXCJEdWUgRGF0ZTogXCI7XG4gIGRhdGVJbnB1dC50eXBlID0gXCJkYXRlXCI7XG4gIGRhdGVEaXYuY2xhc3NMaXN0LmFkZChcImZvcm0tY29tcG9uZW50XCIsIFwiZm9ybS1kYXRlXCIpO1xuICBkYXRlSW5wdXQuY2xhc3NMaXN0LmFkZChcImZvcm0tY29tcG9uZW50XCIsIFwiZGF0ZS1pbnB1dFwiKTtcbiAgZGF0ZURpdi5hcHBlbmRDaGlsZChkYXRlSW5wdXQpO1xuICBib2R5RGl2LmFwcGVuZENoaWxkKGRhdGVEaXYpO1xuXG4gIHByaW9yaXR5RGl2LnRleHRDb250ZW50ID0gXCJQcmlvcml0eTogXCI7XG4gIGxvd1ByaW9yaXR5QnRuLnRleHRDb250ZW50ID0gXCJMT1dcIjtcbiAgbWVkaXVtUHJpb3JpdHlCdG4udGV4dENvbnRlbnQgPSBcIk1FRElVTVwiO1xuICBoaWdoUHJpb3JpdHlCdG4udGV4dENvbnRlbnQgPSBcIkhJR0hcIjtcbiAgYWRkVG9kb0J0bi50ZXh0Q29udGVudCA9IFwiQUREIFRPIERPXCI7XG4gIHByaW9yaXR5RGl2LmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbXBvbmVudFwiLCBcImZvcm0tcHJpb3JpdHlcIik7XG4gIGxvd1ByaW9yaXR5QnRuLmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbXBvbmVudFwiLCBcInByaW9yaXR5LWJ1dHRvblwiLCBcImJ0blwiLCBcImJ0bi1vdXRsaW5lLXN1Y2Nlc3NcIiwgXCJhY3RpdmVcIik7XG4gIGxvd1ByaW9yaXR5QnRuLnNldEF0dHJpYnV0ZShcImRhdGEtYnMtdG9nZ2xlXCIsIFwiYnV0dG9uXCIpO1xuICBtZWRpdW1Qcmlvcml0eUJ0bi5jbGFzc0xpc3QuYWRkKFwiZm9ybS1jb21wb25lbnRcIiwgXCJwcmlvcml0eS1idXR0b25cIiwgXCJidG5cIiwgXCJidG4tb3V0bGluZS13YXJuaW5nXCIpO1xuICBtZWRpdW1Qcmlvcml0eUJ0bi5zZXRBdHRyaWJ1dGUoXCJkYXRhLWJzLXRvZ2dsZVwiLCBcImJ1dHRvblwiKTtcbiAgaGlnaFByaW9yaXR5QnRuLmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbXBvbmVudFwiLCBcInByaW9yaXR5LWJ1dHRvblwiLCBcImJ0blwiLCBcImJ0bi1vdXRsaW5lLWRhbmdlclwiKTtcbiAgaGlnaFByaW9yaXR5QnRuLnNldEF0dHJpYnV0ZShcImRhdGEtYnMtdG9nZ2xlXCIsIFwiYnV0dG9uXCIpO1xuICBhZGRUb2RvQnRuLmNsYXNzTGlzdC5hZGQoXCJmb3JtLWNvbXBvbmVudFwiLCBcImFkZC1idXR0b25cIiwgXCJidG5cIiwgXCJidG4tb3V0bGluZS1wcmltYXJ5XCIpO1xuICBtYWtlQWN0aXZlQnV0dG9uU3RhdGVFeGNsdXNpdmUobG93UHJpb3JpdHlCdG4sIG1lZGl1bVByaW9yaXR5QnRuLCBoaWdoUHJpb3JpdHlCdG4pO1xuICBhZGRUb2RvQnRuLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzdWJtaXRCdG5FdmVudExpc3RlbmVyKTtcbiAgcHJpb3JpdHlEaXYuYXBwZW5kQ2hpbGQobG93UHJpb3JpdHlCdG4pO1xuICBwcmlvcml0eURpdi5hcHBlbmRDaGlsZChtZWRpdW1Qcmlvcml0eUJ0bik7XG4gIHByaW9yaXR5RGl2LmFwcGVuZENoaWxkKGhpZ2hQcmlvcml0eUJ0bik7XG4gIHByaW9yaXR5RGl2LmFwcGVuZENoaWxkKGFkZFRvZG9CdG4pO1xuICBib2R5RGl2LmFwcGVuZENoaWxkKHByaW9yaXR5RGl2KTtcblxuICBpZiAobmV3Rm9ybSA9PT0gZmFsc2UpIHtcbiAgICBmb3JtRGl2LnJlbW92ZUNoaWxkKGhlYWRlckRpdik7XG4gICAgYm9keURpdi5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbik7XG4gICAgdGl0bGVBcmVhLnZhbHVlID0gdG9kb0l0ZW0udGl0bGU7XG4gICAgZGV0YWlsc0FyZWEudmFsdWUgPSB0b2RvSXRlbS5kZXNjcmlwdGlvbjtcbiAgICBkYXRlSW5wdXQudmFsdWUgPSB0b2RvSXRlbS5kYXRlO1xuICAgIGxvd1ByaW9yaXR5QnRuLmNsYXNzTGlzdC5yZW1vdmUoXCJhY3RpdmVcIik7XG4gICAgXG4gICAgY29uc3QgYnV0dG9ucyA9IFtcbiAgICAgIHtrZXk6IFwibG93XCIsIGJ1dHRvbkVsZW1lbnQ6IGxvd1ByaW9yaXR5QnRufSxcbiAgICAgIHtrZXk6IFwibWVkaXVtXCIsIGJ1dHRvbkVsZW1lbnQ6IG1lZGl1bVByaW9yaXR5QnRufSxcbiAgICAgIHtrZXk6IFwiaGlnaFwiLCBidXR0b25FbGVtZW50OiBoaWdoUHJpb3JpdHlCdG59LFxuICAgIF07XG5cbiAgICBidXR0b25zLmZvckVhY2goYnV0dG9uID0+IHtcbiAgICAgIGlmIChidXR0b24ua2V5ID09PSB0b2RvSXRlbS5wcmlvcml0eSkge1xuICAgICAgICBidXR0b24uYnV0dG9uRWxlbWVudC5jbGFzc0xpc3QuYWRkKFwiYWN0aXZlXCIpO1xuICAgICAgfVxuICAgIH0pXG5cbiAgICBmb3JtRGl2LnNldEF0dHJpYnV0ZShcImRhdGEtaW5mb1wiLCBKU09OLnN0cmluZ2lmeSh0b2RvSXRlbSkpO1xuICAgIGFkZFRvZG9CdG4udGV4dENvbnRlbnQgPSBcIkNPTkZJUk0gRURJVFwiO1xuICAgIGFkZFRvZG9CdG4ucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIHN1Ym1pdEJ0bkV2ZW50TGlzdGVuZXIpO1xuICAgIGFkZFRvZG9CdG4uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGVkaXRCdG5FdmVudExpc3RlbmVyKTtcblxuICB9XG5cblxuICByZXR1cm4gZm9ybURpdjtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRldGFpbHNGb3JtR2VuZXJhdG9yKHRvZG9JdGVtKSB7XG4gIGNvbnN0IGZvcm1EaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICBmb3JtRGl2LmNsYXNzTGlzdC5hZGQoXCJkZXRhaWxzLWZvcm1cIik7XG4gIGNvbnN0IGNsb3NlQnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgY2xvc2VCdXR0b24uY2xhc3NMaXN0LmFkZChcImRldGFpbHMtY2xvc2VcIik7XG4gIGNsb3NlQnV0dG9uLnRleHRDb250ZW50ID0gXCJ4XCI7XG4gIGNsb3NlQnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBjbG9zZUJ0bkV2ZW50TGlzdGVuZXIpO1xuICBjb25zdCB0aXRsZVRhZyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJoMVwiKTtcbiAgdGl0bGVUYWcudGV4dENvbnRlbnQgPSB0b2RvSXRlbS50aXRsZTtcbiAgZm9ybURpdi5hcHBlbmRDaGlsZChjbG9zZUJ1dHRvbik7XG4gIGZvcm1EaXYuYXBwZW5kQ2hpbGQodGl0bGVUYWcpO1xuXG4gIGNvbnN0IGZpZWxkcyA9IFtcbiAgICB7IGtleTogXCJwcm9qZWN0XCIsIGxhYmVsOiBcIlByb2plY3Q6XCIsIGNsYXNzTmFtZTogXCJkZXRhaWxzLXByb2plY3RcIiB9LFxuICAgIHsga2V5OiBcInByaW9yaXR5XCIsIGxhYmVsOiBcIlByaW9yaXR5OlwiLCBjbGFzc05hbWU6IFwiZGV0YWlscy1wcmlvcml0eVwiIH0sXG4gICAgeyBrZXk6IFwiZGF0ZVwiLCBsYWJlbDogXCJEdWUgRGF0ZTpcIiwgY2xhc3NOYW1lOiBcImRldGFpbHMtZGF0ZVwiIH0sXG4gICAgeyBrZXk6IFwiZGVzY3JpcHRpb25cIiwgbGFiZWw6IFwiRGVzY3JpcHRpb246XCIsIGNsYXNzTmFtZTogXCJkZXRhaWxzLWRlc2NyaXB0aW9uXCIgfVxuICBdO1xuXG4gIGZpZWxkcy5mb3JFYWNoKGZpZWxkID0+IHtcbiAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGNvbnN0IGxhYmVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgbGFiZWwudGV4dENvbnRlbnQgPSBmaWVsZC5sYWJlbDtcbiAgICBsYWJlbC5jbGFzc0xpc3QuYWRkKGZpZWxkLmNsYXNzTmFtZSk7XG4gICAgZGl2LmFwcGVuZENoaWxkKGxhYmVsKTtcblxuICAgIGNvbnN0IGNvbnRlbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICBjb250ZW50LnRleHRDb250ZW50ID0gdG9kb0l0ZW1bZmllbGQua2V5XTtcbiAgICBkaXYuYXBwZW5kQ2hpbGQoY29udGVudCk7XG5cbiAgICBmb3JtRGl2LmFwcGVuZENoaWxkKGRpdik7XG4gIH0pO1xuXG4gIHJldHVybiBmb3JtRGl2O1xufVxuXG5mdW5jdGlvbiBtYWtlQWN0aXZlQnV0dG9uU3RhdGVFeGNsdXNpdmUoLi4uYXJncykge1xuICAgIGFyZ3MuZm9yRWFjaChidXR0b24gPT4ge1xuICAgICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcignY2xpY2snLCAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBvdGhlckJ1dHRvbnMgPSBhcmdzLmZpbHRlcihwID0+IHAgIT09IGJ1dHRvbik7XG4gICAgICAgICAgICBvdGhlckJ1dHRvbnMubWFwKHAgPT4ge1xuICAgICAgICAgICAgICAgIHAuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgICAgICAgICBwLnNldEF0dHJpYnV0ZShcImFyaWEtcHJlc3NlZFwiLCBcImZhbHNlXCIpO1xuICAgICAgICAgICAgfSlcbiAgICAgICAgfSlcbiAgICB9KVxufVxuXG5mdW5jdGlvbiBjaGVja0JveENoZWNrZXIoY2hlY2ssIGNoZWNrYm94LCAuLi5hcmdzKSB7XG4gIGlmIChjaGVjayA9PT0gdHJ1ZSkge1xuICAgIGNoZWNrYm94LmNsYXNzTGlzdC5hZGQoXCJjYi1jaGVja2VkXCIpO1xuICAgIGNoZWNrYm94LmNoZWNrZWQgPSB0cnVlO1xuICAgIGFyZ3MuZm9yRWFjaChjb21wb25lbnQgPT4ge1xuICAgICAgY29tcG9uZW50LmNsYXNzTGlzdC5hZGQoXCJjaGVja2VkXCIpO1xuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgY2hlY2tib3guY2xhc3NMaXN0LnJlbW92ZShcImNiLWNoZWNrZWRcIik7XG4gICAgY2hlY2tib3guY2hlY2tlZCA9IGZhbHNlO1xuICAgIGFyZ3MuZm9yRWFjaChjb21wb25lbnQgPT4ge1xuICAgICAgY29tcG9uZW50LmNsYXNzTGlzdC5yZW1vdmUoXCJjaGVja2VkXCIpO1xuICAgIH0pXG4gIH1cbn0iLCJpbXBvcnQgXCIuL3N0eWxlLmNzc1wiO1xuaW1wb3J0ICogYXMgaXRlbXMgZnJvbSBcIi4vaXRlbXMuanNcIjtcbmltcG9ydCB7IFBhZ2UgfSBmcm9tIFwiLi9wYWdlc1wiO1xuXG5jb25zdCBzaWRlYmFyID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5zaWRlYmFyXCIpO1xuXG5mdW5jdGlvbiBoaWRlU2lkZWJhcigpIHtcbiAgc2lkZWJhci5zdHlsZS5taW5XaWR0aCA9IFwiMFwiO1xuICBzaWRlYmFyLnN0eWxlLndpZHRoID0gXCIwXCI7XG4gIHNpZGViYXIuY2xhc3NMaXN0LmFkZChcImhpZGRlblwiKTtcbn1cblxuZnVuY3Rpb24gc2hvd1NpZGViYXIoKSB7XG4gIHNpZGViYXIuc3R5bGUubWluV2lkdGggPSBcIjIwMHB4XCI7XG4gIHNpZGViYXIuc3R5bGUud2lkdGggPSBcIjIwMHB4XCI7XG4gIHNpZGViYXIuY2xhc3NMaXN0LnJlbW92ZShcImhpZGRlblwiKTtcbn1cblxuLy9EZXRlcm1pbmVzIHdoZXRoZXIgdG8gaGlkZSBvciBzaG93IHNpZGViYXIuXG5leHBvcnQgZnVuY3Rpb24gc2lkZWJhclRvZ2dsZXIoKSB7XG4gIGlmIChzaWRlYmFyLmNsYXNzTGlzdC5jb250YWlucyhcImhpZGRlblwiKSkge1xuICAgIHNob3dTaWRlYmFyKCk7XG4gIH0gZWxzZSB7XG4gICAgaGlkZVNpZGViYXIoKTtcbiAgfVxufVxuXG5jb25zdCBteUl0ZW0gPSBpdGVtcy50b2RvSXRlbShcInRpdGxlXCIsIFwiZGVzY3JpcHRpb25cIiwgXCIyMDIzLTAxLTAxXCIsIFwibG93XCIpO1xuY29uc3QgbXlEaXYgPSBpdGVtcy5pdGVtQ29tcG9uZW50R2VuZXJhdG9yKG15SXRlbSk7XG5jb25zdCBteUl0ZW0yID0gaXRlbXMudG9kb0l0ZW0oXCJGaW5kXCIsIFwiZGVzY3JpcHRpb25cIixcIjIwMjMtMDEtMDFcIiwgXCJoaWdoXCIpO1xuY29uc3QgbXlEaXYyID0gaXRlbXMuaXRlbUNvbXBvbmVudEdlbmVyYXRvcihteUl0ZW0yKTtcbmNvbnN0IG15SXRlbTMgPSBpdGVtcy50b2RvSXRlbShcImhlbGxvXCIsIFwiYW55XCIsIFwiMjAyNC0wMi0xNFwiLCBcIm1lZGl1bVwiKTtcbmNvbnN0IG15RGl2MyA9IGl0ZW1zLml0ZW1Db21wb25lbnRHZW5lcmF0b3IobXlJdGVtMyk7XG5cbmNvbnN0IG15SXRlbTQgPSBpdGVtcy50b2RvSXRlbShcInRvZGF5XCIsIFwiYW55XCIsIFwiMjAyMy0wMi0wOFwiLCBcIm1lZGl1bVwiKTtcbmNvbnN0IG15SXRlbTUgPSBpdGVtcy50b2RvSXRlbShcInRvZGF5XCIsIFwiYW55XCIsIFwiMjAyMy0wMi0wOFwiLCBcImxvd1wiKTtcbmNvbnN0IG15SXRlbTYgPSBpdGVtcy50b2RvSXRlbShcInRoaXNXZWVrXCIsIFwiYW55XCIsIFwiMjAyMy0wMi0wOVwiLCBcImhpZ2hcIik7XG5cbmV4cG9ydCBsZXQgdG9kb3MgPSBbbXlJdGVtLCBteUl0ZW0yLCBteUl0ZW0zLCBteUl0ZW00LCBteUl0ZW01LCBteUl0ZW02XTtcblxuZXhwb3J0IGxldCBpbmJveFBhZ2UgPSBuZXcgUGFnZSh0b2RvcywgXCJJbmJveFwiKTtcbmxldCB0b2RheVBhZ2UgPSBuZXcgUGFnZSh0b2RvcywgXCJUb2RheVwiKTtcbmxldCB3ZWVrUGFnZSA9IG5ldyBQYWdlKHRvZG9zLCBcIlRoaXMgV2Vla1wiKTtcblxuXG5jb25zdCBtYWluUGFnZXMgPSB7XG4gIFwiSW5ib3hcIjogaW5ib3hQYWdlLFxuICBcIlRvZGF5XCI6IHRvZGF5UGFnZSxcbiAgXCJUaGlzIFdlZWtcIjogd2Vla1BhZ2Vcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIHBhZ2VUb2dnbGVyKCkge1xuICBjb25zdCBwYWdlcyA9IEFycmF5LmZyb20oZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChcIi5wYWdlXCIpKTtcblxuICBwYWdlcy5mb3JFYWNoKHBhZ2UgPT4ge1xuICAgIHBhZ2UuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcblxuICAgICAgY29uc3Qgb3RoZXJQYWdlcyA9IHBhZ2VzLmZpbHRlcihwID0+IHAgIT09IHBhZ2UpO1xuXG4gICAgICBvdGhlclBhZ2VzLmZvckVhY2gocCA9PiB7XG4gICAgICAgIHAuY2xhc3NMaXN0LnJlbW92ZShcImFjdGl2ZVwiKTtcbiAgICAgICAgbWFpblBhZ2VzW3AudGV4dENvbnRlbnRdLmNsZWFySXRlbXMoKTtcbiAgICAgIH0pO1xuXG4gICAgICBtYWluUGFnZXNbcGFnZS50ZXh0Q29udGVudF0uYXBwZW5kSXRlbXMoKTtcbiAgICAgIHBhZ2UuY2xhc3NMaXN0LmFkZChcImFjdGl2ZVwiKTtcblxuICAgIH0pO1xuICB9KTtcbn0iLCJpbXBvcnQgeyBwYXJzZUlTTywgaXNUb2RheSwgaXNUaGlzV2VlayB9IGZyb20gJ2RhdGUtZm5zJztcbmltcG9ydCB7IGl0ZW1Db21wb25lbnRHZW5lcmF0b3IgfSBmcm9tICcuL2l0ZW1zJztcblxuZXhwb3J0IGZ1bmN0aW9uIFBhZ2UodG9kb0l0ZW1zLCBwYWdlTmFtZSkge1xuICAgIHRoaXMudG9kb0l0ZW1zID0gdG9kb0l0ZW1zO1xuICAgIGNvbnN0IG1haW5Db250ZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihcIi5tYWluLWNvbnRlbnRcIik7XG5cbiAgICBjb25zdCBmaWx0ZXIgPSAocGFnZU5hbWUpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9kb0l0ZW1zLmZpbHRlcihpdGVtID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGlzb0RhdGVTdHJpbmcgPSBpdGVtLmRhdGUuc3BsaXQoJy0nKS5qb2luKCcnKTtcbiAgICAgICAgICAgIGNvbnN0IGRhdGVPYmplY3QgPSBwYXJzZUlTTyhpc29EYXRlU3RyaW5nKTtcblxuICAgICAgICAgICAgc3dpdGNoIChwYWdlTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgXCJUb2RheVwiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNUb2RheShkYXRlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcIlRoaXMgV2Vla1wiOlxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gaXNUaGlzV2VlayhkYXRlT2JqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgfVxuXG4gICAgdGhpcy5hcHBlbmRJdGVtcyA9IGZ1bmN0aW9uKCkge1xuICAgICAgICBmaWx0ZXIocGFnZU5hbWUpLmZvckVhY2goZWxlbWVudCA9PiB7XG4gICAgICAgICAgICBtYWluQ29udGVudC5hcHBlbmRDaGlsZChpdGVtQ29tcG9uZW50R2VuZXJhdG9yKGVsZW1lbnQpKTtcbiAgICAgICAgfSlcbiAgICB9XG5cbiAgICB0aGlzLmNsZWFySXRlbXMgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgbWFpbkNvbnRlbnQuaW5uZXJIVE1MID0gJyc7XG4gICAgfVxufVxuIiwiLy8gVGhlIG1vZHVsZSBjYWNoZVxudmFyIF9fd2VicGFja19tb2R1bGVfY2FjaGVfXyA9IHt9O1xuXG4vLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuZnVuY3Rpb24gX193ZWJwYWNrX3JlcXVpcmVfXyhtb2R1bGVJZCkge1xuXHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcblx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG5cdGlmIChjYWNoZWRNb2R1bGUgIT09IHVuZGVmaW5lZCkge1xuXHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcblx0fVxuXHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuXHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcblx0XHRpZDogbW9kdWxlSWQsXG5cdFx0bG9hZGVkOiBmYWxzZSxcblx0XHRleHBvcnRzOiB7fVxuXHR9O1xuXG5cdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuXHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcblxuXHQvLyBGbGFnIHRoZSBtb2R1bGUgYXMgbG9hZGVkXG5cdG1vZHVsZS5sb2FkZWQgPSB0cnVlO1xuXG5cdC8vIFJldHVybiB0aGUgZXhwb3J0cyBvZiB0aGUgbW9kdWxlXG5cdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbn1cblxuIiwiLy8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbl9fd2VicGFja19yZXF1aXJlX18ubiA9IChtb2R1bGUpID0+IHtcblx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG5cdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG5cdFx0KCkgPT4gKG1vZHVsZSk7XG5cdF9fd2VicGFja19yZXF1aXJlX18uZChnZXR0ZXIsIHsgYTogZ2V0dGVyIH0pO1xuXHRyZXR1cm4gZ2V0dGVyO1xufTsiLCIvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSAoZXhwb3J0cywgZGVmaW5pdGlvbikgPT4ge1xuXHRmb3IodmFyIGtleSBpbiBkZWZpbml0aW9uKSB7XG5cdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywga2V5LCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZGVmaW5pdGlvbltrZXldIH0pO1xuXHRcdH1cblx0fVxufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLmcgPSAoZnVuY3Rpb24oKSB7XG5cdGlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHJldHVybiBnbG9iYWxUaGlzO1xuXHR0cnkge1xuXHRcdHJldHVybiB0aGlzIHx8IG5ldyBGdW5jdGlvbigncmV0dXJuIHRoaXMnKSgpO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuXHR9XG59KSgpOyIsIl9fd2VicGFja19yZXF1aXJlX18ubyA9IChvYmosIHByb3ApID0+IChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBwcm9wKSkiLCIvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuXHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgU3ltYm9sLnRvU3RyaW5nVGFnLCB7IHZhbHVlOiAnTW9kdWxlJyB9KTtcblx0fVxuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xufTsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5tZCA9IChtb2R1bGUpID0+IHtcblx0bW9kdWxlLnBhdGhzID0gW107XG5cdGlmICghbW9kdWxlLmNoaWxkcmVuKSBtb2R1bGUuY2hpbGRyZW4gPSBbXTtcblx0cmV0dXJuIG1vZHVsZTtcbn07IiwidmFyIHNjcmlwdFVybDtcbmlmIChfX3dlYnBhY2tfcmVxdWlyZV9fLmcuaW1wb3J0U2NyaXB0cykgc2NyaXB0VXJsID0gX193ZWJwYWNrX3JlcXVpcmVfXy5nLmxvY2F0aW9uICsgXCJcIjtcbnZhciBkb2N1bWVudCA9IF9fd2VicGFja19yZXF1aXJlX18uZy5kb2N1bWVudDtcbmlmICghc2NyaXB0VXJsICYmIGRvY3VtZW50KSB7XG5cdGlmIChkb2N1bWVudC5jdXJyZW50U2NyaXB0KVxuXHRcdHNjcmlwdFVybCA9IGRvY3VtZW50LmN1cnJlbnRTY3JpcHQuc3JjXG5cdGlmICghc2NyaXB0VXJsKSB7XG5cdFx0dmFyIHNjcmlwdHMgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZShcInNjcmlwdFwiKTtcblx0XHRpZihzY3JpcHRzLmxlbmd0aCkgc2NyaXB0VXJsID0gc2NyaXB0c1tzY3JpcHRzLmxlbmd0aCAtIDFdLnNyY1xuXHR9XG59XG4vLyBXaGVuIHN1cHBvcnRpbmcgYnJvd3NlcnMgd2hlcmUgYW4gYXV0b21hdGljIHB1YmxpY1BhdGggaXMgbm90IHN1cHBvcnRlZCB5b3UgbXVzdCBzcGVjaWZ5IGFuIG91dHB1dC5wdWJsaWNQYXRoIG1hbnVhbGx5IHZpYSBjb25maWd1cmF0aW9uXG4vLyBvciBwYXNzIGFuIGVtcHR5IHN0cmluZyAoXCJcIikgYW5kIHNldCB0aGUgX193ZWJwYWNrX3B1YmxpY19wYXRoX18gdmFyaWFibGUgZnJvbSB5b3VyIGNvZGUgdG8gdXNlIHlvdXIgb3duIGxvZ2ljLlxuaWYgKCFzY3JpcHRVcmwpIHRocm93IG5ldyBFcnJvcihcIkF1dG9tYXRpYyBwdWJsaWNQYXRoIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBicm93c2VyXCIpO1xuc2NyaXB0VXJsID0gc2NyaXB0VXJsLnJlcGxhY2UoLyMuKiQvLCBcIlwiKS5yZXBsYWNlKC9cXD8uKiQvLCBcIlwiKS5yZXBsYWNlKC9cXC9bXlxcL10rJC8sIFwiL1wiKTtcbl9fd2VicGFja19yZXF1aXJlX18ucCA9IHNjcmlwdFVybDsiLCJfX3dlYnBhY2tfcmVxdWlyZV9fLm5jID0gdW5kZWZpbmVkOyIsImltcG9ydCBcIi4vc3R5bGUuY3NzXCI7XG5pbXBvcnQgaWNvbiBmcm9tIFwiLi90b2RvLWljb24ucG5nXCI7XG5pbXBvcnQgeyBzaWRlYmFyVG9nZ2xlciwgcGFnZVRvZ2dsZXIsIGluYm94UGFnZX0gZnJvbSBcIi4vbmF2XCI7XG5pbXBvcnQgKiBhcyBpdGVtcyBmcm9tIFwiLi9pdGVtc1wiO1xuaW1wb3J0IHsgYWRkVG9kb0J0bkV2ZW50TGlzdGVuZXIsIGhvbWVCdG5FdmVudExpc3RlbmVyIH0gZnJvbSBcIi4vZXZlbnRzXCI7XG5pbXBvcnQgeyBQYWdlIH0gZnJvbSBcIi4vcGFnZXNcIjtcblxuY29uc3QgdG9kb0ljb24gPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwibGlua1wiKTtcbnRvZG9JY29uLnJlbCA9IFwiaWNvblwiO1xudG9kb0ljb24uaHJlZiA9IGljb247XG5kb2N1bWVudC5oZWFkLmFwcGVuZENoaWxkKHRvZG9JY29uKTtcblxuY29uc3QgdG9nZ2xlciA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoXCIubmF2YmFyLXRvZ2dsZXJcIik7XG50b2dnbGVyLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBzaWRlYmFyVG9nZ2xlcik7XG5cbmNvbnN0IGhvbWVCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiLmhvbWUtYnV0dG9uXCIpO1xuaG9tZUJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgaG9tZUJ0bkV2ZW50TGlzdGVuZXIpO1xuXG5cbnBhZ2VUb2dnbGVyKCk7XG5hZGRUb2RvQnRuRXZlbnRMaXN0ZW5lcigpO1xuXG5cbmluYm94UGFnZS5hcHBlbmRJdGVtcygpO1xuXG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=